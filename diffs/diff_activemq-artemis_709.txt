diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java
index 3e5ede5b91..d91cf1543d 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/postoffice/impl/PostOfficeImpl.java
@@ -17,37 +17,36 @@
 package org.apache.activemq.artemis.core.postoffice.impl;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
-import java.util.concurrent.Executor;
-import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.activemq.artemis.api.core.ActiveMQAddressFullException;
 import org.apache.activemq.artemis.api.core.ActiveMQDuplicateIdException;
+import org.apache.activemq.artemis.api.core.ActiveMQInterruptedException;
 import org.apache.activemq.artemis.api.core.ActiveMQNonExistentQueueException;
 import org.apache.activemq.artemis.api.core.Message;
 import org.apache.activemq.artemis.api.core.Pair;
-import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.api.core.management.CoreNotificationType;
 import org.apache.activemq.artemis.api.core.management.ManagementHelper;
 import org.apache.activemq.artemis.api.core.management.NotificationType;
-import org.apache.activemq.artemis.core.config.WildcardConfiguration;
 import org.apache.activemq.artemis.core.filter.Filter;
 import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.message.impl.CoreMessage;
+import org.apache.activemq.artemis.core.message.impl.MessageImpl;
 import org.apache.activemq.artemis.core.paging.PagingManager;
 import org.apache.activemq.artemis.core.paging.PagingStore;
+import org.apache.activemq.artemis.core.paging.impl.Page;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.postoffice.AddressManager;
 import org.apache.activemq.artemis.core.postoffice.Binding;
@@ -56,22 +55,22 @@ import org.apache.activemq.artemis.core.postoffice.Bindings;
 import org.apache.activemq.artemis.core.postoffice.BindingsFactory;
 import org.apache.activemq.artemis.core.postoffice.DuplicateIDCache;
 import org.apache.activemq.artemis.core.postoffice.PostOffice;
-import org.apache.activemq.artemis.core.postoffice.QueueBinding;
 import org.apache.activemq.artemis.core.postoffice.QueueInfo;
 import org.apache.activemq.artemis.core.postoffice.RoutingStatus;
 import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
-import org.apache.activemq.artemis.core.server.ActiveMQScheduledComponent;
 import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.LargeServerMessage;
 import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.Queue;
+import org.apache.activemq.artemis.core.server.QueueCreator;
 import org.apache.activemq.artemis.core.server.QueueFactory;
 import org.apache.activemq.artemis.core.server.RouteContextList;
 import org.apache.activemq.artemis.core.server.RoutingContext;
+import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.group.GroupingHandler;
-import org.apache.activemq.artemis.core.server.impl.AddressInfo;
 import org.apache.activemq.artemis.core.server.impl.RoutingContextImpl;
+import org.apache.activemq.artemis.core.server.impl.ServerMessageImpl;
 import org.apache.activemq.artemis.core.server.management.ManagementService;
 import org.apache.activemq.artemis.core.server.management.Notification;
 import org.apache.activemq.artemis.core.server.management.NotificationListener;
@@ -82,8 +81,8 @@ import org.apache.activemq.artemis.core.transaction.TransactionOperation;
 import org.apache.activemq.artemis.core.transaction.TransactionOperationAbstract;
 import org.apache.activemq.artemis.core.transaction.TransactionPropertyIndexes;
 import org.apache.activemq.artemis.core.transaction.impl.TransactionImpl;
+import org.apache.activemq.artemis.utils.TypedProperties;
 import org.apache.activemq.artemis.utils.UUIDGenerator;
-import org.apache.activemq.artemis.utils.collections.TypedProperties;
 import org.jboss.logging.Logger;
 
 /**
@@ -92,7 +91,7 @@ import org.jboss.logging.Logger;
  */
 public class PostOfficeImpl implements PostOffice, NotificationListener, BindingsFactory {
 
-   private static final Logger logger = Logger.getLogger(PostOfficeImpl.class);
+   private static final Logger logger = Logger.getLogger(Page.class);
 
    public static final SimpleString HDR_RESET_QUEUE_DATA = new SimpleString("_AMQ_RESET_QUEUE_DATA");
 
@@ -114,6 +113,8 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
    private Reaper reaperRunnable;
 
+   private volatile Thread reaperThread;
+
    private final long reaperPeriod;
 
    private final int reaperPriority;
@@ -132,8 +133,6 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
    private final ActiveMQServer server;
 
-   private final Object addressLock = new Object();
-
    public PostOfficeImpl(final ActiveMQServer server,
                          final StorageManager storageManager,
                          final PagingManager pagingManager,
@@ -141,7 +140,7 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
                          final ManagementService managementService,
                          final long reaperPeriod,
                          final int reaperPriority,
-                         final WildcardConfiguration wildcardConfiguration,
+                         final boolean enableWildCardRouting,
                          final int idCacheSize,
                          final boolean persistIDCache,
                          final HierarchicalRepository<AddressSettings> addressSettingsRepository) {
@@ -157,10 +156,11 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
       this.reaperPriority = reaperPriority;
 
-      if (wildcardConfiguration.isEnabled()) {
-         addressManager = new WildcardAddressManager(this, wildcardConfiguration);
-      } else {
-         addressManager = new SimpleAddressManager(this, wildcardConfiguration);
+      if (enableWildCardRouting) {
+         addressManager = new WildcardAddressManager(this);
+      }
+      else {
+         addressManager = new SimpleAddressManager(this);
       }
 
       this.idCacheSize = idCacheSize;
@@ -199,6 +199,12 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       if (reaperRunnable != null)
          reaperRunnable.stop();
 
+      if (reaperThread != null) {
+         reaperThread.join();
+
+         reaperThread = null;
+      }
+
       addressManager.clear();
 
       queueInfos.clear();
@@ -421,142 +427,6 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
    // PostOffice implementation -----------------------------------------------
 
-   @Override
-   public boolean addAddressInfo(AddressInfo addressInfo) {
-      synchronized (addressLock) {
-         boolean result = addressManager.addAddressInfo(addressInfo);
-         // only register address if it is new
-         if (result) {
-            try {
-               managementService.registerAddress(addressInfo);
-            } catch (Exception e) {
-               e.printStackTrace();
-            }
-         }
-         return result;
-      }
-   }
-
-   /** used on update queue, to validate when a value needs update */
-   private static int replaceNull(Integer value) {
-      if (value == null) {
-         return -1;
-      } else {
-         return value.intValue();
-      }
-   }
-
-   /** used on update queue, to validate when a value needs update */
-   private static boolean replaceNull(Boolean value) {
-      if (value == null) {
-         return false;
-      } else {
-         return value.booleanValue();
-      }
-   }
-
-   @Override
-   public QueueBinding updateQueue(SimpleString name,
-                                   RoutingType routingType,
-                                   Integer maxConsumers,
-                                   Boolean purgeOnNoConsumers) throws Exception {
-      synchronized (addressLock) {
-         final QueueBinding queueBinding = (QueueBinding) addressManager.getBinding(name);
-         if (queueBinding == null) {
-            return null;
-         }
-
-         final Queue queue = queueBinding.getQueue();
-
-         if (queue.getRoutingType() == routingType && replaceNull(maxConsumers) == replaceNull(queue.getMaxConsumers()) && queue.isPurgeOnNoConsumers() == replaceNull(purgeOnNoConsumers)) {
-
-            if (logger.isTraceEnabled()) {
-               logger.tracef("Queue " + name + " didn't need to be updated");
-            }
-            return queueBinding;
-         }
-
-         //validate update
-         if (maxConsumers != null && maxConsumers.intValue() != Queue.MAX_CONSUMERS_UNLIMITED) {
-            final int consumerCount = queue.getConsumerCount();
-            if (consumerCount > maxConsumers) {
-               throw ActiveMQMessageBundle.BUNDLE.invalidMaxConsumersUpdate(name.toString(), maxConsumers, consumerCount);
-            }
-         }
-         if (routingType != null) {
-            final SimpleString address = queue.getAddress();
-            final AddressInfo addressInfo = addressManager.getAddressInfo(address);
-            final Set<RoutingType> addressRoutingTypes = addressInfo.getRoutingTypes();
-            if (!addressRoutingTypes.contains(routingType)) {
-               throw ActiveMQMessageBundle.BUNDLE.invalidRoutingTypeUpdate(name.toString(), routingType, address.toString(), addressRoutingTypes);
-            }
-         }
-
-         //atomic update
-         if (maxConsumers != null) {
-            queue.setMaxConsumer(maxConsumers);
-         }
-         if (routingType != null) {
-            queue.setRoutingType(routingType);
-         }
-         if (purgeOnNoConsumers != null) {
-            queue.setPurgeOnNoConsumers(purgeOnNoConsumers);
-         }
-
-         final long txID = storageManager.generateID();
-         try {
-            storageManager.updateQueueBinding(txID, queueBinding);
-            storageManager.commitBindings(txID);
-         } catch (Throwable throwable) {
-            storageManager.rollback(txID);
-            logger.warn(throwable.getMessage(), throwable);
-            throw throwable;
-         }
-
-         return queueBinding;
-      }
-   }
-
-   @Override
-   public AddressInfo updateAddressInfo(SimpleString addressName,
-                                        Collection<RoutingType> routingTypes) throws Exception {
-      synchronized (addressLock) {
-         return addressManager.updateAddressInfo(addressName, routingTypes);
-      }
-   }
-
-   @Override
-   public AddressInfo removeAddressInfo(SimpleString address) throws Exception {
-      synchronized (addressLock) {
-         Bindings bindingsForAddress = getBindingsForAddress(address);
-         if (bindingsForAddress.getBindings().size() > 0) {
-            throw ActiveMQMessageBundle.BUNDLE.addressHasBindings(address);
-         }
-         managementService.unregisterAddress(address);
-         return addressManager.removeAddressInfo(address);
-      }
-   }
-
-   @Override
-   public AddressInfo getAddressInfo(SimpleString addressName) {
-      synchronized (addressLock) {
-         return addressManager.getAddressInfo(addressName);
-      }
-   }
-
-   @Override
-   public List<Queue> listQueuesForAddress(SimpleString address) throws Exception {
-      Bindings bindingsForAddress = getBindingsForAddress(address);
-      List<Queue> queues = new ArrayList<>();
-      for (Binding b : bindingsForAddress.getBindings()) {
-         if (b instanceof QueueBinding) {
-            Queue q = ((QueueBinding) b).getQueue();
-            queues.add(q);
-         }
-      }
-      return queues;
-   }
-
    // TODO - needs to be synchronized to prevent happening concurrently with activate()
    // (and possible removeBinding and other methods)
    // Otherwise can have situation where createQueue comes in before failover, then failover occurs
@@ -611,14 +481,16 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       if (deleteData && addressManager.getBindingsForRoutingAddress(binding.getAddress()) == null) {
          pagingManager.deletePageStore(binding.getAddress());
 
+         managementService.unregisterAddress(binding.getAddress());
+
          deleteDuplicateCache(binding.getAddress());
       }
 
       if (binding.getType() == BindingType.LOCAL_QUEUE) {
-         Queue queue = (Queue) binding.getBindable();
-         managementService.unregisterQueue(uniqueName, binding.getAddress(), queue.getRoutingType());
-      } else if (binding.getType() == BindingType.DIVERT) {
-         managementService.unregisterDivert(uniqueName, binding.getAddress());
+         managementService.unregisterQueue(uniqueName, binding.getAddress());
+      }
+      else if (binding.getType() == BindingType.DIVERT) {
+         managementService.unregisterDivert(uniqueName);
       }
 
       if (binding.getType() != BindingType.DIVERT) {
@@ -636,7 +508,8 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
          if (binding.getFilter() == null) {
             props.putSimpleStringProperty(ManagementHelper.HDR_FILTERSTRING, null);
-         } else {
+         }
+         else {
             props.putSimpleStringProperty(ManagementHelper.HDR_FILTERSTRING, binding.getFilter().getFilterString());
          }
 
@@ -700,72 +573,81 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
    }
 
    @Override
-   public RoutingStatus route(final Message message, final boolean direct) throws Exception {
-      return route(message, (Transaction) null, direct);
+   public RoutingStatus route(final ServerMessage message, QueueCreator queueCreator, final boolean direct) throws Exception {
+      return route(message, queueCreator, (Transaction) null, direct);
    }
 
    @Override
-   public RoutingStatus route(final Message message, final Transaction tx, final boolean direct) throws Exception {
-      return route(message, new RoutingContextImpl(tx), direct);
+   public RoutingStatus route(final ServerMessage message,
+                     QueueCreator queueCreator,
+                     final Transaction tx,
+                     final boolean direct) throws Exception {
+      return route(message, queueCreator, new RoutingContextImpl(tx), direct);
    }
 
    @Override
-   public RoutingStatus route(final Message message,
-                              final Transaction tx,
-                              final boolean direct,
-                              final boolean rejectDuplicates) throws Exception {
-      return route(message, new RoutingContextImpl(tx), direct, rejectDuplicates);
+   public RoutingStatus route(final ServerMessage message,
+                     final QueueCreator queueCreator,
+                     final Transaction tx,
+                     final boolean direct,
+                     final boolean rejectDuplicates) throws Exception {
+      return route(message, queueCreator, new RoutingContextImpl(tx), direct, rejectDuplicates);
    }
 
    @Override
-   public RoutingStatus route(final Message message,
-                              final RoutingContext context,
-                              final boolean direct) throws Exception {
-      return route(message, context, direct, true);
+   public RoutingStatus route(final ServerMessage message,
+                           final QueueCreator queueCreator,
+                           final RoutingContext context,
+                           final boolean direct) throws Exception {
+      return route(message, queueCreator, context, direct, true);
    }
 
    @Override
-   public RoutingStatus route(final Message message,
+   public RoutingStatus route(final ServerMessage message,
+                              final QueueCreator queueCreator,
                               final RoutingContext context,
                               final boolean direct,
                               boolean rejectDuplicates) throws Exception {
-
       RoutingStatus result = RoutingStatus.OK;
       // Sanity check
       if (message.getRefCount() > 0) {
          throw new IllegalStateException("Message cannot be routed more than once");
       }
 
+      SimpleString address = message.getAddress();
+
       setPagingStore(message);
 
       AtomicBoolean startedTX = new AtomicBoolean(false);
 
-      final SimpleString address = message.getAddressSimpleString();
-
       applyExpiryDelay(message, address);
 
       if (!checkDuplicateID(message, context, rejectDuplicates, startedTX)) {
          return RoutingStatus.DUPLICATED_ID;
       }
 
-      message.cleanupInternalProperties();
+      if (message.hasInternalProperties()) {
+         // We need to perform some cleanup on internal properties,
+         // but we don't do it every time, otherwise it wouldn't be optimal
+         cleanupInternalPropertiesBeforeRouting(message);
+      }
 
-      Bindings bindings = addressManager.getBindingsForRoutingAddress(context.getAddress() == null ? message.getAddressSimpleString() : context.getAddress());
+      Bindings bindings = addressManager.getBindingsForRoutingAddress(address);
 
-      // TODO auto-create queues here?
       // first check for the auto-queue creation thing
-      if (bindings == null) {
+      if (bindings == null && queueCreator != null) {
          // There is no queue with this address, we will check if it needs to be created
-         //         if (queueCreator.create(address)) {
-         // TODO: this is not working!!!!
-         // reassign bindings if it was created
-         //            bindings = addressManager.getBindingsForRoutingAddress(address);
-         //         }
+         if (queueCreator.create(address)) {
+            // TODO: this is not working!!!!
+            // reassign bindings if it was created
+            bindings = addressManager.getBindingsForRoutingAddress(address);
+         }
       }
 
       if (bindings != null) {
          bindings.route(message, context);
-      } else {
+      }
+      else {
          // this is a debug and not warn because this could be a regular scenario on publish-subscribe queues (or topic subscriptions on JMS)
          if (logger.isDebugEnabled()) {
             logger.debug("Couldn't find any bindings for address=" + address + " on message=" + message);
@@ -795,17 +677,17 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
             if (dlaAddress == null) {
                result = RoutingStatus.NO_BINDINGS;
                ActiveMQServerLogger.LOGGER.noDLA(address);
-            } else {
-               message.referenceOriginalMessage(message, null);
+            }
+            else {
+               message.setOriginalHeaders(message, null, false);
 
                message.setAddress(dlaAddress);
 
-               message.reencode();
-
-               route(message, context.getTransaction(), false);
+               route(message, null, context.getTransaction(), false);
                result = RoutingStatus.NO_BINDINGS_DLA;
             }
-         } else {
+         }
+         else {
             result = RoutingStatus.NO_BINDINGS;
 
             if (logger.isDebugEnabled()) {
@@ -816,16 +698,16 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
                ((LargeServerMessage) message).deleteFile();
             }
          }
-      } else {
+      }
+      else {
          try {
-            server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.beforeMessageRoute(message, context, direct, rejectDuplicates) : null);
             processRoute(message, context, direct);
-            final RoutingStatus finalResult = result;
-            server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.afterMessageRoute(message, context, direct, rejectDuplicates, finalResult) : null);
-         } catch (ActiveMQAddressFullException e) {
+         }
+         catch (ActiveMQAddressFullException e) {
             if (startedTX.get()) {
                context.getTransaction().rollback();
-            } else if (context.getTransaction() != null) {
+            }
+            else if (context.getTransaction() != null) {
                context.getTransaction().markAsRollbackOnly(e);
             }
             throw e;
@@ -839,7 +721,7 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
    }
 
    // HORNETQ-1029
-   private void applyExpiryDelay(Message message, SimpleString address) {
+   private void applyExpiryDelay(ServerMessage message, SimpleString address) {
       long expirationOverride = addressSettingsRepository.getMatch(address.toString()).getExpiryDelay();
 
       // A -1 <expiry-delay> means don't do anything
@@ -852,14 +734,15 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
    }
 
    @Override
-   public MessageReference reroute(final Message message, final Queue queue, final Transaction tx) throws Exception {
-
+   public MessageReference reroute(final ServerMessage message,
+                                   final Queue queue,
+                                   final Transaction tx) throws Exception {
       setPagingStore(message);
 
-      MessageReference reference = MessageReference.Factory.createReference(message, queue);
+      MessageReference reference = message.createReference(queue);
 
-      Long scheduledDeliveryTime = message.getScheduledDeliveryTime();
-      if (scheduledDeliveryTime != null) {
+      if (message.containsProperty(Message.HDR_SCHEDULED_DELIVERY_TIME)) {
+         Long scheduledDeliveryTime = message.getLongProperty(Message.HDR_SCHEDULED_DELIVERY_TIME);
          reference.setScheduledDeliveryTime(scheduledDeliveryTime);
       }
 
@@ -869,7 +752,8 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
       if (tx == null) {
          queue.reload(reference);
-      } else {
+      }
+      else {
          List<MessageReference> refs = new ArrayList<>(1);
 
          refs.add(reference);
@@ -884,15 +768,15 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
     * The redistribution can't process the route right away as we may be dealing with a large message which will need to be processed on a different thread
     */
    @Override
-   public Pair<RoutingContext, Message> redistribute(final Message message,
-                                                     final Queue originatingQueue,
-                                                     final Transaction tx) throws Exception {
+   public Pair<RoutingContext, ServerMessage> redistribute(final ServerMessage message,
+                                                           final Queue originatingQueue,
+                                                           final Transaction tx) throws Exception {
       // We have to copy the message and store it separately, otherwise we may lose remote bindings in case of restart before the message
       // arrived the target node
       // as described on https://issues.jboss.org/browse/JBPAPP-6130
-      Message copyRedistribute = message.copy(storageManager.generateID());
+      ServerMessage copyRedistribute = message.copy(storageManager.generateID());
 
-      Bindings bindings = addressManager.getBindingsForRoutingAddress(message.getAddressSimpleString());
+      Bindings bindings = addressManager.getBindingsForRoutingAddress(message.getAddress());
 
       if (bindings != null) {
          RoutingContext context = new RoutingContextImpl(tx);
@@ -938,18 +822,6 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       return addressManager.getAddresses();
    }
 
-   @Override
-   public SimpleString getMatchingQueue(SimpleString address, RoutingType routingType) throws Exception {
-      return addressManager.getMatchingQueue(address, routingType);
-   }
-
-   @Override
-   public SimpleString getMatchingQueue(SimpleString address,
-                                        SimpleString queueName,
-                                        RoutingType routingType) throws Exception {
-      return addressManager.getMatchingQueue(address, queueName, routingType);
-   }
-
    @Override
    public void sendQueueInfoToQueue(final SimpleString queueName, final SimpleString address) throws Exception {
       // We send direct to the queue so we can send it to the same queue that is bound to the notifications address -
@@ -971,7 +843,7 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       synchronized (notificationLock) {
          // First send a reset message
 
-         Message message = new CoreMessage(storageManager.generateID(), 50);
+         ServerMessage message = new ServerMessageImpl(storageManager.generateID(), 50);
 
          message.setAddress(queueName);
          message.putBooleanProperty(PostOfficeImpl.HDR_RESET_QUEUE_DATA, true);
@@ -1021,7 +893,7 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
                }
             }
          }
-         Message completeMessage = new CoreMessage(storageManager.generateID(), 50);
+         ServerMessage completeMessage = new ServerMessageImpl(storageManager.generateID(), 50);
 
          completeMessage.setAddress(queueName);
          completeMessage.putBooleanProperty(PostOfficeImpl.HDR_RESET_QUEUE_DATA_COMPLETE, true);
@@ -1040,13 +912,39 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
    // Private -----------------------------------------------------------------
 
-   private void setPagingStore(final Message message) throws Exception {
-      PagingStore store = pagingManager.getPageStore(message.getAddressSimpleString());
+   /**
+    * @param message
+    */
+   protected void cleanupInternalPropertiesBeforeRouting(final ServerMessage message) {
+      LinkedList<SimpleString> valuesToRemove = null;
+
+      for (SimpleString name : message.getPropertyNames()) {
+         // We use properties to establish routing context on clustering.
+         // However if the client resends the message after receiving, it needs to be removed
+         if ((name.startsWith(MessageImpl.HDR_ROUTE_TO_IDS) && !name.equals(MessageImpl.HDR_ROUTE_TO_IDS)) || (name.startsWith(MessageImpl.HDR_ROUTE_TO_ACK_IDS) && !name.equals(MessageImpl.HDR_ROUTE_TO_ACK_IDS))) {
+            if (valuesToRemove == null) {
+               valuesToRemove = new LinkedList<>();
+            }
+            valuesToRemove.add(name);
+         }
+      }
+
+      if (valuesToRemove != null) {
+         for (SimpleString removal : valuesToRemove) {
+            message.removeProperty(removal);
+         }
+      }
+   }
+
+   private void setPagingStore(final ServerMessage message) throws Exception {
+      PagingStore store = pagingManager.getPageStore(message.getAddress());
 
-      message.setContext(store);
+      message.setPagingStore(store);
    }
 
-   private void routeQueueInfo(final Message message, final Queue queue, final boolean applyFilters) throws Exception {
+   private void routeQueueInfo(final ServerMessage message,
+                               final Queue queue,
+                               final boolean applyFilters) throws Exception {
       if (!applyFilters || queue.getFilter() == null || queue.getFilter().match(message)) {
          RoutingContext context = new RoutingContextImpl(null);
 
@@ -1082,15 +980,13 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
    }
 
    @Override
-   public void processRoute(final Message message,
+   public void processRoute(final ServerMessage message,
                             final RoutingContext context,
                             final boolean direct) throws Exception {
       final List<MessageReference> refs = new ArrayList<>();
 
       Transaction tx = context.getTransaction();
 
-      Long deliveryTime = message.getScheduledDeliveryTime();
-
       for (Map.Entry<SimpleString, RouteContextList> entry : context.getContexListing().entrySet()) {
          PagingStore store = pagingManager.getPageStore(entry.getKey());
 
@@ -1105,12 +1001,14 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
          }
 
          for (Queue queue : entry.getValue().getNonDurableQueues()) {
-            MessageReference reference = MessageReference.Factory.createReference(message, queue);
+            MessageReference reference = message.createReference(queue);
 
-            if (deliveryTime != null) {
-               reference.setScheduledDeliveryTime(deliveryTime);
-            }
             refs.add(reference);
+            if (message.containsProperty(Message.HDR_SCHEDULED_DELIVERY_TIME)) {
+               Long scheduledDeliveryTime = message.getLongProperty(Message.HDR_SCHEDULED_DELIVERY_TIME);
+
+               reference.setScheduledDeliveryTime(scheduledDeliveryTime);
+            }
 
             message.incrementRefCount();
          }
@@ -1120,27 +1018,31 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
          while (iter.hasNext()) {
             Queue queue = iter.next();
 
-            MessageReference reference = MessageReference.Factory.createReference(message, queue);
+            MessageReference reference = message.createReference(queue);
 
-            if (context.isAlreadyAcked(message.getAddressSimpleString(), queue)) {
+            if (context.isAlreadyAcked(message.getAddress(), queue)) {
                reference.setAlreadyAcked();
                if (tx != null) {
                   queue.acknowledge(tx, reference);
                }
             }
 
-            if (deliveryTime != null) {
-               reference.setScheduledDeliveryTime(deliveryTime);
-            }
             refs.add(reference);
 
+            if (message.containsProperty(Message.HDR_SCHEDULED_DELIVERY_TIME)) {
+               Long scheduledDeliveryTime = message.getLongProperty(Message.HDR_SCHEDULED_DELIVERY_TIME);
+
+               reference.setScheduledDeliveryTime(scheduledDeliveryTime);
+            }
+
             if (message.isDurable()) {
                int durableRefCount = message.incrementDurableRefCount();
 
                if (durableRefCount == 1) {
                   if (tx != null) {
                      storageManager.storeMessageTransactional(tx.getID(), message);
-                  } else {
+                  }
+                  else {
                      storageManager.storeMessage(message);
                   }
 
@@ -1153,14 +1055,16 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
                   storageManager.storeReferenceTransactional(tx.getID(), queue.getID(), message.getMessageID());
 
                   tx.setContainsPersistent();
-               } else {
+               }
+               else {
                   storageManager.storeReference(queue.getID(), message.getMessageID(), !iter.hasNext());
                }
 
-               if (deliveryTime > 0) {
+               if (message.containsProperty(Message.HDR_SCHEDULED_DELIVERY_TIME)) {
                   if (tx != null) {
                      storageManager.updateScheduledDeliveryTimeTransactional(tx.getID(), reference);
-                  } else {
+                  }
+                  else {
                      storageManager.updateScheduledDeliveryTime(reference);
                   }
                }
@@ -1172,7 +1076,8 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
       if (tx != null) {
          tx.addOperation(new AddOperation(refs));
-      } else {
+      }
+      else {
          // This will use the same thread if there are no pending operations
          // avoiding a context switch on this case
          storageManager.afterCompleteOperations(new IOCallback() {
@@ -1194,12 +1099,13 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
     * @param message
     * @throws Exception
     */
-   private void confirmLargeMessageSend(Transaction tx, final Message message) throws Exception {
+   private void confirmLargeMessageSend(Transaction tx, final ServerMessage message) throws Exception {
       LargeServerMessage largeServerMessage = (LargeServerMessage) message;
       if (largeServerMessage.getPendingRecordID() >= 0) {
          if (tx == null) {
             storageManager.confirmPendingLargeMessage(largeServerMessage.getPendingRecordID());
-         } else {
+         }
+         else {
             storageManager.confirmPendingLargeMessageTX(tx, largeServerMessage.getMessageID(), largeServerMessage.getPendingRecordID());
          }
          largeServerMessage.setPendingRecordID(-1);
@@ -1223,7 +1129,8 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
 
          delivery.addQueues(entry.getValue().getDurableQueues());
          delivery.addQueues(entry.getValue().getNonDurableQueues());
-      } else {
+      }
+      else {
 
          List<Queue> durableQueues = entry.getValue().getDurableQueues();
          List<Queue> nonDurableQueues = entry.getValue().getNonDurableQueues();
@@ -1250,13 +1157,13 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       }
    }
 
-   private boolean checkDuplicateID(final Message message,
+   private boolean checkDuplicateID(final ServerMessage message,
                                     final RoutingContext context,
                                     boolean rejectDuplicates,
                                     AtomicBoolean startedTX) throws Exception {
       // Check the DuplicateCache for the Bridge first
 
-      Object bridgeDup = message.removeExtraBytesProperty(Message.HDR_BRIDGE_DUPLICATE_ID);
+      Object bridgeDup = message.getObjectProperty(MessageImpl.HDR_BRIDGE_DUPLICATE_ID);
       if (bridgeDup != null) {
          // if the message is being sent from the bridge, we just ignore the duplicate id, and use the internal one
          byte[] bridgeDupBytes = (byte[]) bridgeDup;
@@ -1274,7 +1181,10 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
             message.decrementRefCount();
             return false;
          }
-      } else {
+
+         message.removeProperty(MessageImpl.HDR_BRIDGE_DUPLICATE_ID);
+      }
+      else {
          // if used BridgeDuplicate, it's not going to use the regular duplicate
          // since this will would break redistribution (re-setting the duplicateId)
          byte[] duplicateIDBytes = message.getDuplicateIDBytes();
@@ -1284,7 +1194,7 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
          boolean isDuplicate = false;
 
          if (duplicateIDBytes != null) {
-            cache = getDuplicateIDCache(message.getAddressSimpleString());
+            cache = getDuplicateIDCache(message.getAddress());
 
             isDuplicate = cache.contains(duplicateIDBytes);
 
@@ -1335,14 +1245,17 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       if (reaperPeriod > 0) {
          if (reaperRunnable != null)
             reaperRunnable.stop();
-         reaperRunnable = new Reaper(server.getScheduledPool(), server.getExecutorFactory().getExecutor(), reaperPeriod, TimeUnit.MILLISECONDS, false);
+         reaperRunnable = new Reaper();
+         reaperThread = new Thread(reaperRunnable, "activemq-expiry-reaper-thread");
+
+         reaperThread.setPriority(reaperPriority);
 
-         reaperRunnable.start();
+         reaperThread.start();
       }
    }
 
-   private Message createQueueInfoMessage(final NotificationType type, final SimpleString queueName) {
-      Message message = new CoreMessage().initBuffer(50).setMessageID(storageManager.generateID());
+   private ServerMessage createQueueInfoMessage(final NotificationType type, final SimpleString queueName) {
+      ServerMessage message = new ServerMessageImpl(storageManager.generateID(), 50);
 
       message.setAddress(queueName);
 
@@ -1356,37 +1269,48 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
       return message;
    }
 
-   private final class Reaper extends ActiveMQScheduledComponent {
+   private final class Reaper implements Runnable {
 
-      Reaper(ScheduledExecutorService scheduledExecutorService,
-             Executor executor,
-             long checkPeriod,
-             TimeUnit timeUnit,
-             boolean onDemand) {
-         super(scheduledExecutorService, executor, checkPeriod, timeUnit, onDemand);
+      private final CountDownLatch latch = new CountDownLatch(1);
+
+      public void stop() {
+         latch.countDown();
       }
 
       @Override
       public void run() {
          // The reaper thread should be finished case the PostOffice is gone
          // This is to avoid leaks on PostOffice between stops and starts
-         Map<SimpleString, Binding> nameMap = addressManager.getBindings();
+         while (isStarted()) {
+            try {
+               if (latch.await(reaperPeriod, TimeUnit.MILLISECONDS))
+                  return;
+            }
+            catch (InterruptedException e1) {
+               throw new ActiveMQInterruptedException(e1);
+            }
+            if (!isStarted())
+               return;
+
+            Map<SimpleString, Binding> nameMap = addressManager.getBindings();
 
-         List<Queue> queues = new ArrayList<>();
+            List<Queue> queues = new ArrayList<>();
 
-         for (Binding binding : nameMap.values()) {
-            if (binding.getType() == BindingType.LOCAL_QUEUE) {
-               Queue queue = (Queue) binding.getBindable();
+            for (Binding binding : nameMap.values()) {
+               if (binding.getType() == BindingType.LOCAL_QUEUE) {
+                  Queue queue = (Queue) binding.getBindable();
 
-               queues.add(queue);
+                  queues.add(queue);
+               }
             }
-         }
 
-         for (Queue queue : queues) {
-            try {
-               queue.expireReferences();
-            } catch (Exception e) {
-               ActiveMQServerLogger.LOGGER.errorExpiringMessages(e);
+            for (Queue queue : queues) {
+               try {
+                  queue.expireReferences();
+               }
+               catch (Exception e) {
+                  ActiveMQServerLogger.LOGGER.errorExpiringMessages(e);
+               }
             }
          }
       }
@@ -1436,7 +1360,7 @@ public class PostOfficeImpl implements PostOffice, NotificationListener, Binding
          // Reverse the ref counts, and paging sizes
 
          for (MessageReference ref : refs) {
-            Message message = ref.getMessage();
+            ServerMessage message = ref.getMessage();
 
             if (message.isDurable() && ref.getQueue().isDurable()) {
                message.decrementDurableRefCount();