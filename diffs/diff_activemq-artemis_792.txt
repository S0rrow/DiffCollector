diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPMessage.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPMessage.java
index 821356a6ad..9a03934696 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPMessage.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPMessage.java
@@ -26,18 +26,14 @@ import java.util.Map;
 import java.util.Set;
 
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
-import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.api.core.ActiveMQPropertyConversionException;
 import org.apache.activemq.artemis.api.core.ICoreMessage;
 import org.apache.activemq.artemis.api.core.RefCountMessage;
 import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.core.message.impl.CoreMessageObjectPools;
 import org.apache.activemq.artemis.core.persistence.Persister;
-import org.apache.activemq.artemis.protocol.amqp.converter.AMQPMessageIdHelper;
+import org.apache.activemq.artemis.protocol.amqp.converter.AMQPConverter;
 import org.apache.activemq.artemis.protocol.amqp.converter.AMQPMessageSupport;
-import org.apache.activemq.artemis.protocol.amqp.converter.AmqpCoreConverter;
-import org.apache.activemq.artemis.protocol.amqp.util.NettyReadable;
 import org.apache.activemq.artemis.protocol.amqp.util.NettyWritable;
 import org.apache.activemq.artemis.protocol.amqp.util.TLSEncode;
 import org.apache.activemq.artemis.reader.MessageUtil;
@@ -49,20 +45,13 @@ import org.apache.qpid.proton.amqp.UnsignedByte;
 import org.apache.qpid.proton.amqp.UnsignedInteger;
 import org.apache.qpid.proton.amqp.UnsignedLong;
 import org.apache.qpid.proton.amqp.UnsignedShort;
-import org.apache.qpid.proton.amqp.messaging.AmqpSequence;
-import org.apache.qpid.proton.amqp.messaging.AmqpValue;
 import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;
-import org.apache.qpid.proton.amqp.messaging.Data;
 import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;
-import org.apache.qpid.proton.amqp.messaging.Footer;
 import org.apache.qpid.proton.amqp.messaging.Header;
 import org.apache.qpid.proton.amqp.messaging.MessageAnnotations;
 import org.apache.qpid.proton.amqp.messaging.Properties;
 import org.apache.qpid.proton.amqp.messaging.Section;
 import org.apache.qpid.proton.codec.DecoderImpl;
-import org.apache.qpid.proton.codec.EncoderImpl;
-import org.apache.qpid.proton.codec.ReadableBuffer;
-import org.apache.qpid.proton.codec.TypeConstructor;
 import org.apache.qpid.proton.codec.WritableBuffer;
 import org.apache.qpid.proton.message.Message;
 import org.apache.qpid.proton.message.impl.MessageImpl;
@@ -74,285 +63,99 @@ import io.netty.buffer.Unpooled;
 // see https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html#section-message-format
 public class AMQPMessage extends RefCountMessage {
 
-   public static final SimpleString ADDRESS_PROPERTY = SimpleString.toSimpleString("_AMQ_AD");
-
-   public static final int DEFAULT_MESSAGE_FORMAT = 0;
+   public static final String HDR_LAST_VALUE_NAME = org.apache.activemq.artemis.api.core.Message.HDR_LAST_VALUE_NAME.toString();
    public static final int DEFAULT_MESSAGE_PRIORITY = 4;
    public static final int MAX_MESSAGE_PRIORITY = 9;
 
-   private static final int VALUE_NOT_PRESENT = -1;
-
-   // Buffer and state for the data backing this message.
-   private ReadableBuffer data;
-   private boolean messageDataScanned;
-
-   // Marks the message as needed to be re-encoded to update the backing buffer
-   private boolean modified;
-
-   // Track locations of the message sections for later use and track the size
-   // of the header and delivery annotations if present so we can easily exclude
-   // the delivery annotations later and perform efficient encodes or copies.
-   private int headerPosition = VALUE_NOT_PRESENT;
-   private int encodedHeaderSize;
-   private int deliveryAnnotationsPosition = VALUE_NOT_PRESENT;
-   private int encodedDeliveryAnnotationsSize;
-   private int messageAnnotationsPosition = VALUE_NOT_PRESENT;
-   private int propertiesPosition = VALUE_NOT_PRESENT;
-   private int applicationPropertiesPosition = VALUE_NOT_PRESENT;
-   private int remainingBodyPosition = VALUE_NOT_PRESENT;
-
-   // Message level meta data
-   private final long messageFormat;
-   private long messageID;
-   private SimpleString address;
+   final long messageFormat;
+   ByteBuf data;
+   boolean bufferValid;
+   Boolean durable;
+   long messageID;
+   String address;
+   MessageImpl protonMessage;
    private volatile int memoryEstimate = -1;
-   private long expiration;
-   private long scheduledTime = -1;
+   private long expiration = 0;
 
-   // The Proton based AMQP message section that are retained in memory, these are the
-   // mutable portions of the Message as the broker sees it, although AMQP defines that
-   // the Properties and ApplicationProperties are immutable so care should be taken
-   // here when making changes to those Sections.
-   private Header header;
-   private MessageAnnotations messageAnnotations;
-   private Properties properties;
-   private ApplicationProperties applicationProperties;
+   // Records where the Header section ends if present.
+   private int headerEnds = 0;
+
+   // Records where the message payload starts, ignoring DeliveryAnnotations if present
+   private int messagePaylodStart = 0;
 
+   private boolean parsedHeaders = false;
+   private Header _header;
+   private DeliveryAnnotations _deliveryAnnotations;
+   private MessageAnnotations _messageAnnotations;
+   private Properties _properties;
+   private int appLocation = -1;
+   private ApplicationProperties applicationProperties;
+   private long scheduledTime = -1;
    private String connectionID;
-   private final CoreMessageObjectPools coreMessageObjectPools;
-   private Set<Object> rejectedConsumers;
 
-   // These are properties set at the broker level and carried only internally by broker storage.
-   private volatile TypedProperties extraProperties;
+   Set<Object> rejectedConsumers;
 
-   /**
-    * Creates a new {@link AMQPMessage} instance from binary encoded message data.
-    *
-    * @param messageFormat
-    *       The Message format tag given the in Transfer that carried this message
-    * @param data
-    *       The encoded AMQP message
-    * @param extraProperties
-    *       Broker specific extra properties that should be carried with this message
-    */
-   public AMQPMessage(long messageFormat, byte[] data, TypedProperties extraProperties) {
-      this(messageFormat, data, extraProperties, null);
-   }
+   /** These are properties set at the broker level..
+    *  these are properties created by the broker only */
+   private volatile TypedProperties extraProperties;
 
-   /**
-    * Creates a new {@link AMQPMessage} instance from binary encoded message data.
-    *
-    * @param messageFormat
-    *       The Message format tag given the in Transfer that carried this message
-    * @param data
-    *       The encoded AMQP message
-    * @param extraProperties
-    *       Broker specific extra properties that should be carried with this message
-    * @param coreMessageObjectPools
-    *       Object pool used to accelerate some String operations.
-    */
-   public AMQPMessage(long messageFormat, byte[] data, TypedProperties extraProperties, CoreMessageObjectPools coreMessageObjectPools) {
-      this(messageFormat, ReadableBuffer.ByteBufferReader.wrap(data), extraProperties, coreMessageObjectPools);
+   public AMQPMessage(long messageFormat, byte[] data) {
+      this.data = Unpooled.wrappedBuffer(data);
+      this.messageFormat = messageFormat;
+      this.bufferValid = true;
+      parseHeaders();
    }
 
-   /**
-    * Creates a new {@link AMQPMessage} instance from binary encoded message data.
-    *
-    * @param messageFormat
-    *       The Message format tag given the in Transfer that carried this message
-    * @param data
-    *       The encoded AMQP message in an {@link ReadableBuffer} wrapper.
-    * @param extraProperties
-    *       Broker specific extra properties that should be carried with this message
-    * @param coreMessageObjectPools
-    *       Object pool used to accelerate some String operations.
-    */
-   public AMQPMessage(long messageFormat, ReadableBuffer data, TypedProperties extraProperties, CoreMessageObjectPools coreMessageObjectPools) {
-      this.data = data;
+   /** for persistence reload */
+   public AMQPMessage(long messageFormat) {
       this.messageFormat = messageFormat;
-      this.coreMessageObjectPools = coreMessageObjectPools;
-      this.extraProperties = extraProperties == null ? null : new TypedProperties(extraProperties);
-      ensureMessageDataScanned();
+      this.bufferValid = false;
    }
 
-   /**
-    * Internal constructor used for persistence reload of the message.
-    * <p>
-    * The message will not be usable until the persistence mechanism populates the message
-    * data and triggers a parse of the message contents to fill in the message state.
-    *
-    * @param messageFormat
-    *       The Message format tag given the in Transfer that carried this message
-    */
-   AMQPMessage(long messageFormat) {
+   public AMQPMessage(long messageFormat, Message message) {
       this.messageFormat = messageFormat;
-      this.modified = true;  // No buffer yet so this indicates invalid state.
-      this.coreMessageObjectPools = null;
+      this.protonMessage = (MessageImpl) message;
+      this.bufferValid = false;
    }
 
-   // Access to the AMQP message data using safe copies freshly decoded from the current
-   // AMQP message data stored in this message wrapper.  Changes to these values cannot
-   // be used to influence the underlying AMQP message data, the standard AMQPMessage API
-   // must be used to make changes to mutable portions of the message.
+   public AMQPMessage(Message message) {
+      this(0, message);
+   }
 
-   /**
-    * Creates and returns a Proton-J MessageImpl wrapper around the message data. Changes to
-    * the returned Message are not reflected in this message.
-    *
-    * @return a MessageImpl that wraps the AMQP message data in this {@link AMQPMessage}
-    */
    public MessageImpl getProtonMessage() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-
-      MessageImpl protonMessage = null;
-      if (data != null) {
+      if (protonMessage == null) {
          protonMessage = (MessageImpl) Message.Factory.create();
-         data.rewind();
-         protonMessage.decode(data.duplicate());
-      }
-
-      return protonMessage;
-   }
-
-   /**
-    * Returns a copy of the message Header if one is present, changes to the returned
-    * Header instance do not affect the original Message.
-    *
-    * @return a copy of the Message Header if one exists or null if none present.
-    */
-   public Header getHeader() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-      return scanForMessageSection(headerPosition, Header.class);
-   }
-
-   /**
-    * Returns a copy of the MessageAnnotations in the message if present or null.  Changes to the
-    * returned DeliveryAnnotations instance do not affect the original Message.
-    *
-    * @return a copy of the {@link DeliveryAnnotations} present in the message or null if non present.
-    */
-   public DeliveryAnnotations getDeliveryAnnotations() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-      return scanForMessageSection(deliveryAnnotationsPosition, DeliveryAnnotations.class);
-   }
-
-   /**
-    * Returns a copy of the DeliveryAnnotations in the message if present or null.  Changes to the
-    * returned MessageAnnotations instance do not affect the original Message.
-    *
-    * @return a copy of the {@link MessageAnnotations} present in the message or null if non present.
-    */
-   public MessageAnnotations getMessageAnnotations() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-      return scanForMessageSection(messageAnnotationsPosition, MessageAnnotations.class);
-   }
-
-   /**
-    * Returns a copy of the message Properties if one is present, changes to the returned
-    * Properties instance do not affect the original Message.
-    *
-    * @return a copy of the Message Properties if one exists or null if none present.
-    */
-   public Properties getProperties() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-      return scanForMessageSection(propertiesPosition, Properties.class);
-   }
-
-   /**
-    * Returns a copy of the {@link ApplicationProperties} present in the message if present or null.
-    * Changes to the returned MessageAnnotations instance do not affect the original Message.
-    *
-    * @return a copy of the {@link ApplicationProperties} present in the message or null if non present.
-    */
-   public ApplicationProperties getApplicationProperties() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-      return scanForMessageSection(applicationPropertiesPosition, ApplicationProperties.class);
-   }
-
-   /**
-    * Retrieves the AMQP Section that composes the body of this message by decoding a
-    * fresh copy from the encoded message data.  Changes to the returned value are not
-    * reflected in the value encoded in the original message.
-    *
-    * @return the Section that makes up the body of this message.
-    */
-   public Section getBody() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-
-      // We only handle Sections of AmqpSequence, AmqpValue and Data types so we filter on those.
-      // There could also be a Footer and no body so this will prevent a faulty return type in case
-      // of no body or message type we don't handle.
-      return scanForMessageSection(Math.max(0, remainingBodyPosition), AmqpSequence.class, AmqpValue.class, Data.class);
-   }
-
-   /**
-    * Retrieves the AMQP Footer encoded in the data of this message by decoding a
-    * fresh copy from the encoded message data.  Changes to the returned value are not
-    * reflected in the value encoded in the original message.
-    *
-    * @return the Footer that was encoded into this AMQP Message.
-    */
-   public Footer getFooter() {
-      ensureMessageDataScanned();
-      ensureDataIsValid();
-      return scanForMessageSection(Math.max(0, remainingBodyPosition), Footer.class);
-   }
-
-   @SuppressWarnings({ "unchecked", "rawtypes" })
-   private <T> T scanForMessageSection(int scanStartPosition, Class...targetTypes) {
-      ensureMessageDataScanned();
-
-      // In cases where we parsed out enough to know the value is not encoded in the message
-      // we can exit without doing any reads or buffer hopping.
-      if (scanStartPosition == VALUE_NOT_PRESENT) {
-         return null;
-      }
-
-      ReadableBuffer buffer = data.duplicate().position(0);
-      final DecoderImpl decoder = TLSEncode.getDecoder();
 
-      buffer.position(scanStartPosition);
-
-      T section = null;
-
-      decoder.setBuffer(buffer);
-      try {
-         while (buffer.hasRemaining()) {
-            TypeConstructor<?> constructor = decoder.readConstructor();
-            for (Class<?> type : targetTypes) {
-               if (type.equals(constructor.getTypeClass())) {
-                  section = (T) constructor.readValue();
-                  return section;
-               }
-            }
-
-            constructor.skipValue();
+         if (data != null) {
+            data.readerIndex(0);
+            protonMessage.decode(data.nioBuffer());
+            this._header = protonMessage.getHeader();
+            protonMessage.setHeader(null);
          }
-      } finally {
-         decoder.setBuffer(null);
       }
 
-      return section;
+      return protonMessage;
    }
 
-   private ApplicationProperties lazyDecodeApplicationProperties() {
-      if (applicationProperties == null && applicationPropertiesPosition != VALUE_NOT_PRESENT) {
-         applicationProperties = scanForMessageSection(applicationPropertiesPosition, ApplicationProperties.class);
+   private void initalizeObjects() {
+      if (protonMessage == null) {
+         if (data == null) {
+            headerEnds = 0;
+            messagePaylodStart = 0;
+            _header = new Header();
+            _deliveryAnnotations = new DeliveryAnnotations(new HashMap<>());
+            _properties = new Properties();
+            applicationProperties = new ApplicationProperties(new HashMap<>());
+            protonMessage = (MessageImpl) Message.Factory.create();
+            protonMessage.setApplicationProperties(applicationProperties);
+            protonMessage.setDeliveryAnnotations(_deliveryAnnotations);
+         }
       }
-
-      return applicationProperties;
    }
 
    @SuppressWarnings("unchecked")
-   private Map<String, Object> getApplicationPropertiesMap(boolean createIfAbsent) {
-      ApplicationProperties appMap = lazyDecodeApplicationProperties();
+   private Map<String, Object> getApplicationPropertiesMap() {
+      ApplicationProperties appMap = getApplicationProperties();
       Map<String, Object> map = null;
 
       if (appMap != null) {
@@ -360,359 +163,175 @@ public class AMQPMessage extends RefCountMessage {
       }
 
       if (map == null) {
-         if (createIfAbsent) {
-            map = new HashMap<>();
-            this.applicationProperties = new ApplicationProperties(map);
-         } else {
-            map = Collections.EMPTY_MAP;
-         }
+         return Collections.emptyMap();
+      } else {
+         return map;
       }
-
-      return map;
    }
 
-   @SuppressWarnings("unchecked")
-   private Map<Symbol, Object> getMessageAnnotationsMap(boolean createIfAbsent) {
-      Map<Symbol, Object> map = null;
+   private ApplicationProperties getApplicationProperties() {
+      parseHeaders();
 
-      if (messageAnnotations != null) {
-         map = messageAnnotations.getValue();
+      if (applicationProperties == null && appLocation >= 0) {
+         ByteBuffer buffer = getBuffer().nioBuffer();
+         buffer.position(appLocation);
+         TLSEncode.getDecoder().setByteBuffer(buffer);
+         Object section = TLSEncode.getDecoder().readObject();
+         if (section instanceof ApplicationProperties) {
+            this.applicationProperties = (ApplicationProperties) section;
+         }
+         this.appLocation = -1;
+         TLSEncode.getDecoder().setByteBuffer(null);
       }
 
-      if (map == null) {
-         if (createIfAbsent) {
-            map = new HashMap<>();
-            this.messageAnnotations = new MessageAnnotations(map);
+      return applicationProperties;
+   }
+
+   private void parseHeaders() {
+      if (!parsedHeaders) {
+         if (data == null) {
+            initalizeObjects();
          } else {
-            map = Collections.EMPTY_MAP;
+            partialDecode(data.nioBuffer());
          }
+         parsedHeaders = true;
       }
-
-      return map;
    }
 
-   private Object getMessageAnnotation(String annotation) {
-      return getMessageAnnotation(Symbol.getSymbol(annotation));
+   @Override
+   public org.apache.activemq.artemis.api.core.Message setConnectionID(String connectionID) {
+      this.connectionID = connectionID;
+      return this;
    }
 
-   private Object getMessageAnnotation(Symbol annotation) {
-      return getMessageAnnotationsMap(false).get(annotation);
+   @Override
+   public String getConnectionID() {
+      return connectionID;
    }
 
-   private Object removeMessageAnnotation(Symbol annotation) {
-      return getMessageAnnotationsMap(false).remove(annotation);
+   public MessageAnnotations getMessageAnnotations() {
+      parseHeaders();
+      return _messageAnnotations;
    }
 
-   private void setMessageAnnotation(String annotation, Object value) {
-      setMessageAnnotation(Symbol.getSymbol(annotation), value);
+   public Header getHeader() {
+      parseHeaders();
+      return _header;
    }
 
-   private void setMessageAnnotation(Symbol annotation, Object value) {
-      getMessageAnnotationsMap(true).put(annotation, value);
+   public Properties getProperties() {
+      parseHeaders();
+      return _properties;
    }
 
-   // Message decoding and copying methods.  Care must be taken here to ensure the buffer and the
-   // state tracking information is kept up to data.  When the message is manually changed a forced
-   // re-encode should be done to update the backing data with the in memory elements.
-
-   private synchronized void ensureMessageDataScanned() {
-      if (!messageDataScanned) {
-         scanMessageData();
-         messageDataScanned = true;
-      }
+   private Object getSymbol(String symbol) {
+      return getSymbol(Symbol.getSymbol(symbol));
    }
 
-   private synchronized void scanMessageData() {
-      DecoderImpl decoder = TLSEncode.getDecoder();
-      decoder.setBuffer(data.rewind());
-
-      header = null;
-      messageAnnotations = null;
-      properties = null;
-      applicationProperties = null;
-      expiration = 0;
-      encodedHeaderSize = 0;
-      memoryEstimate = -1;
-      scheduledTime = -1;
-      encodedDeliveryAnnotationsSize = 0;
-      headerPosition = VALUE_NOT_PRESENT;
-      deliveryAnnotationsPosition = VALUE_NOT_PRESENT;
-      propertiesPosition = VALUE_NOT_PRESENT;
-      applicationPropertiesPosition = VALUE_NOT_PRESENT;
-      remainingBodyPosition = VALUE_NOT_PRESENT;
-
-      try {
-         while (data.hasRemaining()) {
-            int constructorPos = data.position();
-            TypeConstructor<?> constructor = decoder.readConstructor();
-            if (Header.class.equals(constructor.getTypeClass())) {
-               header = (Header) constructor.readValue();
-               headerPosition = constructorPos;
-               encodedHeaderSize = data.position();
-               if (header.getTtl() != null) {
-                  expiration = System.currentTimeMillis() + header.getTtl().intValue();
-               }
-            } else if (DeliveryAnnotations.class.equals(constructor.getTypeClass())) {
-               // Don't decode these as they are not used by the broker at all and are
-               // discarded on send, mark for lazy decode if ever needed.
-               constructor.skipValue();
-               deliveryAnnotationsPosition = constructorPos;
-               encodedDeliveryAnnotationsSize = data.position() - constructorPos;
-            } else if (MessageAnnotations.class.equals(constructor.getTypeClass())) {
-               messageAnnotationsPosition = constructorPos;
-               messageAnnotations = (MessageAnnotations) constructor.readValue();
-            } else if (Properties.class.equals(constructor.getTypeClass())) {
-               propertiesPosition = constructorPos;
-               properties = (Properties) constructor.readValue();
-
-               if (properties.getAbsoluteExpiryTime() != null && properties.getAbsoluteExpiryTime().getTime() > 0) {
-                  expiration = properties.getAbsoluteExpiryTime().getTime();
-               }
-            } else if (ApplicationProperties.class.equals(constructor.getTypeClass())) {
-               // Lazy decoding will start at the TypeConstructor of these ApplicationProperties
-               // but we scan past it to grab the location of the possible body and footer section.
-               applicationPropertiesPosition = constructorPos;
-               constructor.skipValue();
-               remainingBodyPosition = data.hasRemaining() ? data.position() : VALUE_NOT_PRESENT;
-               break;
-            } else {
-               // This will be either the body or a Footer section which will be treated as an immutable
-               // and be copied as is when re-encoding the message.
-               remainingBodyPosition = constructorPos;
-               break;
-            }
-         }
-      } finally {
-         decoder.setByteBuffer(null);
-         data.rewind();
+   private Object getSymbol(Symbol symbol) {
+      MessageAnnotations annotations = getMessageAnnotations();
+      Map<Symbol, Object> mapAnnotations = annotations != null ? annotations.getValue() : null;
+      if (mapAnnotations != null) {
+         return mapAnnotations.get(symbol);
       }
-   }
 
-   @Override
-   public org.apache.activemq.artemis.api.core.Message copy() {
-      ensureDataIsValid();
-
-      ReadableBuffer view = data.duplicate().rewind();
-      byte[] newData = new byte[view.remaining()];
-
-      // Copy the full message contents with delivery annotations as they will
-      // be trimmed on send and may become useful on the broker at a later time.
-      data.get(newData);
-
-      AMQPMessage newEncode = new AMQPMessage(this.messageFormat, newData, extraProperties, coreMessageObjectPools);
-      newEncode.setMessageID(this.getMessageID());
-      return newEncode;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message copy(long newID) {
-      return copy().setMessageID(newID);
-   }
-
-   // Core Message APIs for persisting and encoding of message data along with
-   // utilities for checking memory usage and encoded size characteristics.
-
-   /**
-    * Would be called by the Artemis Core components to encode the message into
-    * the provided send buffer.  Because of how Proton message data handling works
-    * this method is not currently used by the AMQP protocol head and will not be
-    * called for out-bound sends.
-    *
-    * @see #getSendBuffer(int) for the actual method used for message sends.
-    */
-   @Override
-   public void sendBuffer(ByteBuf buffer, int deliveryCount) {
-      ensureDataIsValid();
-      NettyWritable writable = new NettyWritable(buffer);
-      writable.put(getSendBuffer(deliveryCount));
+      return null;
    }
 
-   /**
-    * Gets a ByteBuf from the Message that contains the encoded bytes to be sent on the wire.
-    * <p>
-    * When possible this method will present the bytes to the caller without copying them into
-    * a new buffer copy.  If copying is needed a new Netty buffer is created and returned. The
-    * caller should ensure that the reference count on the returned buffer is always decremented
-    * to avoid a leak in the case of a copied buffer being returned.
-    *
-    * @param deliveryCount
-    *       The new delivery count for this message.
-    *
-    * @return a Netty ByteBuf containing the encoded bytes of this Message instance.
-    */
-   public ReadableBuffer getSendBuffer(int deliveryCount) {
-      ensureDataIsValid();
-
-      if (deliveryCount > 1) {
-         return createCopyWithNewDeliveryCount(deliveryCount);
-      } else if (deliveryAnnotationsPosition != VALUE_NOT_PRESENT) {
-         return createCopyWithoutDeliveryAnnotations();
-      } else {
-         // Common case message has no delivery annotations and this is the first delivery
-         // so no re-encoding or section skipping needed.
-         return data.duplicate();
+   private Object removeSymbol(Symbol symbol) {
+      MessageAnnotations annotations = getMessageAnnotations();
+      Map<Symbol, Object> mapAnnotations = annotations != null ? annotations.getValue() : null;
+      if (mapAnnotations != null) {
+         return mapAnnotations.remove(symbol);
       }
-   }
-
-   private ReadableBuffer createCopyWithoutDeliveryAnnotations() {
-      assert deliveryAnnotationsPosition != VALUE_NOT_PRESENT;
 
-      // The original message had delivery annotations and so we must copy into a new
-      // buffer skipping the delivery annotations section as that is not meant to survive
-      // beyond this hop.
-      ReadableBuffer duplicate = data.duplicate();
-
-      final ByteBuf result = PooledByteBufAllocator.DEFAULT.heapBuffer(getEncodeSize());
-      result.writeBytes(duplicate.limit(encodedHeaderSize).byteBuffer());
-      duplicate.clear();
-      duplicate.position(encodedHeaderSize + encodedDeliveryAnnotationsSize);
-      result.writeBytes(duplicate.byteBuffer());
-
-      return new NettyReadable(result);
+      return null;
    }
 
-   private ReadableBuffer createCopyWithNewDeliveryCount(int deliveryCount) {
-      assert deliveryCount > 1;
-
-      final int amqpDeliveryCount = deliveryCount - 1;
-
-      final ByteBuf result = PooledByteBufAllocator.DEFAULT.heapBuffer(getEncodeSize());
+   private void setSymbol(String symbol, Object value) {
+      setSymbol(Symbol.getSymbol(symbol), value);
+   }
 
-      // If this is re-delivering the message then the header must be re-encoded
-      // otherwise we want to write the original header if present.  When a
-      // Header is present we need to copy it as we are updating the re-delivered
-      // message and not the stored version which we don't want to invalidate here.
-      Header header = this.header;
-      if (header == null) {
-         header = new Header();
-      } else {
-         header = new Header(header);
+   private void setSymbol(Symbol symbol, Object value) {
+      MessageAnnotations annotations = getMessageAnnotations();
+      if (annotations == null) {
+         _messageAnnotations = new MessageAnnotations(new HashMap<>());
+         annotations = _messageAnnotations;
+      }
+      Map<Symbol, Object> mapAnnotations = annotations != null ? annotations.getValue() : null;
+      if (mapAnnotations != null) {
+         mapAnnotations.put(symbol, value);
       }
-
-      header.setDeliveryCount(UnsignedInteger.valueOf(amqpDeliveryCount));
-      TLSEncode.getEncoder().setByteBuffer(new NettyWritable(result));
-      TLSEncode.getEncoder().writeObject(header);
-      TLSEncode.getEncoder().setByteBuffer((WritableBuffer) null);
-
-      // This will skip any existing delivery annotations that might have been present
-      // in the original message.
-      data.position(encodedHeaderSize + encodedDeliveryAnnotationsSize);
-      result.writeBytes(data.byteBuffer());
-      data.position(0);
-
-      return new NettyReadable(result);
    }
 
    @Override
-   public void messageChanged() {
-      modified = true;
-   }
+   public RoutingType getRoutingType() {
+      Object routingType = getSymbol(AMQPMessageSupport.ROUTING_TYPE);
 
-   @Override
-   public ByteBuf getBuffer() {
-      if (data == null) {
-         return null;
+      if (routingType != null) {
+         return RoutingType.getType((byte) routingType);
       } else {
-         if (data instanceof NettyReadable) {
-            return ((NettyReadable) data).getByteBuf();
+         routingType = getSymbol(AMQPMessageSupport.JMS_DEST_TYPE_MSG_ANNOTATION);
+         if (routingType != null) {
+            if (AMQPMessageSupport.QUEUE_TYPE == (byte) routingType || AMQPMessageSupport.TEMP_QUEUE_TYPE == (byte) routingType) {
+               return RoutingType.ANYCAST;
+            } else if (AMQPMessageSupport.TOPIC_TYPE == (byte) routingType || AMQPMessageSupport.TEMP_TOPIC_TYPE == (byte) routingType) {
+               return RoutingType.MULTICAST;
+            }
          } else {
-            return Unpooled.wrappedBuffer(data.byteBuffer());
+            return null;
          }
-      }
-   }
 
-   @Override
-   public AMQPMessage setBuffer(ByteBuf buffer) {
-      // If this is ever called we would be in a highly unfortunate state
-      this.data = null;
-      return this;
-   }
-
-   @Override
-   public int getEncodeSize() {
-      ensureDataIsValid();
-      // The encoded size will exclude any delivery annotations that are present as we will clip them.
-      return data.remaining() - encodedDeliveryAnnotationsSize;
-   }
-
-   @Override
-   public void receiveBuffer(ByteBuf buffer) {
-      // Not used for AMQP messages.
-   }
-
-   @Override
-   public int getMemoryEstimate() {
-      if (memoryEstimate == -1) {
-         memoryEstimate = memoryOffset + (data != null ? data.capacity() : 0);
+         return null;
       }
-
-      return memoryEstimate;
    }
 
    @Override
-   public ICoreMessage toCore(CoreMessageObjectPools coreMessageObjectPools) {
-      try {
-         return AmqpCoreConverter.toCore(
-            this, coreMessageObjectPools, header, messageAnnotations, properties, lazyDecodeApplicationProperties(), getBody(), getFooter());
-      } catch (Exception e) {
-         throw new RuntimeException(e.getMessage(), e);
+   public org.apache.activemq.artemis.api.core.Message setRoutingType(RoutingType routingType) {
+      parseHeaders();
+      if (routingType == null) {
+         removeSymbol(AMQPMessageSupport.ROUTING_TYPE);
+      } else {
+         setSymbol(AMQPMessageSupport.ROUTING_TYPE, routingType.getType());
       }
+      return this;
    }
 
    @Override
-   public ICoreMessage toCore() {
-      return toCore(coreMessageObjectPools);
-   }
+   public SimpleString getGroupID() {
+      parseHeaders();
 
-   @Override
-   public void persist(ActiveMQBuffer targetRecord) {
-      ensureDataIsValid();
-      targetRecord.writeInt(internalPersistSize());
-      if (data.hasArray()) {
-         targetRecord.writeBytes(data.array(), data.arrayOffset(), data.remaining());
+      if (_properties != null && _properties.getGroupId() != null) {
+         return SimpleString.toSimpleString(_properties.getGroupId());
       } else {
-         targetRecord.writeBytes(data.byteBuffer());
+         return null;
       }
    }
 
    @Override
-   public int getPersistSize() {
-      ensureDataIsValid();
-      return DataConstants.SIZE_INT + internalPersistSize();
-   }
+   public Long getScheduledDeliveryTime() {
 
-   private int internalPersistSize() {
-      return data.remaining();
-   }
+      if (scheduledTime < 0) {
+         Object objscheduledTime = getSymbol("x-opt-delivery-time");
+         Object objdelay = getSymbol("x-opt-delivery-delay");
 
-   @Override
-   public void reloadPersistence(ActiveMQBuffer record) {
-      int size = record.readInt();
-      byte[] recordArray = new byte[size];
-      record.readBytes(recordArray);
-      data = ReadableBuffer.ByteBufferReader.wrap(ByteBuffer.wrap(recordArray));
-
-      // Message state is now that the underlying buffer is loaded but the contents
-      // not yet scanned, once done the message is fully populated and ready for dispatch.
-      // Force a scan now and tidy the state variables to reflect where we are following
-      // this reload from the store.
-      scanMessageData();
-      messageDataScanned = true;
-      modified = false;
-
-      // Message state should reflect that is came from persistent storage which
-      // can happen when moved to a durable location.  We must re-encode here to
-      // avoid a subsequent redelivery from suddenly appearing with a durable header
-      // tag when the initial delivery did not.
-      if (!isDurable()) {
-         setDurable(true);
-         reencode();
+         if (objscheduledTime != null && objscheduledTime instanceof Number) {
+            this.scheduledTime = ((Number) objscheduledTime).longValue();
+         } else if (objdelay != null && objdelay instanceof Number) {
+            this.scheduledTime = System.currentTimeMillis() + ((Number) objdelay).longValue();
+         } else {
+            this.scheduledTime = 0;
+         }
       }
+
+      return scheduledTime;
    }
 
    @Override
-   public long getPersistentSize() throws ActiveMQException {
-      return getEncodeSize();
+   public AMQPMessage setScheduledDeliveryTime(Long time) {
+      parseHeaders();
+      setSymbol(AMQPMessageSupport.JMS_DELIVERY_TIME, time);
+      return this;
    }
 
    @Override
@@ -721,143 +340,162 @@ public class AMQPMessage extends RefCountMessage {
    }
 
    @Override
-   public void reencode() {
-      ensureMessageDataScanned();
-
-      // The address was updated on a message with Properties so we update them
-      // for cases where there are no properties we aren't adding a properties
-      // section which seems wrong but this preserves previous behavior.
-      if (properties != null && address != null) {
-         properties.setTo(address.toString());
+   public synchronized boolean acceptsConsumer(long consumer) {
+      if (rejectedConsumers == null) {
+         return true;
+      } else {
+         return !rejectedConsumers.contains(consumer);
       }
-
-      encodeMessage();
-      scanMessageData();
-
-      messageDataScanned = true;
-      modified = false;
    }
 
-   private synchronized void ensureDataIsValid() {
-      assert data != null;
-
-      if (modified) {
-         encodeMessage();
-         modified = false;
+   @Override
+   public synchronized void rejectConsumer(long consumer) {
+      if (rejectedConsumers == null) {
+         rejectedConsumers = new HashSet<>();
       }
+
+      rejectedConsumers.add(consumer);
    }
 
-   private synchronized void encodeMessage() {
-      int estimated = Math.max(1500, data != null ? data.capacity() + 1000 : 0);
-      ByteBuf buffer = PooledByteBufAllocator.DEFAULT.heapBuffer(estimated);
-      EncoderImpl encoder = TLSEncode.getEncoder();
+   private synchronized void partialDecode(ByteBuffer buffer) {
+      DecoderImpl decoder = TLSEncode.getDecoder();
+      decoder.setByteBuffer(buffer);
+      buffer.position(0);
 
-      try {
-         NettyWritable writable = new NettyWritable(buffer);
+      _header = null;
+      _deliveryAnnotations = null;
+      _messageAnnotations = null;
+      _properties = null;
+      applicationProperties = null;
+      Section section = null;
 
-         encoder.setByteBuffer(writable);
-         if (header != null) {
-            encoder.writeObject(header);
+      try {
+         if (buffer.hasRemaining()) {
+            section = (Section) decoder.readObject();
          }
 
-         // We currently do not encode any delivery annotations but it is conceivable
-         // that at some point they may need to be preserved, this is where that needs
-         // to happen.
+         if (section instanceof Header) {
+            _header = (Header) section;
+            headerEnds = buffer.position();
+            messagePaylodStart = headerEnds;
 
-         if (messageAnnotations != null) {
-            encoder.writeObject(messageAnnotations);
-         }
-         if (properties != null) {
-            encoder.writeObject(properties);
+            if (_header.getTtl() != null) {
+               this.expiration = System.currentTimeMillis() + _header.getTtl().intValue();
+            }
+
+            if (buffer.hasRemaining()) {
+               section = (Section) decoder.readObject();
+            } else {
+               section = null;
+            }
+
+         } else {
+            // meaning there is no header
+            headerEnds = 0;
          }
+         if (section instanceof DeliveryAnnotations) {
+            _deliveryAnnotations = (DeliveryAnnotations) section;
 
-         // Whenever possible avoid encoding sections we don't need to by
-         // checking if application properties where loaded or added and
-         // encoding only in that case.
-         if (applicationProperties != null) {
-            encoder.writeObject(applicationProperties);
+            // Advance the start beyond the delivery annotations so they are not written
+            // out on send of the message.
+            messagePaylodStart = buffer.position();
 
-            // Now raw write the remainder body and footer if present.
-            if (remainingBodyPosition != VALUE_NOT_PRESENT) {
-               writable.put(data.position(remainingBodyPosition));
+            if (buffer.hasRemaining()) {
+               section = (Section) decoder.readObject();
+            } else {
+               section = null;
             }
-         } else if (applicationPropertiesPosition != VALUE_NOT_PRESENT) {
-            // Writes out ApplicationProperties, Body and Footer in one go if present.
-            writable.put(data.position(applicationPropertiesPosition));
-         } else if (remainingBodyPosition != VALUE_NOT_PRESENT) {
-            // No Application properties at all so raw write Body and Footer sections
-            writable.put(data.position(remainingBodyPosition));
          }
+         if (section instanceof MessageAnnotations) {
+            _messageAnnotations = (MessageAnnotations) section;
 
-         byte[] bytes = new byte[buffer.writerIndex()];
+            if (buffer.hasRemaining()) {
+               section = (Section) decoder.readObject();
+            } else {
+               section = null;
+            }
+         }
+         if (section instanceof Properties) {
+            _properties = (Properties) section;
 
-         buffer.readBytes(bytes);
-         data = ReadableBuffer.ByteBufferReader.wrap(ByteBuffer.wrap(bytes));
-      } finally {
-         encoder.setByteBuffer((WritableBuffer) null);
-         buffer.release();
-      }
-   }
+            if (_properties.getAbsoluteExpiryTime() != null && _properties.getAbsoluteExpiryTime().getTime() > 0) {
+               this.expiration = _properties.getAbsoluteExpiryTime().getTime();
+            }
 
-   // These methods interact with the Extra Properties that can accompany the message but
-   // because these are not sent on the wire, update to these does not force a re-encode on
-   // send of the message.
+            // We don't read the next section on purpose, as we will parse ApplicationProperties
+            // lazily
+            section = null;
+         }
 
-   public TypedProperties createExtraProperties() {
-      if (extraProperties == null) {
-         extraProperties = new TypedProperties();
+         if (section instanceof ApplicationProperties) {
+            applicationProperties = (ApplicationProperties) section;
+         } else {
+            if (buffer.hasRemaining()) {
+               this.appLocation = buffer.position();
+            } else {
+               this.appLocation = -1;
+            }
+         }
+      } finally {
+         decoder.setByteBuffer(null);
       }
-      return extraProperties;
    }
 
-   public TypedProperties getExtraProperties() {
-      return extraProperties;
+   public long getMessageFormat() {
+      return messageFormat;
    }
 
-   public AMQPMessage setExtraProperties(TypedProperties extraProperties) {
-      this.extraProperties = extraProperties;
-      return this;
+   public int getLength() {
+      return data.array().length;
    }
 
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putExtraBytesProperty(SimpleString key, byte[] value) {
-      createExtraProperties().putBytesProperty(key, value);
-      return this;
+   public byte[] getArray() {
+      return data.array();
    }
 
    @Override
-   public byte[] getExtraBytesProperty(SimpleString key) throws ActiveMQPropertyConversionException {
-      if (extraProperties == null) {
-         return null;
-      } else {
-         return extraProperties.getBytesProperty(key);
-      }
+   public void messageChanged() {
+      bufferValid = false;
+      this.data = null;
    }
 
    @Override
-   public byte[] removeExtraBytesProperty(SimpleString key) throws ActiveMQPropertyConversionException {
-      if (extraProperties == null) {
+   public ByteBuf getBuffer() {
+      if (data == null) {
          return null;
       } else {
-         return (byte[])extraProperties.removeProperty(key);
+         return Unpooled.wrappedBuffer(data);
       }
    }
 
-   // Message meta data access for Core and AMQP usage.
-
    @Override
-   public org.apache.activemq.artemis.api.core.Message setConnectionID(String connectionID) {
-      this.connectionID = connectionID;
+   public AMQPMessage setBuffer(ByteBuf buffer) {
+      this.data = null;
       return this;
    }
 
    @Override
-   public String getConnectionID() {
-      return connectionID;
+   public org.apache.activemq.artemis.api.core.Message copy() {
+      checkBuffer();
+
+      byte[] origin = data.array();
+      byte[] newData = new byte[data.array().length - (messagePaylodStart - headerEnds)];
+
+      // Copy the original header
+      System.arraycopy(origin, 0, newData, 0, headerEnds);
+
+      // Copy the body following the delivery annotations if present
+      System.arraycopy(origin, messagePaylodStart, newData, headerEnds, data.array().length - messagePaylodStart);
+
+      AMQPMessage newEncode = new AMQPMessage(this.messageFormat, newData);
+      newEncode.setDurable(isDurable()).setMessageID(this.getMessageID());
+      return newEncode;
    }
 
-   public long getMessageFormat() {
-      return messageFormat;
+   @Override
+   public org.apache.activemq.artemis.api.core.Message copy(long newID) {
+      checkBuffer();
+      return copy().setMessageID(newID);
    }
 
    @Override
@@ -878,31 +516,23 @@ public class AMQPMessage extends RefCountMessage {
 
    @Override
    public AMQPMessage setExpiration(long expiration) {
+
+      Properties properties = getProperties();
+
       if (properties != null) {
          if (expiration <= 0) {
             properties.setAbsoluteExpiryTime(null);
          } else {
             properties.setAbsoluteExpiryTime(new Date(expiration));
          }
-      } else if (expiration > 0) {
-         properties = new Properties();
-         properties.setAbsoluteExpiryTime(new Date(expiration));
       }
-
-      // We are overriding expiration with an Absolute expiration time so any
-      // previous Header based TTL also needs to be removed.
-      if (header != null) {
-         header.setTtl(null);
-      }
-
-      this.expiration = Math.max(0, expiration);
-
+      this.expiration = expiration;
       return this;
    }
 
    @Override
    public Object getUserID() {
-      // User ID in Artemis API means Message ID
+      Properties properties = getProperties();
       if (properties != null && properties.getMessageId() != null) {
          return properties.getMessageId();
       } else {
@@ -911,14 +541,14 @@ public class AMQPMessage extends RefCountMessage {
    }
 
    /**
-    * Before we added AMQP into Artemis the name getUserID was already taken by JMSMessageID.
+    * Before we added AMQP into Artemis / Hornetq, the name getUserID was already taken by JMSMessageID.
     * We cannot simply change the names now as it would break the API for existing clients.
     *
     * This is to return and read the proper AMQP userID.
-    *
-    * @return the UserID value in the AMQP Properties if one is present.
+    * @return
     */
    public Object getAMQPUserID() {
+      Properties properties = getProperties();
       if (properties != null && properties.getUserId() != null) {
          Binary binary = properties.getUserId();
          return new String(binary.getArray(), binary.getArrayOffset(), binary.getLength(), StandardCharsets.UTF_8);
@@ -927,83 +557,71 @@ public class AMQPMessage extends RefCountMessage {
       }
    }
 
-   @Override
-   public org.apache.activemq.artemis.api.core.Message setUserID(Object userID) {
-      return null;
-   }
 
    @Override
-   public Object getDuplicateProperty() {
+   public org.apache.activemq.artemis.api.core.Message setUserID(Object userID) {
       return null;
    }
 
    @Override
    public boolean isDurable() {
-      if (header != null && header.getDurable() != null) {
-         return header.getDurable();
+      if (durable != null) {
+         return durable;
+      }
+
+      if (getHeader() != null && getHeader().getDurable() != null) {
+         durable = getHeader().getDurable();
+         return durable;
       } else {
-         return false;
+         return durable != null ? durable : false;
       }
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message setDurable(boolean durable) {
-      if (header == null) {
-         header = new Header();
-      }
-
-      header.setDurable(durable);  // Message needs to be re-encoded following this action.
+   public Object getDuplicateProperty() {
+      return null;
+   }
 
+   @Override
+   public org.apache.activemq.artemis.api.core.Message setDurable(boolean durable) {
+      this.durable = durable;
       return this;
    }
 
    @Override
    public String getAddress() {
-      SimpleString addressSimpleString = getAddressSimpleString();
-      return addressSimpleString == null ? null : addressSimpleString.toString();
+      if (address == null) {
+         Properties properties = getProtonMessage().getProperties();
+         if (properties != null) {
+            return properties.getTo();
+         } else {
+            return null;
+         }
+      } else {
+         return address;
+      }
    }
 
    @Override
    public AMQPMessage setAddress(String address) {
-      setAddress(cachedAddressSimpleString(address));
+      this.address = address;
       return this;
    }
 
    @Override
    public AMQPMessage setAddress(SimpleString address) {
-      this.address = address;
-      createExtraProperties().putSimpleStringProperty(ADDRESS_PROPERTY, address);
-      return this;
+      return setAddress(address.toString());
    }
 
    @Override
    public SimpleString getAddressSimpleString() {
-      if (address == null) {
-         TypedProperties extraProperties = getExtraProperties();
-
-         // we first check if extraProperties is not null, no need to create it just to check it here
-         if (extraProperties != null) {
-            address = extraProperties.getSimpleStringProperty(ADDRESS_PROPERTY);
-         }
-
-         if (address == null) {
-            // if it still null, it will look for the address on the getTo();
-            if (properties != null && properties.getTo() != null) {
-               address = cachedAddressSimpleString(properties.getTo());
-            }
-         }
-      }
-      return address;
-   }
-
-   private SimpleString cachedAddressSimpleString(String address) {
-      return CoreMessageObjectPools.cachedAddressSimpleString(address, coreMessageObjectPools);
+      return SimpleString.toSimpleString(getAddress());
    }
 
    @Override
    public long getTimestamp() {
-      if (properties != null && properties.getCreationTime() != null) {
-         return properties.getCreationTime().getTime();
+      if (getProperties() != null && getProperties().getCreationTime() != null) {
+         return getProperties().getCreationTime().getTime();
       } else {
          return 0L;
       }
@@ -1011,17 +629,14 @@ public class AMQPMessage extends RefCountMessage {
 
    @Override
    public org.apache.activemq.artemis.api.core.Message setTimestamp(long timestamp) {
-      if (properties == null) {
-         properties = new Properties();
-      }
-      properties.setCreationTime(new Date(timestamp));
+      getProperties().setCreationTime(new Date(timestamp));
       return this;
    }
 
    @Override
    public byte getPriority() {
-      if (header != null && header.getPriority() != null) {
-         return (byte) Math.min(header.getPriority().intValue(), MAX_MESSAGE_PRIORITY);
+      if (getHeader() != null && getHeader().getPriority() != null) {
+         return (byte) Math.min(getHeader().getPriority().intValue(), MAX_MESSAGE_PRIORITY);
       } else {
          return DEFAULT_MESSAGE_PRIORITY;
       }
@@ -1029,193 +644,271 @@ public class AMQPMessage extends RefCountMessage {
 
    @Override
    public org.apache.activemq.artemis.api.core.Message setPriority(byte priority) {
-      if (header == null) {
-         header = new Header();
-      }
-      header.setPriority(UnsignedByte.valueOf(priority));
+      getHeader().setPriority(UnsignedByte.valueOf(priority));
       return this;
    }
 
    @Override
-   public SimpleString getReplyTo() {
-      if (properties != null) {
-         return SimpleString.toSimpleString(properties.getReplyTo());
-      } else {
-         return null;
+   public void receiveBuffer(ByteBuf buffer) {
+
+   }
+
+   private synchronized void checkBuffer() {
+      if (!bufferValid) {
+         int estimated = Math.max(1500, data != null ? data.capacity() + 1000 : 0);
+         ByteBuf buffer = PooledByteBufAllocator.DEFAULT.heapBuffer(estimated);
+         try {
+            getProtonMessage().encode(new NettyWritable(buffer));
+            byte[] bytes = new byte[buffer.writerIndex()];
+            buffer.readBytes(bytes);
+            this.data = Unpooled.wrappedBuffer(bytes);
+         } finally {
+            buffer.release();
+         }
       }
    }
 
    @Override
-   public AMQPMessage setReplyTo(SimpleString address) {
-      if (properties == null) {
-         properties = new Properties();
+   public int getEncodeSize() {
+      checkBuffer();
+      // + 20checkBuffer is an estimate for the Header with the deliveryCount
+      return data.array().length - messagePaylodStart + 20;
+   }
+
+   @Override
+   public void sendBuffer(ByteBuf buffer, int deliveryCount) {
+      checkBuffer();
+
+      int amqpDeliveryCount = deliveryCount - 1;
+
+      Header header = getHeader();
+      if (header == null && (amqpDeliveryCount > 0)) {
+         header = new Header();
+         header.setDurable(durable);
       }
 
-      properties.setReplyTo(address != null ? address.toString() : null);
+      // If the re-delivering the message then the header must be re-encoded
+      // otherwise we want to write the original header if present.
+      if (amqpDeliveryCount > 0) {
+         synchronized (header) {
+            header.setDeliveryCount(UnsignedInteger.valueOf(amqpDeliveryCount));
+            TLSEncode.getEncoder().setByteBuffer(new NettyWritable(buffer));
+            TLSEncode.getEncoder().writeObject(header);
+            TLSEncode.getEncoder().setByteBuffer((WritableBuffer) null);
+         }
+      } else if (headerEnds > 0) {
+         buffer.writeBytes(data, 0, headerEnds);
+      }
+
+      buffer.writeBytes(data, messagePaylodStart, data.writerIndex() - messagePaylodStart);
+   }
+
+   public TypedProperties createExtraProperties() {
+      if (extraProperties == null) {
+         extraProperties = new TypedProperties();
+      }
+      return extraProperties;
+   }
+
+   public TypedProperties getExtraProperties() {
+      return extraProperties;
+   }
+
+   public AMQPMessage setExtraProperties(TypedProperties extraProperties) {
+      this.extraProperties = extraProperties;
       return this;
    }
 
    @Override
-   public RoutingType getRoutingType() {
-      Object routingType = getMessageAnnotation(AMQPMessageSupport.ROUTING_TYPE);
+   public org.apache.activemq.artemis.api.core.Message putExtraBytesProperty(SimpleString key, byte[] value) {
+      createExtraProperties().putBytesProperty(key, value);
+      return this;
+   }
 
-      if (routingType != null) {
-         return RoutingType.getType((byte) routingType);
+
+   @Override
+   public byte[] getExtraBytesProperty(SimpleString key) throws ActiveMQPropertyConversionException {
+      if (extraProperties == null) {
+         return null;
       } else {
-         routingType = getMessageAnnotation(AMQPMessageSupport.JMS_DEST_TYPE_MSG_ANNOTATION);
-         if (routingType != null) {
-            if (AMQPMessageSupport.QUEUE_TYPE == (byte) routingType || AMQPMessageSupport.TEMP_QUEUE_TYPE == (byte) routingType) {
-               return RoutingType.ANYCAST;
-            } else if (AMQPMessageSupport.TOPIC_TYPE == (byte) routingType || AMQPMessageSupport.TEMP_TOPIC_TYPE == (byte) routingType) {
-               return RoutingType.MULTICAST;
-            }
-         } else {
-            return null;
-         }
+         return extraProperties.getBytesProperty(key);
+      }
+   }
 
+
+   @Override
+   public byte[] removeExtraBytesProperty(SimpleString key) throws ActiveMQPropertyConversionException {
+      if (extraProperties == null) {
          return null;
+      } else {
+         return (byte[])extraProperties.removeProperty(key);
       }
    }
 
+
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putBooleanProperty(String key, boolean value) {
+      getApplicationPropertiesMap().put(key, Boolean.valueOf(value));
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putByteProperty(String key, byte value) {
+      getApplicationPropertiesMap().put(key, Byte.valueOf(value));
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putBytesProperty(String key, byte[] value) {
+      getApplicationPropertiesMap().put(key, value);
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putShortProperty(String key, short value) {
+      getApplicationPropertiesMap().put(key, Short.valueOf(value));
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putCharProperty(String key, char value) {
+      getApplicationPropertiesMap().put(key, Character.valueOf(value));
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putIntProperty(String key, int value) {
+      getApplicationPropertiesMap().put(key, Integer.valueOf(value));
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putLongProperty(String key, long value) {
+      getApplicationPropertiesMap().put(key, Long.valueOf(value));
+      return this;
+   }
+
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putFloatProperty(String key, float value) {
+      getApplicationPropertiesMap().put(key, Float.valueOf(value));
+      return this;
+   }
+
    @Override
-   public org.apache.activemq.artemis.api.core.Message setRoutingType(RoutingType routingType) {
-      if (routingType == null) {
-         removeMessageAnnotation(AMQPMessageSupport.ROUTING_TYPE);
-      } else {
-         setMessageAnnotation(AMQPMessageSupport.ROUTING_TYPE, routingType.getType());
-      }
+   public org.apache.activemq.artemis.api.core.Message putDoubleProperty(String key, double value) {
+      getApplicationPropertiesMap().put(key, Double.valueOf(value));
       return this;
    }
 
    @Override
-   public SimpleString getGroupID() {
-      ensureMessageDataScanned();
+   public org.apache.activemq.artemis.api.core.Message putBooleanProperty(SimpleString key, boolean value) {
+      getApplicationPropertiesMap().put(key.toString(), Boolean.valueOf(value));
+      return this;
+   }
 
-      if (properties != null && properties.getGroupId() != null) {
-         return SimpleString.toSimpleString(properties.getGroupId(),
-            coreMessageObjectPools == null ? null : coreMessageObjectPools.getGroupIdStringSimpleStringPool());
-      } else {
-         return null;
-      }
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putByteProperty(SimpleString key, byte value) {
+      return putByteProperty(key.toString(), value);
    }
 
    @Override
-   public Long getScheduledDeliveryTime() {
-      if (scheduledTime < 0) {
-         Object objscheduledTime = getMessageAnnotation(AMQPMessageSupport.SCHEDULED_DELIVERY_TIME);
-         Object objdelay = getMessageAnnotation(AMQPMessageSupport.SCHEDULED_DELIVERY_DELAY);
+   public org.apache.activemq.artemis.api.core.Message putBytesProperty(SimpleString key, byte[] value) {
+      return putBytesProperty(key.toString(), value);
+   }
 
-         if (objscheduledTime != null && objscheduledTime instanceof Number) {
-            this.scheduledTime = ((Number) objscheduledTime).longValue();
-         } else if (objdelay != null && objdelay instanceof Number) {
-            this.scheduledTime = System.currentTimeMillis() + ((Number) objdelay).longValue();
-         } else {
-            this.scheduledTime = 0;
-         }
-      }
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putShortProperty(SimpleString key, short value) {
+      return putShortProperty(key.toString(), value);
+   }
 
-      return scheduledTime;
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putCharProperty(SimpleString key, char value) {
+      return putCharProperty(key.toString(), value);
    }
 
    @Override
-   public AMQPMessage setScheduledDeliveryTime(Long time) {
-      if (time != null && time.longValue() > 0) {
-         setMessageAnnotation(AMQPMessageSupport.SCHEDULED_DELIVERY_TIME, time);
-         removeMessageAnnotation(AMQPMessageSupport.SCHEDULED_DELIVERY_DELAY);
-         scheduledTime = time;
-      } else {
-         removeMessageAnnotation(AMQPMessageSupport.SCHEDULED_DELIVERY_TIME);
-         removeMessageAnnotation(AMQPMessageSupport.SCHEDULED_DELIVERY_DELAY);
-         scheduledTime = 0;
-      }
+   public org.apache.activemq.artemis.api.core.Message putIntProperty(SimpleString key, int value) {
+      return putIntProperty(key.toString(), value);
+   }
 
-      return this;
+   @Override
+   public org.apache.activemq.artemis.api.core.Message putLongProperty(SimpleString key, long value) {
+      return putLongProperty(key.toString(), value);
    }
 
    @Override
-   public Object removeAnnotation(SimpleString key) {
-      return removeMessageAnnotation(Symbol.getSymbol(key.toString()));
+   public org.apache.activemq.artemis.api.core.Message putFloatProperty(SimpleString key, float value) {
+      return putFloatProperty(key.toString(), value);
    }
 
    @Override
-   public Object getAnnotation(SimpleString key) {
-      return getMessageAnnotation(key.toString());
+   public org.apache.activemq.artemis.api.core.Message putDoubleProperty(SimpleString key, double value) {
+      return putDoubleProperty(key.toString(), value);
    }
 
    @Override
-   public AMQPMessage setAnnotation(SimpleString key, Object value) {
-      setMessageAnnotation(key.toString(), value);
+   public org.apache.activemq.artemis.api.core.Message putStringProperty(String key, String value) {
+      getApplicationPropertiesMap().put(key, value);
       return this;
    }
 
-   // JMS Style property access methods.  These can result in additional decode of AMQP message
-   // data from Application properties.  Updates to application properties puts the message in a
-   // dirty state and requires a re-encode of the data to update all buffer state data otherwise
-   // the next send of the Message will not include changes made here.
-
    @Override
-   public Object removeProperty(SimpleString key) {
-      return removeProperty(key.toString());
+   public org.apache.activemq.artemis.api.core.Message putObjectProperty(String key,
+                                                                         Object value) throws ActiveMQPropertyConversionException {
+      getApplicationPropertiesMap().put(key, value);
+      return this;
    }
 
    @Override
-   public Object removeProperty(String key) {
-      return getApplicationPropertiesMap(false).remove(key);
+   public org.apache.activemq.artemis.api.core.Message putObjectProperty(SimpleString key,
+                                                                         Object value) throws ActiveMQPropertyConversionException {
+      return putObjectProperty(key.toString(), value);
    }
 
    @Override
-   public boolean containsProperty(SimpleString key) {
-      return containsProperty(key.toString());
+   public Object removeProperty(String key) {
+      return getApplicationPropertiesMap().remove(key);
    }
 
    @Override
    public boolean containsProperty(String key) {
-      return getApplicationPropertiesMap(false).containsKey(key);
+      return getApplicationPropertiesMap().containsKey(key);
    }
 
    @Override
    public Boolean getBooleanProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Boolean) getApplicationPropertiesMap(false).get(key);
+      return (Boolean) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public Byte getByteProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Byte) getApplicationPropertiesMap(false).get(key);
+      return (Byte) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public Double getDoubleProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Double) getApplicationPropertiesMap(false).get(key);
+      return (Double) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public Integer getIntProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Integer) getApplicationPropertiesMap(false).get(key);
+      return (Integer) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public Long getLongProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Long) getApplicationPropertiesMap(false).get(key);
+      return (Long) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public Object getObjectProperty(String key) {
       if (key.equals(MessageUtil.TYPE_HEADER_NAME.toString())) {
-         if (properties != null) {
-            return properties.getSubject();
-         }
+         return getProperties().getSubject();
       } else if (key.equals(MessageUtil.CONNECTION_ID_PROPERTY_NAME.toString())) {
          return getConnectionID();
-      } else if (key.equals(MessageUtil.JMSXGROUPID)) {
-         return getGroupID();
-      } else if (key.equals(MessageUtil.JMSXUSERID)) {
-         return getAMQPUserID();
-      } else if (key.equals(MessageUtil.CORRELATIONID_HEADER_NAME.toString())) {
-         if (properties != null && properties.getCorrelationId() != null) {
-            return AMQPMessageIdHelper.INSTANCE.toCorrelationIdString(properties.getCorrelationId());
-         }
       } else {
-         Object value = getApplicationPropertiesMap(false).get(key);
+         Object value = getApplicationPropertiesMap().get(key);
          if (value instanceof UnsignedInteger ||
              value instanceof UnsignedByte ||
              value instanceof UnsignedLong ||
@@ -1225,53 +918,83 @@ public class AMQPMessage extends RefCountMessage {
             return value;
          }
       }
-
-      return null;
    }
 
    @Override
    public Short getShortProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Short) getApplicationPropertiesMap(false).get(key);
+      return (Short) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public Float getFloatProperty(String key) throws ActiveMQPropertyConversionException {
-      return (Float) getApplicationPropertiesMap(false).get(key);
+      return (Float) getApplicationPropertiesMap().get(key);
    }
 
    @Override
    public String getStringProperty(String key) throws ActiveMQPropertyConversionException {
       if (key.equals(MessageUtil.TYPE_HEADER_NAME.toString())) {
-         return properties.getSubject();
+         return getProperties().getSubject();
       } else if (key.equals(MessageUtil.CONNECTION_ID_PROPERTY_NAME.toString())) {
          return getConnectionID();
       } else {
-         return (String) getApplicationPropertiesMap(false).get(key);
+         return (String) getApplicationPropertiesMap().get(key);
       }
    }
 
    @Override
-   public Set<SimpleString> getPropertyNames() {
-      HashSet<SimpleString> values = new HashSet<>();
-      for (Object k : getApplicationPropertiesMap(false).keySet()) {
-         values.add(SimpleString.toSimpleString(k.toString(), getPropertyKeysPool()));
-      }
-      return values;
+   public Object removeAnnotation(SimpleString key) {
+      return removeSymbol(Symbol.getSymbol(key.toString()));
    }
 
    @Override
-   public Boolean getBooleanProperty(SimpleString key) throws ActiveMQPropertyConversionException {
-      return getBooleanProperty(key.toString());
+   public Object getAnnotation(SimpleString key) {
+      return getSymbol(key.toString());
    }
 
    @Override
-   public Byte getByteProperty(SimpleString key) throws ActiveMQPropertyConversionException {
-      return getByteProperty(key.toString());
+   public AMQPMessage setAnnotation(SimpleString key, Object value) {
+      setSymbol(key.toString(), value);
+      return this;
+   }
+
+   @Override
+   public void reencode() {
+      if (_deliveryAnnotations != null) getProtonMessage().setDeliveryAnnotations(_deliveryAnnotations);
+      if (_messageAnnotations != null) getProtonMessage().setMessageAnnotations(_messageAnnotations);
+      if (applicationProperties != null) getProtonMessage().setApplicationProperties(applicationProperties);
+      if (_properties != null) getProtonMessage().setProperties(this._properties);
+      bufferValid = false;
+      checkBuffer();
+   }
+
+   @Override
+   public SimpleString getSimpleStringProperty(String key) throws ActiveMQPropertyConversionException {
+      return SimpleString.toSimpleString((String) getApplicationPropertiesMap().get(key));
    }
 
    @Override
    public byte[] getBytesProperty(String key) throws ActiveMQPropertyConversionException {
-      return (byte[]) getApplicationPropertiesMap(false).get(key);
+      return (byte[]) getApplicationPropertiesMap().get(key);
+   }
+
+   @Override
+   public Object removeProperty(SimpleString key) {
+      return removeProperty(key.toString());
+   }
+
+   @Override
+   public boolean containsProperty(SimpleString key) {
+      return containsProperty(key.toString());
+   }
+
+   @Override
+   public Boolean getBooleanProperty(SimpleString key) throws ActiveMQPropertyConversionException {
+      return getBooleanProperty(key.toString());
+   }
+
+   @Override
+   public Byte getByteProperty(SimpleString key) throws ActiveMQPropertyConversionException {
+      return getByteProperty(key.toString());
    }
 
    @Override
@@ -1318,187 +1041,87 @@ public class AMQPMessage extends RefCountMessage {
    public byte[] getBytesProperty(SimpleString key) throws ActiveMQPropertyConversionException {
       return getBytesProperty(key.toString());
    }
-   @Override
-   public SimpleString getSimpleStringProperty(String key) throws ActiveMQPropertyConversionException {
-      return SimpleString.toSimpleString((String) getApplicationPropertiesMap(false).get(key), getPropertyValuesPool());
-   }
-
-   // Core Message Application Property update methods, calling these puts the message in a dirty
-   // state and requires a re-encode of the data to update all buffer state data.  If no re-encode
-   // is done prior to the next dispatch the old view of the message will be sent.
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putBooleanProperty(String key, boolean value) {
-      getApplicationPropertiesMap(true).put(key, Boolean.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putByteProperty(String key, byte value) {
-      getApplicationPropertiesMap(true).put(key, Byte.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putBytesProperty(String key, byte[] value) {
-      getApplicationPropertiesMap(true).put(key, value);
-      return this;
-   }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putShortProperty(String key, short value) {
-      getApplicationPropertiesMap(true).put(key, Short.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putCharProperty(String key, char value) {
-      getApplicationPropertiesMap(true).put(key, Character.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putIntProperty(String key, int value) {
-      getApplicationPropertiesMap(true).put(key, Integer.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putLongProperty(String key, long value) {
-      getApplicationPropertiesMap(true).put(key, Long.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putFloatProperty(String key, float value) {
-      getApplicationPropertiesMap(true).put(key, Float.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putDoubleProperty(String key, double value) {
-      getApplicationPropertiesMap(true).put(key, Double.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putBooleanProperty(SimpleString key, boolean value) {
-      getApplicationPropertiesMap(true).put(key.toString(), Boolean.valueOf(value));
-      return this;
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putByteProperty(SimpleString key, byte value) {
-      return putByteProperty(key.toString(), value);
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putBytesProperty(SimpleString key, byte[] value) {
-      return putBytesProperty(key.toString(), value);
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putShortProperty(SimpleString key, short value) {
-      return putShortProperty(key.toString(), value);
+   public org.apache.activemq.artemis.api.core.Message putStringProperty(SimpleString key, SimpleString value) {
+      return putStringProperty(key.toString(), value.toString());
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putCharProperty(SimpleString key, char value) {
-      return putCharProperty(key.toString(), value);
+   public Set<SimpleString> getPropertyNames() {
+      HashSet<SimpleString> values = new HashSet<>();
+      for (Object k : getApplicationPropertiesMap().keySet()) {
+         values.add(SimpleString.toSimpleString(k.toString()));
+      }
+      return values;
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putIntProperty(SimpleString key, int value) {
-      return putIntProperty(key.toString(), value);
-   }
+   public int getMemoryEstimate() {
+      if (memoryEstimate == -1) {
+         memoryEstimate = memoryOffset + (data != null ? data.capacity() : 0);
+      }
 
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putLongProperty(SimpleString key, long value) {
-      return putLongProperty(key.toString(), value);
+      return memoryEstimate;
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putFloatProperty(SimpleString key, float value) {
-      return putFloatProperty(key.toString(), value);
+   public ICoreMessage toCore() {
+      try {
+         return AMQPConverter.getInstance().toCore(this);
+      } catch (Exception e) {
+         throw new RuntimeException(e.getMessage(), e);
+      }
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putDoubleProperty(SimpleString key, double value) {
-      return putDoubleProperty(key.toString(), value);
+   public SimpleString getLastValueProperty() {
+      return getSimpleStringProperty(HDR_LAST_VALUE_NAME);
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putStringProperty(String key, String value) {
-      getApplicationPropertiesMap(true).put(key, value);
-      return this;
+   public SimpleString getReplyTo() {
+      if (getProperties() != null) {
+         return SimpleString.toSimpleString(getProperties().getReplyTo());
+      } else {
+         return null;
+      }
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putObjectProperty(String key, Object value) throws ActiveMQPropertyConversionException {
-      getApplicationPropertiesMap(true).put(key, value);
+   public AMQPMessage setReplyTo(SimpleString address) {
+      if (getProperties() != null) {
+         getProperties().setReplyTo(address != null ? address.toString() : null);
+      }
       return this;
    }
 
    @Override
-   public org.apache.activemq.artemis.api.core.Message putObjectProperty(SimpleString key, Object value) throws ActiveMQPropertyConversionException {
-      return putObjectProperty(key.toString(), value);
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putStringProperty(SimpleString key, SimpleString value) {
-      return putStringProperty(key.toString(), value.toString());
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message putStringProperty(SimpleString key, String value) {
-      return putStringProperty(key.toString(), value);
-   }
-
-   @Override
-   public SimpleString getLastValueProperty() {
-      return getSimpleStringProperty(HDR_LAST_VALUE_NAME);
-   }
-
-   @Override
-   public org.apache.activemq.artemis.api.core.Message setLastValueProperty(SimpleString lastValueName) {
-      return putStringProperty(HDR_LAST_VALUE_NAME, lastValueName);
+   public int getPersistSize() {
+      checkBuffer();
+      return DataConstants.SIZE_INT + internalPersistSize();
    }
 
-   @Override
-   public String toString() {
-      return "AMQPMessage [durable=" + isDurable() +
-         ", messageID=" + getMessageID() +
-         ", address=" + getAddress() +
-         ", size=" + getEncodeSize() +
-         ", applicationProperties=" + applicationProperties +
-         ", properties=" + properties +
-         ", extraProperties = " + getExtraProperties() +
-         "]";
+   private int internalPersistSize() {
+      return data.array().length;
    }
 
    @Override
-   public synchronized boolean acceptsConsumer(long consumer) {
-      if (rejectedConsumers == null) {
-         return true;
-      } else {
-         return !rejectedConsumers.contains(consumer);
-      }
+   public void persist(ActiveMQBuffer targetRecord) {
+      checkBuffer();
+      targetRecord.writeInt(internalPersistSize());
+      targetRecord.writeBytes(data.array(), 0, data.array().length );
    }
 
    @Override
-   public synchronized void rejectConsumer(long consumer) {
-      if (rejectedConsumers == null) {
-         rejectedConsumers = new HashSet<>();
-      }
-
-      rejectedConsumers.add(consumer);
-   }
-
-   private SimpleString.StringSimpleStringPool getPropertyKeysPool() {
-      return coreMessageObjectPools == null ? null : coreMessageObjectPools.getPropertiesStringSimpleStringPools().getPropertyKeysPool();
-   }
-
-   private SimpleString.StringSimpleStringPool getPropertyValuesPool() {
-      return coreMessageObjectPools == null ? null : coreMessageObjectPools.getPropertiesStringSimpleStringPools().getPropertyValuesPool();
+   public void reloadPersistence(ActiveMQBuffer record) {
+      int size = record.readInt();
+      byte[] recordArray = new byte[size];
+      record.readBytes(recordArray);
+      this.messagePaylodStart = 0; // whatever was persisted will be sent
+      this.data = Unpooled.wrappedBuffer(recordArray);
+      this.bufferValid = true;
+      this.durable = true; // it's coming from the journal, so it's durable
+      parseHeaders();
    }
-}
\ No newline at end of file
+}