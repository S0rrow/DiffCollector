diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
index 7c65c2130b..d9f65a91f2 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
@@ -18,6 +18,7 @@ package org.apache.activemq.artemis.core.server.impl;
 
 import javax.transaction.xa.XAException;
 import javax.transaction.xa.Xid;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -30,7 +31,6 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.activemq.artemis.api.core.ActiveMQException;
-import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
 import org.apache.activemq.artemis.api.core.ActiveMQNonExistentQueueException;
 import org.apache.activemq.artemis.api.core.Message;
 import org.apache.activemq.artemis.api.core.Pair;
@@ -39,29 +39,28 @@ import org.apache.activemq.artemis.api.core.client.ClientSession;
 import org.apache.activemq.artemis.api.core.management.CoreNotificationType;
 import org.apache.activemq.artemis.api.core.management.ManagementHelper;
 import org.apache.activemq.artemis.api.core.management.ResourceNames;
+import org.apache.activemq.artemis.core.io.IOCallback;
 import org.apache.activemq.artemis.core.client.impl.ClientMessageImpl;
 import org.apache.activemq.artemis.core.exception.ActiveMQXAException;
 import org.apache.activemq.artemis.core.filter.Filter;
 import org.apache.activemq.artemis.core.filter.impl.FilterImpl;
-import org.apache.activemq.artemis.core.io.IOCallback;
 import org.apache.activemq.artemis.core.message.impl.MessageInternal;
 import org.apache.activemq.artemis.core.paging.PagingStore;
 import org.apache.activemq.artemis.core.persistence.OperationContext;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.postoffice.Binding;
 import org.apache.activemq.artemis.core.postoffice.BindingType;
+import org.apache.activemq.artemis.core.postoffice.Bindings;
 import org.apache.activemq.artemis.core.postoffice.PostOffice;
 import org.apache.activemq.artemis.core.postoffice.QueueBinding;
-import org.apache.activemq.artemis.core.postoffice.RoutingStatus;
 import org.apache.activemq.artemis.core.remoting.CloseListener;
 import org.apache.activemq.artemis.core.remoting.FailureListener;
 import org.apache.activemq.artemis.core.security.CheckType;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
 import org.apache.activemq.artemis.core.security.SecurityStore;
-import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
-import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.BindingQueryResult;
+import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.LargeServerMessage;
 import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.Queue;
@@ -76,6 +75,7 @@ import org.apache.activemq.artemis.core.server.management.Notification;
 import org.apache.activemq.artemis.core.transaction.ResourceManager;
 import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.core.transaction.Transaction.State;
+import org.apache.activemq.artemis.core.transaction.TransactionFactory;
 import org.apache.activemq.artemis.core.transaction.TransactionOperationAbstract;
 import org.apache.activemq.artemis.core.transaction.TransactionPropertyIndexes;
 import org.apache.activemq.artemis.core.transaction.impl.TransactionImpl;
@@ -85,7 +85,6 @@ import org.apache.activemq.artemis.utils.TypedProperties;
 import org.apache.activemq.artemis.utils.UUID;
 import org.apache.activemq.artemis.utils.json.JSONArray;
 import org.apache.activemq.artemis.utils.json.JSONObject;
-import org.jboss.logging.Logger;
 
 /**
  * Server side Session implementation
@@ -93,14 +92,12 @@ import org.jboss.logging.Logger;
 public class ServerSessionImpl implements ServerSession, FailureListener {
    // Constants -----------------------------------------------------------------------------
 
-   private static final Logger logger = Logger.getLogger(ServerSessionImpl.class);
+   private static final boolean isTrace = ActiveMQServerLogger.LOGGER.isTraceEnabled();
 
    // Static -------------------------------------------------------------------------------
 
    // Attributes ----------------------------------------------------------------------------
 
-   private boolean securityEnabled = true;
-
    protected final String username;
 
    protected final String password;
@@ -117,7 +114,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    protected final RemotingConnection remotingConnection;
 
-   protected final Map<Long, ServerConsumer> consumers = new ConcurrentHashMap<>();
+   protected final Map<Long, ServerConsumer> consumers = new ConcurrentHashMap<Long, ServerConsumer>();
 
    protected Transaction tx;
 
@@ -135,7 +132,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    protected volatile boolean started = false;
 
-   protected final Map<SimpleString, TempQueueCleanerUpper> tempQueueCleannerUppers = new HashMap<>();
+   protected final Map<SimpleString, TempQueueCleanerUpper> tempQueueCleannerUppers = new HashMap<SimpleString, TempQueueCleanerUpper>();
 
    protected final String name;
 
@@ -161,7 +158,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    private QueueCreator queueCreator;
 
    // Session's usage should be by definition single threaded, hence it's not needed to use a concurrentHashMap here
-   protected final Map<SimpleString, Pair<UUID, AtomicLong>> targetAddressInfos = new HashMap<>();
+   protected final Map<SimpleString, Pair<UUID, AtomicLong>> targetAddressInfos = new HashMap<SimpleString, Pair<UUID, AtomicLong>>();
 
    private final long creationTime = System.currentTimeMillis();
 
@@ -173,6 +170,56 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    // concurrently.
    private volatile boolean closed = false;
 
+   private final TransactionFactory transactionFactory;
+
+   //create an 'empty' session. Only used by AMQServerSession
+   //in order to check username and password
+   protected ServerSessionImpl(String username, String password) {
+      this.username = username;
+      this.password = password;
+
+      this.transactionFactory = null;
+      this.strictUpdateDeliveryCount = false;
+      this.storageManager = null;
+      this.server = null;
+      this.securityStore = null;
+      this.resourceManager = null;
+      this.remotingConnection = null;
+      this.preAcknowledge = false;
+      this.postOffice = null;
+      this.name = null;
+      this.minLargeMessageSize = 0;
+      this.managementService = null;
+      this.managementAddress = null;
+      this.context = null;
+      this.callback = null;
+      this.queueCreator = null;
+   }
+
+   public ServerSessionImpl(final String name,
+                            final String username,
+                            final String password,
+                            final int minLargeMessageSize,
+                            final boolean autoCommitSends,
+                            final boolean autoCommitAcks,
+                            final boolean preAcknowledge,
+                            final boolean strictUpdateDeliveryCount,
+                            final boolean xa,
+                            final RemotingConnection remotingConnection,
+                            final StorageManager storageManager,
+                            final PostOffice postOffice,
+                            final ResourceManager resourceManager,
+                            final SecurityStore securityStore,
+                            final ManagementService managementService,
+                            final ActiveMQServer server,
+                            final SimpleString managementAddress,
+                            final SimpleString defaultAddress,
+                            final SessionCallback callback,
+                            final OperationContext context,
+                            final QueueCreator queueCreator) throws Exception {
+      this(name, username, password, minLargeMessageSize, autoCommitSends, autoCommitAcks, preAcknowledge, strictUpdateDeliveryCount, xa, remotingConnection, storageManager, postOffice, resourceManager, securityStore, managementService, server, managementAddress, defaultAddress, callback, context, null, queueCreator);
+   }
+
    public ServerSessionImpl(final String name,
                             final String username,
                             final String password,
@@ -193,6 +240,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                             final SimpleString defaultAddress,
                             final SessionCallback callback,
                             final OperationContext context,
+                            TransactionFactory transactionFactory,
                             final QueueCreator queueCreator) throws Exception {
       this.username = username;
 
@@ -238,6 +286,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       this.queueCreator = queueCreator;
 
+      if (transactionFactory == null) {
+         this.transactionFactory = new DefaultTransactionFactory();
+      }
+      else {
+         this.transactionFactory = transactionFactory;
+      }
+
       if (!xa) {
          tx = newTransaction();
       }
@@ -245,82 +300,44 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    // ServerSession implementation ----------------------------------------------------------------------------
 
-   @Override
-   public void enableSecurity() {
-      this.securityEnabled = true;
-   }
-
-   @Override
-   public void disableSecurity() {
-      this.securityEnabled = false;
-   }
-
-   @Override
-   public boolean isClosed() {
-      return closed;
-   }
    /**
     * @return the sessionContext
     */
-   @Override
    public OperationContext getSessionContext() {
       return context;
    }
 
-   @Override
    public String getUsername() {
       return username;
    }
 
-   @Override
    public String getPassword() {
       return password;
    }
 
-   @Override
    public int getMinLargeMessageSize() {
       return minLargeMessageSize;
    }
 
-   @Override
    public String getName() {
       return name;
    }
 
-   @Override
    public Object getConnectionID() {
       return remotingConnection.getID();
    }
 
-   @Override
    public Set<ServerConsumer> getServerConsumers() {
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
       return Collections.unmodifiableSet(consumersClone);
    }
 
-   @Override
-   public void markTXFailed(Throwable e) {
-      Transaction currentTX = this.tx;
-      if (currentTX != null) {
-         if (e instanceof ActiveMQException) {
-            currentTX.markAsRollbackOnly((ActiveMQException) e);
-         }
-         else {
-            ActiveMQException exception = new ActiveMQException(e.getMessage());
-            exception.initCause(e);
-            currentTX.markAsRollbackOnly(exception);
-         }
-      }
-   }
-
-   @Override
    public boolean removeConsumer(final long consumerID) throws Exception {
       return consumers.remove(consumerID) != null;
    }
 
    protected void doClose(final boolean failed) throws Exception {
       synchronized (this) {
-         this.setStarted(false);
          if (closed)
             return;
 
@@ -338,7 +355,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       //putting closing of consumers outside the sync block
       //https://issues.jboss.org/browse/HORNETQ-1141
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
 
       for (ServerConsumer consumer : consumersClone) {
          try {
@@ -371,26 +388,16 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
          remotingConnection.removeFailureListener(this);
 
-         if (callback != null) {
-            callback.closed();
-         }
+         callback.closed();
 
          closed = true;
       }
    }
 
-   @Override
    public QueueCreator getQueueCreator() {
       return queueCreator;
    }
 
-   protected void securityCheck(SimpleString address, CheckType checkType, SecurityAuth auth) throws Exception {
-      if (securityEnabled) {
-         securityStore.check(address, checkType, auth);
-      }
-   }
-
-   @Override
    public ServerConsumer createConsumer(final long consumerID,
                                         final SimpleString queueName,
                                         final SimpleString filterString,
@@ -398,7 +405,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       return this.createConsumer(consumerID, queueName, filterString, browseOnly, true, null);
    }
 
-   @Override
    public ServerConsumer createConsumer(final long consumerID,
                                         final SimpleString queueName,
                                         final SimpleString filterString,
@@ -411,11 +417,11 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          throw ActiveMQMessageBundle.BUNDLE.noSuchQueue(queueName);
       }
 
-      securityCheck(binding.getAddress(), CheckType.CONSUME, this);
+      securityStore.check(binding.getAddress(), CheckType.CONSUME, this);
 
       Filter filter = FilterImpl.createFilter(filterString);
 
-      ServerConsumer consumer = new ServerConsumerImpl(consumerID, this, (QueueBinding)binding, filter, started, browseOnly, storageManager, callback, preAcknowledge, strictUpdateDeliveryCount, managementService, supportLargeMessage, credits, server);
+      ServerConsumer consumer = newConsumer(consumerID, this, (QueueBinding) binding, filter, started, browseOnly, storageManager, callback, preAcknowledge, strictUpdateDeliveryCount, managementService, supportLargeMessage, credits);
       consumers.put(consumer.getID(), consumer);
 
       if (!browseOnly) {
@@ -446,8 +452,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
          Notification notification = new Notification(null, CoreNotificationType.CONSUMER_CREATED, props);
 
-         if (logger.isDebugEnabled()) {
-            logger.debug("Session with user=" + username +
+         if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+            ActiveMQServerLogger.LOGGER.debug("Session with user=" + username +
                                                  ", connection=" + this.remotingConnection +
                                                  " created a consumer on queue " + queueName +
                                                  ", filter = " + filterString);
@@ -459,17 +465,22 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       return consumer;
    }
 
-   /** Some protocols may chose to hold their transactions outside of the ServerSession.
-    *  This can be used to replace the transaction.
-    *  Notice that we set autoCommitACK and autoCommitSends to true if tx == null */
-   @Override
-   public void resetTX(Transaction transaction) {
-      this.tx = transaction;
-      this.autoCommitAcks = transaction == null;
-      this.autoCommitSends = transaction == null;
+   protected ServerConsumer newConsumer(long consumerID,
+                                        ServerSessionImpl serverSessionImpl,
+                                        QueueBinding binding,
+                                        Filter filter,
+                                        boolean started2,
+                                        boolean browseOnly,
+                                        StorageManager storageManager2,
+                                        SessionCallback callback2,
+                                        boolean preAcknowledge2,
+                                        boolean strictUpdateDeliveryCount2,
+                                        ManagementService managementService2,
+                                        boolean supportLargeMessage,
+                                        Integer credits) throws Exception {
+      return new ServerConsumerImpl(consumerID, this, (QueueBinding) binding, filter, started, browseOnly, storageManager, callback, preAcknowledge, strictUpdateDeliveryCount, managementService, supportLargeMessage, credits);
    }
 
-   @Override
    public Queue createQueue(final SimpleString address,
                             final SimpleString name,
                             final SimpleString filterString,
@@ -477,13 +488,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                             final boolean durable) throws Exception {
       if (durable) {
          // make sure the user has privileges to create this queue
-         securityCheck(address, CheckType.CREATE_DURABLE_QUEUE, this);
+         securityStore.check(address, CheckType.CREATE_DURABLE_QUEUE, this);
       }
       else {
-         securityCheck(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
+         securityStore.check(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
       }
 
-      server.checkQueueCreationLimit(getUsername());
+      ((ActiveMQServerImpl) server).checkQueueCreationLimit(getUsername());
 
       Queue queue;
 
@@ -510,8 +521,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          tempQueueCleannerUppers.put(name, cleaner);
       }
 
-      if (logger.isDebugEnabled()) {
-         logger.debug("Queue " + name + " created on address " + address +
+      if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+         ActiveMQServerLogger.LOGGER.debug("Queue " + name + " created on address " + address +
                                               " with filter=" + filterString + " temporary = " +
                                               temporary + " durable=" + durable + " on session user=" + this.username + ", connection=" + this.remotingConnection);
       }
@@ -525,14 +536,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                                  final SimpleString name,
                                  boolean durable,
                                  final SimpleString filterString) throws Exception {
-      securityCheck(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
+      securityStore.check(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
 
-      server.checkQueueCreationLimit(getUsername());
+      ((ActiveMQServerImpl) server).checkQueueCreationLimit(getUsername());
 
       server.createSharedQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable);
    }
 
-   @Override
    public RemotingConnection getRemotingConnection() {
       return remotingConnection;
    }
@@ -551,15 +561,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       private void run() {
          try {
-            if (logger.isDebugEnabled()) {
-               logger.debug("deleting temporary queue " + bindingName);
+            if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+               ActiveMQServerLogger.LOGGER.debug("deleting temporary queue " + bindingName);
             }
             try {
                server.destroyQueue(bindingName, null, false);
             }
             catch (ActiveMQException e) {
                // that's fine.. it can happen due to queue already been deleted
-               logger.debug(e.getMessage(), e);
+               ActiveMQServerLogger.LOGGER.debug(e.getMessage(), e);
             }
          }
          catch (Exception e) {
@@ -567,7 +577,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          }
       }
 
-      @Override
       public void connectionFailed(ActiveMQException exception, boolean failedOver) {
          run();
       }
@@ -577,7 +586,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          connectionFailed(me, failedOver);
       }
 
-      @Override
       public void connectionClosed() {
          run();
       }
@@ -589,7 +597,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    }
 
-   @Override
    public void deleteQueue(final SimpleString queueToDelete) throws Exception {
       Binding binding = postOffice.getBinding(queueToDelete);
 
@@ -608,19 +615,67 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public QueueQueryResult executeQueueQuery(final SimpleString name) throws Exception {
-      return server.queueQuery(name);
+      boolean autoCreateJmsQueues = name.toString().startsWith(ResourceNames.JMS_QUEUE) && server.getAddressSettingsRepository().getMatch(name.toString()).isAutoCreateJmsQueues();
+
+      if (name == null) {
+         throw ActiveMQMessageBundle.BUNDLE.queueNameIsNull();
+      }
+
+      QueueQueryResult response;
+
+      Binding binding = postOffice.getBinding(name);
+
+      if (binding != null && binding.getType() == BindingType.LOCAL_QUEUE) {
+         Queue queue = (Queue) binding.getBindable();
+
+         Filter filter = queue.getFilter();
+
+         SimpleString filterString = filter == null ? null : filter.getFilterString();
+
+         response = new QueueQueryResult(name, binding.getAddress(), queue.isDurable(), queue.isTemporary(), filterString, queue.getConsumerCount(), queue.getMessageCount(), autoCreateJmsQueues);
+      }
+      // make an exception for the management address (see HORNETQ-29)
+      else if (name.equals(managementAddress)) {
+         response = new QueueQueryResult(name, managementAddress, true, false, null, -1, -1, autoCreateJmsQueues);
+      }
+      else if (autoCreateJmsQueues) {
+         response = new QueueQueryResult(name, name, true, false, null, 0, 0, true, false);
+      }
+      else {
+         response = new QueueQueryResult(null, null, false, false, null, 0, 0, false, false);
+      }
+
+      return response;
    }
 
-   @Override
    public BindingQueryResult executeBindingQuery(final SimpleString address) throws Exception {
-      return server.bindingQuery(address);
+      boolean autoCreateJmsQueues = address.toString().startsWith(ResourceNames.JMS_QUEUE) && server.getAddressSettingsRepository().getMatch(address.toString()).isAutoCreateJmsQueues();
+
+      if (address == null) {
+         throw ActiveMQMessageBundle.BUNDLE.addressIsNull();
+      }
+
+      List<SimpleString> names = new ArrayList<SimpleString>();
+
+      // make an exception for the management address (see HORNETQ-29)
+      if (address.equals(managementAddress)) {
+         return new BindingQueryResult(true, names, autoCreateJmsQueues);
+      }
+
+      Bindings bindings = postOffice.getMatchingBindings(address);
+
+      for (Binding binding : bindings.getBindings()) {
+         if (binding.getType() == BindingType.LOCAL_QUEUE || binding.getType() == BindingType.REMOTE_QUEUE) {
+            names.add(binding.getUniqueName());
+         }
+      }
+
+      return new BindingQueryResult(!names.isEmpty(), names, autoCreateJmsQueues);
    }
 
-   @Override
    public void forceConsumerDelivery(final long consumerID, final long sequence) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
+      ServerConsumer consumer = consumers.get(consumerID);
 
       // this would be possible if the server consumer was closed by pings/pongs.. etc
       if (consumer != null) {
@@ -628,24 +683,28 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
+   public void promptDelivery(long consumerID) {
+      ServerConsumer consumer = consumers.get(consumerID);
+
+      // this would be possible if the server consumer was closed by pings/pongs.. etc
+      if (consumer != null) {
+         consumer.promptDelivery();
+      }
+   }
+
    public void acknowledge(final long consumerID, final long messageID) throws Exception {
-      ServerConsumer consumer = findConsumer(consumerID);
+      ServerConsumer consumer = consumers.get(consumerID);
+
+      if (consumer == null) {
+         throw ActiveMQMessageBundle.BUNDLE.consumerDoesntExist(consumerID);
+      }
 
       if (tx != null && tx.getState() == State.ROLLEDBACK) {
          // JBPAPP-8845 - if we let stuff to be acked on a rolled back TX, we will just
          // have these messages to be stuck on the limbo until the server is restarted
          // The tx has already timed out, so we need to ack and rollback immediately
          Transaction newTX = newTransaction();
-         try {
-            consumer.acknowledge(newTX, messageID);
-         }
-         catch (Exception e) {
-            // just ignored
-            // will log it just in case
-            logger.debug("Ignored exception while acking messageID " + messageID +
-                                                 " on a rolledback TX", e);
-         }
+         consumer.acknowledge(newTX, messageID);
          newTX.rollback();
       }
       else {
@@ -653,30 +712,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
-   public ServerConsumer locateConsumer(long consumerID) {
-      return consumers.get(consumerID);
-   }
-
-   private ServerConsumer findConsumer(long consumerID) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
-
-      if (consumer == null) {
-         Transaction currentTX = tx;
-         ActiveMQIllegalStateException exception = ActiveMQMessageBundle.BUNDLE.consumerDoesntExist(consumerID);
-
-         if (currentTX != null) {
-            currentTX.markAsRollbackOnly(exception);
-         }
-
-         throw exception;
-      }
-      return consumer;
-   }
-
-   @Override
    public void individualAcknowledge(final long consumerID, final long messageID) throws Exception {
-      ServerConsumer consumer = findConsumer(consumerID);
+      ServerConsumer consumer = consumers.get(consumerID);
 
       if (tx != null && tx.getState() == State.ROLLEDBACK) {
          // JBPAPP-8845 - if we let stuff to be acked on a rolled back TX, we will just
@@ -692,9 +729,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    }
 
-   @Override
    public void individualCancel(final long consumerID, final long messageID, boolean failed) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
+      ServerConsumer consumer = consumers.get(consumerID);
 
       if (consumer != null) {
          consumer.individualCancel(messageID, failed);
@@ -702,19 +738,17 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    }
 
-   @Override
    public void expire(final long consumerID, final long messageID) throws Exception {
-      MessageReference ref = locateConsumer(consumerID).removeReferenceByID(messageID);
+      MessageReference ref = consumers.get(consumerID).removeReferenceByID(messageID);
 
       if (ref != null) {
          ref.getQueue().expire(ref);
       }
    }
 
-   @Override
    public synchronized void commit() throws Exception {
-      if (logger.isTraceEnabled()) {
-         logger.trace("Calling commit");
+      if (isTrace) {
+         ActiveMQServerLogger.LOGGER.trace("Calling commit");
       }
       try {
          if (tx != null) {
@@ -731,7 +765,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public void rollback(final boolean considerLastMessageAsDelivered) throws Exception {
       rollback(false, considerLastMessageAsDelivered);
    }
@@ -762,9 +795,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    /**
     * @return
     */
-   @Override
-   public Transaction newTransaction() {
-      return new TransactionImpl(null, storageManager, timeoutSeconds);
+   protected Transaction newTransaction() {
+      return transactionFactory.newTransaction(null, storageManager, timeoutSeconds);
    }
 
    /**
@@ -772,10 +804,9 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
     * @return
     */
    private Transaction newTransaction(final Xid xid) {
-      return new TransactionImpl(xid, storageManager, timeoutSeconds);
+      return transactionFactory.newTransaction(xid, storageManager, timeoutSeconds);
    }
 
-   @Override
    public synchronized void xaCommit(final Xid xid, final boolean onePhase) throws Exception {
 
       if (tx != null && tx.getXid().equals(xid)) {
@@ -786,8 +817,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       else {
          Transaction theTx = resourceManager.removeTransaction(xid);
 
-         if (logger.isTraceEnabled()) {
-            logger.trace("XAcommit into " + theTx + ", xid=" + xid);
+         if (isTrace) {
+            ActiveMQServerLogger.LOGGER.trace("XAcommit into " + theTx + ", xid=" + xid);
          }
 
          if (theTx == null) {
@@ -800,8 +831,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                throw new ActiveMQXAException(XAException.XA_HEURRB, "transaction has been heuristically rolled back: " + xid);
             }
             else {
-               if (logger.isTraceEnabled()) {
-                  logger.trace("XAcommit into " + theTx + ", xid=" + xid + " cannot find it");
+               if (isTrace) {
+                  ActiveMQServerLogger.LOGGER.trace("XAcommit into " + theTx + ", xid=" + xid + " cannot find it");
                }
 
                throw new ActiveMQXAException(XAException.XAER_NOTA, "Cannot find xid in resource manager: " + xid);
@@ -821,7 +852,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaEnd(final Xid xid) throws Exception {
       if (tx != null && tx.getXid().equals(xid)) {
          if (tx.getState() == Transaction.State.SUSPENDED) {
@@ -865,7 +895,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaForget(final Xid xid) throws Exception {
       long id = resourceManager.removeHeuristicCompletion(xid);
 
@@ -884,7 +913,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaJoin(final Xid xid) throws Exception {
       Transaction theTx = resourceManager.getTransaction(xid);
 
@@ -903,7 +931,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaResume(final Xid xid) throws Exception {
       if (tx != null) {
          final String msg = "Cannot resume, session is currently doing work in a transaction " + tx.getXid();
@@ -931,7 +958,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaRollback(final Xid xid) throws Exception {
       if (tx != null && tx.getXid().equals(xid)) {
          final String msg = "Cannot roll back, session is currently doing work in a transaction " + tx.getXid();
@@ -940,8 +966,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
       else {
          Transaction theTx = resourceManager.removeTransaction(xid);
-         if (logger.isTraceEnabled()) {
-            logger.trace("xarollback into " + theTx);
+         if (isTrace) {
+            ActiveMQServerLogger.LOGGER.trace("xarollback into " + theTx);
          }
 
          if (theTx == null) {
@@ -954,8 +980,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                throw new ActiveMQXAException(XAException.XA_HEURRB, "transaction has ben heuristically rolled back: " + xid);
             }
             else {
-               if (logger.isTraceEnabled()) {
-                  logger.trace("xarollback into " + theTx + ", xid=" + xid + " forcing a rollback regular");
+               if (isTrace) {
+                  ActiveMQServerLogger.LOGGER.trace("xarollback into " + theTx + ", xid=" + xid + " forcing a rollback regular");
                }
 
                try {
@@ -973,8 +999,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          }
          else {
             if (theTx.getState() == Transaction.State.SUSPENDED) {
-               if (logger.isTraceEnabled()) {
-                  logger.trace("xarollback into " + theTx + " sending tx back as it was suspended");
+               if (isTrace) {
+                  ActiveMQServerLogger.LOGGER.trace("xarollback into " + theTx + " sending tx back as it was suspended");
                }
 
                // Put it back
@@ -989,7 +1015,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaStart(final Xid xid) throws Exception {
       if (tx != null) {
          ActiveMQServerLogger.LOGGER.xidReplacedOnXStart(tx.getXid().toString(), xid.toString());
@@ -1004,14 +1029,14 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             }
          }
          catch (Exception e) {
-            logger.debug("An exception happened while we tried to debug the previous tx, we can ignore this exception", e);
+            ActiveMQServerLogger.LOGGER.debug("An exception happened while we tried to debug the previous tx, we can ignore this exception", e);
          }
       }
 
       tx = newTransaction(xid);
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("xastart into tx= " + tx);
+      if (isTrace) {
+         ActiveMQServerLogger.LOGGER.trace("xastart into tx= " + tx);
       }
 
       boolean added = resourceManager.putTransaction(xid, tx);
@@ -1023,34 +1048,35 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaFailed(final Xid xid) throws Exception {
-      Transaction theTX = resourceManager.getTransaction(xid);
-
-      if (theTX == null) {
-         theTX = newTransaction(xid);
-         resourceManager.putTransaction(xid, theTX);
-      }
+      if (tx != null) {
+         final String msg = "Cannot start, session is already doing work in a transaction " + tx.getXid();
 
-      if (theTX.isEffective()) {
-         logger.debug("Client failed with Xid " + xid + " but the server already had it " + theTX.getState());
-         tx = null;
+         throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
       }
       else {
-         theTX.markAsRollbackOnly(new ActiveMQException("Can't commit as a Failover happened during the operation"));
-         tx = theTX;
-      }
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("xastart into tx= " + tx);
+         tx = newTransaction(xid);
+         tx.markAsRollbackOnly(new ActiveMQException("Can't commit as a Failover happened during the operation"));
+
+         if (isTrace) {
+            ActiveMQServerLogger.LOGGER.trace("xastart into tx= " + tx);
+         }
+
+         boolean added = resourceManager.putTransaction(xid, tx);
+
+         if (!added) {
+            final String msg = "Cannot start, there is already a xid " + tx.getXid();
+
+            throw new ActiveMQXAException(XAException.XAER_DUPID, msg);
+         }
       }
    }
 
-   @Override
    public synchronized void xaSuspend() throws Exception {
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("xasuspend on " + this.tx);
+      if (isTrace) {
+         ActiveMQServerLogger.LOGGER.trace("xasuspend on " + this.tx);
       }
 
       if (tx == null) {
@@ -1072,7 +1098,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public synchronized void xaPrepare(final Xid xid) throws Exception {
       if (tx != null && tx.getXid().equals(xid)) {
          final String msg = "Cannot commit, session is currently doing work in a transaction " + tx.getXid();
@@ -1082,8 +1107,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       else {
          Transaction theTx = resourceManager.getTransaction(xid);
 
-         if (logger.isTraceEnabled()) {
-            logger.trace("xaprepare into " + ", xid=" + xid + ", tx= " + tx);
+         if (isTrace) {
+            ActiveMQServerLogger.LOGGER.trace("xaprepare into " + ", xid=" + xid + ", tx= " + tx);
          }
 
          if (theTx == null) {
@@ -1105,17 +1130,20 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public List<Xid> xaGetInDoubtXids() {
-      return resourceManager.getInDoubtTransactions();
+      List<Xid> xids = new ArrayList<Xid>();
+
+      xids.addAll(resourceManager.getPreparedTransactions());
+      xids.addAll(resourceManager.getHeuristicCommittedTransactions());
+      xids.addAll(resourceManager.getHeuristicRolledbackTransactions());
+
+      return xids;
    }
 
-   @Override
    public int xaGetTimeout() {
       return resourceManager.getTimeoutSeconds();
    }
 
-   @Override
    public void xaSetTimeout(final int timeout) {
       timeoutSeconds = timeout;
       if (tx != null) {
@@ -1123,17 +1151,14 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public void start() {
       setStarted(true);
    }
 
-   @Override
    public void stop() {
       setStarted(false);
    }
 
-   @Override
    public void waitContextCompletion() {
       try {
          if (!context.waitCompletion(10000)) {
@@ -1145,16 +1170,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public void close(final boolean failed) {
       if (closed)
          return;
       context.executeOnCompletion(new IOCallback() {
-         @Override
          public void onError(int errorCode, String errorMessage) {
          }
 
-         @Override
          public void done() {
             try {
                doClose(failed);
@@ -1166,9 +1188,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       });
    }
 
-   @Override
    public void closeConsumer(final long consumerID) throws Exception {
-      final ServerConsumer consumer = locateConsumer(consumerID);
+      final ServerConsumer consumer = consumers.get(consumerID);
 
       if (consumer != null) {
          consumer.close(false);
@@ -1178,12 +1199,11 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public void receiveConsumerCredits(final long consumerID, final int credits) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
+      ServerConsumer consumer = consumers.get(consumerID);
 
       if (consumer == null) {
-         logger.debug("There is no consumer with id " + consumerID);
+         ActiveMQServerLogger.LOGGER.debug("There is no consumer with id " + consumerID);
 
          return;
       }
@@ -1193,18 +1213,20 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public Transaction getCurrentTransaction() {
+      if (tx == null) {
+         tx = newTransaction();
+      }
       return tx;
    }
 
-   @Override
    public void sendLarge(final MessageInternal message) throws Exception {
       // need to create the LargeMessage before continue
       long id = storageManager.generateID();
 
       LargeServerMessage largeMsg = storageManager.createLargeMessage(id, message);
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("sendLarge::" + largeMsg);
+      if (ActiveMQServerLogger.LOGGER.isTraceEnabled()) {
+         ActiveMQServerLogger.LOGGER.trace("sendLarge::" + largeMsg);
       }
 
       if (currentLargeMessage != null) {
@@ -1214,14 +1236,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       currentLargeMessage = largeMsg;
    }
 
-   @Override
-   public RoutingStatus send(final ServerMessage message, final boolean direct) throws Exception {
-      return send(message, direct, false);
-   }
-
-   @Override
-   public RoutingStatus send(final ServerMessage message, final boolean direct, boolean noAutoCreateQueue) throws Exception {
-      RoutingStatus result = RoutingStatus.OK;
+   public void send(final ServerMessage message, final boolean direct) throws Exception {
       //large message may come from StompSession directly, in which
       //case the id header already generated.
       if (!message.isLargeMessage()) {
@@ -1233,7 +1248,9 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       SimpleString address = message.getAddress();
 
-      checkDefaultAddress(address);
+      if (defaultAddress == null && address != null) {
+         defaultAddress = address;
+      }
 
       if (address == null) {
          if (message.isDurable()) {
@@ -1247,8 +1264,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          }
       }
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("send(message=" + message + ", direct=" + direct + ") being called");
+      if (isTrace) {
+         ActiveMQServerLogger.LOGGER.trace("send(message=" + message + ", direct=" + direct + ") being called");
       }
 
       if (message.getAddress() == null) {
@@ -1262,18 +1279,10 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          handleManagementMessage(message, direct);
       }
       else {
-         result = doSend(message, direct, noAutoCreateQueue);
+         doSend(message, direct);
       }
-      return result;
    }
 
-   protected void checkDefaultAddress(SimpleString address) {
-      if (defaultAddress == null && address != null) {
-         defaultAddress = address;
-      }
-   }
-
-   @Override
    public void sendContinuations(final int packetSize,
                                  final long messageBodySize,
                                  final byte[] body,
@@ -1294,22 +1303,16 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             currentLargeMessage.putLongProperty(Message.HDR_LARGE_BODY_SIZE, messageBodySize);
          }
 
-         doSend(currentLargeMessage, false, false);
+         doSend(currentLargeMessage, false);
 
          currentLargeMessage = null;
       }
    }
 
-   @Override
    public void requestProducerCredits(final SimpleString address, final int credits) throws Exception {
-      // When the client gets the producer credits it already has the intention of sending messages
-      // and it will already register the default address on the core protocol
-      // hence we need to set it here when we request credits as well
-      checkDefaultAddress(address);
       PagingStore store = server.getPagingManager().getPageStore(address);
 
       if (!store.checkMemory(new Runnable() {
-         @Override
          public void run() {
             callback.sendProducerCreditsMessage(credits, address);
          }
@@ -1318,24 +1321,21 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public void setTransferring(final boolean transferring) {
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
 
       for (ServerConsumer consumer : consumersClone) {
          consumer.setTransferring(transferring);
       }
    }
 
-   @Override
    public void addMetaData(String key, String data) {
       if (metaData == null) {
-         metaData = new HashMap<>();
+         metaData = new HashMap<String, String>();
       }
       metaData.put(key, data);
    }
 
-   @Override
    public boolean addUniqueMetaData(String key, String data) {
       ServerSession sessionWithMetaData = server.lookupSession(key, data);
       if (sessionWithMetaData != null && sessionWithMetaData != this) {
@@ -1348,7 +1348,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public String getMetaData(String key) {
       String data = null;
       if (metaData != null) {
@@ -1362,7 +1361,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       return data;
    }
 
-   @Override
    public String[] getTargetAddresses() {
       Map<SimpleString, Pair<UUID, AtomicLong>> copy = cloneTargetAddresses();
       Iterator<SimpleString> iter = copy.keySet().iterator();
@@ -1376,7 +1374,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       return addresses;
    }
 
-   @Override
    public String getLastSentMessageID(String address) {
       Pair<UUID, AtomicLong> value = targetAddressInfos.get(SimpleString.toSimpleString(address));
       if (value != null) {
@@ -1387,7 +1384,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
    public long getCreationTime() {
       return this.creationTime;
    }
@@ -1465,11 +1461,11 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    }
 
    private Map<SimpleString, Pair<UUID, AtomicLong>> cloneTargetAddresses() {
-      return new HashMap<>(targetAddressInfos);
+      return new HashMap<SimpleString, Pair<UUID, AtomicLong>>(targetAddressInfos);
    }
 
    private void setStarted(final boolean s) {
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
 
       for (ServerConsumer consumer : consumersClone) {
          consumer.setStarted(s);
@@ -1480,7 +1476,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    private void handleManagementMessage(final ServerMessage message, final boolean direct) throws Exception {
       try {
-         securityCheck(message.getAddress(), CheckType.MANAGE, this);
+         securityStore.check(message.getAddress(), CheckType.MANAGE, this);
       }
       catch (ActiveMQException e) {
          if (!autoCommitSends) {
@@ -1496,7 +1492,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (replyTo != null) {
          reply.setAddress(replyTo);
 
-         doSend(reply, direct, false);
+         doSend(reply, direct);
       }
    }
 
@@ -1505,7 +1501,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                            final Transaction theTx) throws Exception {
       boolean wasStarted = started;
 
-      List<MessageReference> toCancel = new ArrayList<>();
+      List<MessageReference> toCancel = new ArrayList<MessageReference>();
 
       for (ServerConsumer consumer : consumers.values()) {
          if (wasStarted) {
@@ -1522,10 +1518,9 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (theTx.getState() == State.ROLLEDBACK) {
          Transaction newTX = newTransaction();
          cancelAndRollback(clientFailed, newTX, wasStarted, toCancel);
+         throw new IllegalStateException("Transaction has already been rolled back");
       }
-      else {
-         cancelAndRollback(clientFailed, theTx, wasStarted, toCancel);
-      }
+      cancelAndRollback(clientFailed, theTx, wasStarted, toCancel);
    }
 
    private void cancelAndRollback(boolean clientFailed,
@@ -1552,11 +1547,10 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       theTx.rollback();
    }
 
-   protected RoutingStatus doSend(final ServerMessage msg, final boolean direct, final boolean noAutoCreateQueue) throws Exception {
-      RoutingStatus result = RoutingStatus.OK;
+   protected void doSend(final ServerMessage msg, final boolean direct) throws Exception {
       // check the user has write access to this address.
       try {
-         securityCheck(msg.getAddress(), CheckType.SEND, this);
+         securityStore.check(msg.getAddress(), CheckType.SEND, this);
       }
       catch (ActiveMQException e) {
          if (!autoCommitSends && tx != null) {
@@ -1572,17 +1566,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
 
       try {
-         if (noAutoCreateQueue) {
-            result = postOffice.route(msg, null, routingContext, direct);
-         }
-         else {
-            result = postOffice.route(msg, queueCreator, routingContext, direct);
-         }
+         postOffice.route(msg, queueCreator, routingContext, direct);
 
          Pair<UUID, AtomicLong> value = targetAddressInfos.get(msg.getAddress());
 
          if (value == null) {
-            targetAddressInfos.put(msg.getAddress(), new Pair<>(msg.getUserID(), new AtomicLong(1)));
+            targetAddressInfos.put(msg.getAddress(), new Pair<UUID, AtomicLong>(msg.getUserID(), new AtomicLong(1)));
          }
          else {
             value.setA(msg.getUserID());
@@ -1592,7 +1581,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       finally {
          routingContext.clear();
       }
-      return result;
    }
 
    @Override
@@ -1611,4 +1599,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          return Collections.emptyList();
       }
    }
+
+   private static class DefaultTransactionFactory implements TransactionFactory {
+
+      @Override
+      public Transaction newTransaction(Xid xid, StorageManager storageManager, int timeoutSeconds) {
+         return new TransactionImpl(xid, storageManager, timeoutSeconds);
+      }
+   }
 }