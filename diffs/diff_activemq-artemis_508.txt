diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/RefsOperation.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/RefsOperation.java
index 92d1a61be3..bd6d772862 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/RefsOperation.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/RefsOperation.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -16,13 +16,6 @@
  */
 package org.apache.activemq.artemis.core.server.impl;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.MessageReference;
@@ -32,11 +25,17 @@ import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.core.transaction.TransactionOperationAbstract;
 import org.apache.activemq.artemis.core.transaction.impl.TransactionImpl;
 
-public class RefsOperation extends TransactionOperationAbstract {
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
 
+public class RefsOperation extends TransactionOperationAbstract
+{
    private final StorageManager storageManager;
    private Queue queue;
-   List<MessageReference> refsToAck = new ArrayList<>();
+   List<MessageReference> refsToAck = new ArrayList<MessageReference>();
 
    List<ServerMessage> pagedMessagesToPostACK = null;
 
@@ -46,29 +45,35 @@ public class RefsOperation extends TransactionOperationAbstract {
     */
    protected boolean ignoreRedeliveryCheck = false;
 
-   public RefsOperation(Queue queue, StorageManager storageManager) {
+   public RefsOperation(Queue queue, StorageManager storageManager)
+   {
       this.queue = queue;
       this.storageManager = storageManager;
    }
 
    // once turned on, we shouldn't turn it off, that's why no parameters
-   public void setIgnoreRedeliveryCheck() {
+   public void setIgnoreRedeliveryCheck()
+   {
       ignoreRedeliveryCheck = true;
    }
 
-   synchronized void addAck(final MessageReference ref) throws ActiveMQException {
+   synchronized void addAck(final MessageReference ref)
+   {
       refsToAck.add(ref);
-      if (ref.isPaged()) {
-         if (pagedMessagesToPostACK == null) {
-            pagedMessagesToPostACK = new ArrayList<>();
+      if (ref.isPaged())
+      {
+         if (pagedMessagesToPostACK == null)
+         {
+            pagedMessagesToPostACK = new ArrayList<ServerMessage>();
          }
          pagedMessagesToPostACK.add(ref.getMessage());
       }
    }
 
    @Override
-   public void afterRollback(final Transaction tx) {
-      Map<QueueImpl, LinkedList<MessageReference>> queueMap = new HashMap<>();
+   public void afterRollback(final Transaction tx)
+   {
+      Map<QueueImpl, LinkedList<MessageReference>> queueMap = new HashMap<QueueImpl, LinkedList<MessageReference>>();
 
       long timeBase = System.currentTimeMillis();
 
@@ -76,22 +81,28 @@ public class RefsOperation extends TransactionOperationAbstract {
       // previous state persisted.
       List<MessageReference> ackedRefs = new ArrayList<>();
 
-      for (MessageReference ref : refsToAck) {
+      for (MessageReference ref : refsToAck)
+      {
          ref.setConsumerId(null);
 
-         if (ActiveMQServerLogger.LOGGER.isTraceEnabled()) {
+         if (ActiveMQServerLogger.LOGGER.isTraceEnabled())
+         {
             ActiveMQServerLogger.LOGGER.trace("rolling back " + ref);
          }
-         try {
-            if (ref.isAlreadyAcked()) {
+         try
+         {
+            if (ref.isAlreadyAcked())
+            {
                ackedRefs.add(ref);
             }
             // if ignore redelivery check, we just perform redelivery straight
-            if (ref.getQueue().checkRedelivery(ref, timeBase, ignoreRedeliveryCheck)) {
+            if (ref.getQueue().checkRedelivery(ref, timeBase, ignoreRedeliveryCheck))
+            {
                LinkedList<MessageReference> toCancel = queueMap.get(ref.getQueue());
 
-               if (toCancel == null) {
-                  toCancel = new LinkedList<>();
+               if (toCancel == null)
+               {
+                  toCancel = new LinkedList<MessageReference>();
 
                   queueMap.put((QueueImpl) ref.getQueue(), toCancel);
                }
@@ -99,32 +110,40 @@ public class RefsOperation extends TransactionOperationAbstract {
                toCancel.addFirst(ref);
             }
          }
-         catch (Exception e) {
+         catch (Exception e)
+         {
             ActiveMQServerLogger.LOGGER.errorCheckingDLQ(e);
          }
       }
 
-      for (Map.Entry<QueueImpl, LinkedList<MessageReference>> entry : queueMap.entrySet()) {
+      for (Map.Entry<QueueImpl, LinkedList<MessageReference>> entry : queueMap.entrySet())
+      {
          LinkedList<MessageReference> refs = entry.getValue();
 
          QueueImpl queue = entry.getKey();
 
-         synchronized (queue) {
+         synchronized (queue)
+         {
             queue.postRollback(refs);
          }
       }
 
-      if (!ackedRefs.isEmpty()) {
+      if (!ackedRefs.isEmpty())
+      {
          //since pre acked refs have no previous state we need to actually create this by storing the message and the
          //message references
-         try {
+         try
+         {
             Transaction ackedTX = new TransactionImpl(storageManager);
-            for (MessageReference ref : ackedRefs) {
+            for (MessageReference ref : ackedRefs)
+            {
                ServerMessage message = ref.getMessage();
-               if (message.isDurable()) {
+               if (message.isDurable())
+               {
                   int durableRefCount = message.incrementDurableRefCount();
 
-                  if (durableRefCount == 1) {
+                  if (durableRefCount == 1)
+                  {
                      storageManager.storeMessageTransactional(ackedTX.getID(), message);
                   }
                   Queue queue = ref.getQueue();
@@ -138,36 +157,34 @@ public class RefsOperation extends TransactionOperationAbstract {
             }
             ackedTX.commit(true);
          }
-         catch (Exception e) {
+         catch (Exception e)
+         {
             e.printStackTrace();
          }
       }
    }
 
    @Override
-   public void afterCommit(final Transaction tx) {
-      for (MessageReference ref : refsToAck) {
-         synchronized (ref.getQueue()) {
-            try {
-               queue.postAcknowledge(ref);
-            }
-            catch (ActiveMQException e) {
-               if (queue instanceof QueueImpl) {
-                  ((QueueImpl) queue).criticalError(e);
-               }
-               else {
-                  ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
-               }
-            }
+   public void afterCommit(final Transaction tx)
+   {
+      for (MessageReference ref : refsToAck)
+      {
+         synchronized (ref.getQueue())
+         {
+            queue.postAcknowledge(ref);
          }
       }
 
-      if (pagedMessagesToPostACK != null) {
-         for (ServerMessage msg : pagedMessagesToPostACK) {
-            try {
+      if (pagedMessagesToPostACK != null)
+      {
+         for (ServerMessage msg : pagedMessagesToPostACK)
+         {
+            try
+            {
                msg.decrementRefCount();
             }
-            catch (Exception e) {
+            catch (Exception e)
+            {
                ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
             }
          }
@@ -175,17 +192,21 @@ public class RefsOperation extends TransactionOperationAbstract {
    }
 
    @Override
-   public synchronized List<MessageReference> getRelatedMessageReferences() {
-      List<MessageReference> listRet = new LinkedList<>();
+   public synchronized List<MessageReference> getRelatedMessageReferences()
+   {
+      List<MessageReference> listRet = new LinkedList<MessageReference>();
       listRet.addAll(listRet);
       return listRet;
    }
 
    @Override
-   public synchronized List<MessageReference> getListOnConsumer(long consumerID) {
-      List<MessageReference> list = new LinkedList<>();
-      for (MessageReference ref : refsToAck) {
-         if (ref.getConsumerId() != null && ref.getConsumerId().equals(consumerID)) {
+   public synchronized List<MessageReference> getListOnConsumer(long consumerID)
+   {
+      List<MessageReference> list = new LinkedList<MessageReference>();
+      for (MessageReference ref : refsToAck)
+      {
+         if (ref.getConsumerId() != null && ref.getConsumerId().equals(consumerID))
+         {
             list.add(ref);
          }
       }
@@ -193,7 +214,8 @@ public class RefsOperation extends TransactionOperationAbstract {
       return list;
    }
 
-   public List<MessageReference> getReferencesToAcknowledge() {
+   public List<MessageReference> getReferencesToAcknowledge()
+   {
       return refsToAck;
    }
 