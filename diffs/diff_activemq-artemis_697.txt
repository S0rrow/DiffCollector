diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/ServerSessionPacketHandler.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/ServerSessionPacketHandler.java
index 54d1d44157..192afb60de 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/ServerSessionPacketHandler.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/protocol/core/ServerSessionPacketHandler.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -16,31 +16,55 @@
  */
 package org.apache.activemq.artemis.core.protocol.core;
 
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_QUEUE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_SHARED_QUEUE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.DELETE_QUEUE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_ACKNOWLEDGE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_BINDINGQUERY;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_CLOSE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_COMMIT;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_CONSUMER_CLOSE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_CREATECONSUMER;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_EXPIRED;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_FLOWTOKEN;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_FORCE_CONSUMER_DELIVERY;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_INDIVIDUAL_ACKNOWLEDGE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_QUEUEQUERY;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_ROLLBACK;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_SEND;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_SEND_CONTINUATION;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_SEND_LARGE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_START;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_STOP;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_COMMIT;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_END;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_FORGET;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_GET_TIMEOUT;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_INDOUBT_XIDS;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_JOIN;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_PREPARE;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_RESUME;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_ROLLBACK;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_SET_TIMEOUT;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_START;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_FAILED;
+import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_SUSPEND;
+
+import java.util.List;
+
 import javax.transaction.xa.XAResource;
 import javax.transaction.xa.Xid;
-import java.util.List;
-import java.util.concurrent.Executor;
 
 import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.api.core.ActiveMQExceptionType;
-import org.apache.activemq.artemis.api.core.ActiveMQIOErrorException;
 import org.apache.activemq.artemis.api.core.ActiveMQInternalErrorException;
-import org.apache.activemq.artemis.api.core.ActiveMQQueueMaxConsumerLimitReached;
-import org.apache.activemq.artemis.api.core.Message;
-import org.apache.activemq.artemis.api.core.RoutingType;
-import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.api.core.client.ClientSession;
 import org.apache.activemq.artemis.core.exception.ActiveMQXAException;
-import org.apache.activemq.artemis.core.io.IOCallback;
+import org.apache.activemq.artemis.core.journal.IOAsyncTask;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
-import org.apache.activemq.artemis.core.protocol.core.impl.CoreProtocolManager;
 import org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ActiveMQExceptionMessage;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.CreateAddressMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.CreateQueueMessage;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.CreateQueueMessage_V2;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.CreateSharedQueueMessage;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.CreateSharedQueueMessage_V2;
+import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ActiveMQExceptionMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.NullResponseMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.RollbackMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionAcknowledgeMessage;
@@ -49,8 +73,6 @@ import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionAdd
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionBindingQueryMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionBindingQueryResponseMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionBindingQueryResponseMessage_V2;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionBindingQueryResponseMessage_V3;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionBindingQueryResponseMessage_V4;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionConsumerCloseMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionConsumerFlowCreditMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionCreateConsumerMessage;
@@ -61,7 +83,6 @@ import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionInd
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionQueueQueryMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionQueueQueryResponseMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionQueueQueryResponseMessage_V2;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionQueueQueryResponseMessage_V3;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionRequestProducerCreditsMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionSendContinuationMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionSendLargeMessage;
@@ -84,59 +105,16 @@ import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.SessionXAS
 import org.apache.activemq.artemis.core.remoting.CloseListener;
 import org.apache.activemq.artemis.core.remoting.FailureListener;
 import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;
-import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.BindingQueryResult;
-import org.apache.activemq.artemis.core.server.LargeServerMessage;
+import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
+import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
 import org.apache.activemq.artemis.spi.core.remoting.Connection;
-import org.apache.activemq.artemis.utils.OrderedExecutorFactory;
-import org.apache.activemq.artemis.utils.SimpleFuture;
-import org.apache.activemq.artemis.utils.SimpleFutureImpl;
-import org.jboss.logging.Logger;
-
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_ADDRESS;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_QUEUE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_QUEUE_V2;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_SHARED_QUEUE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.CREATE_SHARED_QUEUE_V2;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.DELETE_QUEUE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_ACKNOWLEDGE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_BINDINGQUERY;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_CLOSE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_COMMIT;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_CONSUMER_CLOSE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_CREATECONSUMER;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_EXPIRED;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_FLOWTOKEN;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_FORCE_CONSUMER_DELIVERY;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_INDIVIDUAL_ACKNOWLEDGE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_QUEUEQUERY;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_ROLLBACK;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_SEND;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_SEND_CONTINUATION;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_SEND_LARGE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_START;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_STOP;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_COMMIT;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_END;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_FAILED;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_FORGET;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_GET_TIMEOUT;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_INDOUBT_XIDS;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_JOIN;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_PREPARE;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_RESUME;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_ROLLBACK;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_SET_TIMEOUT;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_START;
-import static org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl.SESS_XA_SUSPEND;
-
-public class ServerSessionPacketHandler implements ChannelHandler {
-
-   private static final Logger logger = Logger.getLogger(ServerSessionPacketHandler.class);
 
+public class ServerSessionPacketHandler implements ChannelHandler
+{
    private final ServerSession session;
 
    private final StorageManager storageManager;
@@ -145,101 +123,80 @@ public class ServerSessionPacketHandler implements ChannelHandler {
 
    private volatile CoreRemotingConnection remotingConnection;
 
-   private final Executor callExecutor;
-
-   private final CoreProtocolManager manager;
-
-   // The current currentLargeMessage being processed
-   private volatile LargeServerMessage currentLargeMessage;
-
    private final boolean direct;
 
-   public ServerSessionPacketHandler(final Executor callExecutor,
-                                     final CoreProtocolManager manager,
-                                     final ServerSession session,
+   public ServerSessionPacketHandler(final ServerSession session,
                                      final StorageManager storageManager,
-                                     final Channel channel) {
-      this.manager = manager;
-
+                                     final Channel channel)
+   {
       this.session = session;
 
-      session.addCloseable((boolean failed) -> clearLargeMessage());
-
       this.storageManager = storageManager;
 
       this.channel = channel;
 
       this.remotingConnection = channel.getConnection();
 
+      //TODO think of a better way of doing this
       Connection conn = remotingConnection.getTransportConnection();
 
-      this.callExecutor = callExecutor;
-
-      if (conn instanceof NettyConnection) {
-         direct = ((NettyConnection) conn).isDirectDeliver();
-      } else {
-         direct = false;
+      if (conn instanceof NettyConnection)
+      {
+         direct = ((NettyConnection)conn).isDirectDeliver();
       }
-   }
-
-   private void clearLargeMessage() {
-      if (currentLargeMessage != null) {
-         try {
-            currentLargeMessage.deleteFile();
-         } catch (Throwable error) {
-            ActiveMQServerLogger.LOGGER.errorDeletingLargeMessageFile(error);
-         }
+      else
+      {
+         direct = false;
       }
    }
 
-   public ServerSession getSession() {
+   public ServerSession getSession()
+   {
       return session;
    }
 
-   public long getID() {
+   public long getID()
+   {
       return channel.getID();
    }
 
-   public void connectionFailed(final ActiveMQException exception, boolean failedOver) {
+   public void connectionFailed(final ActiveMQException exception, boolean failedOver)
+   {
       ActiveMQServerLogger.LOGGER.clientConnectionFailed(session.getName());
 
-      try {
+      try
+      {
          session.close(true);
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          ActiveMQServerLogger.LOGGER.errorClosingSession(e);
       }
-      flushExecutor();
 
       ActiveMQServerLogger.LOGGER.clearingUpSession(session.getName());
    }
 
-   private void flushExecutor() {
-      OrderedExecutorFactory.flushExecutor(callExecutor);
-   }
-
-   public void close() {
-      flushExecutor();
-
+   public void close()
+   {
       channel.flushConfirmations();
 
-      try {
+      try
+      {
          session.close(false);
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          ActiveMQServerLogger.LOGGER.errorClosingSession(e);
       }
    }
 
-   public Channel getChannel() {
+   public Channel getChannel()
+   {
       return channel;
    }
 
-   @Override
-   public void handlePacket(final Packet packet) {
-      channel.confirm(packet);
-      callExecutor.execute(() -> internalHandlePacket(packet));
-   }
-
-   private void internalHandlePacket(final Packet packet) {
+   public void handlePacket(final Packet packet)
+   {
       byte type = packet.getType();
 
       storageManager.setContext(session.getSessionContext());
@@ -249,388 +206,405 @@ public class ServerSessionPacketHandler implements ChannelHandler {
       boolean closeChannel = false;
       boolean requiresResponse = false;
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("ServerSessionPacketHandler::handlePacket," + packet);
-      }
-
-      try {
-         try {
-            switch (type) {
-               case SESS_CREATECONSUMER: {
-                  SessionCreateConsumerMessage request = (SessionCreateConsumerMessage) packet;
+      try
+      {
+         try
+         {
+            switch (type)
+            {
+               case SESS_CREATECONSUMER:
+               {
+                  SessionCreateConsumerMessage request = (SessionCreateConsumerMessage)packet;
                   requiresResponse = request.isRequiresResponse();
-                  session.createConsumer(request.getID(), request.getQueueName(remotingConnection.getClientVersion()), request.getFilterString(), request.isBrowseOnly());
-                  if (requiresResponse) {
+                  session.createConsumer(request.getID(),
+                        request.getQueueName(),
+                        request.getFilterString(),
+                        request.isBrowseOnly());
+                  if (requiresResponse)
+                  {
                      // We send back queue information on the queue as a response- this allows the queue to
                      // be automatically recreated on failover
-                     QueueQueryResult queueQueryResult = session.executeQueueQuery(request.getQueueName(remotingConnection.getClientVersion()));
-
-                     if (channel.supports(PacketImpl.SESS_QUEUEQUERY_RESP_V3)) {
-                        response = new SessionQueueQueryResponseMessage_V3(queueQueryResult);
-                     } else if (channel.supports(PacketImpl.SESS_QUEUEQUERY_RESP_V2)) {
+                     QueueQueryResult queueQueryResult = session.executeQueueQuery(request.getQueueName());
+                     if (channel.supports(PacketImpl.SESS_QUEUEQUERY_RESP_V2))
+                     {
                         response = new SessionQueueQueryResponseMessage_V2(queueQueryResult);
-                     } else {
+                     }
+                     else
+                     {
                         response = new SessionQueueQueryResponseMessage(queueQueryResult);
                      }
                   }
 
                   break;
                }
-               case CREATE_ADDRESS: {
-                  CreateAddressMessage request = (CreateAddressMessage) packet;
-                  requiresResponse = request.isRequiresResponse();
-                  session.createAddress(request.getAddress(), request.getRoutingTypes(), request.isAutoCreated());
-                  if (requiresResponse) {
-                     response = new NullResponseMessage();
-                  }
-                  break;
-               }
-               case CREATE_QUEUE: {
-                  CreateQueueMessage request = (CreateQueueMessage) packet;
-                  requiresResponse = request.isRequiresResponse();
-                  session.createQueue(request.getAddress(), request.getQueueName(), RoutingType.MULTICAST, request.getFilterString(), request.isTemporary(), request.isDurable());
-                  if (requiresResponse) {
-                     response = new NullResponseMessage();
-                  }
-                  break;
-               }
-               case CREATE_QUEUE_V2: {
-                  CreateQueueMessage_V2 request = (CreateQueueMessage_V2) packet;
+               case CREATE_QUEUE:
+               {
+                  CreateQueueMessage request = (CreateQueueMessage)packet;
                   requiresResponse = request.isRequiresResponse();
-                  session.createQueue(request.getAddress(), request.getQueueName(), request.getRoutingType(), request.getFilterString(), request.isTemporary(), request.isDurable(), request.getMaxConsumers(), request.isPurgeOnNoConsumers(),
-                                      request.isAutoCreated());
-                  if (requiresResponse) {
+                  session.createQueue(request.getAddress(),
+                        request.getQueueName(),
+                        request.getFilterString(),
+                        request.isTemporary(),
+                        request.isDurable());
+                  if (requiresResponse)
+                  {
                      response = new NullResponseMessage();
                   }
                   break;
                }
-               case CREATE_SHARED_QUEUE: {
-                  CreateSharedQueueMessage request = (CreateSharedQueueMessage) packet;
+               case CREATE_SHARED_QUEUE:
+               {
+                  CreateSharedQueueMessage request = (CreateSharedQueueMessage)packet;
                   requiresResponse = request.isRequiresResponse();
-                  session.createSharedQueue(request.getAddress(), request.getQueueName(), request.isDurable(), request.getFilterString());
-                  if (requiresResponse) {
+                  session.createSharedQueue(request.getAddress(),
+                        request.getQueueName(),
+                        request.isDurable(),
+                        request.getFilterString());
+                  if (requiresResponse)
+                  {
                      response = new NullResponseMessage();
                   }
                   break;
                }
-               case CREATE_SHARED_QUEUE_V2: {
-                  CreateSharedQueueMessage_V2 request = (CreateSharedQueueMessage_V2) packet;
-                  requiresResponse = request.isRequiresResponse();
-                  session.createSharedQueue(request.getAddress(), request.getQueueName(), request.getRoutingType(), request.isDurable(), request.getFilterString());
-                  if (requiresResponse) {
-                     response = new NullResponseMessage();
-                  }
-                  break;
-               }
-               case DELETE_QUEUE: {
+               case DELETE_QUEUE:
+               {
                   requiresResponse = true;
-                  SessionDeleteQueueMessage request = (SessionDeleteQueueMessage) packet;
+                  SessionDeleteQueueMessage request = (SessionDeleteQueueMessage)packet;
                   session.deleteQueue(request.getQueueName());
                   response = new NullResponseMessage();
                   break;
                }
-               case SESS_QUEUEQUERY: {
+               case SESS_QUEUEQUERY:
+               {
                   requiresResponse = true;
-                  SessionQueueQueryMessage request = (SessionQueueQueryMessage) packet;
-                  QueueQueryResult result = session.executeQueueQuery(request.getQueueName(remotingConnection.getClientVersion()));
-                  if (channel.supports(PacketImpl.SESS_QUEUEQUERY_RESP_V3)) {
-                     response = new SessionQueueQueryResponseMessage_V3(result);
-                  } else if (channel.supports(PacketImpl.SESS_QUEUEQUERY_RESP_V2)) {
+                  SessionQueueQueryMessage request = (SessionQueueQueryMessage)packet;
+                  QueueQueryResult result = session.executeQueueQuery(request.getQueueName());
+                  if (channel.supports(PacketImpl.SESS_QUEUEQUERY_RESP_V2))
+                  {
                      response = new SessionQueueQueryResponseMessage_V2(result);
-                  } else {
+                  }
+                  else
+                  {
                      response = new SessionQueueQueryResponseMessage(result);
                   }
                   break;
                }
-               case SESS_BINDINGQUERY: {
+               case SESS_BINDINGQUERY:
+               {
                   requiresResponse = true;
-                  SessionBindingQueryMessage request = (SessionBindingQueryMessage) packet;
-                  final int clientVersion = remotingConnection.getClientVersion();
-                  BindingQueryResult result = session.executeBindingQuery(request.getAddress(clientVersion));
-
-                  /* if the session is JMS and it's from an older client then we need to add the old prefix to the queue
-                   * names otherwise the older client won't realize the queue exists and will try to create it and receive
-                   * an error
-                   */
-                  if (clientVersion < PacketImpl.ADDRESSING_CHANGE_VERSION && session.getMetaData(ClientSession.JMS_SESSION_IDENTIFIER_PROPERTY) != null) {
-                     final List<SimpleString> queueNames = result.getQueueNames();
-                     if (!queueNames.isEmpty()) {
-                        final List<SimpleString> convertedQueueNames = request.convertQueueNames(clientVersion, queueNames);
-                        if (convertedQueueNames != queueNames) {
-                           result = new BindingQueryResult(result.isExists(), convertedQueueNames, result.isAutoCreateQueues(), result.isAutoCreateAddresses(), result.isDefaultPurgeOnNoConsumers(), result.getDefaultMaxConsumers());
-                        }
-                     }
+                  SessionBindingQueryMessage request = (SessionBindingQueryMessage)packet;
+                  BindingQueryResult result = session.executeBindingQuery(request.getAddress());
+                  if (channel.supports(PacketImpl.SESS_BINDINGQUERY_RESP_V2))
+                  {
+                     response = new SessionBindingQueryResponseMessage_V2(result.isExists(), result.getQueueNames(), result.isAutoCreateJmsQueues());
                   }
-
-                  if (channel.supports(PacketImpl.SESS_BINDINGQUERY_RESP_V4)) {
-                     response = new SessionBindingQueryResponseMessage_V4(result.isExists(), result.getQueueNames(), result.isAutoCreateQueues(), result.isAutoCreateAddresses(), result.isDefaultPurgeOnNoConsumers(), result.getDefaultMaxConsumers());
-                  } else if (channel.supports(PacketImpl.SESS_BINDINGQUERY_RESP_V3)) {
-                     response = new SessionBindingQueryResponseMessage_V3(result.isExists(), result.getQueueNames(), result.isAutoCreateQueues(), result.isAutoCreateAddresses());
-                  } else if (channel.supports(PacketImpl.SESS_BINDINGQUERY_RESP_V2)) {
-                     response = new SessionBindingQueryResponseMessage_V2(result.isExists(), result.getQueueNames(), result.isAutoCreateQueues());
-                  } else {
+                  else
+                  {
                      response = new SessionBindingQueryResponseMessage(result.isExists(), result.getQueueNames());
                   }
                   break;
                }
-               case SESS_ACKNOWLEDGE: {
-                  SessionAcknowledgeMessage message = (SessionAcknowledgeMessage) packet;
+               case SESS_ACKNOWLEDGE:
+               {
+                  SessionAcknowledgeMessage message = (SessionAcknowledgeMessage)packet;
                   requiresResponse = message.isRequiresResponse();
                   session.acknowledge(message.getConsumerID(), message.getMessageID());
-                  if (requiresResponse) {
+                  if (requiresResponse)
+                  {
                      response = new NullResponseMessage();
                   }
                   break;
                }
-               case SESS_EXPIRED: {
-                  SessionExpireMessage message = (SessionExpireMessage) packet;
+               case SESS_EXPIRED:
+               {
+                  SessionExpireMessage message = (SessionExpireMessage)packet;
                   session.expire(message.getConsumerID(), message.getMessageID());
                   break;
                }
-               case SESS_COMMIT: {
+               case SESS_COMMIT:
+               {
                   requiresResponse = true;
                   session.commit();
                   response = new NullResponseMessage();
                   break;
                }
-               case SESS_ROLLBACK: {
+               case SESS_ROLLBACK:
+               {
                   requiresResponse = true;
                   session.rollback(((RollbackMessage) packet).isConsiderLastMessageAsDelivered());
                   response = new NullResponseMessage();
                   break;
                }
-               case SESS_XA_COMMIT: {
+               case SESS_XA_COMMIT:
+               {
                   requiresResponse = true;
-                  SessionXACommitMessage message = (SessionXACommitMessage) packet;
+                  SessionXACommitMessage message = (SessionXACommitMessage)packet;
                   session.xaCommit(message.getXid(), message.isOnePhase());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_END: {
+               case SESS_XA_END:
+               {
                   requiresResponse = true;
-                  SessionXAEndMessage message = (SessionXAEndMessage) packet;
+                  SessionXAEndMessage message = (SessionXAEndMessage)packet;
                   session.xaEnd(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_FORGET: {
+               case SESS_XA_FORGET:
+               {
                   requiresResponse = true;
-                  SessionXAForgetMessage message = (SessionXAForgetMessage) packet;
+                  SessionXAForgetMessage message = (SessionXAForgetMessage)packet;
                   session.xaForget(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_JOIN: {
+               case SESS_XA_JOIN:
+               {
                   requiresResponse = true;
-                  SessionXAJoinMessage message = (SessionXAJoinMessage) packet;
+                  SessionXAJoinMessage message = (SessionXAJoinMessage)packet;
                   session.xaJoin(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_RESUME: {
+               case SESS_XA_RESUME:
+               {
                   requiresResponse = true;
-                  SessionXAResumeMessage message = (SessionXAResumeMessage) packet;
+                  SessionXAResumeMessage message = (SessionXAResumeMessage)packet;
                   session.xaResume(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_ROLLBACK: {
+               case SESS_XA_ROLLBACK:
+               {
                   requiresResponse = true;
-                  SessionXARollbackMessage message = (SessionXARollbackMessage) packet;
+                  SessionXARollbackMessage message = (SessionXARollbackMessage)packet;
                   session.xaRollback(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_START: {
+               case SESS_XA_START:
+               {
                   requiresResponse = true;
-                  SessionXAStartMessage message = (SessionXAStartMessage) packet;
+                  SessionXAStartMessage message = (SessionXAStartMessage)packet;
                   session.xaStart(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_FAILED: {
+               case SESS_XA_FAILED:
+               {
                   requiresResponse = true;
-                  SessionXAAfterFailedMessage message = (SessionXAAfterFailedMessage) packet;
+                  SessionXAAfterFailedMessage message = (SessionXAAfterFailedMessage)packet;
                   session.xaFailed(message.getXid());
                   // no response on this case
                   break;
                }
-               case SESS_XA_SUSPEND: {
+               case SESS_XA_SUSPEND:
+               {
                   requiresResponse = true;
                   session.xaSuspend();
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_PREPARE: {
+               case SESS_XA_PREPARE:
+               {
                   requiresResponse = true;
-                  SessionXAPrepareMessage message = (SessionXAPrepareMessage) packet;
+                  SessionXAPrepareMessage message = (SessionXAPrepareMessage)packet;
                   session.xaPrepare(message.getXid());
                   response = new SessionXAResponseMessage(false, XAResource.XA_OK, null);
                   break;
                }
-               case SESS_XA_INDOUBT_XIDS: {
+               case SESS_XA_INDOUBT_XIDS:
+               {
                   requiresResponse = true;
                   List<Xid> xids = session.xaGetInDoubtXids();
                   response = new SessionXAGetInDoubtXidsResponseMessage(xids);
                   break;
                }
-               case SESS_XA_GET_TIMEOUT: {
+               case SESS_XA_GET_TIMEOUT:
+               {
                   requiresResponse = true;
                   int timeout = session.xaGetTimeout();
                   response = new SessionXAGetTimeoutResponseMessage(timeout);
                   break;
                }
-               case SESS_XA_SET_TIMEOUT: {
+               case SESS_XA_SET_TIMEOUT:
+               {
                   requiresResponse = true;
-                  SessionXASetTimeoutMessage message = (SessionXASetTimeoutMessage) packet;
+                  SessionXASetTimeoutMessage message = (SessionXASetTimeoutMessage)packet;
                   session.xaSetTimeout(message.getTimeoutSeconds());
                   response = new SessionXASetTimeoutResponseMessage(true);
                   break;
                }
-               case SESS_START: {
+               case SESS_START:
+               {
                   session.start();
                   break;
                }
-               case SESS_STOP: {
+               case SESS_STOP:
+               {
                   requiresResponse = true;
                   session.stop();
                   response = new NullResponseMessage();
                   break;
                }
-               case SESS_CLOSE: {
+               case SESS_CLOSE:
+               {
                   requiresResponse = true;
                   session.close(false);
-                  // removeConnectionListeners();
+                 // removeConnectionListeners();
                   response = new NullResponseMessage();
                   flush = true;
                   closeChannel = true;
                   break;
                }
-               case SESS_INDIVIDUAL_ACKNOWLEDGE: {
-                  SessionIndividualAcknowledgeMessage message = (SessionIndividualAcknowledgeMessage) packet;
+               case SESS_INDIVIDUAL_ACKNOWLEDGE:
+               {
+                  SessionIndividualAcknowledgeMessage message = (SessionIndividualAcknowledgeMessage)packet;
                   requiresResponse = message.isRequiresResponse();
                   session.individualAcknowledge(message.getConsumerID(), message.getMessageID());
-                  if (requiresResponse) {
+                  if (requiresResponse)
+                  {
                      response = new NullResponseMessage();
                   }
                   break;
                }
-               case SESS_CONSUMER_CLOSE: {
+               case SESS_CONSUMER_CLOSE:
+               {
                   requiresResponse = true;
-                  SessionConsumerCloseMessage message = (SessionConsumerCloseMessage) packet;
+                  SessionConsumerCloseMessage message = (SessionConsumerCloseMessage)packet;
                   session.closeConsumer(message.getConsumerID());
                   response = new NullResponseMessage();
                   break;
                }
-               case SESS_FLOWTOKEN: {
-                  SessionConsumerFlowCreditMessage message = (SessionConsumerFlowCreditMessage) packet;
+               case SESS_FLOWTOKEN:
+               {
+                  SessionConsumerFlowCreditMessage message = (SessionConsumerFlowCreditMessage)packet;
                   session.receiveConsumerCredits(message.getConsumerID(), message.getCredits());
                   break;
                }
-               case SESS_SEND: {
-                  SessionSendMessage message = (SessionSendMessage) packet;
+               case SESS_SEND:
+               {
+                  SessionSendMessage message = (SessionSendMessage)packet;
                   requiresResponse = message.isRequiresResponse();
-                  session.send(message.getMessage(), direct);
-                  if (requiresResponse) {
+                  session.send((ServerMessage)message.getMessage(), direct);
+                  if (requiresResponse)
+                  {
                      response = new NullResponseMessage();
                   }
                   break;
                }
-               case SESS_SEND_LARGE: {
-                  SessionSendLargeMessage message = (SessionSendLargeMessage) packet;
-                  sendLarge(message.getLargeMessage());
+               case SESS_SEND_LARGE:
+               {
+                  SessionSendLargeMessage message = (SessionSendLargeMessage)packet;
+                  session.sendLarge(message.getLargeMessage());
                   break;
                }
-               case SESS_SEND_CONTINUATION: {
-                  SessionSendContinuationMessage message = (SessionSendContinuationMessage) packet;
+               case SESS_SEND_CONTINUATION:
+               {
+                  SessionSendContinuationMessage message = (SessionSendContinuationMessage)packet;
                   requiresResponse = message.isRequiresResponse();
-                  sendContinuations(message.getPacketSize(), message.getMessageBodySize(), message.getBody(), message.isContinues());
-                  if (requiresResponse) {
+                  session.sendContinuations(message.getPacketSize(), message.getMessageBodySize(), message.getBody(), message.isContinues());
+                  if (requiresResponse)
+                  {
                      response = new NullResponseMessage();
                   }
                   break;
                }
-               case SESS_FORCE_CONSUMER_DELIVERY: {
-                  SessionForceConsumerDelivery message = (SessionForceConsumerDelivery) packet;
+               case SESS_FORCE_CONSUMER_DELIVERY:
+               {
+                  SessionForceConsumerDelivery message = (SessionForceConsumerDelivery)packet;
                   session.forceConsumerDelivery(message.getConsumerID(), message.getSequence());
                   break;
                }
-               case PacketImpl.SESS_PRODUCER_REQUEST_CREDITS: {
-                  SessionRequestProducerCreditsMessage message = (SessionRequestProducerCreditsMessage) packet;
+               case PacketImpl.SESS_PRODUCER_REQUEST_CREDITS:
+               {
+                  SessionRequestProducerCreditsMessage message = (SessionRequestProducerCreditsMessage)packet;
                   session.requestProducerCredits(message.getAddress(), message.getCredits());
                   break;
                }
-               case PacketImpl.SESS_ADD_METADATA: {
+               case PacketImpl.SESS_ADD_METADATA:
+               {
                   response = new NullResponseMessage();
-                  SessionAddMetaDataMessage message = (SessionAddMetaDataMessage) packet;
+                  SessionAddMetaDataMessage message = (SessionAddMetaDataMessage)packet;
                   session.addMetaData(message.getKey(), message.getData());
                   break;
                }
-               case PacketImpl.SESS_ADD_METADATA2: {
-                  SessionAddMetaDataMessageV2 message = (SessionAddMetaDataMessageV2) packet;
-                  if (message.isRequiresConfirmations()) {
+               case PacketImpl.SESS_ADD_METADATA2:
+               {
+                  SessionAddMetaDataMessageV2 message = (SessionAddMetaDataMessageV2)packet;
+                  if (message.isRequiresConfirmations())
+                  {
                      response = new NullResponseMessage();
                   }
                   session.addMetaData(message.getKey(), message.getData());
                   break;
                }
-               case PacketImpl.SESS_UNIQUE_ADD_METADATA: {
-                  SessionUniqueAddMetaDataMessage message = (SessionUniqueAddMetaDataMessage) packet;
-                  if (session.addUniqueMetaData(message.getKey(), message.getData())) {
+               case PacketImpl.SESS_UNIQUE_ADD_METADATA:
+               {
+                  SessionUniqueAddMetaDataMessage message = (SessionUniqueAddMetaDataMessage)packet;
+                  if (session.addUniqueMetaData(message.getKey(), message.getData()))
+                  {
                      response = new NullResponseMessage();
-                  } else {
+                  }
+                  else
+                  {
                      response = new ActiveMQExceptionMessage(ActiveMQMessageBundle.BUNDLE.duplicateMetadata(message.getKey(), message.getData()));
                   }
                   break;
                }
             }
-         } catch (ActiveMQIOErrorException e) {
-            getSession().markTXFailed(e);
-            if (requiresResponse) {
-               logger.debug("Sending exception to client", e);
-               response = new ActiveMQExceptionMessage(e);
-            } else {
-               ActiveMQServerLogger.LOGGER.caughtException(e);
-            }
-         } catch (ActiveMQXAException e) {
-            if (requiresResponse) {
-               logger.debug("Sending exception to client", e);
+         }
+         catch (ActiveMQXAException e)
+         {
+            if (requiresResponse)
+            {
+               ActiveMQServerLogger.LOGGER.debug("Sending exception to client", e);
                response = new SessionXAResponseMessage(true, e.errorCode, e.getMessage());
-            } else {
+            }
+            else
+            {
                ActiveMQServerLogger.LOGGER.caughtXaException(e);
             }
-         } catch (ActiveMQQueueMaxConsumerLimitReached e) {
-            if (requiresResponse) {
-               logger.debug("Sending exception to client", e);
+         }
+         catch (ActiveMQException e)
+         {
+            if (requiresResponse)
+            {
+               ActiveMQServerLogger.LOGGER.debug("Sending exception to client", e);
                response = new ActiveMQExceptionMessage(e);
-            } else {
-               ActiveMQServerLogger.LOGGER.caughtException(e);
             }
-         } catch (ActiveMQException e) {
-            if (requiresResponse) {
-               logger.debug("Sending exception to client", e);
-               response = new ActiveMQExceptionMessage(e);
-            } else {
-               if (e.getType() == ActiveMQExceptionType.QUEUE_EXISTS) {
-                  logger.debug("Caught exception", e);
-               } else {
+            else
+            {
+               if (e.getType() == ActiveMQExceptionType.QUEUE_EXISTS)
+               {
+                  ActiveMQServerLogger.LOGGER.debug("Caught exception", e);
+               }
+               else
+               {
                   ActiveMQServerLogger.LOGGER.caughtException(e);
                }
             }
-         } catch (Throwable t) {
-            getSession().markTXFailed(t);
-            if (requiresResponse) {
+         }
+         catch (Throwable t)
+         {
+            if (requiresResponse)
+            {
                ActiveMQServerLogger.LOGGER.warn("Sending unexpected exception to the client", t);
                ActiveMQException activeMQInternalErrorException = new ActiveMQInternalErrorException();
                activeMQInternalErrorException.initCause(t);
                response = new ActiveMQExceptionMessage(activeMQInternalErrorException);
-            } else {
+            }
+            else
+            {
                ActiveMQServerLogger.LOGGER.caughtException(t);
             }
          }
 
          sendResponse(packet, response, flush, closeChannel);
-      } finally {
+      }
+      finally
+      {
          storageManager.clearContext();
       }
    }
@@ -638,32 +612,21 @@ public class ServerSessionPacketHandler implements ChannelHandler {
    private void sendResponse(final Packet confirmPacket,
                              final Packet response,
                              final boolean flush,
-                             final boolean closeChannel) {
-      if (logger.isTraceEnabled()) {
-         logger.trace("ServerSessionPacketHandler::scheduling response::" + response);
-      }
-
-      storageManager.afterCompleteOperations(new IOCallback() {
-         @Override
-         public void onError(final int errorCode, final String errorMessage) {
+                             final boolean closeChannel)
+   {
+      storageManager.afterCompleteOperations(new IOAsyncTask()
+      {
+         public void onError(final int errorCode, final String errorMessage)
+         {
             ActiveMQServerLogger.LOGGER.errorProcessingIOCallback(errorCode, errorMessage);
 
-            ActiveMQExceptionMessage exceptionMessage = new ActiveMQExceptionMessage(ActiveMQExceptionType.createException(errorCode, errorMessage));
+            ActiveMQExceptionMessage exceptionMessage = new ActiveMQExceptionMessage( ActiveMQExceptionType.createException(errorCode, errorMessage));
 
             doConfirmAndResponse(confirmPacket, exceptionMessage, flush, closeChannel);
-
-            if (logger.isTraceEnabled()) {
-               logger.trace("ServerSessionPacketHandler::exception response sent::" + exceptionMessage);
-            }
-
          }
 
-         @Override
-         public void done() {
-            if (logger.isTraceEnabled()) {
-               logger.trace("ServerSessionPacketHandler::regular response sent::" + response);
-            }
-
+         public void done()
+         {
             doConfirmAndResponse(confirmPacket, response, flush, closeChannel);
          }
       });
@@ -672,51 +635,45 @@ public class ServerSessionPacketHandler implements ChannelHandler {
    private void doConfirmAndResponse(final Packet confirmPacket,
                                      final Packet response,
                                      final boolean flush,
-                                     final boolean closeChannel) {
-      if (confirmPacket != null) {
-         if (flush) {
+                                     final boolean closeChannel)
+   {
+      if (confirmPacket != null)
+      {
+         channel.confirm(confirmPacket);
+
+         if (flush)
+         {
             channel.flushConfirmations();
          }
       }
 
-      if (response != null) {
+      if (response != null)
+      {
          channel.send(response);
       }
 
-      if (closeChannel) {
+      if (closeChannel)
+      {
          channel.close();
       }
    }
 
-   public void closeListeners() {
+   public void closeListeners()
+   {
       List<CloseListener> listeners = remotingConnection.removeCloseListeners();
 
-      for (CloseListener closeListener : listeners) {
+      for (CloseListener closeListener: listeners)
+      {
          closeListener.connectionClosed();
-         if (closeListener instanceof FailureListener) {
-            remotingConnection.removeFailureListener((FailureListener) closeListener);
+         if (closeListener instanceof FailureListener)
+         {
+            remotingConnection.removeFailureListener((FailureListener)closeListener);
          }
       }
-
-      flushExecutor();
    }
 
-   public int transferConnection(final CoreRemotingConnection newConnection, final int lastReceivedCommandID) {
-
-      SimpleFuture<Integer> future = new SimpleFutureImpl<>();
-      callExecutor.execute(() -> {
-         int value = internaltransferConnection(newConnection, lastReceivedCommandID);
-         future.set(value);
-      });
-
-      try {
-         return future.get().intValue();
-      } catch (Exception e) {
-         throw new IllegalStateException(e);
-      }
-   }
-
-   private int internaltransferConnection(final CoreRemotingConnection newConnection, final int lastReceivedCommandID) {
+   public int transferConnection(final CoreRemotingConnection newConnection, final int lastReceivedCommandID)
+   {
       // We need to disable delivery on all the consumers while the transfer is occurring- otherwise packets might get
       // delivered
       // after the channel has transferred but *before* packets have been replayed - this will give the client the wrong
@@ -740,8 +697,6 @@ public class ServerSessionPacketHandler implements ChannelHandler {
 
       newConnection.syncIDGeneratorSequence(remotingConnection.getIDGeneratorSequence());
 
-      Connection oldTransportConnection = remotingConnection.getTransportConnection();
-
       remotingConnection = newConnection;
 
       remotingConnection.setCloseListeners(closeListeners);
@@ -755,59 +710,6 @@ public class ServerSessionPacketHandler implements ChannelHandler {
 
       session.setTransferring(false);
 
-      // We do this because the old connection could be out of credits on netty
-      // this will force anything to resume after the reattach through the ReadyListener callbacks
-      oldTransportConnection.fireReady(true);
-
       return serverLastReceivedCommandID;
    }
-
-   // Large Message is part of the core protocol, we have these functions here as part of Packet handler
-   private void sendLarge(final Message message) throws Exception {
-      // need to create the LargeMessage before continue
-      long id = storageManager.generateID();
-
-      LargeServerMessage largeMsg = storageManager.createLargeMessage(id, message);
-
-      if (logger.isTraceEnabled()) {
-         logger.trace("sendLarge::" + largeMsg);
-      }
-
-      if (currentLargeMessage != null) {
-         ActiveMQServerLogger.LOGGER.replacingIncompleteLargeMessage(currentLargeMessage.getMessageID());
-      }
-
-      currentLargeMessage = largeMsg;
-   }
-
-
-
-   private void sendContinuations(final int packetSize,
-                                 final long messageBodySize,
-                                 final byte[] body,
-                                 final boolean continues) throws Exception {
-      if (currentLargeMessage == null) {
-         throw ActiveMQMessageBundle.BUNDLE.largeMessageNotInitialised();
-      }
-
-      // Immediately release the credits for the continuations- these don't contribute to the in-memory size
-      // of the message
-
-      currentLargeMessage.addBytes(body);
-
-      if (!continues) {
-         currentLargeMessage.releaseResources();
-
-         if (messageBodySize >= 0) {
-            currentLargeMessage.putLongProperty(Message.HDR_LARGE_BODY_SIZE, messageBodySize);
-         }
-
-
-         session.doSend(session.getCurrentTransaction(), currentLargeMessage, null, false, false);
-
-         currentLargeMessage = null;
-      }
-   }
-
-
 }