diff --git a/hyracks-fullstack/hyracks/hyracks-dataflow-std/src/main/java/org/apache/hyracks/dataflow/std/join/NestedLoopJoin.java b/hyracks-fullstack/hyracks/hyracks-dataflow-std/src/main/java/org/apache/hyracks/dataflow/std/join/NestedLoopJoin.java
index 2eae25c78c..16c21df7a4 100644
--- a/hyracks-fullstack/hyracks/hyracks-dataflow-std/src/main/java/org/apache/hyracks/dataflow/std/join/NestedLoopJoin.java
+++ b/hyracks-fullstack/hyracks/hyracks-dataflow-std/src/main/java/org/apache/hyracks/dataflow/std/join/NestedLoopJoin.java
@@ -24,7 +24,7 @@ import java.nio.ByteBuffer;
 import org.apache.hyracks.api.comm.IFrame;
 import org.apache.hyracks.api.comm.IFrameWriter;
 import org.apache.hyracks.api.comm.VSizeFrame;
-import org.apache.hyracks.api.context.IHyracksJobletContext;
+import org.apache.hyracks.api.context.IHyracksTaskContext;
 import org.apache.hyracks.api.dataflow.value.IMissingWriter;
 import org.apache.hyracks.api.dataflow.value.IPredicateEvaluator;
 import org.apache.hyracks.api.dataflow.value.ITuplePairComparator;
@@ -46,7 +46,7 @@ public class NestedLoopJoin {
     private final FrameTupleAccessor accessorInner;
     private final FrameTupleAccessor accessorOuter;
     private final FrameTupleAppender appender;
-    private ITuplePairComparator tpComparator;
+    private final ITuplePairComparator tpComparator;
     private final IFrame outBuffer;
     private final IFrame innerBuffer;
     private final VariableFrameMemoryManager outerBufferMngr;
@@ -55,22 +55,23 @@ public class NestedLoopJoin {
     private final ArrayTupleBuilder missingTupleBuilder;
     private final IPredicateEvaluator predEvaluator;
     private boolean isReversed; //Added for handling correct calling for predicate-evaluator upon recursive calls (in OptimizedHybridHashJoin) that cause role-reversal
-    private final BufferInfo tempInfo = new BufferInfo(null, -1, -1);
+    private BufferInfo tempInfo = new BufferInfo(null, -1, -1);
 
-    public NestedLoopJoin(IHyracksJobletContext jobletContext, FrameTupleAccessor accessorOuter,
-            FrameTupleAccessor accessorInner, int memSize, IPredicateEvaluator predEval, boolean isLeftOuter,
+    public NestedLoopJoin(IHyracksTaskContext ctx, FrameTupleAccessor accessorOuter, FrameTupleAccessor accessorInner,
+            ITuplePairComparator comparatorsOuter2Inner, int memSize, IPredicateEvaluator predEval, boolean isLeftOuter,
             IMissingWriter[] missingWriters) throws HyracksDataException {
         this.accessorInner = accessorInner;
         this.accessorOuter = accessorOuter;
         this.appender = new FrameTupleAppender();
-        this.outBuffer = new VSizeFrame(jobletContext);
-        this.innerBuffer = new VSizeFrame(jobletContext);
+        this.tpComparator = comparatorsOuter2Inner;
+        this.outBuffer = new VSizeFrame(ctx);
+        this.innerBuffer = new VSizeFrame(ctx);
         this.appender.reset(outBuffer, true);
         if (memSize < 3) {
             throw new HyracksDataException("Not enough memory is available for Nested Loop Join");
         }
         this.outerBufferMngr = new VariableFrameMemoryManager(
-                new VariableFramePool(jobletContext, jobletContext.getInitialFrameSize() * (memSize - 2)),
+                new VariableFramePool(ctx, ctx.getInitialFrameSize() * (memSize - 2)),
                 FrameFreeSlotPolicyFactory.createFreeSlotPolicy(EnumFreeSlotPolicy.LAST_FIT, memSize - 2));
 
         this.predEvaluator = predEval;
@@ -89,9 +90,9 @@ public class NestedLoopJoin {
             missingTupleBuilder = null;
         }
 
-        FileReference file =
-                jobletContext.createManagedWorkspaceFile(this.getClass().getSimpleName() + this.toString());
-        runFileWriter = new RunFileWriter(file, jobletContext.getIoManager());
+        FileReference file = ctx.getJobletContext()
+                .createManagedWorkspaceFile(this.getClass().getSimpleName() + this.toString());
+        runFileWriter = new RunFileWriter(file, ctx.getIOManager());
         runFileWriter.open();
     }
 
@@ -99,29 +100,14 @@ public class NestedLoopJoin {
         runFileWriter.nextFrame(buffer);
     }
 
-    /**
-     * Must be called before starting to join to set the right comparator with the right context.
-     *
-     * @param comparator the comparator to use for comparing the probe tuples against the build tuples
-     */
-    void setComparator(ITuplePairComparator comparator) {
-        tpComparator = comparator;
-    }
-
     public void join(ByteBuffer outerBuffer, IFrameWriter writer) throws HyracksDataException {
         if (outerBufferMngr.insertFrame(outerBuffer) < 0) {
             RunFileReader runFileReader = runFileWriter.createReader();
             try {
                 runFileReader.open();
-                if (runFileReader.nextFrame(innerBuffer)) {
-                    do {
-                        for (int i = 0; i < outerBufferMngr.getNumFrames(); i++) {
-                            blockJoin(outerBufferMngr.getFrame(i, tempInfo), innerBuffer.getBuffer(), writer);
-                        }
-                    } while (runFileReader.nextFrame(innerBuffer));
-                } else if (isLeftOuter) {
+                while (runFileReader.nextFrame(innerBuffer)) {
                     for (int i = 0; i < outerBufferMngr.getNumFrames(); i++) {
-                        appendMissing(outerBufferMngr.getFrame(i, tempInfo), writer);
+                        blockJoin(outerBufferMngr.getFrame(i, tempInfo), innerBuffer.getBuffer(), writer);
                     }
                 }
             } finally {
@@ -145,7 +131,7 @@ public class NestedLoopJoin {
         for (int i = 0; i < tupleCount0; ++i) {
             boolean matchFound = false;
             for (int j = 0; j < tupleCount1; ++j) {
-                int c = tpComparator.compare(accessorOuter, i, accessorInner, j);
+                int c = compare(accessorOuter, i, accessorInner, j);
                 boolean prdEval = evaluatePredicate(i, j);
                 if (c == 0 && prdEval) {
                     matchFound = true;
@@ -184,18 +170,6 @@ public class NestedLoopJoin {
         FrameUtils.appendConcatToWriter(writer, appender, accessor1, tupleId1, accessor2, tupleId2);
     }
 
-    private void appendMissing(BufferInfo outerBufferInfo, IFrameWriter writer) throws HyracksDataException {
-        accessorOuter.reset(outerBufferInfo.getBuffer(), outerBufferInfo.getStartOffset(), outerBufferInfo.getLength());
-        int tupleCount = accessorOuter.getTupleCount();
-        for (int i = 0; i < tupleCount; ++i) {
-            final int[] ntFieldEndOffsets = missingTupleBuilder.getFieldEndOffsets();
-            final byte[] ntByteArray = missingTupleBuilder.getByteArray();
-            final int ntSize = missingTupleBuilder.getSize();
-            FrameUtils.appendConcatToWriter(writer, appender, accessorOuter, i, ntFieldEndOffsets, ntByteArray, 0,
-                    ntSize);
-        }
-    }
-
     public void closeCache() throws HyracksDataException {
         if (runFileWriter != null) {
             runFileWriter.close();
@@ -206,15 +180,9 @@ public class NestedLoopJoin {
         RunFileReader runFileReader = runFileWriter.createDeleteOnCloseReader();
         try {
             runFileReader.open();
-            if (runFileReader.nextFrame(innerBuffer)) {
-                do {
-                    for (int i = 0; i < outerBufferMngr.getNumFrames(); i++) {
-                        blockJoin(outerBufferMngr.getFrame(i, tempInfo), innerBuffer.getBuffer(), writer);
-                    }
-                } while (runFileReader.nextFrame(innerBuffer));
-            } else if (isLeftOuter) {
+            while (runFileReader.nextFrame(innerBuffer)) {
                 for (int i = 0; i < outerBufferMngr.getNumFrames(); i++) {
-                    appendMissing(outerBufferMngr.getFrame(i, tempInfo), writer);
+                    blockJoin(outerBufferMngr.getFrame(i, tempInfo), innerBuffer.getBuffer(), writer);
                 }
             }
         } finally {
@@ -227,6 +195,15 @@ public class NestedLoopJoin {
         outerBufferMngr.reset();
     }
 
+    private int compare(FrameTupleAccessor accessor0, int tIndex0, FrameTupleAccessor accessor1, int tIndex1)
+            throws HyracksDataException {
+        int c = tpComparator.compare(accessor0, tIndex0, accessor1, tIndex1);
+        if (c != 0) {
+            return c;
+        }
+        return 0;
+    }
+
     public void setIsReversed(boolean b) {
         this.isReversed = b;
     }