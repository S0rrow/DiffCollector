diff --git a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java
index 6043df34d7..abb324ee1c 100644
--- a/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java
+++ b/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java
@@ -16,12 +16,9 @@
  */
 package org.apache.accumulo.core.util.shell;
 
-import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
-import java.io.FileOutputStream;
 import java.io.IOException;
-import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.net.InetAddress;
 import java.util.Arrays;
@@ -37,33 +34,27 @@ import java.util.Set;
 import java.util.TreeMap;
 import java.util.UUID;
 
-import jline.console.ConsoleReader;
-import jline.console.UserInterruptException;
-import jline.console.history.FileHistory;
+import jline.ConsoleReader;
+import jline.History;
 
 import org.apache.accumulo.core.Constants;
 import org.apache.accumulo.core.client.AccumuloException;
 import org.apache.accumulo.core.client.AccumuloSecurityException;
-import org.apache.accumulo.core.client.ClientConfiguration;
-import org.apache.accumulo.core.client.ClientConfiguration.ClientProperty;
 import org.apache.accumulo.core.client.Connector;
 import org.apache.accumulo.core.client.Instance;
 import org.apache.accumulo.core.client.IteratorSetting;
-import org.apache.accumulo.core.client.NamespaceNotFoundException;
 import org.apache.accumulo.core.client.TableNotFoundException;
 import org.apache.accumulo.core.client.ZooKeeperInstance;
-import org.apache.accumulo.core.client.impl.ServerConfigurationUtil;
-import org.apache.accumulo.core.client.impl.Tables;
 import org.apache.accumulo.core.client.mock.MockInstance;
 import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;
+import org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties;
 import org.apache.accumulo.core.client.security.tokens.PasswordToken;
 import org.apache.accumulo.core.conf.AccumuloConfiguration;
-import org.apache.accumulo.core.conf.DefaultConfiguration;
 import org.apache.accumulo.core.conf.Property;
-import org.apache.accumulo.core.conf.SiteConfiguration;
 import org.apache.accumulo.core.data.Key;
 import org.apache.accumulo.core.data.Value;
 import org.apache.accumulo.core.data.thrift.TConstraintViolationSummary;
+import org.apache.accumulo.core.security.AuditLevel;
 import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;
 import org.apache.accumulo.core.trace.DistributedTrace;
 import org.apache.accumulo.core.util.BadArgumentException;
@@ -83,7 +74,6 @@ import org.apache.accumulo.core.util.shell.commands.ClsCommand;
 import org.apache.accumulo.core.util.shell.commands.CompactCommand;
 import org.apache.accumulo.core.util.shell.commands.ConfigCommand;
 import org.apache.accumulo.core.util.shell.commands.ConstraintCommand;
-import org.apache.accumulo.core.util.shell.commands.CreateNamespaceCommand;
 import org.apache.accumulo.core.util.shell.commands.CreateTableCommand;
 import org.apache.accumulo.core.util.shell.commands.CreateUserCommand;
 import org.apache.accumulo.core.util.shell.commands.DUCommand;
@@ -91,7 +81,6 @@ import org.apache.accumulo.core.util.shell.commands.DebugCommand;
 import org.apache.accumulo.core.util.shell.commands.DeleteCommand;
 import org.apache.accumulo.core.util.shell.commands.DeleteIterCommand;
 import org.apache.accumulo.core.util.shell.commands.DeleteManyCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteNamespaceCommand;
 import org.apache.accumulo.core.util.shell.commands.DeleteRowsCommand;
 import org.apache.accumulo.core.util.shell.commands.DeleteScanIterCommand;
 import org.apache.accumulo.core.util.shell.commands.DeleteShellIterCommand;
@@ -103,8 +92,6 @@ import org.apache.accumulo.core.util.shell.commands.EGrepCommand;
 import org.apache.accumulo.core.util.shell.commands.ExecfileCommand;
 import org.apache.accumulo.core.util.shell.commands.ExitCommand;
 import org.apache.accumulo.core.util.shell.commands.ExportTableCommand;
-import org.apache.accumulo.core.util.shell.commands.ExtensionCommand;
-import org.apache.accumulo.core.util.shell.commands.FateCommand;
 import org.apache.accumulo.core.util.shell.commands.FlushCommand;
 import org.apache.accumulo.core.util.shell.commands.FormatterCommand;
 import org.apache.accumulo.core.util.shell.commands.GetAuthsCommand;
@@ -126,22 +113,17 @@ import org.apache.accumulo.core.util.shell.commands.ListScansCommand;
 import org.apache.accumulo.core.util.shell.commands.ListShellIterCommand;
 import org.apache.accumulo.core.util.shell.commands.MaxRowCommand;
 import org.apache.accumulo.core.util.shell.commands.MergeCommand;
-import org.apache.accumulo.core.util.shell.commands.NamespacePermissionsCommand;
-import org.apache.accumulo.core.util.shell.commands.NamespacesCommand;
 import org.apache.accumulo.core.util.shell.commands.NoTableCommand;
 import org.apache.accumulo.core.util.shell.commands.OfflineCommand;
 import org.apache.accumulo.core.util.shell.commands.OnlineCommand;
-import org.apache.accumulo.core.util.shell.commands.OptUtil;
 import org.apache.accumulo.core.util.shell.commands.PasswdCommand;
 import org.apache.accumulo.core.util.shell.commands.PingCommand;
 import org.apache.accumulo.core.util.shell.commands.QuestionCommand;
 import org.apache.accumulo.core.util.shell.commands.QuitCommand;
 import org.apache.accumulo.core.util.shell.commands.QuotedStringTokenizer;
-import org.apache.accumulo.core.util.shell.commands.RenameNamespaceCommand;
 import org.apache.accumulo.core.util.shell.commands.RenameTableCommand;
 import org.apache.accumulo.core.util.shell.commands.RevokeCommand;
 import org.apache.accumulo.core.util.shell.commands.ScanCommand;
-import org.apache.accumulo.core.util.shell.commands.ScriptCommand;
 import org.apache.accumulo.core.util.shell.commands.SetAuthsCommand;
 import org.apache.accumulo.core.util.shell.commands.SetGroupsCommand;
 import org.apache.accumulo.core.util.shell.commands.SetIterCommand;
@@ -157,40 +139,31 @@ import org.apache.accumulo.core.util.shell.commands.UserCommand;
 import org.apache.accumulo.core.util.shell.commands.UserPermissionsCommand;
 import org.apache.accumulo.core.util.shell.commands.UsersCommand;
 import org.apache.accumulo.core.util.shell.commands.WhoAmICommand;
-import org.apache.accumulo.core.volume.VolumeConfiguration;
-import org.apache.accumulo.core.zookeeper.ZooUtil;
 import org.apache.accumulo.fate.zookeeper.ZooReader;
-import org.apache.accumulo.start.classloader.vfs.AccumuloVFSClassLoader;
-import org.apache.accumulo.start.classloader.vfs.ContextManager;
 import org.apache.commons.cli.BasicParser;
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.HelpFormatter;
+import org.apache.commons.cli.MissingArgumentException;
 import org.apache.commons.cli.MissingOptionException;
 import org.apache.commons.cli.Option;
 import org.apache.commons.cli.Options;
 import org.apache.commons.cli.ParseException;
-import org.apache.commons.vfs2.FileSystemException;
 import org.apache.hadoop.fs.Path;
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
 
-import com.beust.jcommander.JCommander;
-import com.beust.jcommander.ParameterException;
-
 /**
  * A convenient console interface to perform basic accumulo functions Includes auto-complete, help, and quoted strings with escape sequences
  */
 public class Shell extends ShellOptions {
   public static final Logger log = Logger.getLogger(Shell.class);
   private static final Logger audit = Logger.getLogger(Shell.class.getName() + ".audit");
-
+  
   public static final String CHARSET = "ISO-8859-1";
   public static final int NO_FIXED_ARG_LENGTH_CHECK = -1;
-  public static final String COMMENT_PREFIX = "#";
-  public static final String HISTORY_DIR_NAME = ".accumulo";
-  public static final String HISTORY_FILE_NAME = "shell_history.txt";
   private static final String SHELL_DESCRIPTION = "Shell - Apache Accumulo Interactive Shell";
-
+  private static final String DEFAULT_AUTH_TIMEOUT = "60"; // in minutes
+  
   protected int exitCode = 0;
   private String tableName;
   protected Instance instance;
@@ -202,21 +175,21 @@ public class Shell extends ShellOptions {
   private final Class<? extends Formatter> binaryFormatterClass = BinaryFormatter.class;
   public Map<String,List<IteratorSetting>> scanIteratorOptions = new HashMap<String,List<IteratorSetting>>();
   public Map<String,List<IteratorSetting>> iteratorProfiles = new HashMap<String,List<IteratorSetting>>();
-
+  
   private Token rootToken;
   public final Map<String,Command> commandFactory = new TreeMap<String,Command>();
   public final Map<String,Command[]> commandGrouping = new TreeMap<String,Command[]>();
   protected boolean configError = false;
-
+  
   // exit if true
   private boolean exit = false;
-
+  
   // file to execute commands from
-  protected File execFile = null;
+  protected String execFile = null;
   // single command to execute from the command line
   protected String execCommand = null;
   protected boolean verbose = true;
-
+  
   private boolean tabCompletion;
   private boolean disableAuthTimeout;
   private long authTimeout;
@@ -224,150 +197,156 @@ public class Shell extends ShellOptions {
   private boolean logErrorsToConsole = false;
   private PrintWriter writer = null;
   private boolean masking = false;
-
+  
   public Shell() throws IOException {
-    this(new ConsoleReader(), new PrintWriter(
-        new OutputStreamWriter(System.out,
-        System.getProperty("jline.WindowsTerminal.output.encoding", System.getProperty("file.encoding")))));
+    this(new ConsoleReader());
   }
-
-  public Shell(ConsoleReader reader, PrintWriter writer) {
+  
+  public Shell(ConsoleReader reader) {
     super();
     this.reader = reader;
+  }
+  
+  public Shell(ConsoleReader reader, PrintWriter writer) {
+    this(reader);
     this.writer = writer;
   }
-
+  
   // Not for client use
   public boolean config(String... args) {
-    ShellOptionsJC options = new ShellOptionsJC();
-    JCommander jc = new JCommander();
-
-    jc.setProgramName("accumulo shell");
-    jc.addObject(options);
+    
+    CommandLine cl;
     try {
-      jc.parse(args);
-    } catch (ParameterException e) {
-      configError = true;
-    }
-
-    if (options.isHelpEnabled()) {
-      configError = true;
-    }
-
-    if (!configError && options.getUnrecognizedOptions() != null) {
+      cl = new BasicParser().parse(opts, args);
+      if (cl.getArgs().length > 0)
+        throw new ParseException("Unrecognized arguments: " + cl.getArgList());
+      
+      if (cl.hasOption(helpOpt.getOpt())) {
+        configError = true;
+        printHelp("shell", SHELL_DESCRIPTION, opts);
+        return true;
+      }
+      
+      setDebugging(cl.hasOption(debugOption.getLongOpt()));
+      authTimeout = Integer.parseInt(cl.getOptionValue(authTimeoutOpt.getLongOpt(), DEFAULT_AUTH_TIMEOUT)) * 60 * 1000;
+      disableAuthTimeout = cl.hasOption(disableAuthTimeoutOpt.getLongOpt());
+      
+      if (cl.hasOption(zooKeeperInstance.getOpt()) && cl.getOptionValues(zooKeeperInstance.getOpt()).length != 2)
+        throw new MissingArgumentException(zooKeeperInstance);
+      
+    } catch (Exception e) {
       configError = true;
-      logError("Unrecognized Options: " + options.getUnrecognizedOptions().toString());
-    }
-
-    if (configError) {
-      jc.usage();
+      printException(e);
+      printHelp("shell", SHELL_DESCRIPTION, opts);
       return true;
     }
-
-    setDebugging(options.isDebugEnabled());
-    authTimeout = options.getAuthTimeout() * 60 * 1000; // convert minutes to milliseconds
-    disableAuthTimeout = options.isAuthTimeoutDisabled();
-
+    
     // get the options that were parsed
-    String user = options.getUsername();
-    String password = options.getPassword();
-
-    tabCompletion = !options.isTabCompletionDisabled();
-
+    String sysUser = System.getProperty("user.name");
+    if (sysUser == null)
+      sysUser = "root";
+    String user = cl.getOptionValue(usernameOption.getOpt(), sysUser);
+
+    String passw = cl.getOptionValue(passwOption.getOpt(), null);
+    tabCompletion = !cl.hasOption(tabCompleteOption.getLongOpt());
+    String[] loginOptions = cl.getOptionValues(loginOption.getOpt());
+    
     // Use a fake (Mock), ZK, or HdfsZK Accumulo instance
-    setInstance(options);
-
-    // AuthenticationToken options
-    token = options.getAuthenticationToken();
-    Map<String,String> loginOptions = options.getTokenProperties();
-
+    setInstance(cl);
+    
     // process default parameters if unspecified
     try {
-      boolean hasToken = (token != null);
-      boolean hasTokenOptions = !loginOptions.isEmpty();
-
-      if (hasToken && password != null) {
-        throw new ParameterException("Can not supply '--pass' option with '--tokenClass' option");
+      if (loginOptions != null && !cl.hasOption(tokenOption.getOpt()))
+        throw new IllegalArgumentException("Must supply '-" + tokenOption.getOpt() + "' option with '-" + loginOption.getOpt() + "' option");
+      
+      if (loginOptions == null && cl.hasOption(tokenOption.getOpt()))
+        throw new IllegalArgumentException("Must supply '-" + loginOption.getOpt() + "' option with '-" + tokenOption.getOpt() + "' option");
+
+      if (passw != null && cl.hasOption(tokenOption.getOpt()))
+        throw new IllegalArgumentException("Can not supply '-" + passwOption.getOpt() + "' option with '-" + tokenOption.getOpt() + "' option");
+
+      if (user == null)
+        throw new MissingArgumentException(usernameOption);
+
+      if (loginOptions != null && cl.hasOption(tokenOption.getOpt())) {
+        Properties props = new Properties();
+        for (String loginOption : loginOptions)
+          for (String lo : loginOption.split(",")) {
+            String[] split = lo.split("=");
+            props.put(split[0], split[1]);
+          }
+        
+        this.token = Class.forName(cl.getOptionValue(tokenOption.getOpt())).asSubclass(AuthenticationToken.class).newInstance();
+        this.token.init(props);
       }
 
+      if (!cl.hasOption(fakeOption.getLongOpt())) {
+        DistributedTrace.enable(instance, new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut()), "shell", InetAddress.getLocalHost()
+            .getHostName());
+      }
+      
       Runtime.getRuntime().addShutdownHook(new Thread() {
         @Override
-        public void run() {
-          reader.getTerminal().setEchoEnabled(true);
+        public void start() {
+          reader.getTerminal().enableEcho();
         }
       });
-
-      // Need either both a token and options, or neither, but not just one.
-      if (hasToken != hasTokenOptions) {
-        throw new ParameterException("Must supply either both or neither of '--tokenClass' and '--tokenProperty'");
-      } else if (hasToken) { // implied hasTokenOptions
-        // Fully qualified name so we don't shadow java.util.Properties
-        org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties props;
-        // and line wrap it because the package name is so long
-        props = new org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties();
-
-        props.putAllStrings(loginOptions);
-        token.init(props);
-      } else {
-        // Read password if the user explicitly asked for it, or didn't specify anything at all
-        if ("stdin".equals(password) || password == null) {
-          password = reader.readLine("Password: ", '*');
-        }
-
-        if (password == null) {
-          // User cancel, e.g. Ctrl-D pressed
-          throw new ParameterException("No password or token option supplied");
-        } else {
-          this.token = new PasswordToken(password);
-        }
+      
+      if (passw != null) {
+        this.token = new PasswordToken(passw);
       }
-
-      if (!options.isFake()) {
-        ZooReader zr = new ZooReader(instance.getZooKeepers(), instance.getZooKeepersSessionTimeOut());
-        DistributedTrace.enable(instance, zr, "shell", InetAddress.getLocalHost().getHostName());
+      
+      if (this.token == null) {
+        passw = readMaskedLine("Password: ", '*');
+        if (passw != null)
+          this.token = new PasswordToken(passw);
       }
-
+      
+      if (this.token == null) {
+        reader.printNewline();
+        throw new MissingArgumentException("No password or token option supplied");
+      } // user canceled
+      
       this.setTableName("");
       this.principal = user;
       connector = instance.getConnector(this.principal, token);
-
+      
     } catch (Exception e) {
       printException(e);
       configError = true;
     }
-
+    
     // decide whether to execute commands from a file and quit
-    if (options.getExecFile() != null) {
-      execFile = options.getExecFile();
+    if (cl.hasOption(execfileOption.getOpt())) {
+      execFile = cl.getOptionValue(execfileOption.getOpt());
       verbose = false;
-    } else if (options.getExecFileVerbose() != null) {
-      execFile = options.getExecFileVerbose();
-      verbose = true;
+    } else if (cl.hasOption(execfileVerboseOption.getOpt())) {
+      execFile = cl.getOptionValue(execfileVerboseOption.getOpt());
     }
-    execCommand = options.getExecCommand();
-    if (execCommand != null) {
+    if (cl.hasOption(execCommandOpt.getOpt())) {
+      execCommand = cl.getOptionValue(execCommandOpt.getOpt());
       verbose = false;
     }
-
+    
     rootToken = new Token();
-
+    
     Command[] dataCommands = {new DeleteCommand(), new DeleteManyCommand(), new DeleteRowsCommand(), new EGrepCommand(), new FormatterCommand(),
         new InterpreterCommand(), new GrepCommand(), new ImportDirectoryCommand(), new InsertCommand(), new MaxRowCommand(), new ScanCommand()};
     Command[] debuggingCommands = {new ClasspathCommand(), new DebugCommand(), new ListScansCommand(), new ListCompactionsCommand(), new TraceCommand(),
         new PingCommand()};
-    Command[] execCommands = {new ExecfileCommand(), new HistoryCommand(), new ExtensionCommand(), new ScriptCommand()};
+    Command[] execCommands = {new ExecfileCommand(), new HistoryCommand()};
     Command[] exitCommands = {new ByeCommand(), new ExitCommand(), new QuitCommand()};
     Command[] helpCommands = {new AboutCommand(), new HelpCommand(), new InfoCommand(), new QuestionCommand()};
     Command[] iteratorCommands = {new DeleteIterCommand(), new DeleteScanIterCommand(), new ListIterCommand(), new SetIterCommand(), new SetScanIterCommand(),
         new SetShellIterCommand(), new ListShellIterCommand(), new DeleteShellIterCommand()};
     Command[] otherCommands = {new HiddenCommand()};
     Command[] permissionsCommands = {new GrantCommand(), new RevokeCommand(), new SystemPermissionsCommand(), new TablePermissionsCommand(),
-        new UserPermissionsCommand(), new NamespacePermissionsCommand()};
-    Command[] stateCommands = {new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new FateCommand(), new NoTableCommand(), new SleepCommand(),
-        new TableCommand(), new UserCommand(), new WhoAmICommand()};
+        new UserPermissionsCommand()};
+    Command[] stateCommands = {new AuthenticateCommand(), new ClsCommand(), new ClearCommand(), new NoTableCommand(), new SleepCommand(), new TableCommand(),
+        new UserCommand(), new WhoAmICommand()};
     Command[] tableCommands = {new CloneTableCommand(), new ConfigCommand(), new CreateTableCommand(), new DeleteTableCommand(), new DropTableCommand(),
         new DUCommand(), new ExportTableCommand(), new ImportTableCommand(), new OfflineCommand(), new OnlineCommand(), new RenameTableCommand(),
-        new TablesCommand(), new NamespacesCommand(), new CreateNamespaceCommand(), new DeleteNamespaceCommand(), new RenameNamespaceCommand()};
+        new TablesCommand()};
     Command[] tableControlCommands = {new AddSplitsCommand(), new CompactCommand(), new ConstraintCommand(), new FlushCommand(), new GetGroupsCommand(),
         new GetSplitsCommand(), new MergeCommand(), new SetGroupsCommand()};
     Command[] userCommands = {new AddAuthsCommand(), new CreateUserCommand(), new DeleteUserCommand(), new DropUserCommand(), new GetAuthsCommand(),
@@ -383,7 +362,7 @@ public class Shell extends ShellOptions {
     commandGrouping.put("-- Table Administration Commands --------", tableCommands);
     commandGrouping.put("-- Table Control Commands ---------------", tableControlCommands);
     commandGrouping.put("-- User Administration Commands ---------", userCommands);
-
+    
     for (Command[] cmds : commandGrouping.values()) {
       for (Command cmd : cmds)
         commandFactory.put(cmd.getName(), cmd);
@@ -393,241 +372,112 @@ public class Shell extends ShellOptions {
     }
     return configError;
   }
-
-  /**
-   * Sets the instance used by the shell based on the given options.
-   * 
-   * @param options
-   *          shell options
-   */
-  protected void setInstance(ShellOptionsJC options) {
-    // should only be one set of instance options set
+  
+  protected void setInstance(CommandLine cl) {
+    // should only be one instance option set
     instance = null;
-    if (options.isFake()) {
+    if (cl.hasOption(fakeOption.getLongOpt())) {
       instance = new MockInstance("fake");
+    } else if (cl.hasOption(hdfsZooInstance.getOpt())) {
+      @SuppressWarnings("deprecation")
+      AccumuloConfiguration deprecatedSiteConfiguration = AccumuloConfiguration.getSiteConfiguration();
+      instance = getDefaultInstance(deprecatedSiteConfiguration);
+    } else if (cl.hasOption(zooKeeperInstance.getOpt())) {
+      String[] zkOpts = cl.getOptionValues(zooKeeperInstance.getOpt());
+      instance = new ZooKeeperInstance(zkOpts[0], zkOpts[1]);
     } else {
-      String instanceName, hosts;
-      if (options.isHdfsZooInstance()) {
-        instanceName = hosts = null;
-      } else if (options.getZooKeeperInstance().size() > 0) {
-        List<String> zkOpts = options.getZooKeeperInstance();
-        instanceName = zkOpts.get(0);
-        hosts = zkOpts.get(1);
-      } else {
-        instanceName = options.getZooKeeperInstanceName();
-        hosts = options.getZooKeeperHosts();
-      }
-      try {
-        instance = getZooInstance(instanceName, hosts, options.getClientConfiguration());
-      } catch (Exception e) {
-        throw new IllegalArgumentException("Unable to load client config from " + options.getClientConfigFile(), e);
-      }
+      @SuppressWarnings("deprecation")
+      AccumuloConfiguration deprecatedSiteConfiguration = AccumuloConfiguration.getSiteConfiguration();
+      instance = getDefaultInstance(deprecatedSiteConfiguration);
     }
   }
-
-  /*
-   * Takes instanceName and keepers as separate arguments, rather than just packaged into the clientConfig, so that we can fail over to accumulo-site.xml or
-   * HDFS config if they're unspecified.
-   */
-  private static Instance getZooInstance(String instanceName, String keepers, ClientConfiguration clientConfig) {
-    UUID instanceId = null;
-    if (instanceName == null) {
-      instanceName = clientConfig.get(ClientProperty.INSTANCE_NAME);
-    }
-    if (instanceName == null || keepers == null) {
-      AccumuloConfiguration conf = SiteConfiguration.getInstance(ServerConfigurationUtil.convertClientConfig(DefaultConfiguration.getInstance(), clientConfig));
-      if (instanceName == null) {
-        Path instanceDir = new Path(VolumeConfiguration.getVolumeUris(conf)[0], "instance_id");
-        instanceId = UUID.fromString(ZooUtil.getInstanceIDFromHdfs(instanceDir, conf));
-      }
-      if (keepers == null) {
-        keepers = conf.get(Property.INSTANCE_ZK_HOST);
-      }
-    }
-    if (instanceId != null) {
-      return new ZooKeeperInstance(clientConfig.withInstance(instanceId).withZkHosts(keepers));
-    } else {
-      return new ZooKeeperInstance(clientConfig.withInstance(instanceName).withZkHosts(keepers));
-    }
+  
+  @SuppressWarnings("deprecation")
+  private static Instance getDefaultInstance(AccumuloConfiguration conf) {
+    String keepers = conf.get(Property.INSTANCE_ZK_HOST);
+    Path instanceDir = new Path(conf.get(Property.INSTANCE_DFS_DIR), "instance_id");
+    return new ZooKeeperInstance(UUID.fromString(ZooKeeperInstance.getInstanceIDFromHdfs(instanceDir)), keepers);
   }
-
+  
   public Connector getConnector() {
     return connector;
   }
-
-  public Instance getInstance() {
-    return instance;
-  }
-
-  public ClassLoader getClassLoader(final CommandLine cl, final Shell shellState) throws AccumuloException, TableNotFoundException, AccumuloSecurityException,
-      IOException, FileSystemException {
-
-    boolean tables = cl.hasOption(OptUtil.tableOpt().getOpt()) || !shellState.getTableName().isEmpty();
-    boolean namespaces = cl.hasOption(OptUtil.namespaceOpt().getOpt());
-
-    String classpath = null;
-    Iterable<Entry<String,String>> tableProps;
-
-    if (namespaces) {
-      try {
-        tableProps = shellState.getConnector().namespaceOperations().getProperties(OptUtil.getNamespaceOpt(cl, shellState));
-      } catch (NamespaceNotFoundException e) {
-        throw new IllegalArgumentException(e);
-      }
-    } else if (tables) {
-      tableProps = shellState.getConnector().tableOperations().getProperties(OptUtil.getTableOpt(cl, shellState));
-    } else {
-      throw new IllegalArgumentException("No table or namespace specified");
-    }
-    for (Entry<String,String> entry : tableProps) {
-      if (entry.getKey().equals(Property.TABLE_CLASSPATH.getKey())) {
-        classpath = entry.getValue();
-      }
-    }
-
-    ClassLoader classloader;
-
-    if (classpath != null && !classpath.equals("")) {
-      shellState.getConnector().instanceOperations().getSystemConfiguration().get(Property.VFS_CONTEXT_CLASSPATH_PROPERTY.getKey() + classpath);
-
-      try {
-        AccumuloVFSClassLoader.getContextManager().setContextConfig(new ContextManager.DefaultContextsConfig(new Iterable<Map.Entry<String,String>>() {
-          @Override
-          public Iterator<Entry<String,String>> iterator() {
-            try {
-              return shellState.getConnector().instanceOperations().getSystemConfiguration().entrySet().iterator();
-            } catch (AccumuloException e) {
-              throw new RuntimeException(e);
-            } catch (AccumuloSecurityException e) {
-              throw new RuntimeException(e);
-            }
-          }
-        }));
-      } catch (IllegalStateException ise) {}
-
-      classloader = AccumuloVFSClassLoader.getContextManager().getClassLoader(classpath);
-    } else {
-      classloader = AccumuloVFSClassLoader.getClassLoader();
-    }
-    return classloader;
-  }
-
+  
   public static void main(String args[]) throws IOException {
     Shell shell = new Shell();
-    try {
-      shell.config(args);
-
-      System.exit(shell.start());
-    } finally {
-      shell.shutdown();
-    }
+    shell.config(args);
+    
+    System.exit(shell.start());
   }
-
+  
   public int start() throws IOException {
     if (configError)
       return 1;
-
+    
     String input;
     if (isVerbose())
       printInfo();
-
+    
     String home = System.getProperty("HOME");
     if (home == null)
       home = System.getenv("HOME");
-    String configDir = home + "/" + HISTORY_DIR_NAME;
-    String historyPath = configDir + "/" + HISTORY_FILE_NAME;
+    String configDir = home + "/.accumulo";
+    String historyPath = configDir + "/shell_history.txt";
     File accumuloDir = new File(configDir);
     if (!accumuloDir.exists() && !accumuloDir.mkdirs())
       log.warn("Unable to make directory for history at " + accumuloDir);
     try {
-      final FileHistory history = new FileHistory(new File(historyPath));
+      History history = new History();
+      history.setHistoryFile(new File(historyPath));
       reader.setHistory(history);
-      // Add shutdown hook to flush file history, per jline javadocs
-      Runtime.getRuntime().addShutdownHook(new Thread() {
-        @Override
-        public void run() {
-          try {
-            history.flush();
-          } catch (IOException e) {
-            log.warn("Could not flush history to file.");
-          }
-        }
-      });
     } catch (IOException e) {
       log.warn("Unable to load history file at " + historyPath);
     }
-
-    // Turn Ctrl+C into Exception instead of JVM exit
-    reader.setHandleUserInterrupt(true);
-
+    
     ShellCompletor userCompletor = null;
-
+    
     if (execFile != null) {
-      java.util.Scanner scanner = new java.util.Scanner(execFile, Constants.UTF8.name());
-      try {
-        while (scanner.hasNextLine() && !hasExited()) {
-          execCommand(scanner.nextLine(), true, isVerbose());
-        }
-      } finally {
-        scanner.close();
-      }
+      java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
+      while (scanner.hasNextLine())
+        execCommand(scanner.nextLine(), true, isVerbose());
     } else if (execCommand != null) {
       for (String command : execCommand.split("\n")) {
         execCommand(command, true, isVerbose());
       }
       return exitCode;
     }
-
+    
     while (true) {
-      try {
-        if (hasExited())
-          return exitCode;
-
-        // If tab completion is true we need to reset
-        if (tabCompletion) {
-          if (userCompletor != null)
-            reader.removeCompleter(userCompletor);
-
-          userCompletor = setupCompletion();
-          reader.addCompleter(userCompletor);
-        }
-
-        reader.setPrompt(getDefaultPrompt());
-        input = reader.readLine();
-        if (input == null) {
-          reader.println();
-          return exitCode;
-        } // User Canceled (Ctrl+D)
-
-        execCommand(input, disableAuthTimeout, false);
-      } catch (UserInterruptException uie) {
-        // User Cancelled (Ctrl+C)
-        reader.println();
-
-        String partialLine = uie.getPartialLine();
-        if (partialLine == null || "".equals(uie.getPartialLine().trim())) {
-          // No content, actually exit
-          return exitCode;
-        }
-      } finally {
-        reader.flush();
+      if (hasExited())
+        return exitCode;
+      
+      // If tab completion is true we need to reset
+      if (tabCompletion) {
+        if (userCompletor != null)
+          reader.removeCompletor(userCompletor);
+        
+        userCompletor = setupCompletion();
+        reader.addCompletor(userCompletor);
       }
+      
+      reader.setDefaultPrompt(getDefaultPrompt());
+      input = reader.readLine();
+      if (input == null) {
+        reader.printNewline();
+        return exitCode;
+      } // user canceled
+      
+      execCommand(input, disableAuthTimeout, false);
     }
   }
-
-  public void shutdown() {
-    if (reader != null) {
-      reader.shutdown();
-    }
-  }
-
+  
   public void printInfo() throws IOException {
-    reader.print("\n" + SHELL_DESCRIPTION + "\n" + "- \n" + "- version: " + Constants.VERSION + "\n" + "- instance name: "
+    reader.printString("\n" + SHELL_DESCRIPTION + "\n" + "- \n" + "- version: " + Constants.VERSION + "\n" + "- instance name: "
         + connector.getInstance().getInstanceName() + "\n" + "- instance id: " + connector.getInstance().getInstanceID() + "\n" + "- \n"
         + "- type 'help' for a list of available commands\n" + "- \n");
-    reader.flush();
+    reader.flushConsole();
   }
-
+  
   public void printVerboseInfo() throws IOException {
     StringBuilder sb = new StringBuilder("-\n");
     sb.append("- Current user: ").append(connector.whoami()).append("\n");
@@ -652,24 +502,21 @@ public class Shell extends ShellOptions {
       }
     }
     sb.append("-\n");
-    reader.print(sb.toString());
+    reader.printString(sb.toString());
   }
-
+  
   public String getDefaultPrompt() {
     return connector.whoami() + "@" + connector.getInstance().getInstanceName() + (getTableName().isEmpty() ? "" : " ") + getTableName() + "> ";
   }
-
+  
   public void execCommand(String input, boolean ignoreAuthTimeout, boolean echoPrompt) throws IOException {
-    audit.log(Level.INFO, getDefaultPrompt() + input);
+    audit.log(AuditLevel.AUDIT, getDefaultPrompt() + input);
     if (echoPrompt) {
-      reader.print(getDefaultPrompt());
-      reader.println(input);
-    }
-
-    if (input.startsWith(COMMENT_PREFIX)) {
-      return;
+      reader.printString(getDefaultPrompt());
+      reader.printString(input);
+      reader.printNewline();
     }
-
+    
     String fields[];
     try {
       fields = new QuotedStringTokenizer(input).getTokens();
@@ -680,50 +527,50 @@ public class Shell extends ShellOptions {
     }
     if (fields.length == 0)
       return;
-
+    
     String command = fields[0];
     fields = fields.length > 1 ? Arrays.copyOfRange(fields, 1, fields.length) : new String[] {};
-
+    
     Command sc = null;
     if (command.length() > 0) {
       try {
         // Obtain the command from the command table
         sc = commandFactory.get(command);
         if (sc == null) {
-          reader.println(String.format("Unknown command \"%s\".  Enter \"help\" for a list possible commands.", command));
-          reader.flush();
+          reader.printString(String.format("Unknown command \"%s\".  Enter \"help\" for a list possible commands.\n", command));
+          reader.flushConsole();
           return;
         }
-
+        
         if (!(sc instanceof ExitCommand) && !ignoreAuthTimeout && System.currentTimeMillis() - lastUserActivity > authTimeout) {
-          reader.println("Shell has been idle for too long. Please re-authenticate.");
+          reader.printString("Shell has been idle for too long. Please re-authenticate.\n");
           boolean authFailed = true;
           do {
             String pwd = readMaskedLine("Enter current password for '" + connector.whoami() + "': ", '*');
             if (pwd == null) {
-              reader.println();
+              reader.printNewline();
               return;
             } // user canceled
-
+            
             try {
               authFailed = !connector.securityOperations().authenticateUser(connector.whoami(), new PasswordToken(pwd));
             } catch (Exception e) {
               ++exitCode;
               printException(e);
             }
-
+            
             if (authFailed)
-              reader.print("Invalid password. ");
+              reader.printString("Invalid password. ");
           } while (authFailed);
           lastUserActivity = System.currentTimeMillis();
         }
-
+        
         // Get the options from the command on how to parse the string
         Options parseOpts = sc.getOptionsWithHelp();
-
+        
         // Parse the string using the given options
         CommandLine cl = new BasicParser().parse(parseOpts, fields);
-
+        
         int actualArgLen = cl.getArgs().length;
         int expectedArgLen = sc.numArgs();
         if (cl.hasOption(helpOption)) {
@@ -740,9 +587,9 @@ public class Shell extends ShellOptions {
         } else {
           int tmpCode = sc.execute(input, cl, this);
           exitCode += tmpCode;
-          reader.flush();
+          reader.flushConsole();
         }
-
+        
       } catch (ConstraintViolationException e) {
         ++exitCode;
         printConstraintViolationException(e);
@@ -760,8 +607,6 @@ public class Shell extends ShellOptions {
         }
         if (sc != null)
           sc.printHelp(this);
-      } catch (UserInterruptException e) {
-        ++exitCode;
       } catch (Exception e) {
         ++exitCode;
         printException(e);
@@ -770,16 +615,16 @@ public class Shell extends ShellOptions {
       ++exitCode;
       printException(new BadArgumentException("Unrecognized empty command", command, -1));
     }
-    reader.flush();
+    reader.flushConsole();
   }
-
+  
   /**
    * The command tree is built in reverse so that the references are more easily linked up. There is some code in token to allow forward building of the command
    * tree.
    */
   private ShellCompletor setupCompletion() {
     rootToken = new Token();
-
+    
     Set<String> tableNames = null;
     try {
       tableNames = connector.tableOperations().list();
@@ -787,7 +632,7 @@ public class Shell extends ShellOptions {
       log.debug("Unable to obtain list of tables", e);
       tableNames = Collections.emptySet();
     }
-
+    
     Set<String> userlist = null;
     try {
       userlist = connector.securityOperations().listLocalUsers();
@@ -795,39 +640,25 @@ public class Shell extends ShellOptions {
       log.debug("Unable to obtain list of users", e);
       userlist = Collections.emptySet();
     }
-
-    Set<String> namespaces = null;
-    try {
-      namespaces = connector.namespaceOperations().list();
-    } catch (Exception e) {
-      log.debug("Unable to obtain list of namespaces", e);
-      namespaces = Collections.emptySet();
-    }
-
+    
     Map<Command.CompletionSet,Set<String>> options = new HashMap<Command.CompletionSet,Set<String>>();
-
+    
     Set<String> commands = new HashSet<String>();
     for (String a : commandFactory.keySet())
       commands.add(a);
-
+    
     Set<String> modifiedUserlist = new HashSet<String>();
     Set<String> modifiedTablenames = new HashSet<String>();
-    Set<String> modifiedNamespaces = new HashSet<String>();
-
+    
     for (String a : tableNames)
       modifiedTablenames.add(a.replaceAll("([\\s'\"])", "\\\\$1"));
     for (String a : userlist)
       modifiedUserlist.add(a.replaceAll("([\\s'\"])", "\\\\$1"));
-    for (String a : namespaces) {
-      String b = a.replaceAll("([\\s'\"])", "\\\\$1");
-      modifiedNamespaces.add(b.isEmpty() ? "\"\"" : b);
-    }
-
+    
     options.put(Command.CompletionSet.USERNAMES, modifiedUserlist);
     options.put(Command.CompletionSet.TABLENAMES, modifiedTablenames);
-    options.put(Command.CompletionSet.NAMESPACES, modifiedNamespaces);
     options.put(Command.CompletionSet.COMMANDS, commands);
-
+    
     for (Command[] cmdGroup : commandGrouping.values()) {
       for (Command c : cmdGroup) {
         c.getOptionsWithHelp(); // prep the options for the command
@@ -838,7 +669,7 @@ public class Shell extends ShellOptions {
     }
     return new ShellCompletor(rootToken, options);
   }
-
+  
   /**
    * The Command class represents a command to be run in the shell. It contains the methods to execute along with some methods to help tab completion, and
    * return the command name, help, and usage.
@@ -846,64 +677,56 @@ public class Shell extends ShellOptions {
   public static abstract class Command {
     // Helper methods for completion
     public enum CompletionSet {
-      TABLENAMES, USERNAMES, COMMANDS, NAMESPACES
+      TABLENAMES, USERNAMES, COMMANDS
     }
-
+    
     static Set<String> getCommandNames(Map<CompletionSet,Set<String>> objects) {
       return objects.get(CompletionSet.COMMANDS);
     }
-
+    
     static Set<String> getTableNames(Map<CompletionSet,Set<String>> objects) {
       return objects.get(CompletionSet.TABLENAMES);
     }
-
+    
     static Set<String> getUserNames(Map<CompletionSet,Set<String>> objects) {
       return objects.get(CompletionSet.USERNAMES);
     }
-
-    static Set<String> getNamespaces(Map<CompletionSet,Set<String>> objects) {
-      return objects.get(CompletionSet.NAMESPACES);
-    }
-
+    
     public void registerCompletionGeneral(Token root, Set<String> args, boolean caseSens) {
       Token t = new Token(args);
       t.setCaseSensitive(caseSens);
-
+      
       Token command = new Token(getName());
       command.addSubcommand(t);
-
+      
       root.addSubcommand(command);
     }
-
+    
     public void registerCompletionForTables(Token root, Map<CompletionSet,Set<String>> completionSet) {
       registerCompletionGeneral(root, completionSet.get(CompletionSet.TABLENAMES), true);
     }
-
+    
     public void registerCompletionForUsers(Token root, Map<CompletionSet,Set<String>> completionSet) {
       registerCompletionGeneral(root, completionSet.get(CompletionSet.USERNAMES), true);
     }
-
+    
     public void registerCompletionForCommands(Token root, Map<CompletionSet,Set<String>> completionSet) {
       registerCompletionGeneral(root, completionSet.get(CompletionSet.COMMANDS), false);
     }
-
-    public void registerCompletionForNamespaces(Token root, Map<CompletionSet,Set<String>> completionSet) {
-      registerCompletionGeneral(root, completionSet.get(CompletionSet.NAMESPACES), true);
-    }
-
+    
     // abstract methods to override
     public abstract int execute(String fullCommand, CommandLine cl, Shell shellState) throws Exception;
-
+    
     public abstract String description();
-
+    
     /**
      * If the number of arguments is not always zero (not including those arguments handled through Options), make sure to override the {@link #usage()} method.
      * Otherwise, {@link #usage()} does need to be overridden.
      */
     public abstract int numArgs();
-
+    
     // OPTIONAL methods to override:
-
+    
     // the general version of getname uses reflection to get the class name
     // and then cuts off the suffix -Command to get the name of the command
     public String getName() {
@@ -912,96 +735,96 @@ public class Shell extends ShellOptions {
       int i = s.indexOf("Command");
       return i > 0 ? s.substring(st + 1, i).toLowerCase(Locale.ENGLISH) : null;
     }
-
+    
     // The general version of this method adds the name
     // of the command to the completion tree
     public void registerCompletion(Token root, Map<CompletionSet,Set<String>> completion_set) {
       root.addSubcommand(new Token(getName()));
     }
-
+    
     // The general version of this method uses the HelpFormatter
     // that comes with the apache Options package to print out the help
     public final void printHelp(Shell shellState) {
       shellState.printHelp(usage(), "description: " + this.description(), getOptionsWithHelp());
     }
-
+    
     public final void printHelp(Shell shellState, int width) {
       shellState.printHelp(usage(), "description: " + this.description(), getOptionsWithHelp(), width);
     }
-
+    
     // Get options with help
     public final Options getOptionsWithHelp() {
       Options opts = getOptions();
       opts.addOption(new Option(helpOption, helpLongOption, false, "display this help"));
       return opts;
     }
-
+    
     // General usage is just the command
     public String usage() {
       return getName();
     }
-
+    
     // General Options are empty
     public Options getOptions() {
       return new Options();
     }
   }
-
+  
   public interface PrintLine {
-    void print(String s);
-
-    void close();
+    public void print(String s);
+    
+    public void close();
   }
-
+  
   public static class PrintShell implements PrintLine {
     ConsoleReader reader;
-
+    
     public PrintShell(ConsoleReader reader) {
       this.reader = reader;
     }
-
+    
     @Override
     public void print(String s) {
       try {
-        reader.println(s);
+        reader.printString(s + "\n");
       } catch (Exception ex) {
         throw new RuntimeException(ex);
       }
     }
-
+    
     @Override
     public void close() {}
   };
-
+  
   public static class PrintFile implements PrintLine {
     PrintWriter writer;
-
+    
     public PrintFile(String filename) throws FileNotFoundException {
-      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filename), Constants.UTF8)));
+      writer = new PrintWriter(filename);
     }
-
+    
     @Override
     public void print(String s) {
       writer.println(s);
     }
-
+    
     @Override
     public void close() {
       writer.close();
     }
   };
-
+  
   public final void printLines(Iterator<String> lines, boolean paginate) throws IOException {
     printLines(lines, paginate, null);
   }
-
+  
   public final void printLines(Iterator<String> lines, boolean paginate, PrintLine out) throws IOException {
     int linesPrinted = 0;
     String prompt = "-- hit any key to continue or 'q' to quit --";
     int lastPromptLength = prompt.length();
-    int termWidth = reader.getTerminal().getWidth();
-    int maxLines = reader.getTerminal().getHeight();
-
+    int termWidth = reader.getTermwidth();
+    int maxLines = reader.getTermheight();
+    
     String peek = null;
     while (lines.hasNext()) {
       String nextLine = lines.next();
@@ -1010,10 +833,11 @@ public class Shell extends ShellOptions {
       for (String line : nextLine.split("\\n")) {
         if (out == null) {
           if (peek != null) {
-            reader.println(peek);
+            reader.printString(peek);
+            reader.printNewline();
             if (paginate) {
               linesPrinted += peek.length() == 0 ? 0 : Math.ceil(peek.length() * 1.0 / termWidth);
-
+              
               // check if displaying the next line would result in
               // scrolling off the screen
               if (linesPrinted + Math.ceil(lastPromptLength * 1.0 / termWidth) + Math.ceil(prompt.length() * 1.0 / termWidth)
@@ -1022,16 +846,15 @@ public class Shell extends ShellOptions {
                 int numdashes = (termWidth - prompt.length()) / 2;
                 String nextPrompt = repeat("-", numdashes) + prompt + repeat("-", numdashes);
                 lastPromptLength = nextPrompt.length();
-                reader.print(nextPrompt);
-                reader.flush();
-
-                if (Character.toUpperCase((char) reader.readCharacter()) == 'Q') {
-                  reader.println();
+                reader.printString(nextPrompt);
+                reader.flushConsole();
+                if (Character.toUpperCase((char) reader.readVirtualKey()) == 'Q') {
+                  reader.printNewline();
                   return;
                 }
-                reader.println();
-                termWidth = reader.getTerminal().getWidth();
-                maxLines = reader.getTerminal().getHeight();
+                reader.printNewline();
+                termWidth = reader.getTermwidth();
+                maxLines = reader.getTermheight();
               }
             }
           }
@@ -1042,45 +865,46 @@ public class Shell extends ShellOptions {
       }
     }
     if (out == null && peek != null) {
-      reader.println(peek);
+      reader.printString(peek);
+      reader.printNewline();
     }
   }
-
+  
   public final void printRecords(Iterable<Entry<Key,Value>> scanner, boolean printTimestamps, boolean paginate, Class<? extends Formatter> formatterClass,
       PrintLine outFile) throws IOException {
     printLines(FormatterFactory.getFormatter(formatterClass, scanner, printTimestamps), paginate, outFile);
   }
-
+  
   public final void printRecords(Iterable<Entry<Key,Value>> scanner, boolean printTimestamps, boolean paginate, Class<? extends Formatter> formatterClass)
       throws IOException {
     printLines(FormatterFactory.getFormatter(formatterClass, scanner, printTimestamps), paginate);
   }
-
+  
   public final void printBinaryRecords(Iterable<Entry<Key,Value>> scanner, boolean printTimestamps, boolean paginate, PrintLine outFile) throws IOException {
     printLines(FormatterFactory.getFormatter(binaryFormatterClass, scanner, printTimestamps), paginate, outFile);
   }
-
+  
   public final void printBinaryRecords(Iterable<Entry<Key,Value>> scanner, boolean printTimestamps, boolean paginate) throws IOException {
     printLines(FormatterFactory.getFormatter(binaryFormatterClass, scanner, printTimestamps), paginate);
   }
-
+  
   public static String repeat(String s, int c) {
     StringBuilder sb = new StringBuilder();
     for (int i = 0; i < c; i++)
       sb.append(s);
     return sb.toString();
   }
-
+  
   public void checkTableState() {
     if (getTableName().isEmpty())
       throw new IllegalStateException(
           "Not in a table context. Please use 'table <tableName>' to switch to a table, or use '-t' to specify a table if option is available.");
   }
-
+  
   private final void printConstraintViolationException(ConstraintViolationException cve) {
     printException(cve, "");
     int COL1 = 50, COL2 = 14;
-    int col3 = Math.max(1, Math.min(Integer.MAX_VALUE, reader.getTerminal().getWidth() - COL1 - COL2 - 6));
+    int col3 = Math.max(1, Math.min(Integer.MAX_VALUE, reader.getTermwidth() - COL1 - COL2 - 6));
     logError(String.format("%" + COL1 + "s-+-%" + COL2 + "s-+-%" + col3 + "s%n", repeat("-", COL1), repeat("-", COL2), repeat("-", col3)));
     logError(String.format("%-" + COL1 + "s | %" + COL2 + "s | %-" + col3 + "s%n", "Constraint class", "Violation code", "Violation Description"));
     logError(String.format("%" + COL1 + "s-+-%" + COL2 + "s-+-%" + col3 + "s%n", repeat("-", COL1), repeat("-", COL2), repeat("-", col3)));
@@ -1088,80 +912,84 @@ public class Shell extends ShellOptions {
       logError(String.format("%-" + COL1 + "s | %" + COL2 + "d | %-" + col3 + "s%n", cvs.constrainClass, cvs.violationCode, cvs.violationDescription));
     logError(String.format("%" + COL1 + "s-+-%" + COL2 + "s-+-%" + col3 + "s%n", repeat("-", COL1), repeat("-", COL2), repeat("-", col3)));
   }
-
+  
   public final void printException(Exception e) {
     printException(e, e.getMessage());
   }
-
+  
   private final void printException(Exception e, String msg) {
     logError(e.getClass().getName() + (msg != null ? ": " + msg : ""));
     log.debug(e.getClass().getName() + (msg != null ? ": " + msg : ""), e);
   }
-
+  
   public static final void setDebugging(boolean debuggingEnabled) {
     Logger.getLogger(Constants.CORE_PACKAGE_NAME).setLevel(debuggingEnabled ? Level.TRACE : Level.INFO);
   }
-
+  
   public static final boolean isDebuggingEnabled() {
     return Logger.getLogger(Constants.CORE_PACKAGE_NAME).isTraceEnabled();
   }
-
+  
   private final void printHelp(String usage, String description, Options opts) {
     printHelp(usage, description, opts, Integer.MAX_VALUE);
   }
-
+  
   private final void printHelp(String usage, String description, Options opts, int width) {
-    // TODO Use the OutputStream from the JLine ConsoleReader if we can ever get access to it
-    new HelpFormatter().printHelp(writer, width, usage, description, opts, 2, 5, null, true);
-    writer.flush();
+    PrintWriter pw = new PrintWriter(System.err);
+    new HelpFormatter().printHelp(pw, width, usage, description, opts, 2, 5, null, true);
+    pw.flush();
+    if (logErrorsToConsole && writer != null) {
+      new HelpFormatter().printHelp(writer, width, usage, description, opts, 2, 5, null, true);
+      writer.flush();
+    }
   }
-
+  
   public int getExitCode() {
     return exitCode;
   }
-
+  
   public void resetExitCode() {
     exitCode = 0;
   }
-
+  
   public void setExit(boolean exit) {
     this.exit = exit;
   }
-
+  
   public boolean getExit() {
     return this.exit;
   }
-
+  
   public boolean isVerbose() {
     return verbose;
   }
-
+  
   public void setTableName(String tableName) {
-    this.tableName = (tableName == null || tableName.isEmpty()) ? "" : Tables.qualified(tableName);
+    this.tableName = tableName;
   }
-
+  
   public String getTableName() {
     return tableName;
   }
-
+  
   public ConsoleReader getReader() {
     return reader;
   }
-
+  
   public void updateUser(String principal, AuthenticationToken token) throws AccumuloException, AccumuloSecurityException {
     connector = instance.getConnector(principal, token);
     this.principal = principal;
     this.token = token;
   }
-
+  
   public String getPrincipal() {
     return principal;
   }
-
+  
   public AuthenticationToken getToken() {
     return token;
   }
-
+  
   /**
    * Return the formatter for the current table.
    * 
@@ -1170,7 +998,7 @@ public class Shell extends ShellOptions {
   public Class<? extends Formatter> getFormatter() {
     return getFormatter(this.tableName);
   }
-
+  
   /**
    * Return the formatter for the given table.
    * 
@@ -1180,7 +1008,7 @@ public class Shell extends ShellOptions {
    */
   public Class<? extends Formatter> getFormatter(String tableName) {
     Class<? extends Formatter> formatter = FormatterCommand.getCurrentFormatter(tableName, this);
-
+    
     if (null == formatter) {
       logError("Could not load the specified formatter. Using the DefaultFormatter");
       return this.defaultFormatterClass;
@@ -1188,38 +1016,33 @@ public class Shell extends ShellOptions {
       return formatter;
     }
   }
-
+  
   public void setLogErrorsToConsole() {
     this.logErrorsToConsole = true;
   }
-
+  
   private void logError(String s) {
     log.error(s);
     if (logErrorsToConsole) {
       try {
-        reader.println("ERROR: " + s);
-        reader.flush();
+        reader.printString("ERROR: " + s + "\n");
+        reader.flushConsole();
       } catch (IOException e) {}
     }
   }
-
+  
   public String readMaskedLine(String prompt, Character mask) throws IOException {
     this.masking = true;
     String s = reader.readLine(prompt, mask);
     this.masking = false;
     return s;
   }
-
+  
   public boolean isMasking() {
     return masking;
   }
-
+  
   public boolean hasExited() {
     return exit;
   }
-
-  public boolean isTabCompletion() {
-    return tabCompletion;
-  }
-
 }