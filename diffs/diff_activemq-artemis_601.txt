diff --git a/artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java b/artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java
index 983bd7df92..66a38cd393 100644
--- a/artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java
+++ b/artemis-journal/src/main/java/org/apache/activemq/artemis/core/journal/impl/JournalImpl.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -18,8 +18,6 @@ package org.apache.activemq.artemis.core.journal.impl;
 
 import java.io.Serializable;
 import java.nio.ByteBuffer;
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -34,30 +32,29 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.Executor;
-import java.util.concurrent.SynchronousQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
 import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.ThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantLock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffers;
 import org.apache.activemq.artemis.api.core.Pair;
-import org.apache.activemq.artemis.api.core.ActiveMQExceptionType;
-import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.io.SequentialFile;
-import org.apache.activemq.artemis.core.io.SequentialFileFactory;
 import org.apache.activemq.artemis.core.journal.EncodingSupport;
+import org.apache.activemq.artemis.core.journal.IOAsyncTask;
 import org.apache.activemq.artemis.core.journal.IOCompletion;
 import org.apache.activemq.artemis.core.journal.JournalLoadInformation;
 import org.apache.activemq.artemis.core.journal.LoaderCallback;
 import org.apache.activemq.artemis.core.journal.PreparedTransactionInfo;
 import org.apache.activemq.artemis.core.journal.RecordInfo;
+import org.apache.activemq.artemis.core.journal.SequentialFile;
+import org.apache.activemq.artemis.core.journal.SequentialFileFactory;
 import org.apache.activemq.artemis.core.journal.TestableJournal;
 import org.apache.activemq.artemis.core.journal.TransactionFailureCallback;
 import org.apache.activemq.artemis.core.journal.impl.dataformat.ByteArrayEncoding;
@@ -71,18 +68,16 @@ import org.apache.activemq.artemis.core.journal.impl.dataformat.JournalInternalR
 import org.apache.activemq.artemis.core.journal.impl.dataformat.JournalRollbackRecordTX;
 import org.apache.activemq.artemis.journal.ActiveMQJournalBundle;
 import org.apache.activemq.artemis.journal.ActiveMQJournalLogger;
-import org.apache.activemq.artemis.utils.ActiveMQThreadFactory;
 import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.artemis.utils.DataConstants;
-import org.apache.activemq.artemis.utils.OrderedExecutorFactory;
-import org.apache.activemq.artemis.utils.SimpleFuture;
-import org.jboss.logging.Logger;
 
 /**
- * <p>A circular log implementation.</p>
+ * <p>A circular log implementation.</p
+ * <p/>
  * <p>Look at {@link JournalImpl#load(LoaderCallback)} for the file layout
  */
-public class JournalImpl extends JournalBase implements TestableJournal, JournalRecordProvider {
+public class JournalImpl extends JournalBase implements TestableJournal, JournalRecordProvider
+{
 
    // Constants -----------------------------------------------------
 
@@ -91,7 +86,24 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    private static final int[] COMPATIBLE_VERSIONS = new int[]{1};
 
    // Static --------------------------------------------------------
-   private static final Logger logger = Logger.getLogger(JournalImpl.class);
+   private static final boolean trace = ActiveMQJournalLogger.LOGGER.isTraceEnabled();
+
+   // This is useful at debug time...
+   // if you set it to true, all the appends, deletes, rollbacks, commits, etc.. are sent to System.out
+   private static final boolean TRACE_RECORDS = trace;
+
+   // This method exists just to make debug easier.
+   // I could replace log.trace by log.info temporarily while I was debugging
+   // Journal
+   private static void trace(final String message)
+   {
+      ActiveMQJournalLogger.LOGGER.trace(message);
+   }
+
+   private static void traceRecord(final String message)
+   {
+      ActiveMQJournalLogger.LOGGER.trace(message);
+   }
 
    // The sizes of primitive types
 
@@ -165,35 +177,32 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    private final JournalFilesRepository filesRepository;
 
    // Compacting may replace this structure
-   private final ConcurrentMap<Long, JournalRecord> records = new ConcurrentHashMap<>();
-
-   private final Set<Long> pendingRecords = new ConcurrentHashSet<>();
+   private final ConcurrentMap<Long, JournalRecord> records = new ConcurrentHashMap<Long, JournalRecord>();
 
    // Compacting may replace this structure
-   private final ConcurrentMap<Long, JournalTransaction> transactions = new ConcurrentHashMap<>();
+   private final ConcurrentMap<Long, JournalTransaction> transactions = new ConcurrentHashMap<Long, JournalTransaction>();
 
    // This will be set only while the JournalCompactor is being executed
    private volatile JournalCompactor compactor;
 
    private final AtomicBoolean compactorRunning = new AtomicBoolean();
 
-   private Executor filesExecutor = null;
-
-   private Executor compactorExecutor = null;
+   private ExecutorService filesExecutor = null;
 
-   private Executor appendExecutor = null;
+   private ExecutorService compactorExecutor = null;
 
-   private ConcurrentHashSet<CountDownLatch> latches = new ConcurrentHashSet<>();
+   private ConcurrentHashSet<CountDownLatch> latches = new ConcurrentHashSet<CountDownLatch>();
 
-   private final OrderedExecutorFactory providedIOThreadPool;
-   protected OrderedExecutorFactory ioExecutorFactory;
-   private ThreadPoolExecutor threadPool;
+   // Lock used during the append of records
+   // This lock doesn't represent a global lock.
+   // After a record is appended, the usedFile can't be changed until the positives and negatives are updated
+   private final ReentrantLock lockAppend = new ReentrantLock();
 
    /**
     * We don't lock the journal during the whole compacting operation. During compacting we only
     * lock it (i) when gathering the initial structure, and (ii) when replicating the structures
     * after finished compacting.
-    *
+    * <p/>
     * However we need to lock it while taking and updating snapshots
     */
    private final ReadWriteLock journalLock = new ReentrantReadWriteLock();
@@ -203,67 +212,53 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
    private volatile JournalState state = JournalState.STOPPED;
 
-   private volatile int compactCount = 0;
-
    private final Reclaimer reclaimer = new Reclaimer();
 
    // Constructors --------------------------------------------------
 
    public JournalImpl(final int fileSize,
                       final int minFiles,
-                      final int poolSize,
                       final int compactMinFiles,
                       final int compactPercentage,
                       final SequentialFileFactory fileFactory,
                       final String filePrefix,
                       final String fileExtension,
-                      final int maxAIO) {
-      this(fileSize, minFiles, poolSize, compactMinFiles, compactPercentage, fileFactory, filePrefix, fileExtension, maxAIO, 0);
+                      final int maxAIO)
+   {
+      this(fileSize, minFiles, compactMinFiles, compactPercentage, fileFactory, filePrefix, fileExtension, maxAIO, 0);
    }
 
-   public JournalImpl(final int fileSize,
-                      final int minFiles,
-                      final int poolSize,
-                      final int compactMinFiles,
-                      final int compactPercentage,
-                      final SequentialFileFactory fileFactory,
-                      final String filePrefix,
-                      final String fileExtension,
-                      final int maxAIO,
-                      final int userVersion) {
-      this(null, fileSize, minFiles, poolSize, compactMinFiles, compactPercentage, fileFactory, filePrefix, fileExtension, maxAIO, userVersion);
-   }
 
-   public JournalImpl(final OrderedExecutorFactory ioExecutors,
-                      final int fileSize,
+   public JournalImpl(final int fileSize,
                       final int minFiles,
-                      final int poolSize,
                       final int compactMinFiles,
                       final int compactPercentage,
                       final SequentialFileFactory fileFactory,
                       final String filePrefix,
                       final String fileExtension,
-                      final int maxAIO,
-                      final int userVersion) {
-
+                      final int maxAIO, final int userVersion)
+   {
       super(fileFactory.isSupportsCallbacks(), fileSize);
-
-      this.providedIOThreadPool = ioExecutors;
-
-      if (fileSize % fileFactory.getAlignment() != 0) {
+      if (fileSize % fileFactory.getAlignment() != 0)
+      {
          throw new IllegalArgumentException("Invalid journal-file-size " + fileSize + ", It should be multiple of " +
                                                fileFactory.getAlignment());
       }
-      if (minFiles < 2) {
+      if (minFiles < 2)
+      {
          throw new IllegalArgumentException("minFiles cannot be less than 2");
       }
-      if (compactPercentage < 0 || compactPercentage > 100) {
+      if (compactPercentage < 0 || compactPercentage > 100)
+      {
          throw new IllegalArgumentException("Compact Percentage out of range");
       }
 
-      if (compactPercentage == 0) {
+      if (compactPercentage == 0)
+      {
          this.compactPercentage = 0;
-      } else {
+      }
+      else
+      {
          this.compactPercentage = compactPercentage / 100f;
       }
 
@@ -272,60 +267,69 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
       this.fileFactory = fileFactory;
 
-      filesRepository = new JournalFilesRepository(fileFactory, this, filePrefix, fileExtension, userVersion, maxAIO, fileSize, minFiles, poolSize);
+      filesRepository = new JournalFilesRepository(fileFactory,
+                                                   this,
+                                                   filePrefix,
+                                                   fileExtension,
+                                                   userVersion,
+                                                   maxAIO,
+                                                   fileSize,
+                                                   minFiles);
 
       this.userVersion = userVersion;
    }
 
    @Override
-   public String toString() {
+   public String toString()
+   {
       return "JournalImpl(state=" + state + ", currentFile=[" + currentFile + "], hash=" + super.toString() + ")";
    }
 
-   @Override
-   public void runDirectJournalBlast() throws Exception {
+   public void runDirectJournalBlast() throws Exception
+   {
       final int numIts = 100000000;
 
       ActiveMQJournalLogger.LOGGER.runningJournalBlast(numIts);
 
       final CountDownLatch latch = new CountDownLatch(numIts * 2);
 
-      class MyAIOCallback implements IOCompletion {
-
-         @Override
-         public void done() {
+      class MyIOAsyncTask implements IOCompletion
+      {
+         public void done()
+         {
             latch.countDown();
          }
 
-         @Override
-         public void onError(final int errorCode, final String errorMessage) {
+         public void onError(final int errorCode, final String errorMessage)
+         {
 
          }
 
-         @Override
-         public void storeLineUp() {
+         public void storeLineUp()
+         {
          }
       }
 
-      final MyAIOCallback task = new MyAIOCallback();
+      final MyIOAsyncTask task = new MyIOAsyncTask();
 
       final int recordSize = 1024;
 
       final byte[] bytes = new byte[recordSize];
 
-      class MyRecord implements EncodingSupport {
+      class MyRecord implements EncodingSupport
+      {
 
-         @Override
-         public void decode(final ActiveMQBuffer buffer) {
+         public void decode(final ActiveMQBuffer buffer)
+         {
          }
 
-         @Override
-         public void encode(final ActiveMQBuffer buffer) {
+         public void encode(final ActiveMQBuffer buffer)
+         {
             buffer.writeBytes(bytes);
          }
 
-         @Override
-         public int getEncodeSize() {
+         public int getEncodeSize()
+         {
             return recordSize;
          }
 
@@ -333,7 +337,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
       MyRecord record = new MyRecord();
 
-      for (int i = 0; i < numIts; i++) {
+      for (int i = 0; i < numIts; i++)
+      {
          appendAddRecord(i, (byte) 1, record, true, task);
          appendDeleteRecord(i, true, task);
       }
@@ -341,18 +346,18 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       latch.await();
    }
 
-   @Override
-   public Map<Long, JournalRecord> getRecords() {
+   public Map<Long, JournalRecord> getRecords()
+   {
       return records;
    }
 
-   @Override
-   public JournalFile getCurrentFile() {
+   public JournalFile getCurrentFile()
+   {
       return currentFile;
    }
 
-   @Override
-   public JournalCompactor getCompactor() {
+   public JournalCompactor getCompactor()
+   {
       return compactor;
    }
 
@@ -360,27 +365,28 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * this method is used internally only however tools may use it to maintenance.
     * It won't be part of the interface as the tools should be specific to the implementation
     */
-   public List<JournalFile> orderFiles() throws Exception {
+   public List<JournalFile> orderFiles() throws Exception
+   {
       List<String> fileNames = fileFactory.listFiles(filesRepository.getFileExtension());
 
-      List<JournalFile> orderedFiles = new ArrayList<>(fileNames.size());
+      List<JournalFile> orderedFiles = new ArrayList<JournalFile>(fileNames.size());
 
-      for (String fileName : fileNames) {
-         SequentialFile file = fileFactory.createSequentialFile(fileName);
+      for (String fileName : fileNames)
+      {
+         SequentialFile file = fileFactory.createSequentialFile(fileName, filesRepository.getMaxAIO());
 
-         if (file.size() >= SIZE_HEADER) {
-            file.open();
+         file.open(1, false);
 
-            try {
-               JournalFileImpl jrnFile = readFileHeader(file);
+         try
+         {
 
-               orderedFiles.add(jrnFile);
-            } finally {
-               file.close();
-            }
-         } else {
-            ActiveMQJournalLogger.LOGGER.ignoringShortFile(fileName);
-            file.delete();
+            JournalFileImpl jrnFile = readFileHeader(file);
+
+            orderedFiles.add(jrnFile);
+         }
+         finally
+         {
+            file.close();
          }
       }
 
@@ -397,17 +403,20 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     */
    public static int readJournalFile(final SequentialFileFactory fileFactory,
                                      final JournalFile file,
-                                     final JournalReaderCallback reader) throws Exception {
+                                     final JournalReaderCallback reader) throws Exception
+   {
       file.getFile().open(1, false);
       ByteBuffer wholeFileBuffer = null;
-      try {
+      try
+      {
          final int filesize = (int) file.getFile().size();
 
          wholeFileBuffer = fileFactory.newBuffer(filesize);
 
          final int journalFileSize = file.getFile().read(wholeFileBuffer);
 
-         if (journalFileSize != filesize) {
+         if (journalFileSize != filesize)
+         {
             throw new RuntimeException("Invalid read! The system couldn't read the entire file into memory");
          }
 
@@ -416,19 +425,22 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
          int lastDataPos = JournalImpl.SIZE_HEADER;
 
-         while (wholeFileBuffer.hasRemaining()) {
+         while (wholeFileBuffer.hasRemaining())
+         {
             final int pos = wholeFileBuffer.position();
 
             byte recordType = wholeFileBuffer.get();
 
-            if (recordType < JournalImpl.ADD_RECORD || recordType > JournalImpl.ROLLBACK_RECORD) {
+            if (recordType < JournalImpl.ADD_RECORD || recordType > JournalImpl.ROLLBACK_RECORD)
+            {
                // I - We scan for any valid record on the file. If a hole
                // happened on the middle of the file we keep looking until all
                // the possibilities are gone
                continue;
             }
 
-            if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT)) {
+            if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT))
+            {
                reader.markAsDataFile(file);
 
                wholeFileBuffer.position(pos + 1);
@@ -442,15 +454,18 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             // This record is from a previous file-usage. The file was
             // reused and we need to ignore this record
-            if (readFileId != file.getRecordID()) {
+            if (readFileId != file.getRecordID())
+            {
                wholeFileBuffer.position(pos + 1);
                continue;
             }
 
             short compactCount = 0;
 
-            if (file.getJournalVersion() >= 2) {
-               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_BYTE)) {
+            if (file.getJournalVersion() >= 2)
+            {
+               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_BYTE))
+               {
                   reader.markAsDataFile(file);
 
                   wholeFileBuffer.position(pos + 1);
@@ -462,8 +477,10 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             long transactionID = 0;
 
-            if (JournalImpl.isTransaction(recordType)) {
-               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_LONG)) {
+            if (JournalImpl.isTransaction(recordType))
+            {
+               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_LONG))
+               {
                   wholeFileBuffer.position(pos + 1);
                   reader.markAsDataFile(file);
                   continue;
@@ -475,8 +492,10 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             long recordID = 0;
 
             // If prepare or commit
-            if (!JournalImpl.isCompleteTransaction(recordType)) {
-               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_LONG)) {
+            if (!JournalImpl.isCompleteTransaction(recordType))
+            {
+               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_LONG))
+               {
                   wholeFileBuffer.position(pos + 1);
                   reader.markAsDataFile(file);
                   continue;
@@ -499,8 +518,10 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             byte[] record = null;
 
-            if (JournalImpl.isContainsBody(recordType)) {
-               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT)) {
+            if (JournalImpl.isContainsBody(recordType))
+            {
+               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT))
+               {
                   wholeFileBuffer.position(pos + 1);
                   reader.markAsDataFile(file);
                   continue;
@@ -508,8 +529,10 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                variableSize = wholeFileBuffer.getInt();
 
-               if (recordType != JournalImpl.DELETE_RECORD_TX) {
-                  if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), 1)) {
+               if (recordType != JournalImpl.DELETE_RECORD_TX)
+               {
+                  if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), 1))
+                  {
                      wholeFileBuffer.position(pos + 1);
                      continue;
                   }
@@ -517,7 +540,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                   userRecordType = wholeFileBuffer.get();
                }
 
-               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), variableSize)) {
+               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), variableSize))
+               {
                   wholeFileBuffer.position(pos + 1);
                   continue;
                }
@@ -531,16 +555,20 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             // currentFile
             int transactionCheckNumberOfRecords = 0;
 
-            if (recordType == JournalImpl.PREPARE_RECORD || recordType == JournalImpl.COMMIT_RECORD) {
-               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT)) {
+            if (recordType == JournalImpl.PREPARE_RECORD || recordType == JournalImpl.COMMIT_RECORD)
+            {
+               if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT))
+               {
                   wholeFileBuffer.position(pos + 1);
                   continue;
                }
 
                transactionCheckNumberOfRecords = wholeFileBuffer.getInt();
 
-               if (recordType == JournalImpl.PREPARE_RECORD) {
-                  if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT)) {
+               if (recordType == JournalImpl.PREPARE_RECORD)
+               {
+                  if (JournalImpl.isInvalidSize(journalFileSize, wholeFileBuffer.position(), DataConstants.SIZE_INT))
+                  {
                      wholeFileBuffer.position(pos + 1);
                      continue;
                   }
@@ -556,21 +584,22 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             // of the record,
             // But we avoid buffer overflows by damaged data
             if (JournalImpl.isInvalidSize(journalFileSize, pos, recordSize + variableSize +
-               preparedTransactionExtraDataSize)) {
+               preparedTransactionExtraDataSize))
+            {
                // Avoid a buffer overflow caused by damaged data... continue
                // scanning for more pendingTransactions...
-               logger.trace("Record at position " + pos +
-                               " recordType = " +
-                               recordType +
-                               " file:" +
-                               file.getFile().getFileName() +
-                               " recordSize: " +
-                               recordSize +
-                               " variableSize: " +
-                               variableSize +
-                               " preparedTransactionExtraDataSize: " +
-                               preparedTransactionExtraDataSize +
-                               " is corrupted and it is being ignored (II)");
+               JournalImpl.trace("Record at position " + pos +
+                                    " recordType = " +
+                                    recordType +
+                                    " file:" +
+                                    file.getFile().getFileName() +
+                                    " recordSize: " +
+                                    recordSize +
+                                    " variableSize: " +
+                                    variableSize +
+                                    " preparedTransactionExtraDataSize: " +
+                                    preparedTransactionExtraDataSize +
+                                    " is corrupted and it is being ignored (II)");
                // If a file has damaged pendingTransactions, we make it a dataFile, and the
                // next reclaiming will fix it
                reader.markAsDataFile(file);
@@ -583,7 +612,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             wholeFileBuffer.position(pos + variableSize +
                                         recordSize +
-                                        preparedTransactionExtraDataSize - DataConstants.SIZE_INT);
+                                        preparedTransactionExtraDataSize -
+                                        DataConstants.SIZE_INT);
 
             int checkSize = wholeFileBuffer.getInt();
 
@@ -591,17 +621,18 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             // informed at the beginning.
             // This is like testing a hash for the record. (We could replace the
             // checkSize by some sort of calculated hash)
-            if (checkSize != variableSize + recordSize + preparedTransactionExtraDataSize) {
-               logger.trace("Record at position " + pos +
-                               " recordType = " +
-                               recordType +
-                               " possible transactionID = " +
-                               transactionID +
-                               " possible recordID = " +
-                               recordID +
-                               " file:" +
-                               file.getFile().getFileName() +
-                               " is corrupted and it is being ignored (III)");
+            if (checkSize != variableSize + recordSize + preparedTransactionExtraDataSize)
+            {
+               JournalImpl.trace("Record at position " + pos +
+                                    " recordType = " +
+                                    recordType +
+                                    " possible transactionID = " +
+                                    transactionID +
+                                    " possible recordID = " +
+                                    recordID +
+                                    " file:" +
+                                    file.getFile().getFileName() +
+                                    " is corrupted and it is being ignored (III)");
 
                // If a file has damaged pendingTransactions, we make it a dataFile, and the
                // next reclaiming will fix it
@@ -617,38 +648,58 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             // At this point everything is checked. So we relax and just load
             // the data now.
 
-            switch (recordType) {
-               case ADD_RECORD: {
+            switch (recordType)
+            {
+               case ADD_RECORD:
+               {
                   reader.onReadAddRecord(new RecordInfo(recordID, userRecordType, record, false, compactCount));
                   break;
                }
 
-               case UPDATE_RECORD: {
+               case UPDATE_RECORD:
+               {
                   reader.onReadUpdateRecord(new RecordInfo(recordID, userRecordType, record, true, compactCount));
                   break;
                }
 
-               case DELETE_RECORD: {
+               case DELETE_RECORD:
+               {
                   reader.onReadDeleteRecord(recordID);
                   break;
                }
 
-               case ADD_RECORD_TX: {
-                  reader.onReadAddRecordTX(transactionID, new RecordInfo(recordID, userRecordType, record, false, compactCount));
+               case ADD_RECORD_TX:
+               {
+                  reader.onReadAddRecordTX(transactionID, new RecordInfo(recordID,
+                                                                         userRecordType,
+                                                                         record,
+                                                                         false,
+                                                                         compactCount));
                   break;
                }
 
-               case UPDATE_RECORD_TX: {
-                  reader.onReadUpdateRecordTX(transactionID, new RecordInfo(recordID, userRecordType, record, true, compactCount));
+               case UPDATE_RECORD_TX:
+               {
+                  reader.onReadUpdateRecordTX(transactionID, new RecordInfo(recordID,
+                                                                            userRecordType,
+                                                                            record,
+                                                                            true,
+                                                                            compactCount));
                   break;
                }
 
-               case DELETE_RECORD_TX: {
-                  reader.onReadDeleteRecordTX(transactionID, new RecordInfo(recordID, (byte) 0, record, true, compactCount));
+               case DELETE_RECORD_TX:
+               {
+                  reader.onReadDeleteRecordTX(transactionID, new RecordInfo(recordID,
+                                                                            (byte) 0,
+                                                                            record,
+                                                                            true,
+                                                                            compactCount));
                   break;
                }
 
-               case PREPARE_RECORD: {
+               case PREPARE_RECORD:
+               {
 
                   byte[] extraData = new byte[preparedTransactionExtraDataSize];
 
@@ -658,16 +709,19 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                   break;
                }
-               case COMMIT_RECORD: {
+               case COMMIT_RECORD:
+               {
 
                   reader.onReadCommitRecord(transactionID, transactionCheckNumberOfRecords);
                   break;
                }
-               case ROLLBACK_RECORD: {
+               case ROLLBACK_RECORD:
+               {
                   reader.onReadRollbackRecord(transactionID);
                   break;
                }
-               default: {
+               default:
+               {
                   throw new IllegalStateException("Journal " + file.getFile().getFileName() +
                                                      " is corrupt, invalid record type " +
                                                      recordType);
@@ -679,7 +733,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             // This is a sanity check about the loading code itself.
             // If this checkSize doesn't match, it means the reading method is
             // not doing what it was supposed to do
-            if (checkSize != variableSize + recordSize + preparedTransactionExtraDataSize) {
+            if (checkSize != variableSize + recordSize + preparedTransactionExtraDataSize)
+            {
                throw new IllegalStateException("Internal error on loading file. Position doesn't match with checkSize, file = " + file.getFile() +
                                                   ", pos = " +
                                                   pos);
@@ -690,17 +745,25 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
          }
 
          return lastDataPos;
-      } catch (Throwable e) {
+      }
+      catch (Throwable e)
+      {
          ActiveMQJournalLogger.LOGGER.errorReadingFile(e);
          throw new Exception(e.getMessage(), e);
-      } finally {
-         if (wholeFileBuffer != null) {
+      }
+      finally
+      {
+         if (wholeFileBuffer != null)
+         {
             fileFactory.releaseBuffer(wholeFileBuffer);
          }
 
-         try {
+         try
+         {
             file.getFile().close();
-         } catch (Throwable ignored) {
+         }
+         catch (Throwable ignored)
+         {
          }
       }
    }
@@ -713,47 +776,45 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                                final byte recordType,
                                final EncodingSupport record,
                                final boolean sync,
-                               final IOCompletion callback) throws Exception {
+                               final IOCompletion callback) throws Exception
+   {
       checkJournalIsLoaded();
-      lineUpContext(callback);
-      pendingRecords.add(id);
-
-
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalInternalRecord addRecord = new JournalAddRecord(true, id, recordType, record);
-               JournalFile usedFile = appendRecord(addRecord, false, sync, null, callback);
-               records.put(id, new JournalRecord(usedFile, addRecord.getEncodeSize()));
-
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendAddRecord::id=" + id +
-                                             ", userRecordType=" +
-                                             recordType +
-                                             ", record = " + record +
-                                             ", usedFile = " +
-                                             usedFile);
-               }
-               if (result != null) {
-                  result.set(true);
-               }
-            } catch (Exception e) {
-               if (result != null) {
-                  result.fail(e);
-               }
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-            } finally {
-               pendingRecords.remove(id);
-               journalLock.readLock().unlock();
-            }
+
+      journalLock.readLock().lock();
+
+      try
+      {
+         JournalInternalRecord addRecord = new JournalAddRecord(true, id, recordType, record);
+
+         if (callback != null)
+         {
+            callback.storeLineUp();
          }
-      });
 
-      if (result != null) {
-         result.get();
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(addRecord, false, sync, null, callback);
+
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendAddRecord::id=" + id +
+                                          ", userRecordType=" +
+                                          recordType +
+                                          ", usedFile = " +
+                                          usedFile);
+            }
+
+            records.put(id, new JournalRecord(usedFile, addRecord.getEncodeSize()));
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
       }
    }
 
@@ -762,187 +823,191 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                                   final byte recordType,
                                   final EncodingSupport record,
                                   final boolean sync,
-                                  final IOCompletion callback) throws Exception {
+                                  final IOCompletion callback) throws Exception
+   {
       checkJournalIsLoaded();
-      lineUpContext(callback);
-      checkKnownRecordID(id);
-
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
-
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalRecord jrnRecord = records.get(id);
-               JournalInternalRecord updateRecord = new JournalAddRecord(false, id, recordType, record);
-               JournalFile usedFile = appendRecord(updateRecord, false, sync, null, callback);
-
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendUpdateRecord::id=" + id +
-                                  ", userRecordType=" +
-                                  recordType +
-                                  ", usedFile = " +
-                                  usedFile);
-               }
 
-               // record==null here could only mean there is a compactor
-               // computing the delete should be done after compacting is done
-               if (jrnRecord == null) {
-                  compactor.addCommandUpdate(id, usedFile, updateRecord.getEncodeSize());
-               } else {
-                  jrnRecord.addUpdateFile(usedFile, updateRecord.getEncodeSize());
-               }
+      journalLock.readLock().lock();
 
-               if (result != null) {
-                  result.set(true);
-               }
-            } catch (Exception e) {
-               if (result != null) {
-                  result.fail(e);
-               }
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-            } finally {
-               journalLock.readLock().unlock();
+      try
+      {
+         JournalRecord jrnRecord = records.get(id);
+
+         if (jrnRecord == null)
+         {
+            if (!(compactor != null && compactor.lookupRecord(id)))
+            {
+               throw new IllegalStateException("Cannot find add info " + id);
             }
          }
-      });
 
-      if (result != null) {
-         result.get();
+         JournalInternalRecord updateRecord = new JournalAddRecord(false, id, recordType, record);
+
+         if (callback != null)
+         {
+            callback.storeLineUp();
+         }
+
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(updateRecord, false, sync, null, callback);
+
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendUpdateRecord::id=" + id +
+                                          ", userRecordType=" +
+                                          recordType +
+                                          ", usedFile = " +
+                                          usedFile);
+            }
+
+            // record== null here could only mean there is a compactor, and computing the delete should be done after
+            // compacting is done
+            if (jrnRecord == null)
+            {
+               compactor.addCommandUpdate(id, usedFile, updateRecord.getEncodeSize());
+            }
+            else
+            {
+               jrnRecord.addUpdateFile(usedFile, updateRecord.getEncodeSize());
+            }
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
       }
    }
 
+
    @Override
-   public void appendDeleteRecord(final long id, final boolean sync, final IOCompletion callback) throws Exception {
+   public void appendDeleteRecord(final long id, final boolean sync, final IOCompletion callback) throws Exception
+   {
       checkJournalIsLoaded();
-      lineUpContext(callback);
-      checkKnownRecordID(id);
-
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalRecord record = null;
-               if (compactor == null) {
-                  record = records.remove(id);
-               }
 
-               JournalInternalRecord deleteRecord = new JournalDeleteRecord(id);
-               JournalFile usedFile = appendRecord(deleteRecord, false, sync, null, callback);
+      journalLock.readLock().lock();
+      try
+      {
 
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendDeleteRecord::id=" + id + ", usedFile = " + usedFile);
-               }
+         JournalRecord record = null;
 
-               // record==null here could only mean there is a compactor
-               // computing the delete should be done after compacting is done
-               if (record == null) {
-                  compactor.addCommandDelete(id, usedFile);
-               } else {
-                  record.delete(usedFile);
-               }
-               if (result != null) {
-                  result.set(true);
-               }
-            } catch (Exception e) {
-               if (result != null) {
-                  result.fail(e);
-               }
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-            } finally {
-               journalLock.readLock().unlock();
+         if (compactor == null)
+         {
+            record = records.remove(id);
+
+            if (record == null)
+            {
+               throw new IllegalStateException("Cannot find add info " + id);
+            }
+         }
+         else
+         {
+            if (!records.containsKey(id) && !compactor.lookupRecord(id))
+            {
+               throw new IllegalStateException("Cannot find add info " + id + " on compactor or current records");
             }
          }
-      });
 
-      if (result != null) {
-         result.get();
-      }
-   }
+         JournalInternalRecord deleteRecord = new JournalDeleteRecord(id);
+
+         if (callback != null)
+         {
+            callback.storeLineUp();
+         }
+
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(deleteRecord, false, sync, null, callback);
 
-   private static SimpleFuture<Boolean> newSyncAndCallbackResult(boolean sync, IOCompletion callback) {
-      return (sync && callback == null) ? new SimpleFuture<>() : null;
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendDeleteRecord::id=" + id + ", usedFile = " + usedFile);
+            }
+
+            // record== null here could only mean there is a compactor, and computing the delete should be done after
+            // compacting is done
+            if (record == null)
+            {
+               compactor.addCommandDelete(id, usedFile);
+            }
+            else
+            {
+               record.delete(usedFile);
+            }
+
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
+      }
    }
 
    @Override
    public void appendAddRecordTransactional(final long txID,
                                             final long id,
                                             final byte recordType,
-                                            final EncodingSupport record) throws Exception {
+                                            final EncodingSupport record) throws Exception
+   {
       checkJournalIsLoaded();
 
-      final JournalTransaction tx = getTransactionInfo(txID);
-      tx.checkErrorCondition();
-
-      appendExecutor.execute(new Runnable() {
-
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalInternalRecord addRecord = new JournalAddRecordTX(true, txID, id, recordType, record);
-               JournalFile usedFile = appendRecord(addRecord, false, false, tx, null);
-
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendAddRecordTransactional:txID=" + txID +
-                                  ",id=" +
-                                  id +
-                                  ", userRecordType=" +
-                                  recordType +
-                                  ", record = " + record +
-                                  ", usedFile = " +
-                                  usedFile);
-               }
+      journalLock.readLock().lock();
 
-               tx.addPositive(usedFile, id, addRecord.getEncodeSize());
-            } catch (Exception e) {
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-               setErrorCondition(tx, e);
-            } finally {
-               journalLock.readLock().unlock();
-            }
-         }
-      });
-   }
+      try
+      {
+         JournalInternalRecord addRecord = new JournalAddRecordTX(true, txID, id, recordType, record);
 
-   private void checkKnownRecordID(final long id) throws Exception {
-      if (records.containsKey(id) || pendingRecords.contains(id) || (compactor != null && compactor.lookupRecord(id))) {
-         return;
-      }
+         JournalTransaction tx = getTransactionInfo(txID);
 
-      final SimpleFuture<Boolean> known = new SimpleFuture<>();
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(addRecord, false, false, tx, null);
 
-      // retry on the append thread. maybe the appender thread is not keeping up.
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-
-               known.set(records.containsKey(id)
-                  || pendingRecords.contains(id)
-                  || (compactor != null && compactor.lookupRecord(id)));
-            } finally {
-               journalLock.readLock().unlock();
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendAddRecordTransactional:txID=" + txID +
+                                          ",id=" +
+                                          id +
+                                          ", userRecordType=" +
+                                          recordType +
+                                          ", usedFile = " +
+                                          usedFile);
             }
-         }
-      });
 
-      if (!known.get()) {
-         throw new IllegalStateException("Cannot find add info " + id + " on compactor or current records");
+            tx.addPositive(usedFile, id, addRecord.getEncodeSize());
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
       }
    }
 
-   private void checkJournalIsLoaded() {
-      if (state != JournalState.LOADED && state != JournalState.SYNCING) {
+   private void checkJournalIsLoaded()
+   {
+      if (state != JournalState.LOADED && state != JournalState.SYNCING)
+      {
          throw new IllegalStateException("Journal must be in state=" + JournalState.LOADED + ", was [" + state + "]");
       }
    }
 
-   private void setJournalState(JournalState newState) {
+   private void setJournalState(JournalState newState)
+   {
       state = newState;
    }
 
@@ -950,85 +1015,94 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    public void appendUpdateRecordTransactional(final long txID,
                                                final long id,
                                                final byte recordType,
-                                               final EncodingSupport record) throws Exception {
+                                               final EncodingSupport record) throws Exception
+   {
       checkJournalIsLoaded();
 
-      final JournalTransaction tx = getTransactionInfo(txID);
-      tx.checkErrorCondition();
+      journalLock.readLock().lock();
 
-      appendExecutor.execute(new Runnable() {
+      try
+      {
+         JournalInternalRecord updateRecordTX = new JournalAddRecordTX(false, txID, id, recordType, record);
 
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
+         JournalTransaction tx = getTransactionInfo(txID);
 
-               JournalInternalRecord updateRecordTX = new JournalAddRecordTX( false, txID, id, recordType, record );
-               JournalFile usedFile = appendRecord( updateRecordTX, false, false, tx, null );
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(updateRecordTX, false, false, tx, null);
 
-               if ( logger.isTraceEnabled() ) {
-                  logger.trace( "appendUpdateRecordTransactional::txID=" + txID +
-                          ",id=" +
-                          id +
-                          ", userRecordType=" +
-                          recordType +
-                          ", record = " + record +
-                          ", usedFile = " +
-                          usedFile );
-               }
-
-               tx.addPositive( usedFile, id, updateRecordTX.getEncodeSize() );
-            } catch ( Exception e ) {
-               ActiveMQJournalLogger.LOGGER.error( e.getMessage(), e );
-               setErrorCondition( tx, e );
-            } finally {
-               journalLock.readLock().unlock();
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendUpdateRecordTransactional::txID=" + txID +
+                                          ",id=" +
+                                          id +
+                                          ", userRecordType=" +
+                                          recordType +
+                                          ", usedFile = " +
+                                          usedFile);
             }
+
+            tx.addPositive(usedFile, id, updateRecordTX.getEncodeSize());
          }
-      });
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
+      }
    }
 
+
    @Override
-   public void appendDeleteRecordTransactional(final long txID,
-                                               final long id,
-                                               final EncodingSupport record) throws Exception {
+   public void appendDeleteRecordTransactional(final long txID, final long id, final EncodingSupport record) throws Exception
+   {
       checkJournalIsLoaded();
 
-      final JournalTransaction tx = getTransactionInfo(txID);
-      tx.checkErrorCondition();
+      journalLock.readLock().lock();
 
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
+      try
+      {
+         JournalInternalRecord deleteRecordTX = new JournalDeleteRecordTX(txID, id, record);
 
-               JournalInternalRecord deleteRecordTX = new JournalDeleteRecordTX(txID, id, record);
-               JournalFile usedFile = appendRecord(deleteRecordTX, false, false, tx, null);
+         JournalTransaction tx = getTransactionInfo(txID);
 
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendDeleteRecordTransactional::txID=" + txID +
-                                  ", id=" +
-                                  id +
-                                  ", usedFile = " +
-                                  usedFile);
-               }
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(deleteRecordTX, false, false, tx, null);
 
-               tx.addNegative(usedFile, id);
-            } catch (Exception e) {
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-               setErrorCondition(tx, e);
-            } finally {
-               journalLock.readLock().unlock();
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendDeleteRecordTransactional::txID=" + txID +
+                                          ", id=" +
+                                          id +
+                                          ", usedFile = " +
+                                          usedFile);
             }
+
+            tx.addNegative(usedFile, id);
          }
-      });
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
+      }
    }
 
    /**
     * <p>If the system crashed after a prepare was called, it should store information that is required to bring the transaction
     * back to a state it could be committed. </p>
+    * <p/>
     * <p> transactionData allows you to store any other supporting user-data related to the transaction</p>
+    * <p/>
     * <p> This method also uses the same logic applied on {@link JournalImpl#appendCommitRecord(long, boolean)}
     *
     * @param txID
@@ -1039,214 +1113,197 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    public void appendPrepareRecord(final long txID,
                                    final EncodingSupport transactionData,
                                    final boolean sync,
-                                   final IOCompletion callback) throws Exception {
+                                   final IOCompletion callback) throws Exception
+   {
 
       checkJournalIsLoaded();
-      lineUpContext(callback);
 
-      final JournalTransaction tx = getTransactionInfo(txID);
-      tx.checkErrorCondition();
+      journalLock.readLock().lock();
 
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
+      try
+      {
+         JournalTransaction tx = getTransactionInfo(txID);
 
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalInternalRecord prepareRecord = new JournalCompleteRecordTX(TX_RECORD_TYPE.PREPARE, txID, transactionData);
-               JournalFile usedFile = appendRecord(prepareRecord, true, sync, tx, callback);
+         JournalInternalRecord prepareRecord =
+            new JournalCompleteRecordTX(TX_RECORD_TYPE.PREPARE, txID, transactionData);
 
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendPrepareRecord::txID=" + txID + ", usedFile = " + usedFile);
-               }
+         if (callback != null)
+         {
+            callback.storeLineUp();
+         }
 
-               tx.prepare(usedFile);
-               if (result != null) {
-                  result.set(true);
-               }
-            } catch (Exception e) {
-               if (result != null) {
-                  result.fail(e);
-               }
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-               setErrorCondition(tx, e);
-            } finally {
-               journalLock.readLock().unlock();
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(prepareRecord, true, sync, tx, callback);
+
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendPrepareRecord::txID=" + txID + ", usedFile = " + usedFile);
             }
+
+            tx.prepare(usedFile);
+         }
+         finally
+         {
+            lockAppend.unlock();
          }
-      });
 
-      if (result != null) {
-         result.get();
-         tx.checkErrorCondition();
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
       }
    }
 
    @Override
-   public void lineUpContext(IOCompletion callback) {
-      if (callback != null) {
-         callback.storeLineUp();
-      }
+   public void lineUpContext(IOCompletion callback)
+   {
+      callback.storeLineUp();
    }
 
-   private void setErrorCondition(JournalTransaction jt, Throwable t) {
-      if (jt != null) {
-         TransactionCallback callback = jt.getCurrentCallback();
-         if (callback != null && callback.getErrorMessage() != null) {
-            callback.onError(ActiveMQExceptionType.IO_ERROR.getCode(), t.getMessage());
-         }
-      }
-   }
 
    /**
     * Regarding the number of operations in a given file see {@link JournalCompleteRecordTX}.
     */
    @Override
-   public void appendCommitRecord(final long txID,
-                                  final boolean sync,
-                                  final IOCompletion callback,
-                                  final boolean lineUpContext) throws Exception {
+   public void appendCommitRecord(final long txID, final boolean sync, final IOCompletion callback, boolean lineUpContext) throws Exception
+   {
       checkJournalIsLoaded();
-      if (lineUpContext) {
-         lineUpContext(callback);
-      }
 
-      final JournalTransaction tx = transactions.remove(txID);
+      journalLock.readLock().lock();
 
-      if (tx == null) {
-         throw new IllegalStateException("Cannot find tx with id " + txID);
-      }
+      try
+      {
+         JournalTransaction tx = transactions.remove(txID);
 
-      tx.checkErrorCondition();
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
+         if (tx == null)
+         {
+            throw new IllegalStateException("Cannot find tx with id " + txID);
+         }
 
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalInternalRecord commitRecord = new JournalCompleteRecordTX(TX_RECORD_TYPE.COMMIT, txID, null);
-               JournalFile usedFile = appendRecord(commitRecord, true, sync, tx, callback);
+         JournalInternalRecord commitRecord = new JournalCompleteRecordTX(TX_RECORD_TYPE.COMMIT, txID, null);
 
+         if (callback != null && lineUpContext)
+         {
+            callback.storeLineUp();
+         }
 
-               if (logger.isTraceEnabled()) {
-                  logger.trace("appendCommitRecord::txID=" + txID + ", usedFile = " + usedFile);
-               }
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(commitRecord, true, sync, tx, callback);
 
-               tx.commit(usedFile);
-               if (result != null) {
-                  result.set(true);
-               }
-            } catch (Exception e) {
-               if (result != null) {
-                  result.fail(e);
-               }
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-               setErrorCondition(tx, e);
-            } finally {
-               journalLock.readLock().unlock();
+            if (JournalImpl.TRACE_RECORDS)
+            {
+               JournalImpl.traceRecord("appendCommitRecord::txID=" + txID + ", usedFile = " + usedFile);
             }
+
+            tx.commit(usedFile);
+         }
+         finally
+         {
+            lockAppend.unlock();
          }
-      });
 
-      if (result != null) {
-         result.get();
-         tx.checkErrorCondition();
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
       }
    }
 
    @Override
-   public void appendRollbackRecord(final long txID, final boolean sync, final IOCompletion callback) throws Exception {
+   public void appendRollbackRecord(final long txID, final boolean sync, final IOCompletion callback) throws Exception
+   {
       checkJournalIsLoaded();
-      lineUpContext(callback);
 
-      final JournalTransaction tx = transactions.remove(txID);
+      journalLock.readLock().lock();
 
-      if (tx == null) {
-         throw new IllegalStateException("Cannot find tx with id " + txID);
-      }
+      JournalTransaction tx = null;
 
-      tx.checkErrorCondition();
-      final SimpleFuture<Boolean> result = newSyncAndCallbackResult(sync, callback);
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-               JournalInternalRecord rollbackRecord = new JournalRollbackRecordTX(txID);
-               JournalFile usedFile = appendRecord(rollbackRecord, false, sync, tx, callback);
+      try
+      {
+         tx = transactions.remove(txID);
 
-               tx.rollback(usedFile);
-               if (result != null) {
-                  result.set(true);
-               }
-            } catch (Exception e) {
-               if (result != null) {
-                  result.fail(e);
-               }
-               ActiveMQJournalLogger.LOGGER.error(e.getMessage(), e);
-               setErrorCondition(tx, e);
-            }  finally {
-               journalLock.readLock().unlock();
-            }
+         if (tx == null)
+         {
+            throw new IllegalStateException("Cannot find tx with id " + txID);
+         }
+
+         JournalInternalRecord rollbackRecord = new JournalRollbackRecordTX(txID);
+
+         if (callback != null)
+         {
+            callback.storeLineUp();
          }
-      });
 
-      if (result != null) {
-         result.get();
-         tx.checkErrorCondition();
+         lockAppend.lock();
+         try
+         {
+            JournalFile usedFile = appendRecord(rollbackRecord, false, sync, tx, callback);
+
+            tx.rollback(usedFile);
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
       }
    }
 
    // XXX make it protected?
-   @Override
-   public int getAlignment() throws Exception {
+   public int getAlignment() throws Exception
+   {
       return fileFactory.getAlignment();
    }
 
-   private static final class DummyLoader implements LoaderCallback {
-
+   private static final class DummyLoader implements LoaderCallback
+   {
       static final LoaderCallback INSTANCE = new DummyLoader();
 
-      @Override
-      public void failedTransaction(final long transactionID,
-                                    final List<RecordInfo> records,
-                                    final List<RecordInfo> recordsToDelete) {
+      public void failedTransaction(final long transactionID, final List<RecordInfo> records,
+                                    final List<RecordInfo> recordsToDelete)
+      {
       }
 
-      @Override
-      public void updateRecord(final RecordInfo info) {
+      public void updateRecord(final RecordInfo info)
+      {
       }
 
-      @Override
-      public void deleteRecord(final long id) {
+      public void deleteRecord(final long id)
+      {
       }
 
-      @Override
-      public void addRecord(final RecordInfo info) {
+      public void addRecord(final RecordInfo info)
+      {
       }
 
-      @Override
-      public void addPreparedTransaction(final PreparedTransactionInfo preparedTransaction) {
+      public void addPreparedTransaction(final PreparedTransactionInfo preparedTransaction)
+      {
       }
    }
 
-   @Override
-   public synchronized JournalLoadInformation loadInternalOnly() throws Exception {
+   public synchronized JournalLoadInformation loadInternalOnly() throws Exception
+   {
       return load(DummyLoader.INSTANCE, true, null);
    }
 
-   @Override
-   public synchronized JournalLoadInformation loadSyncOnly(JournalState syncState) throws Exception {
+   public synchronized JournalLoadInformation loadSyncOnly(JournalState syncState) throws Exception
+   {
       assert syncState == JournalState.SYNCING || syncState == JournalState.SYNCING_UP_TO_DATE;
       return load(DummyLoader.INSTANCE, true, syncState);
    }
 
-   @Override
    public JournalLoadInformation load(final List<RecordInfo> committedRecords,
                                       final List<PreparedTransactionInfo> preparedTransactions,
-                                      final TransactionFailureCallback failureCallback) throws Exception {
+                                      final TransactionFailureCallback failureCallback) throws Exception
+   {
       return load(committedRecords, preparedTransactions, failureCallback, true);
    }
 
@@ -1256,27 +1313,33 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    public synchronized JournalLoadInformation load(final List<RecordInfo> committedRecords,
                                                    final List<PreparedTransactionInfo> preparedTransactions,
                                                    final TransactionFailureCallback failureCallback,
-                                                   final boolean fixBadTX) throws Exception {
-      final Set<Long> recordsToDelete = new HashSet<>();
+                                                   final boolean fixBadTX) throws Exception
+   {
+      final Set<Long> recordsToDelete = new HashSet<Long>();
       // ArrayList was taking too long to delete elements on checkDeleteSize
-      final List<RecordInfo> records = new LinkedList<>();
+      final List<RecordInfo> records = new LinkedList<RecordInfo>();
 
       final int DELETE_FLUSH = 20000;
 
-      JournalLoadInformation info = load(new LoaderCallback() {
+      JournalLoadInformation info = load(new LoaderCallback()
+      {
          Runtime runtime = Runtime.getRuntime();
 
-         private void checkDeleteSize() {
+         private void checkDeleteSize()
+         {
             // HORNETQ-482 - Flush deletes only if memory is critical
-            if (recordsToDelete.size() > DELETE_FLUSH && runtime.freeMemory() < runtime.maxMemory() * 0.2) {
+            if (recordsToDelete.size() > DELETE_FLUSH && runtime.freeMemory() < runtime.maxMemory() * 0.2)
+            {
                ActiveMQJournalLogger.LOGGER.debug("Flushing deletes during loading, deleteCount = " + recordsToDelete.size());
                // Clean up when the list is too large, or it won't be possible to load large sets of files
                // Done as part of JBMESSAGING-1678
                Iterator<RecordInfo> iter = records.iterator();
-               while (iter.hasNext()) {
+               while (iter.hasNext())
+               {
                   RecordInfo record = iter.next();
 
-                  if (recordsToDelete.contains(record.id)) {
+                  if (recordsToDelete.contains(record.id))
+                  {
                      iter.remove();
                   }
                }
@@ -1287,42 +1350,45 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             }
          }
 
-         @Override
-         public void addPreparedTransaction(final PreparedTransactionInfo preparedTransaction) {
+         public void addPreparedTransaction(final PreparedTransactionInfo preparedTransaction)
+         {
             preparedTransactions.add(preparedTransaction);
             checkDeleteSize();
          }
 
-         @Override
-         public void addRecord(final RecordInfo info) {
+         public void addRecord(final RecordInfo info)
+         {
             records.add(info);
             checkDeleteSize();
          }
 
-         @Override
-         public void updateRecord(final RecordInfo info) {
+         public void updateRecord(final RecordInfo info)
+         {
             records.add(info);
             checkDeleteSize();
          }
 
-         @Override
-         public void deleteRecord(final long id) {
+         public void deleteRecord(final long id)
+         {
             recordsToDelete.add(id);
             checkDeleteSize();
          }
 
-         @Override
          public void failedTransaction(final long transactionID,
                                        final List<RecordInfo> records,
-                                       final List<RecordInfo> recordsToDelete) {
-            if (failureCallback != null) {
+                                       final List<RecordInfo> recordsToDelete)
+         {
+            if (failureCallback != null)
+            {
                failureCallback.failedTransaction(transactionID, records, recordsToDelete);
             }
          }
       }, fixBadTX, null);
 
-      for (RecordInfo record : records) {
-         if (!recordsToDelete.contains(record.id)) {
+      for (RecordInfo record : records)
+      {
+         if (!recordsToDelete.contains(record.id))
+         {
             committedRecords.add(record);
          }
       }
@@ -1330,8 +1396,9 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       return info;
    }
 
-   @Override
-   public void scheduleCompactAndBlock(int timeout) throws Exception {
+
+   public void scheduleCompactAndBlock(int timeout) throws Exception
+   {
       final AtomicInteger errors = new AtomicInteger(0);
 
       final CountDownLatch latch = newLatch(1);
@@ -1340,30 +1407,40 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
       // We can't use the executor for the compacting... or we would dead lock because of file open and creation
       // operations (that will use the executor)
-      compactorExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
+      compactorExecutor.execute(new Runnable()
+      {
+         public void run()
+         {
 
-            try {
+            try
+            {
                JournalImpl.this.compact();
-            } catch (Throwable e) {
+            }
+            catch (Throwable e)
+            {
                errors.incrementAndGet();
                ActiveMQJournalLogger.LOGGER.errorCompacting(e);
                e.printStackTrace();
-            } finally {
+            }
+            finally
+            {
                latch.countDown();
             }
          }
       });
 
-      try {
+      try
+      {
 
          awaitLatch(latch, timeout);
 
-         if (errors.get() > 0) {
+         if (errors.get() > 0)
+         {
             throw new RuntimeException("Error during compact, look at the logs");
          }
-      } finally {
+      }
+      finally
+      {
          compactorRunning.set(false);
       }
    }
@@ -1371,28 +1448,26 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    /**
     * Note: This method can't be called from the main executor, as it will invoke other methods
     * depending on it.
-    *
+    * <p/>
     * Note: only synchronized methods on journal are methods responsible for the life-cycle such as
     * stop, start records will still come as this is being executed
     */
-
-   public synchronized void compact() throws Exception {
-
-      if (compactor != null) {
+   protected synchronized void compact() throws Exception
+   {
+      if (compactor != null)
+      {
          throw new IllegalStateException("There is pending compacting operation");
       }
 
-      if (ActiveMQJournalLogger.LOGGER.isDebugEnabled()) {
-         ActiveMQJournalLogger.LOGGER.debug("JournalImpl::compact compacting journal " + (++compactCount));
-      }
-
       compactorLock.writeLock().lock();
-      try {
-         ArrayList<JournalFile> dataFilesToProcess = new ArrayList<>(filesRepository.getDataFilesCount());
+      try
+      {
+         ArrayList<JournalFile> dataFilesToProcess = new ArrayList<JournalFile>(filesRepository.getDataFilesCount());
 
          boolean previousReclaimValue = isAutoReclaim();
 
-         try {
+         try
+         {
             ActiveMQJournalLogger.LOGGER.debug("Starting compacting operation on journal");
 
             onCompactStart();
@@ -1400,8 +1475,10 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             // We need to guarantee that the journal is frozen for this short time
             // We don't freeze the journal as we compact, only for the short time where we replace records
             journalLock.writeLock().lock();
-            try {
-               if (state != JournalState.LOADED) {
+            try
+            {
+               if (state != JournalState.LOADED)
+               {
                   return;
                }
 
@@ -1418,14 +1495,20 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                filesRepository.clearDataFiles();
 
-               if (dataFilesToProcess.size() == 0) {
-                  logger.trace("Finishing compacting, nothing to process");
+               if (dataFilesToProcess.size() == 0)
+               {
+                  trace("Finishing compacting, nothing to process");
                   return;
                }
 
-               compactor = new JournalCompactor(fileFactory, this, filesRepository, records.keySet(), dataFilesToProcess.get(0).getFileID());
+               compactor = new JournalCompactor(fileFactory,
+                                                this,
+                                                filesRepository,
+                                                records.keySet(),
+                                                dataFilesToProcess.get(0).getFileID());
 
-               for (Map.Entry<Long, JournalTransaction> entry : transactions.entrySet()) {
+               for (Map.Entry<Long, JournalTransaction> entry : transactions.entrySet())
+               {
                   compactor.addPendingTransaction(entry.getKey(), entry.getValue().getPositiveArray());
                   entry.getValue().setCompacting();
                }
@@ -1433,7 +1516,9 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                // We will calculate the new records during compacting, what will take the position the records will take
                // after compacting
                records.clear();
-            } finally {
+            }
+            finally
+            {
                journalLock.writeLock().unlock();
             }
 
@@ -1444,10 +1529,14 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             // Read the files, and use the JournalCompactor class to create the new outputFiles, and the new collections as
             // well
-            for (final JournalFile file : dataFilesToProcess) {
-               try {
+            for (final JournalFile file : dataFilesToProcess)
+            {
+               try
+               {
                   JournalImpl.readJournalFile(fileFactory, file, compactor);
-               } catch (Throwable e) {
+               }
+               catch (Throwable e)
+               {
                   ActiveMQJournalLogger.LOGGER.compactReadError(file);
                   throw new Exception("Error on reading compacting for " + file, e);
                }
@@ -1467,7 +1556,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             SequentialFile controlFile = createControlFile(dataFilesToProcess, compactor.getNewDataFiles(), null);
 
             journalLock.writeLock().lock();
-            try {
+            try
+            {
                // Need to clear the compactor here, or the replay commands will send commands back (infinite loop)
                compactor = null;
 
@@ -1476,26 +1566,31 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                newDatafiles = localCompactor.getNewDataFiles();
 
                // Restore newRecords created during compacting
-               for (Map.Entry<Long, JournalRecord> newRecordEntry : localCompactor.getNewRecords().entrySet()) {
+               for (Map.Entry<Long, JournalRecord> newRecordEntry : localCompactor.getNewRecords().entrySet())
+               {
                   records.put(newRecordEntry.getKey(), newRecordEntry.getValue());
                }
 
                // Restore compacted dataFiles
-               for (int i = newDatafiles.size() - 1; i >= 0; i--) {
+               for (int i = newDatafiles.size() - 1; i >= 0; i--)
+               {
                   JournalFile fileToAdd = newDatafiles.get(i);
-                  if (logger.isTraceEnabled()) {
-                     logger.trace("Adding file " + fileToAdd + " back as datafile");
+                  if (JournalImpl.trace)
+                  {
+                     JournalImpl.trace("Adding file " + fileToAdd + " back as datafile");
                   }
                   filesRepository.addDataFileOnTop(fileToAdd);
                }
 
-               if (logger.isTraceEnabled()) {
-                  logger.trace("There are " + filesRepository.getDataFilesCount() + " datafiles Now");
+               if (JournalImpl.trace)
+               {
+                  JournalImpl.trace("There are " + filesRepository.getDataFilesCount() + " datafiles Now");
                }
 
                // Replay pending commands (including updates, deletes and commits)
 
-               for (JournalTransaction newTransaction : localCompactor.getNewTransactions().values()) {
+               for (JournalTransaction newTransaction : localCompactor.getNewTransactions().values())
+               {
                   newTransaction.replaceRecordProvider(this);
                }
 
@@ -1505,18 +1600,25 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                // This has to be done after the replay pending commands, as we need to delete commits
                // that happened during the compacting
 
-               for (JournalTransaction newTransaction : localCompactor.getNewTransactions().values()) {
-                  if (logger.isTraceEnabled()) {
-                     logger.trace("Merging pending transaction " + newTransaction + " after compacting the journal");
+               for (JournalTransaction newTransaction : localCompactor.getNewTransactions().values())
+               {
+                  if (JournalImpl.trace)
+                  {
+                     JournalImpl.trace("Merging pending transaction " + newTransaction + " after compacting the journal");
                   }
                   JournalTransaction liveTransaction = transactions.get(newTransaction.getId());
-                  if (liveTransaction != null) {
+                  if (liveTransaction != null)
+                  {
                      liveTransaction.merge(newTransaction);
-                  } else {
+                  }
+                  else
+                  {
                      ActiveMQJournalLogger.LOGGER.compactMergeError(newTransaction.getId());
                   }
                }
-            } finally {
+            }
+            finally
+            {
                journalLock.writeLock().unlock();
             }
 
@@ -1526,19 +1628,27 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             ActiveMQJournalLogger.LOGGER.debug("Finished compacting on journal");
 
-         } finally {
+         }
+         finally
+         {
             // An Exception was probably thrown, and the compactor was not cleared
-            if (compactor != null) {
-               try {
+            if (compactor != null)
+            {
+               try
+               {
                   compactor.flush();
-               } catch (Throwable ignored) {
+               }
+               catch (Throwable ignored)
+               {
                }
 
                compactor = null;
             }
             setAutoReclaim(previousReclaimValue);
          }
-      } finally {
+      }
+      finally
+      {
          compactorLock.writeLock().unlock();
       }
 
@@ -1546,8 +1656,9 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
    /**
     * <p>Load data accordingly to the record layouts</p>
+    * <p/>
     * <p>Basic record layout:</p>
-    * <table border=1 summary="">
+    * <table border=1>
     * <tr><td><b>Field Name</b></td><td><b>Size</b></td></tr>
     * <tr><td>RecordType</td><td>Byte (1)</td></tr>
     * <tr><td>FileID</td><td>Integer (4 bytes)</td></tr>
@@ -1555,13 +1666,15 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * <tr><td>TransactionID <i>(if record is transactional)</i></td><td>Long (8 bytes)</td></tr>
     * <tr><td>RecordID</td><td>Long (8 bytes)</td></tr>
     * <tr><td>BodySize(Add, update and delete)</td><td>Integer (4 bytes)</td></tr>
-    * <tr><td>UserDefinedRecordType (If add/update only)</td><td>Byte (1)</td></tr>
+    * <tr><td>UserDefinedRecordType (If add/update only)</td><td>Byte (1)</td</tr>
     * <tr><td>RecordBody</td><td>Byte Array (size=BodySize)</td></tr>
     * <tr><td>Check Size</td><td>Integer (4 bytes)</td></tr>
     * </table>
+    * <p/>
     * <p> The check-size is used to validate if the record is valid and complete </p>
+    * <p/>
     * <p>Commit/Prepare record layout:</p>
-    * <table border=1 summary="">
+    * <table border=1>
     * <tr><td><b>Field Name</b></td><td><b>Size</b></td></tr>
     * <tr><td>RecordType</td><td>Byte (1)</td></tr>
     * <tr><td>FileID</td><td>Integer (4 bytes)</td></tr>
@@ -1572,12 +1685,13 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * <tr><td>ExtraDataBytes</td><td>Bytes (sized by ExtraDataLength)</td></tr>
     * <tr><td>* FileID(n)</td><td>Integer (4 bytes)</td></tr>
     * <tr><td>* NumberOfElements(n)</td><td>Integer (4 bytes)</td></tr>
-    * <tr><td>CheckSize</td><td>Integer (4 bytes)</td></tr>
+    * <tr><td>CheckSize</td><td>Integer (4 bytes)</td</tr>
     * </table>
+    * <p/>
     * <p> * FileID and NumberOfElements are the transaction summary, and they will be repeated (N)umberOfFiles times </p>
     */
-   @Override
-   public JournalLoadInformation load(final LoaderCallback loadManager) throws Exception {
+   public JournalLoadInformation load(final LoaderCallback loadManager) throws Exception
+   {
       return load(loadManager, true, null);
    }
 
@@ -1588,14 +1702,16 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @return
     * @throws Exception
     */
-   private synchronized JournalLoadInformation load(final LoaderCallback loadManager,
-                                                    final boolean changeData,
-                                                    final JournalState replicationSync) throws Exception {
-      if (state == JournalState.STOPPED || state == JournalState.LOADED) {
+   private synchronized JournalLoadInformation load(final LoaderCallback loadManager, final boolean changeData,
+                                                    final JournalState replicationSync) throws Exception
+   {
+      if (state == JournalState.STOPPED || state == JournalState.LOADED)
+      {
          throw new IllegalStateException("Journal " + this + " must be in " + JournalState.STARTED + " state, was " +
                                             state);
       }
-      if (state == replicationSync) {
+      if (state == replicationSync)
+      {
          throw new IllegalStateException("Journal cannot be in state " + JournalState.STARTED);
       }
 
@@ -1608,7 +1724,7 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       transactions.clear();
       currentFile = null;
 
-      final Map<Long, TransactionHolder> loadTransactions = new LinkedHashMap<>();
+      final Map<Long, TransactionHolder> loadTransactions = new LinkedHashMap<Long, TransactionHolder>();
 
       final List<JournalFile> orderedFiles = orderFiles();
 
@@ -1619,21 +1735,25 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       // AtomicLong is used only as a reference, not as an Atomic value
       final AtomicLong maxID = new AtomicLong(-1);
 
-      for (final JournalFile file : orderedFiles) {
-         logger.trace("Loading file " + file.getFile().getFileName());
+      for (final JournalFile file : orderedFiles)
+      {
+         JournalImpl.trace("Loading file " + file.getFile().getFileName());
 
          final AtomicBoolean hasData = new AtomicBoolean(false);
 
-         int resultLastPost = JournalImpl.readJournalFile(fileFactory, file, new JournalReaderCallback() {
+         int resultLastPost = JournalImpl.readJournalFile(fileFactory, file, new JournalReaderCallback()
+         {
 
-            private void checkID(final long id) {
-               if (id > maxID.longValue()) {
+            private void checkID(final long id)
+            {
+               if (id > maxID.longValue())
+               {
                   maxID.set(id);
                }
             }
 
-            @Override
-            public void onReadAddRecord(final RecordInfo info) throws Exception {
+            public void onReadAddRecord(final RecordInfo info) throws Exception
+            {
                checkID(info.id);
 
                hasData.set(true);
@@ -1643,8 +1763,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                records.put(info.id, new JournalRecord(file, info.data.length + JournalImpl.SIZE_ADD_RECORD + 1));
             }
 
-            @Override
-            public void onReadUpdateRecord(final RecordInfo info) throws Exception {
+            public void onReadUpdateRecord(final RecordInfo info) throws Exception
+            {
                checkID(info.id);
 
                hasData.set(true);
@@ -1653,7 +1773,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                JournalRecord posFiles = records.get(info.id);
 
-               if (posFiles != null) {
+               if (posFiles != null)
+               {
                   // It's legal for this to be null. The file(s) with the may
                   // have been deleted
                   // just leaving some updates in this file
@@ -1663,26 +1784,27 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                }
             }
 
-            @Override
-            public void onReadDeleteRecord(final long recordID) throws Exception {
+            public void onReadDeleteRecord(final long recordID) throws Exception
+            {
                hasData.set(true);
 
                loadManager.deleteRecord(recordID);
 
                JournalRecord posFiles = records.remove(recordID);
 
-               if (posFiles != null) {
+               if (posFiles != null)
+               {
                   posFiles.delete(file);
                }
             }
 
-            @Override
-            public void onReadUpdateRecordTX(final long transactionID, final RecordInfo info) throws Exception {
+            public void onReadUpdateRecordTX(final long transactionID, final RecordInfo info) throws Exception
+            {
                onReadAddRecordTX(transactionID, info);
             }
 
-            @Override
-            public void onReadAddRecordTX(final long transactionID, final RecordInfo info) throws Exception {
+            public void onReadAddRecordTX(final long transactionID, final RecordInfo info) throws Exception
+            {
 
                checkID(info.id);
 
@@ -1690,7 +1812,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                TransactionHolder tx = loadTransactions.get(transactionID);
 
-               if (tx == null) {
+               if (tx == null)
+               {
                   tx = new TransactionHolder(transactionID);
 
                   loadTransactions.put(transactionID, tx);
@@ -1700,7 +1823,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                JournalTransaction tnp = transactions.get(transactionID);
 
-               if (tnp == null) {
+               if (tnp == null)
+               {
                   tnp = new JournalTransaction(transactionID, JournalImpl.this);
 
                   transactions.put(transactionID, tnp);
@@ -1710,13 +1834,14 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                // count
             }
 
-            @Override
-            public void onReadDeleteRecordTX(final long transactionID, final RecordInfo info) throws Exception {
+            public void onReadDeleteRecordTX(final long transactionID, final RecordInfo info) throws Exception
+            {
                hasData.set(true);
 
                TransactionHolder tx = loadTransactions.get(transactionID);
 
-               if (tx == null) {
+               if (tx == null)
+               {
                   tx = new TransactionHolder(transactionID);
 
                   loadTransactions.put(transactionID, tx);
@@ -1726,7 +1851,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                JournalTransaction tnp = transactions.get(transactionID);
 
-               if (tnp == null) {
+               if (tnp == null)
+               {
                   tnp = new JournalTransaction(transactionID, JournalImpl.this);
 
                   transactions.put(transactionID, tnp);
@@ -1736,15 +1862,14 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             }
 
-            @Override
-            public void onReadPrepareRecord(final long transactionID,
-                                            final byte[] extraData,
-                                            final int numberOfRecords) throws Exception {
+            public void onReadPrepareRecord(final long transactionID, final byte[] extraData, final int numberOfRecords) throws Exception
+            {
                hasData.set(true);
 
                TransactionHolder tx = loadTransactions.get(transactionID);
 
-               if (tx == null) {
+               if (tx == null)
+               {
                   // The user could choose to prepare empty transactions
                   tx = new TransactionHolder(transactionID);
 
@@ -1757,7 +1882,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                JournalTransaction journalTransaction = transactions.get(transactionID);
 
-               if (journalTransaction == null) {
+               if (journalTransaction == null)
+               {
                   journalTransaction = new JournalTransaction(transactionID, JournalImpl.this);
 
                   transactions.put(transactionID, journalTransaction);
@@ -1765,16 +1891,19 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
                boolean healthy = checkTransactionHealth(file, journalTransaction, orderedFiles, numberOfRecords);
 
-               if (healthy) {
+               if (healthy)
+               {
                   journalTransaction.prepare(file);
-               } else {
+               }
+               else
+               {
                   ActiveMQJournalLogger.LOGGER.preparedTXIncomplete(transactionID);
                   tx.invalid = true;
                }
             }
 
-            @Override
-            public void onReadCommitRecord(final long transactionID, final int numberOfRecords) throws Exception {
+            public void onReadCommitRecord(final long transactionID, final int numberOfRecords) throws Exception
+            {
                TransactionHolder tx = loadTransactions.remove(transactionID);
 
                // The commit could be alone on its own journal-file and the
@@ -1784,30 +1913,40 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                // point
                // If we can't find it, we assume the TX was reclaimed and we
                // ignore this
-               if (tx != null) {
+               if (tx != null)
+               {
                   JournalTransaction journalTransaction = transactions.remove(transactionID);
 
-                  if (journalTransaction == null) {
+                  if (journalTransaction == null)
+                  {
                      throw new IllegalStateException("Cannot find tx " + transactionID);
                   }
 
                   boolean healthy = checkTransactionHealth(file, journalTransaction, orderedFiles, numberOfRecords);
 
-                  if (healthy) {
-                     for (RecordInfo txRecord : tx.recordInfos) {
-                        if (txRecord.isUpdate) {
+                  if (healthy)
+                  {
+                     for (RecordInfo txRecord : tx.recordInfos)
+                     {
+                        if (txRecord.isUpdate)
+                        {
                            loadManager.updateRecord(txRecord);
-                        } else {
+                        }
+                        else
+                        {
                            loadManager.addRecord(txRecord);
                         }
                      }
 
-                     for (RecordInfo deleteValue : tx.recordsToDelete) {
+                     for (RecordInfo deleteValue : tx.recordsToDelete)
+                     {
                         loadManager.deleteRecord(deleteValue.id);
                      }
 
                      journalTransaction.commit(file);
-                  } else {
+                  }
+                  else
+                  {
                      ActiveMQJournalLogger.LOGGER.txMissingElements(transactionID);
 
                      journalTransaction.forget();
@@ -1818,18 +1957,20 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
             }
 
-            @Override
-            public void onReadRollbackRecord(final long transactionID) throws Exception {
+            public void onReadRollbackRecord(final long transactionID) throws Exception
+            {
                TransactionHolder tx = loadTransactions.remove(transactionID);
 
                // The rollback could be alone on its own journal-file and the
                // whole transaction body was reclaimed but the commit-record
                // So it is completely legal to not find a transaction at this
                // point
-               if (tx != null) {
+               if (tx != null)
+               {
                   JournalTransaction tnp = transactions.remove(transactionID);
 
-                  if (tnp == null) {
+                  if (tnp == null)
+                  {
                      throw new IllegalStateException("Cannot find tx " + transactionID);
                   }
 
@@ -1841,25 +1982,30 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                }
             }
 
-            @Override
-            public void markAsDataFile(final JournalFile file) {
+            public void markAsDataFile(final JournalFile file)
+            {
                hasData.set(true);
             }
 
          });
 
-         if (hasData.get()) {
+         if (hasData.get())
+         {
             lastDataPos = resultLastPost;
             filesRepository.addDataFileOnBottom(file);
-         } else {
-            if (changeData) {
+         }
+         else
+         {
+            if (changeData)
+            {
                // Empty dataFiles with no data
                filesRepository.addFreeFile(file, false, false);
             }
          }
       }
 
-      if (replicationSync == JournalState.SYNCING) {
+      if (replicationSync == JournalState.SYNCING)
+      {
          assert filesRepository.getDataFiles().isEmpty();
          setJournalState(JournalState.SYNCING);
          return new JournalLoadInformation(0, -1);
@@ -1869,28 +2015,37 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
       setJournalState(JournalState.LOADED);
 
-      for (TransactionHolder transaction : loadTransactions.values()) {
-         if ((!transaction.prepared || transaction.invalid) && replicationSync != JournalState.SYNCING_UP_TO_DATE) {
+      for (TransactionHolder transaction : loadTransactions.values())
+      {
+         if ((!transaction.prepared || transaction.invalid) && replicationSync != JournalState.SYNCING_UP_TO_DATE)
+         {
             ActiveMQJournalLogger.LOGGER.uncomittedTxFound(transaction.transactionID);
 
-            if (changeData) {
+            if (changeData)
+            {
                // I append a rollback record here, because otherwise compacting will be throwing messages because of unknown transactions
                this.appendRollbackRecord(transaction.transactionID, false);
             }
 
-            loadManager.failedTransaction(transaction.transactionID, transaction.recordInfos, transaction.recordsToDelete);
-         } else {
-            for (RecordInfo info : transaction.recordInfos) {
-               if (info.id > maxID.get()) {
+            loadManager.failedTransaction(transaction.transactionID,
+                                          transaction.recordInfos,
+                                          transaction.recordsToDelete);
+         }
+         else
+         {
+            for (RecordInfo info : transaction.recordInfos)
+            {
+               if (info.id > maxID.get())
+               {
                   maxID.set(info.id);
                }
             }
 
             PreparedTransactionInfo info = new PreparedTransactionInfo(transaction.transactionID, transaction.extraData);
 
-            info.getRecords().addAll(transaction.recordInfos);
+            info.records.addAll(transaction.recordInfos);
 
-            info.getRecordsToDelete().addAll(transaction.recordsToDelete);
+            info.recordsToDelete.addAll(transaction.recordsToDelete);
 
             loadManager.addPreparedTransaction(info);
          }
@@ -1904,15 +2059,17 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    /**
     * @return true if cleanup was called
     */
-   @Override
-   public final boolean checkReclaimStatus() throws Exception {
+   public final boolean checkReclaimStatus() throws Exception
+   {
 
-      if (compactorRunning.get()) {
+      if (compactorRunning.get())
+      {
          return false;
       }
 
       // We can't start reclaim while compacting is working
-      while (true) {
+      while (true)
+      {
          if (state != JournalImpl.JournalState.LOADED)
             return false;
          if (!isAutoReclaim())
@@ -1920,14 +2077,18 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
          if (journalLock.readLock().tryLock(250, TimeUnit.MILLISECONDS))
             break;
       }
-      try {
+      try
+      {
          reclaimer.scan(getDataFiles());
 
-         for (JournalFile file : filesRepository.getDataFiles()) {
-            if (file.isCanReclaim()) {
+         for (JournalFile file : filesRepository.getDataFiles())
+         {
+            if (file.isCanReclaim())
+            {
                // File can be reclaimed or deleted
-               if (logger.isTraceEnabled()) {
-                  logger.trace("Reclaiming file " + file);
+               if (JournalImpl.trace)
+               {
+                  JournalImpl.trace("Reclaiming file " + file);
                }
 
                filesRepository.removeDataFile(file);
@@ -1935,19 +2096,23 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                filesRepository.addFreeFile(file, false);
             }
          }
-      } finally {
+      }
+      finally
+      {
          journalLock.readLock().unlock();
       }
 
       return false;
    }
 
-   private boolean needsCompact() throws Exception {
+   private boolean needsCompact() throws Exception
+   {
       JournalFile[] dataFiles = getDataFiles();
 
       long totalLiveSize = 0;
 
-      for (JournalFile file : dataFiles) {
+      for (JournalFile file : dataFiles)
+      {
          totalLiveSize += file.getLiveSize();
       }
 
@@ -1961,37 +2126,49 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
    }
 
-   private void checkCompact() throws Exception {
-      if (compactMinFiles == 0) {
+   private void checkCompact() throws Exception
+   {
+      if (compactMinFiles == 0)
+      {
          // compacting is disabled
          return;
       }
 
-      if (state != JournalState.LOADED) {
+      if (state != JournalState.LOADED)
+      {
          return;
       }
 
-      if (!compactorRunning.get() && needsCompact()) {
+      if (!compactorRunning.get() && needsCompact())
+      {
          scheduleCompact();
       }
    }
 
-   private void scheduleCompact() {
-      if (!compactorRunning.compareAndSet(false, true)) {
+   private void scheduleCompact()
+   {
+      if (!compactorRunning.compareAndSet(false, true))
+      {
          return;
       }
 
       // We can't use the executor for the compacting... or we would dead lock because of file open and creation
       // operations (that will use the executor)
-      compactorExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
+      compactorExecutor.execute(new Runnable()
+      {
+         public void run()
+         {
 
-            try {
+            try
+            {
                JournalImpl.this.compact();
-            } catch (Throwable e) {
+            }
+            catch (Throwable e)
+            {
                ActiveMQJournalLogger.LOGGER.errorCompacting(e);
-            } finally {
+            }
+            finally
+            {
                compactorRunning.set(false);
             }
          }
@@ -2001,24 +2178,26 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    // TestableJournal implementation
    // --------------------------------------------------------------
 
-   @Override
-   public final void setAutoReclaim(final boolean autoReclaim) {
+   public final void setAutoReclaim(final boolean autoReclaim)
+   {
       this.autoReclaim = autoReclaim;
    }
 
-   @Override
-   public final boolean isAutoReclaim() {
+   public final boolean isAutoReclaim()
+   {
       return autoReclaim;
    }
 
    /* Only meant to be used in tests. */
    @Override
-   public String debug() throws Exception {
+   public String debug() throws Exception
+   {
       reclaimer.scan(getDataFiles());
 
       StringBuilder builder = new StringBuilder();
 
-      for (JournalFile file : filesRepository.getDataFiles()) {
+      for (JournalFile file : filesRepository.getDataFiles())
+      {
          builder.append("DataFile:" + file +
                            " posCounter = " +
                            file.getPosCount() +
@@ -2027,23 +2206,29 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                            " live size = " +
                            file.getLiveSize() +
                            "\n");
-         if (file instanceof JournalFileImpl) {
+         if (file instanceof JournalFileImpl)
+         {
             builder.append(((JournalFileImpl) file).debug());
 
          }
       }
 
-      for (JournalFile file : filesRepository.getFreeFiles()) {
+      for (JournalFile file : filesRepository.getFreeFiles())
+      {
          builder.append("FreeFile:" + file + "\n");
       }
 
-      if (currentFile != null) {
+      if (currentFile != null)
+      {
          builder.append("CurrentFile:" + currentFile + " posCounter = " + currentFile.getPosCount() + "\n");
 
-         if (currentFile instanceof JournalFileImpl) {
+         if (currentFile instanceof JournalFileImpl)
+         {
             builder.append(((JournalFileImpl) currentFile).debug());
          }
-      } else {
+      }
+      else
+      {
          builder.append("CurrentFile: No current file at this point!");
       }
 
@@ -2054,184 +2239,150 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * Method for use on testcases.
     * It will call waitComplete on every transaction, so any assertions on the file system will be correct after this
     */
-   @Override
-   public void debugWait() throws InterruptedException {
+   public void debugWait() throws InterruptedException
+   {
       fileFactory.flush();
 
-      flushExecutor(filesExecutor);
-
-      flushExecutor(appendExecutor);
-   }
-
-   @Override
-   public void flush() throws Exception {
-      fileFactory.flush();
-
-
-      flushExecutor(appendExecutor);
-
-      flushExecutor(filesExecutor);
-
-      flushExecutor(compactorExecutor);
-   }
-
-   private void flushExecutor(Executor executor) throws InterruptedException {
-
-      if (executor != null) {
-         // Send something to the closingExecutor, just to make sure we went until its end
-         final CountDownLatch latch = new CountDownLatch(1);
+      for (JournalTransaction tx : transactions.values())
+      {
+         tx.waitCallbacks();
+      }
 
-         executor.execute(new Runnable() {
+      if (filesExecutor != null && !filesExecutor.isShutdown())
+      {
+         // Send something to the closingExecutor, just to make sure we went
+         // until its end
+         final CountDownLatch latch = newLatch(1);
 
-            @Override
-            public void run() {
+         filesExecutor.execute(new Runnable()
+         {
+            public void run()
+            {
                latch.countDown();
             }
-
          });
-         latch.await(10, TimeUnit.SECONDS);
+
+         awaitLatch(latch, -1);
       }
+
    }
 
-   @Override
-   public int getDataFilesCount() {
+   public int getDataFilesCount()
+   {
       return filesRepository.getDataFilesCount();
    }
 
-   @Override
-   public JournalFile[] getDataFiles() {
+   public JournalFile[] getDataFiles()
+   {
       return filesRepository.getDataFilesArray();
    }
 
-   @Override
-   public int getFreeFilesCount() {
+   public int getFreeFilesCount()
+   {
       return filesRepository.getFreeFilesCount();
    }
 
-   @Override
-   public int getOpenedFilesCount() {
+   public int getOpenedFilesCount()
+   {
       return filesRepository.getOpenedFilesCount();
    }
 
-   @Override
-   public int getIDMapSize() {
+   public int getIDMapSize()
+   {
       return records.size();
    }
 
    @Override
-   public int getFileSize() {
+   public int getFileSize()
+   {
       return fileSize;
    }
 
-   @Override
-   public int getMinFiles() {
+   public int getMinFiles()
+   {
       return minFiles;
    }
 
-   @Override
-   public String getFilePrefix() {
+   public String getFilePrefix()
+   {
       return filesRepository.getFilePrefix();
    }
 
-   @Override
-   public String getFileExtension() {
+   public String getFileExtension()
+   {
       return filesRepository.getFileExtension();
    }
 
-   @Override
-   public int getMaxAIO() {
+   public int getMaxAIO()
+   {
       return filesRepository.getMaxAIO();
    }
 
-   @Override
-   public int getUserVersion() {
+   public int getUserVersion()
+   {
       return userVersion;
    }
 
    // In some tests we need to force the journal to move to a next file
-   @Override
-   public void forceMoveNextFile() throws Exception {
-      debugWait();
-      journalLock.writeLock().lock();
-      try {
-         moveNextFile(false);
-      } finally {
-         journalLock.writeLock().unlock();
-      }
-   }
-
-   @Override
-   public void perfBlast(final int pages) {
-
-      checkJournalIsLoaded();
-
-      final ByteArrayEncoding byteEncoder = new ByteArrayEncoding(new byte[128 * 1024]);
-
-      final JournalInternalRecord blastRecord = new JournalInternalRecord() {
-
-         @Override
-         public int getEncodeSize() {
-            return byteEncoder.getEncodeSize();
+   public void forceMoveNextFile() throws Exception
+   {
+      journalLock.readLock().lock();
+      try
+      {
+         lockAppend.lock();
+         try
+         {
+            moveNextFile(false);
+            debugWait();
          }
-
-         @Override
-         public void encode(final ActiveMQBuffer buffer) {
-            byteEncoder.encode(buffer);
+         finally
+         {
+            lockAppend.unlock();
          }
-      };
-
-      appendExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            journalLock.readLock().lock();
-            try {
-
-               for (int i = 0; i < pages; i++) {
-                  appendRecord(blastRecord, false, false, null, null);
-               }
+      }
+      finally
+      {
+         journalLock.readLock().unlock();
+      }
+   }
 
-            } catch (Exception e) {
-               ActiveMQJournalLogger.LOGGER.failedToPerfBlast(e);
-            } finally {
-               journalLock.readLock().unlock();
-            }
-         }
-      });
+   public void perfBlast(final int pages)
+   {
+      new PerfBlast(pages).start();
    }
 
    // ActiveMQComponent implementation
    // ---------------------------------------------------
 
-   @Override
-   public synchronized boolean isStarted() {
+   public synchronized boolean isStarted()
+   {
       return state != JournalState.STOPPED;
    }
 
-   @Override
-   public synchronized void start() {
-      if (state != JournalState.STOPPED) {
+   public synchronized void start()
+   {
+      if (state != JournalState.STOPPED)
+      {
          throw new IllegalStateException("Journal " + this + " is not stopped, state is " + state);
       }
 
-      if (providedIOThreadPool == null) {
-         ThreadFactory factory = AccessController.doPrivileged(new PrivilegedAction<ThreadFactory>() {
-            @Override
-            public ThreadFactory run() {
-               return new ActiveMQThreadFactory("ArtemisIOThread", true, JournalImpl.class.getClassLoader());
-            }
-         });
-
-         threadPool = new ThreadPoolExecutor(0,Integer.MAX_VALUE, 60L,TimeUnit.SECONDS, new SynchronousQueue<>(), factory);
-         ioExecutorFactory = new OrderedExecutorFactory(threadPool);
-      } else {
-         ioExecutorFactory = providedIOThreadPool;
-      }
+      filesExecutor = Executors.newSingleThreadExecutor(new ThreadFactory()
+      {
 
-      filesExecutor = ioExecutorFactory.getExecutor();
+         public Thread newThread(final Runnable r)
+         {
+            return new Thread(r, "JournalImpl::FilesExecutor");
+         }
+      });
 
-      compactorExecutor = ioExecutorFactory.getExecutor();
+      compactorExecutor = Executors.newSingleThreadExecutor(new ThreadFactory()
+      {
 
-      appendExecutor = ioExecutorFactory.getExecutor();
+         public Thread newThread(final Runnable r)
+         {
+            return new Thread(r, "JournalImpl::CompactorExecutor");
+         }
+      });
 
       filesRepository.setExecutor(filesExecutor);
 
@@ -2240,78 +2391,109 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       setJournalState(JournalState.STARTED);
    }
 
-   @Override
-   public synchronized void stop() throws Exception {
-      if (state == JournalState.STOPPED) {
+   public synchronized void stop() throws Exception
+   {
+      if (state == JournalState.STOPPED)
+      {
          throw new IllegalStateException("Journal is already stopped");
       }
 
-      setJournalState(JournalState.STOPPED);
 
-      flush();
+      journalLock.writeLock().lock();
+      try
+      {
+         lockAppend.lock();
 
-      if (providedIOThreadPool == null) {
-         threadPool.shutdown();
+         try
+         {
 
-         if (!threadPool.awaitTermination(120, TimeUnit.SECONDS)) {
-            threadPool.shutdownNow();
-         }
-         threadPool = null;
-         ioExecutorFactory = null;
-      }
+            setJournalState(JournalState.STOPPED);
 
+            compactorExecutor.shutdown();
 
-      journalLock.writeLock().lock();
-      try {
-         try {
-            for (CountDownLatch latch : latches) {
-               latch.countDown();
+            if (!compactorExecutor.awaitTermination(120, TimeUnit.SECONDS))
+            {
+               ActiveMQJournalLogger.LOGGER.couldNotStopCompactor();
             }
-         } catch (Throwable e) {
-            ActiveMQJournalLogger.LOGGER.warn(e.getMessage(), e);
-         }
 
-         fileFactory.deactivateBuffer();
+            filesExecutor.shutdown();
 
-         if (currentFile != null && currentFile.getFile().isOpen()) {
-            currentFile.getFile().close();
-         }
-         filesRepository.clear();
+            filesRepository.setExecutor(null);
 
-         fileFactory.stop();
+            if (!filesExecutor.awaitTermination(60, TimeUnit.SECONDS))
+            {
+               ActiveMQJournalLogger.LOGGER.couldNotStopJournalExecutor();
+            }
+
+            try
+            {
+               for (CountDownLatch latch : latches)
+               {
+                  latch.countDown();
+               }
+            }
+            catch (Throwable e)
+            {
+               ActiveMQJournalLogger.LOGGER.warn(e.getMessage(), e);
+            }
+
+            fileFactory.deactivateBuffer();
 
-         currentFile = null;
-      } finally {
+            if (currentFile != null && currentFile.getFile().isOpen())
+            {
+               currentFile.getFile().close();
+            }
+
+            filesRepository.clear();
+
+            fileFactory.stop();
+
+            currentFile = null;
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+      finally
+      {
          journalLock.writeLock().unlock();
       }
    }
 
-   @Override
-   public int getNumberOfRecords() {
+   public int getNumberOfRecords()
+   {
       return records.size();
    }
 
+
    protected SequentialFile createControlFile(final List<JournalFile> files,
                                               final List<JournalFile> newFiles,
-                                              final Pair<String, String> cleanupRename) throws Exception {
+                                              final Pair<String, String> cleanupRename) throws Exception
+   {
       ArrayList<Pair<String, String>> cleanupList;
-      if (cleanupRename == null) {
+      if (cleanupRename == null)
+      {
          cleanupList = null;
-      } else {
-         cleanupList = new ArrayList<>();
+      }
+      else
+      {
+         cleanupList = new ArrayList<Pair<String, String>>();
          cleanupList.add(cleanupRename);
       }
       return AbstractJournalUpdateTask.writeControlFile(fileFactory, files, newFiles, cleanupList);
    }
 
-   protected void deleteControlFile(final SequentialFile controlFile) throws Exception {
+   protected void deleteControlFile(final SequentialFile controlFile) throws Exception
+   {
       controlFile.delete();
    }
 
    /**
     * being protected as testcases can override this method
     */
-   protected void renameFiles(final List<JournalFile> oldFiles, final List<JournalFile> newFiles) throws Exception {
+   protected void renameFiles(final List<JournalFile> oldFiles, final List<JournalFile> newFiles) throws Exception
+   {
 
       // addFreeFiles has to be called through filesExecutor, or the fileID on the orderedFiles may end up in a wrong
       // order
@@ -2320,18 +2502,26 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
       final CountDownLatch done = newLatch(1);
 
-      filesExecutor.execute(new Runnable() {
-         @Override
-         public void run() {
-            try {
-               for (JournalFile file : oldFiles) {
-                  try {
+      filesExecutor.execute(new Runnable()
+      {
+         public void run()
+         {
+            try
+            {
+               for (JournalFile file : oldFiles)
+               {
+                  try
+                  {
                      filesRepository.addFreeFile(file, false);
-                  } catch (Throwable e) {
+                  }
+                  catch (Throwable e)
+                  {
                      ActiveMQJournalLogger.LOGGER.errorReinitializingFile(e, file);
                   }
                }
-            } finally {
+            }
+            finally
+            {
                done.countDown();
             }
          }
@@ -2342,7 +2532,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       // what could cause a duplicate in case of a crash after the CTR is deleted and before the file is initialized
       awaitLatch(done, -1);
 
-      for (JournalFile file : newFiles) {
+      for (JournalFile file : newFiles)
+      {
          String newName = JournalImpl.renameExtensionFile(file.getFile().getFileName(), ".cmp");
          file.getFile().renameTo(newName);
       }
@@ -2353,7 +2544,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @param name
     * @return
     */
-   protected static String renameExtensionFile(String name, final String extension) {
+   protected static String renameExtensionFile(String name, final String extension)
+   {
       name = name.substring(0, name.lastIndexOf(extension));
       return name;
    }
@@ -2361,32 +2553,35 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    /**
     * This is an interception point for testcases, when the compacted files are written, before replacing the data structures
     */
-   protected void onCompactStart() throws Exception {
+   protected void onCompactStart() throws Exception
+   {
    }
 
    /**
     * This is an interception point for testcases, when the compacted files are written, to be called
     * as soon as the compactor gets a writeLock
     */
-   protected void onCompactLockingTheJournal() throws Exception {
+   protected void onCompactLockingTheJournal() throws Exception
+   {
    }
 
    /**
     * This is an interception point for testcases, when the compacted files are written, before replacing the data structures
     */
-   protected void onCompactDone() {
+   protected void onCompactDone()
+   {
    }
 
    // Private
    // -----------------------------------------------------------------------------
 
    /**
-    * <br>
+    * <p/>
     * Checks for holes on the transaction (a commit written but with an incomplete transaction).
-    * <br>
+    * <p/>
     * This method will validate if the transaction (PREPARE/COMMIT) is complete as stated on the
     * COMMIT-RECORD.
-    * <br>
+    * <p/>
     * For details see {@link JournalCompleteRecordTX} about how the transaction-summary is recorded.
     *
     * @param journalTransaction
@@ -2397,29 +2592,35 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    private boolean checkTransactionHealth(final JournalFile currentFile,
                                           final JournalTransaction journalTransaction,
                                           final List<JournalFile> orderedFiles,
-                                          final int numberOfRecords) {
+                                          final int numberOfRecords)
+   {
       return journalTransaction.getCounter(currentFile) == numberOfRecords;
    }
 
-   private static boolean isTransaction(final byte recordType) {
+   private static boolean isTransaction(final byte recordType)
+   {
       return recordType == JournalImpl.ADD_RECORD_TX || recordType == JournalImpl.UPDATE_RECORD_TX ||
          recordType == JournalImpl.DELETE_RECORD_TX ||
          JournalImpl.isCompleteTransaction(recordType);
    }
 
-   private static boolean isCompleteTransaction(final byte recordType) {
+   private static boolean isCompleteTransaction(final byte recordType)
+   {
       return recordType == JournalImpl.COMMIT_RECORD || recordType == JournalImpl.PREPARE_RECORD ||
          recordType == JournalImpl.ROLLBACK_RECORD;
    }
 
-   private static boolean isContainsBody(final byte recordType) {
+   private static boolean isContainsBody(final byte recordType)
+   {
       return recordType >= JournalImpl.ADD_RECORD && recordType <= JournalImpl.DELETE_RECORD_TX;
    }
 
-   private static int getRecordSize(final byte recordType, final int journalVersion) {
+   private static int getRecordSize(final byte recordType, final int journalVersion)
+   {
       // The record size (without the variable portion)
       int recordSize = 0;
-      switch (recordType) {
+      switch (recordType)
+      {
          case ADD_RECORD:
             recordSize = JournalImpl.SIZE_ADD_RECORD;
             break;
@@ -2453,9 +2654,12 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
             throw new IllegalStateException("Record other than expected");
 
       }
-      if (journalVersion >= 2) {
+      if (journalVersion >= 2)
+      {
          return recordSize + 1;
-      } else {
+      }
+      else
+      {
          return recordSize;
       }
    }
@@ -2465,30 +2669,36 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @return
     * @throws Exception
     */
-   private JournalFileImpl readFileHeader(final SequentialFile file) throws Exception {
+   private JournalFileImpl readFileHeader(final SequentialFile file) throws Exception
+   {
       ByteBuffer bb = fileFactory.newBuffer(JournalImpl.SIZE_HEADER);
 
       file.read(bb);
 
       int journalVersion = bb.getInt();
 
-      if (journalVersion != JournalImpl.FORMAT_VERSION) {
+      if (journalVersion != JournalImpl.FORMAT_VERSION)
+      {
          boolean isCompatible = false;
 
-         for (int v : JournalImpl.COMPATIBLE_VERSIONS) {
-            if (v == journalVersion) {
+         for (int v : JournalImpl.COMPATIBLE_VERSIONS)
+         {
+            if (v == journalVersion)
+            {
                isCompatible = true;
             }
          }
 
-         if (!isCompatible) {
+         if (!isCompatible)
+         {
             throw ActiveMQJournalBundle.BUNDLE.journalFileMisMatch();
          }
       }
 
       int readUserVersion = bb.getInt();
 
-      if (readUserVersion != userVersion) {
+      if (readUserVersion != userVersion)
+      {
          throw ActiveMQJournalBundle.BUNDLE.journalDifferentVersion();
       }
 
@@ -2509,13 +2719,15 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    public static int initFileHeader(final SequentialFileFactory fileFactory,
                                     final SequentialFile sequentialFile,
                                     final int userVersion,
-                                    final long fileID) throws Exception {
+                                    final long fileID) throws Exception
+   {
       // We don't need to release buffers while writing.
       ByteBuffer bb = fileFactory.newBuffer(JournalImpl.SIZE_HEADER);
 
       ActiveMQBuffer buffer = ActiveMQBuffers.wrappedBuffer(bb);
 
-      try {
+      try
+      {
          JournalImpl.writeHeader(buffer, userVersion, fileID);
 
          bb.rewind();
@@ -2526,7 +2738,9 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
          sequentialFile.writeDirect(bb, true);
          return bufferSize;
-      } finally {
+      }
+      finally
+      {
          // release it by first unwrap the unreleasable buffer and then release it.
          buffer.byteBuf().unwrap().release();
       }
@@ -2537,7 +2751,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @param userVersion
     * @param fileID
     */
-   public static void writeHeader(final ActiveMQBuffer buffer, final int userVersion, final long fileID) {
+   public static void writeHeader(final ActiveMQBuffer buffer, final int userVersion, final long fileID)
+   {
       buffer.writeInt(JournalImpl.FORMAT_VERSION);
 
       buffer.writeInt(userVersion);
@@ -2554,44 +2769,57 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
                                     final boolean completeTransaction,
                                     final boolean sync,
                                     final JournalTransaction tx,
-                                    final IOCallback parameterCallback) throws Exception {
+                                    final IOAsyncTask parameterCallback) throws Exception
+   {
+      checkJournalIsLoaded();
 
-      final IOCallback callback;
+      final IOAsyncTask callback;
 
       final int size = encoder.getEncodeSize();
 
       switchFileIfNecessary(size);
 
-      if (tx != null) {
+      if (tx != null)
+      {
          // The callback of a transaction has to be taken inside the lock,
          // when we guarantee the currentFile will not be changed,
          // since we individualize the callback per file
-         if (fileFactory.isSupportsCallbacks()) {
+         if (fileFactory.isSupportsCallbacks())
+         {
             // Set the delegated callback as a parameter
             TransactionCallback txcallback = tx.getCallback(currentFile);
-            if (parameterCallback != null) {
+            if (parameterCallback != null)
+            {
                txcallback.setDelegateCompletion(parameterCallback);
             }
             callback = txcallback;
-         } else {
+         }
+         else
+         {
             callback = null;
          }
 
          // We need to add the number of records on currentFile if prepare or commit
-         if (completeTransaction) {
+         if (completeTransaction)
+         {
             // Filling the number of pendingTransactions at the current file
             tx.fillNumberOfRecords(currentFile, encoder);
          }
-      } else {
+      }
+      else
+      {
          callback = parameterCallback;
       }
 
       // Adding fileID
       encoder.setFileID(currentFile.getRecordID());
 
-      if (callback != null) {
+      if (callback != null)
+      {
          currentFile.getFile().write(encoder, sync, callback);
-      } else {
+      }
+      else
+      {
          currentFile.getFile().write(encoder, sync);
       }
 
@@ -2599,20 +2827,28 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    }
 
    @Override
-   void scheduleReclaim() {
-      if (state != JournalState.LOADED) {
+   void scheduleReclaim()
+   {
+      if (state != JournalState.LOADED)
+      {
          return;
       }
 
-      if (isAutoReclaim() && !compactorRunning.get()) {
-         compactorExecutor.execute(new Runnable() {
-            @Override
-            public void run() {
-               try {
-                  if (!checkReclaimStatus()) {
+      if (isAutoReclaim() && !compactorRunning.get())
+      {
+         compactorExecutor.execute(new Runnable()
+         {
+            public void run()
+            {
+               try
+               {
+                  if (!checkReclaimStatus())
+                  {
                      checkCompact();
                   }
-               } catch (Exception e) {
+               }
+               catch (Exception e)
+               {
                   ActiveMQJournalLogger.LOGGER.errorSchedulingCompacting(e);
                }
             }
@@ -2620,15 +2856,18 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       }
    }
 
-   private JournalTransaction getTransactionInfo(final long txID) {
+   private JournalTransaction getTransactionInfo(final long txID)
+   {
       JournalTransaction tx = transactions.get(txID);
 
-      if (tx == null) {
+      if (tx == null)
+      {
          tx = new JournalTransaction(txID, this);
 
          JournalTransaction trans = transactions.putIfAbsent(txID, tx);
 
-         if (trans != null) {
+         if (trans != null)
+         {
             tx = trans;
          }
       }
@@ -2639,35 +2878,43 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    /**
     * @throws Exception
     */
-   private void checkControlFile() throws Exception {
-      ArrayList<String> dataFiles = new ArrayList<>();
-      ArrayList<String> newFiles = new ArrayList<>();
-      ArrayList<Pair<String, String>> renames = new ArrayList<>();
+   private void checkControlFile() throws Exception
+   {
+      ArrayList<String> dataFiles = new ArrayList<String>();
+      ArrayList<String> newFiles = new ArrayList<String>();
+      ArrayList<Pair<String, String>> renames = new ArrayList<Pair<String, String>>();
 
       SequentialFile controlFile = JournalCompactor.readControlFile(fileFactory, dataFiles, newFiles, renames);
-      if (controlFile != null) {
-         for (String dataFile : dataFiles) {
-            SequentialFile file = fileFactory.createSequentialFile(dataFile);
-            if (file.exists()) {
+      if (controlFile != null)
+      {
+         for (String dataFile : dataFiles)
+         {
+            SequentialFile file = fileFactory.createSequentialFile(dataFile, 1);
+            if (file.exists())
+            {
                file.delete();
             }
          }
 
-         for (String newFile : newFiles) {
-            SequentialFile file = fileFactory.createSequentialFile(newFile);
-            if (file.exists()) {
+         for (String newFile : newFiles)
+         {
+            SequentialFile file = fileFactory.createSequentialFile(newFile, 1);
+            if (file.exists())
+            {
                final String originalName = file.getFileName();
                final String newName = originalName.substring(0, originalName.lastIndexOf(".cmp"));
                file.renameTo(newName);
             }
          }
 
-         for (Pair<String, String> rename : renames) {
-            SequentialFile fileTmp = fileFactory.createSequentialFile(rename.getA());
-            SequentialFile fileTo = fileFactory.createSequentialFile(rename.getB());
+         for (Pair<String, String> rename : renames)
+         {
+            SequentialFile fileTmp = fileFactory.createSequentialFile(rename.getA(), 1);
+            SequentialFile fileTo = fileFactory.createSequentialFile(rename.getB(), 1);
             // We should do the rename only if the tmp file still exist, or else we could
             // delete a valid file depending on where the crash occurred during the control file delete
-            if (fileTmp.exists()) {
+            if (fileTmp.exists())
+            {
                fileTo.delete();
                fileTmp.renameTo(rename.getB());
             }
@@ -2686,24 +2933,31 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    /**
     * @throws Exception
     */
-   private void cleanupTmpFiles(final String extension) throws Exception {
+   private void cleanupTmpFiles(final String extension) throws Exception
+   {
       List<String> leftFiles = fileFactory.listFiles(getFileExtension() + extension);
 
-      if (leftFiles.size() > 0) {
+      if (leftFiles.size() > 0)
+      {
          ActiveMQJournalLogger.LOGGER.tempFilesLeftOpen();
 
-         for (String fileToDelete : leftFiles) {
+         for (String fileToDelete : leftFiles)
+         {
             ActiveMQJournalLogger.LOGGER.deletingOrphanedFile(fileToDelete);
-            SequentialFile file = fileFactory.createSequentialFile(fileToDelete);
+            SequentialFile file = fileFactory.createSequentialFile(fileToDelete, 1);
             file.delete();
          }
       }
    }
 
-   private static boolean isInvalidSize(final int fileSize, final int bufferPos, final int size) {
-      if (size < 0) {
+   private static boolean isInvalidSize(final int fileSize, final int bufferPos, final int size)
+   {
+      if (size < 0)
+      {
          return true;
-      } else {
+      }
+      else
+      {
          final int position = bufferPos + size;
 
          return position > fileSize || position < 0;
@@ -2715,17 +2969,18 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    // ---------------------------------------------------------------------------
 
    // Used on Load
-   private static final class TransactionHolder {
-
-      private TransactionHolder(final long id) {
+   private static final class TransactionHolder
+   {
+      public TransactionHolder(final long id)
+      {
          transactionID = id;
       }
 
       public final long transactionID;
 
-      public final List<RecordInfo> recordInfos = new ArrayList<>();
+      public final List<RecordInfo> recordInfos = new ArrayList<RecordInfo>();
 
-      public final List<RecordInfo> recordsToDelete = new ArrayList<>();
+      public final List<RecordInfo> recordsToDelete = new ArrayList<RecordInfo>();
 
       public boolean prepared;
 
@@ -2735,12 +2990,12 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
 
    }
 
-   private static final class JournalFileComparator implements Comparator<JournalFile>, Serializable {
-
+   private static final class JournalFileComparator implements Comparator<JournalFile>, Serializable
+   {
       private static final long serialVersionUID = -6264728973604070321L;
 
-      @Override
-      public int compare(final JournalFile f1, final JournalFile f2) {
+      public int compare(final JournalFile f1, final JournalFile f2)
+      {
          long id1 = f1.getFileID();
          long id2 = f2.getFileID();
 
@@ -2748,24 +3003,78 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       }
    }
 
-   @Override
-   public final void synchronizationLock() {
+   private final class PerfBlast extends Thread
+   {
+      private final int pages;
+
+      private PerfBlast(final int pages)
+      {
+         super("activemq-perfblast-thread");
+
+         this.pages = pages;
+      }
+
+      @Override
+      public void run()
+      {
+         lockAppend.lock();
+         try
+         {
+
+            final ByteArrayEncoding byteEncoder = new ByteArrayEncoding(new byte[128 * 1024]);
+
+            JournalInternalRecord blastRecord = new JournalInternalRecord()
+            {
+
+               @Override
+               public int getEncodeSize()
+               {
+                  return byteEncoder.getEncodeSize();
+               }
+
+               public void encode(final ActiveMQBuffer buffer)
+               {
+                  byteEncoder.encode(buffer);
+               }
+            };
+
+            for (int i = 0; i < pages; i++)
+            {
+               appendRecord(blastRecord, false, false, null, null);
+            }
+         }
+         catch (Exception e)
+         {
+            ActiveMQJournalLogger.LOGGER.failedToPerfBlast(e);
+         }
+         finally
+         {
+            lockAppend.unlock();
+         }
+      }
+   }
+
+   public final void synchronizationLock()
+   {
       compactorLock.writeLock().lock();
       journalLock.writeLock().lock();
    }
 
-   @Override
-   public final void synchronizationUnlock() {
-      try {
+   public final void synchronizationUnlock()
+   {
+      try
+      {
          compactorLock.writeLock().unlock();
-      } finally {
+      }
+      finally
+      {
          journalLock.writeLock().unlock();
       }
    }
 
    /**
     * Returns Map with a {@link JournalFile} for all existing files.
-    *
+    * <p/>
     * These are the files needed to be sent to a backup in order to synchronize it.
     *
     * @param fileIds
@@ -2773,24 +3082,30 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @throws Exception
     */
    @Override
-   public synchronized Map<Long, JournalFile> createFilesForBackupSync(long[] fileIds) throws Exception {
+   public synchronized Map<Long, JournalFile> createFilesForBackupSync(long[] fileIds) throws Exception
+   {
       synchronizationLock();
-      try {
-         Map<Long, JournalFile> map = new HashMap<>();
+      try
+      {
+         Map<Long, JournalFile> map = new HashMap<Long, JournalFile>();
          long maxID = -1;
-         for (long id : fileIds) {
+         for (long id : fileIds)
+         {
             maxID = Math.max(maxID, id);
-            map.put(id, filesRepository.createRemoteBackupSyncFile(id));
+            map.put(Long.valueOf(id), filesRepository.createRemoteBackupSyncFile(id));
          }
          filesRepository.setNextFileID(maxID);
          return map;
-      } finally {
+      }
+      finally
+      {
          synchronizationUnlock();
       }
    }
 
    @Override
-   public SequentialFileFactory getFileFactory() {
+   public SequentialFileFactory getFileFactory()
+   {
       return fileFactory;
    }
 
@@ -2799,7 +3114,8 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @return
     * @throws Exception
     */
-   protected JournalFile setUpCurrentFile(int lastDataPos) throws Exception {
+   protected JournalFile setUpCurrentFile(int lastDataPos) throws Exception
+   {
       // Create any more files we need
 
       filesRepository.ensureMinFiles();
@@ -2807,11 +3123,14 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       // The current file is the last one that has data
 
       currentFile = filesRepository.pollLastDataFile();
-      if (currentFile != null) {
+      if (currentFile != null)
+      {
          if (!currentFile.getFile().isOpen())
             currentFile.getFile().open();
          currentFile.getFile().position(currentFile.getFile().calculateBlockStart(lastDataPos));
-      } else {
+      }
+      else
+      {
          currentFile = filesRepository.getFreeFile();
          filesRepository.openFile(currentFile, true);
       }
@@ -2827,17 +3146,21 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
     * @return
     * @throws Exception
     */
-   protected JournalFile switchFileIfNecessary(int size) throws Exception {
+   protected JournalFile switchFileIfNecessary(int size) throws Exception
+   {
       // We take into account the fileID used on the Header
-      if (size > fileSize - currentFile.getFile().calculateBlockStart(JournalImpl.SIZE_HEADER)) {
+      if (size > fileSize - currentFile.getFile().calculateBlockStart(JournalImpl.SIZE_HEADER))
+      {
          throw new IllegalArgumentException("Record is too large to store " + size);
       }
 
-      if (!currentFile.getFile().fits(size)) {
+      if (!currentFile.getFile().fits(size))
+      {
          moveNextFile(true);
 
          // The same check needs to be done at the new file also
-         if (!currentFile.getFile().fits(size)) {
+         if (!currentFile.getFile().fits(size))
+         {
             // Sanity check, this should never happen
             throw new IllegalStateException("Invalid logic on buffer allocation");
          }
@@ -2845,8 +3168,10 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       return currentFile;
    }
 
-   private CountDownLatch newLatch(int countDown) {
-      if (state == JournalState.STOPPED) {
+   private CountDownLatch newLatch(int countDown)
+   {
+      if (state == JournalState.STOPPED)
+      {
          throw new RuntimeException("Server is not started");
       }
       CountDownLatch latch = new CountDownLatch(countDown);
@@ -2854,19 +3179,27 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
       return latch;
    }
 
-   private void awaitLatch(CountDownLatch latch, int timeout) throws InterruptedException {
-      try {
-         if (timeout < 0) {
+   private void awaitLatch(CountDownLatch latch, int timeout) throws InterruptedException
+   {
+      try
+      {
+         if (timeout < 0)
+         {
             latch.await();
-         } else {
+         }
+         else
+         {
             latch.await(timeout, TimeUnit.SECONDS);
          }
 
          // in case of an interrupted server, we need to make sure we don't proceed on anything
-         if (state == JournalState.STOPPED) {
+         if (state == JournalState.STOPPED)
+         {
             throw new RuntimeException("Server is not started");
          }
-      } finally {
+      }
+      finally
+      {
          latches.remove(latch);
       }
    }
@@ -2874,46 +3207,47 @@ public class JournalImpl extends JournalBase implements TestableJournal, Journal
    /**
     * You need to guarantee lock.acquire() before calling this method!
     */
-   private void moveNextFile(final boolean scheduleReclaim) throws Exception {
+   private void moveNextFile(final boolean scheduleReclaim) throws Exception
+   {
       filesRepository.closeFile(currentFile);
 
       currentFile = filesRepository.openFile();
 
-      if (scheduleReclaim) {
+      if (scheduleReclaim)
+      {
          scheduleReclaim();
       }
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("Moving next file " + currentFile);
+      if (trace)
+      {
+         ActiveMQJournalLogger.LOGGER.trace("Moving next file " + currentFile);
       }
 
       fileFactory.activateBuffer(currentFile.getFile());
    }
 
    @Override
-   public void replicationSyncPreserveOldFiles() {
+   public void replicationSyncPreserveOldFiles()
+   {
       setAutoReclaim(false);
    }
 
    @Override
-   public void replicationSyncFinished() {
+   public void replicationSyncFinished()
+   {
       setAutoReclaim(true);
    }
 
    @Override
-   public void testCompact() {
-      try {
+   public void testCompact()
+   {
+      try
+      {
          scheduleCompactAndBlock(60);
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          throw new RuntimeException(e);
       }
    }
-
-   /**
-    * For tests only
-    */
-   public int getCompactCount() {
-      return compactCount;
-   }
-
 }