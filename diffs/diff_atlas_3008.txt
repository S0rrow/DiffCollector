diff --git a/repository/src/main/java/org/apache/atlas/repository/store/graph/v1/DeleteHandlerV1.java b/repository/src/main/java/org/apache/atlas/repository/store/graph/v1/DeleteHandlerV1.java
index 4056eb124..42713763f 100644
--- a/repository/src/main/java/org/apache/atlas/repository/store/graph/v1/DeleteHandlerV1.java
+++ b/repository/src/main/java/org/apache/atlas/repository/store/graph/v1/DeleteHandlerV1.java
@@ -40,41 +40,38 @@ import org.apache.atlas.type.AtlasStructType.AtlasAttribute;
 import org.apache.atlas.type.AtlasStructType.AtlasAttribute.AtlasRelationshipEdgeDirection;
 import org.apache.atlas.type.AtlasType;
 import org.apache.atlas.type.AtlasTypeRegistry;
-import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.Stack;
 
-import static org.apache.atlas.model.instance.AtlasEntity.Status.DELETED;
-import static org.apache.atlas.repository.Constants.PROPAGATED_TRAIT_NAMES_PROPERTY_KEY;
 import static org.apache.atlas.repository.graph.GraphHelper.EDGE_LABEL_PREFIX;
-import static org.apache.atlas.repository.graph.GraphHelper.addListProperty;
-import static org.apache.atlas.repository.graph.GraphHelper.getIncomingEdgesByLabel;
-import static org.apache.atlas.repository.graph.GraphHelper.getPropagatedEdgeLabel;
-import static org.apache.atlas.repository.graph.GraphHelper.getPropagatedTraitNames;
-import static org.apache.atlas.repository.graph.GraphHelper.getTypeName;
+import static org.apache.atlas.repository.graph.GraphHelper.getReferenceObjectId;
 import static org.apache.atlas.repository.graph.GraphHelper.isRelationshipEdge;
 import static org.apache.atlas.repository.graph.GraphHelper.string;
-import static org.apache.atlas.repository.graph.GraphHelper.updateModificationMetadata;
-import static org.apache.atlas.repository.store.graph.v1.AtlasGraphUtilsV1.getIdFromEdge;
-import static org.apache.atlas.repository.store.graph.v1.AtlasGraphUtilsV1.getState;
 
 public abstract class DeleteHandlerV1 {
+
     public static final Logger LOG = LoggerFactory.getLogger(DeleteHandlerV1.class);
 
-    private final AtlasTypeRegistry    typeRegistry;
-    private final EntityGraphRetriever entityRetriever;
-    private final boolean              shouldUpdateInverseReferences;
-    private final boolean              softDelete;
+    private AtlasTypeRegistry typeRegistry;
+    private boolean shouldUpdateInverseReferences;
+    private boolean softDelete;
 
     protected static final GraphHelper graphHelper = GraphHelper.getInstance();
 
     public DeleteHandlerV1(AtlasTypeRegistry typeRegistry, boolean shouldUpdateInverseReference, boolean softDelete) {
-        this.typeRegistry                  = typeRegistry;
-        this.entityRetriever               = new EntityGraphRetriever(typeRegistry);
+        this.typeRegistry = typeRegistry;
         this.shouldUpdateInverseReferences = shouldUpdateInverseReference;
-        this.softDelete                    = softDelete;
+        this.softDelete = softDelete;
     }
 
     /**
@@ -86,25 +83,34 @@ public abstract class DeleteHandlerV1 {
      * @throws AtlasException
      */
     public void deleteEntities(Collection<AtlasVertex> instanceVertices) throws AtlasBaseException {
-        RequestContextV1 requestContext            = RequestContextV1.get();
+        RequestContextV1 requestContext = RequestContextV1.get();
+
         Set<AtlasVertex> deletionCandidateVertices = new HashSet<>();
 
         for (AtlasVertex instanceVertex : instanceVertices) {
             String              guid = AtlasGraphUtilsV1.getIdFromVertex(instanceVertex);
-            AtlasEntity.Status state = getState(instanceVertex);
+            AtlasEntity.Status state = AtlasGraphUtilsV1.getState(instanceVertex);
 
-            if (state == DELETED || requestContext.isDeletedEntity(guid)) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Skipping deletion of {} as it is already deleted", guid);
-                }
+            if (state == AtlasEntity.Status.DELETED) {
+                LOG.debug("Skipping deletion of {} as it is already deleted", guid);
+                continue;
+            }
+
+            String typeName = AtlasGraphUtilsV1.getTypeName(instanceVertex);
+            AtlasObjectId objId = new AtlasObjectId(guid, typeName);
 
+            if (requestContext.getDeletedEntityIds().contains(objId)) {
+                LOG.debug("Skipping deletion of {} as it is already deleted", guid);
                 continue;
             }
 
-            // Record all deletion candidate entities in RequestContext
+            // Get GUIDs and vertices for all deletion candidates.
+            Set<GraphHelper.VertexInfo> compositeVertices = getOwnedVertices(instanceVertex);
+
+            // Record all deletion candidate GUIDs in RequestContext
             // and gather deletion candidate vertices.
-            for (GraphHelper.VertexInfo vertexInfo : getOwnedVertices(instanceVertex)) {
-                requestContext.recordEntityDelete(vertexInfo.getEntity());
+            for (GraphHelper.VertexInfo vertexInfo : compositeVertices) {
+                requestContext.recordEntityDelete(new AtlasObjectId(vertexInfo.getGuid(), vertexInfo.getTypeName()));
                 deletionCandidateVertices.add(vertexInfo.getVertex());
             }
         }
@@ -116,26 +122,6 @@ public abstract class DeleteHandlerV1 {
         }
     }
 
-    /**
-     * Deletes the specified relationship edges.
-     *
-     * @param edges
-     * @throws AtlasBaseException
-     */
-    public void deleteRelationships(Collection<AtlasEdge> edges) throws AtlasBaseException {
-        for (AtlasEdge edge : edges) {
-            if (getState(edge) == DELETED) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Skipping deletion of {} as it is already deleted", getIdFromEdge(edge));
-                }
-
-                continue;
-            }
-
-            deleteEdge(edge, false);
-        }
-    }
-
     /**
      * Get the GUIDs and vertices for all composite entities owned/contained by the specified root entity AtlasVertex.
      * The graph is traversed from the root entity through to the leaf nodes of the containment graph.
@@ -144,104 +130,83 @@ public abstract class DeleteHandlerV1 {
      * @return set of VertexInfo for all composite entities
      * @throws AtlasException
      */
-    public Collection<GraphHelper.VertexInfo> getOwnedVertices(AtlasVertex entityVertex) throws AtlasBaseException {
-        Map<String, GraphHelper.VertexInfo> vertexInfoMap = new HashMap<>();
-        Stack<AtlasVertex>                  vertices      = new Stack<>();
-
+    public Set<GraphHelper.VertexInfo> getOwnedVertices(AtlasVertex entityVertex) throws AtlasBaseException {
+        Set<GraphHelper.VertexInfo> result = new LinkedHashSet<>();
+        Stack<AtlasVertex> vertices = new Stack<>();
         vertices.push(entityVertex);
-
         while (vertices.size() > 0) {
-            AtlasVertex        vertex = vertices.pop();
-            AtlasEntity.Status state  = getState(vertex);
+            AtlasVertex vertex = vertices.pop();
 
-            if (state == DELETED) {
+            AtlasEntity.Status state = AtlasGraphUtilsV1.getState(vertex);
+            if (state == AtlasEntity.Status.DELETED) {
                 //If the reference vertex is marked for deletion, skip it
                 continue;
             }
 
+            String typeName = GraphHelper.getTypeName(vertex);
             String guid = GraphHelper.getGuid(vertex);
 
-            if (vertexInfoMap.containsKey(guid)) {
-                continue;
-            }
-
-            AtlasObjectId   entity     = entityRetriever.toAtlasObjectId(vertex);
-            String          typeName   = entity.getTypeName();
+            result.add(new GraphHelper.VertexInfo(guid, vertex, typeName));
             AtlasEntityType entityType = typeRegistry.getEntityTypeByName(typeName);
 
             if (entityType == null) {
                 throw new AtlasBaseException(AtlasErrorCode.TYPE_NAME_INVALID, TypeCategory.ENTITY.name(), typeName);
             }
 
-            vertexInfoMap.put(guid, new GraphHelper.VertexInfo(entity, vertex));
-
             for (AtlasStructType.AtlasAttribute attributeInfo : entityType.getAllAttributes().values()) {
                 if (! attributeInfo.isOwnedRef()) {
                     continue;
                 }
-
-                String    edgeLabel = AtlasGraphUtilsV1.getAttributeEdgeLabel(entityType, attributeInfo.getName());
-                AtlasType attrType  = attributeInfo.getAttributeType();
-
+                String edgeLabel = AtlasGraphUtilsV1.getAttributeEdgeLabel(entityType, attributeInfo.getName());
+                AtlasType attrType = attributeInfo.getAttributeType();
                 switch (attrType.getTypeCategory()) {
-                    case OBJECT_ID_TYPE: {
-                        AtlasEdge edge = graphHelper.getEdgeForLabel(vertex, edgeLabel);
-
-                        if (edge != null && getState(edge) == AtlasEntity.Status.ACTIVE) {
-                            vertices.push(edge.getInVertex());
-                        }
+                case OBJECT_ID_TYPE:
+                    AtlasEdge edge = graphHelper.getEdgeForLabel(vertex, edgeLabel);
+                    if (edge != null && AtlasGraphUtilsV1.getState(edge) == AtlasEntity.Status.ACTIVE) {
+                        AtlasVertex compositeVertex = edge.getInVertex();
+                        vertices.push(compositeVertex);
                     }
                     break;
-
-                    case ARRAY: {
-                        AtlasArrayType arrType = (AtlasArrayType) attrType;
-
-                        if (arrType.getElementType().getTypeCategory() != TypeCategory.OBJECT_ID_TYPE) {
-                            continue;
-                        }
-
-                        Iterator<AtlasEdge> edges = graphHelper.getOutGoingEdgesByLabel(vertex, edgeLabel);
-
-                        if (edges != null) {
-                            while (edges.hasNext()) {
-                                AtlasEdge edge = edges.next();
-
-                                if (edge != null && getState(edge) == AtlasEntity.Status.ACTIVE) {
-                                    vertices.push(edge.getInVertex());
-                                }
+                case ARRAY:
+                    AtlasArrayType arrType = (AtlasArrayType) attrType;
+                    if (arrType.getElementType().getTypeCategory() != TypeCategory.OBJECT_ID_TYPE) {
+                        continue;
+                    }
+                    Iterator<AtlasEdge> edges = graphHelper.getOutGoingEdgesByLabel(vertex, edgeLabel);
+                    if (edges != null) {
+                        while (edges.hasNext()) {
+                            edge = edges.next();
+                            if (edge != null && AtlasGraphUtilsV1.getState(edge) == AtlasEntity.Status.ACTIVE) {
+                                AtlasVertex compositeVertex = edge.getInVertex();
+                                vertices.push(compositeVertex);
                             }
                         }
                     }
                     break;
-
-                    case MAP: {
-                        AtlasMapType mapType           = (AtlasMapType) attrType;
-                        TypeCategory valueTypeCategory = mapType.getValueType().getTypeCategory();
-
-                        if (valueTypeCategory != TypeCategory.OBJECT_ID_TYPE) {
-                            continue;
-                        }
-
-                        String       propertyName = AtlasGraphUtilsV1.getQualifiedAttributePropertyKey(entityType, attributeInfo.getName());
-                        List<String> keys         = vertex.getProperty(propertyName, List.class);
-
-                        if (keys != null) {
-                            for (String key : keys) {
-                                String    mapEdgeLabel = GraphHelper.getQualifiedNameForMapKey(edgeLabel, key);
-                                AtlasEdge edge         = graphHelper.getEdgeForLabel(vertex, mapEdgeLabel);
-
-                                if (edge != null && getState(edge) == AtlasEntity.Status.ACTIVE) {
-                                    vertices.push(edge.getInVertex());
-                                }
+                case MAP:
+                    AtlasMapType mapType = (AtlasMapType) attrType;
+                    TypeCategory valueTypeCategory = mapType.getValueType().getTypeCategory();
+                    if (valueTypeCategory != TypeCategory.OBJECT_ID_TYPE) {
+                        continue;
+                    }
+                    String propertyName = AtlasGraphUtilsV1.getQualifiedAttributePropertyKey(entityType, attributeInfo.getName());
+                    List<String> keys = vertex.getProperty(propertyName, List.class);
+                    if (keys != null) {
+                        for (String key : keys) {
+                            String mapEdgeLabel = GraphHelper.getQualifiedNameForMapKey(edgeLabel, key);
+                            edge = graphHelper.getEdgeForLabel(vertex, mapEdgeLabel);
+                            if (edge != null && AtlasGraphUtilsV1.getState(edge) == AtlasEntity.Status.ACTIVE) {
+                                AtlasVertex compositeVertex = edge.getInVertex();
+                                vertices.push(compositeVertex);
                             }
                         }
                     }
                     break;
+                default:
                 }
             }
         }
-
-        return vertexInfoMap.values();
+        return result;
     }
 
     /**
@@ -254,20 +219,20 @@ public abstract class DeleteHandlerV1 {
      * @throws AtlasException
      */
     public boolean deleteEdgeReference(AtlasEdge edge, TypeCategory typeCategory, boolean isOwned,
-                                       boolean forceDeleteStructTrait, AtlasVertex vertex) throws AtlasBaseException {
+                                       boolean forceDeleteStructTrait) throws AtlasBaseException {
+
         // default edge direction is outward
-        return deleteEdgeReference(edge, typeCategory, isOwned, forceDeleteStructTrait, AtlasRelationshipEdgeDirection.OUT, vertex);
+        return deleteEdgeReference(edge, typeCategory, isOwned, forceDeleteStructTrait, AtlasRelationshipEdgeDirection.OUT);
     }
 
     public boolean deleteEdgeReference(AtlasEdge edge, TypeCategory typeCategory, boolean isOwned, boolean forceDeleteStructTrait,
-                                       AtlasRelationshipEdgeDirection relationshipDirection, AtlasVertex entityVertex) throws AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Deleting {}", string(edge));
-        }
-
-        boolean forceDelete = (typeCategory == TypeCategory.STRUCT || typeCategory == TypeCategory.CLASSIFICATION) && forceDeleteStructTrait;
+                                       AtlasRelationshipEdgeDirection relationshipDirection) throws AtlasBaseException {
+        LOG.debug("Deleting {}", string(edge));
+        boolean forceDelete =
+                (typeCategory == TypeCategory.STRUCT || typeCategory == TypeCategory.CLASSIFICATION) && forceDeleteStructTrait;
 
-        if (typeCategory == TypeCategory.STRUCT || typeCategory == TypeCategory.CLASSIFICATION || (typeCategory == TypeCategory.OBJECT_ID_TYPE && isOwned)) {
+        if (typeCategory == TypeCategory.STRUCT || typeCategory == TypeCategory.CLASSIFICATION
+                || (typeCategory == TypeCategory.OBJECT_ID_TYPE && isOwned)) {
             //If the vertex is of type struct/trait, delete the edge and then the reference vertex as the vertex is not shared by any other entities.
             //If the vertex is of type class, and its composite attribute, this reference vertex' lifecycle is controlled
             //through this delete, hence delete the edge and the reference vertex.
@@ -285,18 +250,8 @@ public abstract class DeleteHandlerV1 {
             if (isRelationshipEdge(edge)) {
                 deleteEdge(edge, false);
 
-                AtlasVertex referencedVertex = entityRetriever.getReferencedEntityVertex(edge, relationshipDirection, entityVertex);
-
-                if (referencedVertex != null) {
-                    RequestContextV1 requestContext = RequestContextV1.get();
-
-                    if (!requestContext.isUpdatedEntity(GraphHelper.getGuid(referencedVertex))) {
-                        GraphHelper.setProperty(referencedVertex, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY, requestContext.getRequestTime());
-                        GraphHelper.setProperty(referencedVertex, Constants.MODIFIED_BY_KEY, requestContext.getUser());
-
-                        requestContext.recordEntityUpdate(entityRetriever.toAtlasObjectId(referencedVertex));
-                    }
-                }
+                AtlasObjectId deletedReferenceObjectId = getReferenceObjectId(edge, relationshipDirection);
+                RequestContextV1.get().recordEntityUpdate(deletedReferenceObjectId);
             } else {
                 //legacy case - not a relationship edge
                 //If deleting just the edge, reverse attribute should be updated for any references
@@ -304,7 +259,6 @@ public abstract class DeleteHandlerV1 {
                 deleteEdge(edge, true, false);
             }
         }
-
         return !softDelete || forceDelete;
     }
 
@@ -312,12 +266,13 @@ public abstract class DeleteHandlerV1 {
         //update inverse attribute
         if (updateInverseAttribute) {
             AtlasEdgeLabel atlasEdgeLabel = new AtlasEdgeLabel(edge.getLabel());
-            AtlasType      parentType     = typeRegistry.getType(atlasEdgeLabel.getTypeName());
+
+            AtlasType parentType = typeRegistry.getType(atlasEdgeLabel.getTypeName());
 
             if (parentType instanceof AtlasEntityType) {
-                AtlasEntityType                parentEntityType = (AtlasEntityType) parentType;
-                AtlasStructType.AtlasAttribute attribute        = parentEntityType.getAttribute(atlasEdgeLabel.getAttributeName());
+                AtlasEntityType parentEntityType = (AtlasEntityType) parentType;
 
+                AtlasStructType.AtlasAttribute attribute = parentEntityType.getAttribute(atlasEdgeLabel.getAttributeName());
                 if (attribute.getInverseRefAttribute() != null) {
                     deleteEdgeBetweenVertices(edge.getInVertex(), edge.getOutVertex(), attribute.getInverseRefAttribute());
                 }
@@ -330,64 +285,18 @@ public abstract class DeleteHandlerV1 {
 
     protected void deleteTypeVertex(AtlasVertex instanceVertex, TypeCategory typeCategory, boolean force) throws AtlasBaseException {
         switch (typeCategory) {
-            case STRUCT:
-                deleteTypeVertex(instanceVertex, force);
+        case STRUCT:
+        case CLASSIFICATION:
+            deleteTypeVertex(instanceVertex, force);
             break;
 
-            case CLASSIFICATION:
-                removeTagPropagation(instanceVertex);
-
-                deleteTypeVertex(instanceVertex, force);
+        case ENTITY:
+        case OBJECT_ID_TYPE:
+            deleteEntities(Collections.singletonList(instanceVertex));
             break;
 
-            case ENTITY:
-            case OBJECT_ID_TYPE:
-                deleteEntities(Collections.singletonList(instanceVertex));
-            break;
-
-            default:
-                throw new IllegalStateException("Type category " + typeCategory + " not handled");
-        }
-    }
-
-    public void removeTagPropagation(AtlasVertex classificationVertex) throws AtlasBaseException {
-        if (classificationVertex != null) {
-            String              classificationName = getTypeName(classificationVertex);
-            Iterator<AtlasEdge> iterator           = getIncomingEdgesByLabel(classificationVertex, getPropagatedEdgeLabel(classificationName));
-
-            // remove classification from propagated entity vertices
-            while (iterator != null && iterator.hasNext()) {
-                AtlasEdge propagatedEdge = iterator.next();
-
-                if (propagatedEdge != null) {
-                    AtlasVertex propagatedEntityVertex = propagatedEdge.getOutVertex();
-
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug("Removing propagated classification: [{}] from: [{}][{}] with edge label: [{}]", classificationName,
-                                getTypeName(propagatedEntityVertex), GraphHelper.getGuid(propagatedEntityVertex), getPropagatedEdgeLabel(classificationName));
-                    }
-
-                    removePropagatedTraitName(propagatedEntityVertex, classificationName);
-
-                    deleteEdge(propagatedEdge, true);
-
-                    updateModificationMetadata(propagatedEntityVertex);
-                }
-            }
-        }
-    }
-
-    private void removePropagatedTraitName(AtlasVertex entityVertex, String classificationName) {
-        if (entityVertex != null && StringUtils.isNotEmpty(classificationName)) {
-            List<String> propagatedTraitNames = getPropagatedTraitNames(entityVertex);
-
-            propagatedTraitNames.remove(classificationName);
-
-            entityVertex.removeProperty(PROPAGATED_TRAIT_NAMES_PROPERTY_KEY);
-
-            for (String propagatedTraitName : propagatedTraitNames) {
-                addListProperty(entityVertex, PROPAGATED_TRAIT_NAMES_PROPERTY_KEY, propagatedTraitName);
-            }
+        default:
+            throw new IllegalStateException("Type category " + typeCategory + " not handled");
         }
     }
 
@@ -397,11 +306,10 @@ public abstract class DeleteHandlerV1 {
      * @throws AtlasException
      */
     protected void deleteTypeVertex(AtlasVertex instanceVertex, boolean force) throws AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Deleting {}", string(instanceVertex));
-        }
+        LOG.debug("Deleting {}", string(instanceVertex));
+        String typeName = GraphHelper.getTypeName(instanceVertex);
+
 
-        String    typeName   = GraphHelper.getTypeName(instanceVertex);
         AtlasType parentType = typeRegistry.getType(typeName);
 
         if (parentType instanceof AtlasStructType) {
@@ -409,62 +317,55 @@ public abstract class DeleteHandlerV1 {
             boolean         isEntityType = (parentType instanceof AtlasEntityType);
 
             for (AtlasStructType.AtlasAttribute attributeInfo : structType.getAllAttributes().values()) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Deleting attribute {} for {}", attributeInfo.getName(), string(instanceVertex));
-                }
+                LOG.debug("Deleting attribute {} for {}", attributeInfo.getName(), string(instanceVertex));
+                boolean isOwned = isEntityType && attributeInfo.isOwnedRef();
+
+                AtlasType attrType = attributeInfo.getAttributeType();
 
-                boolean   isOwned   = isEntityType && attributeInfo.isOwnedRef();
-                AtlasType attrType  = attributeInfo.getAttributeType();
-                String    edgeLabel = AtlasGraphUtilsV1.getAttributeEdgeLabel(structType, attributeInfo.getName());
+                String edgeLabel = AtlasGraphUtilsV1.getAttributeEdgeLabel(structType, attributeInfo.getName());
 
                 switch (attrType.getTypeCategory()) {
-                    case OBJECT_ID_TYPE:
-                        //If its class attribute, delete the reference
-                        deleteEdgeReference(instanceVertex, edgeLabel, attrType.getTypeCategory(), isOwned);
+                case OBJECT_ID_TYPE:
+                    //If its class attribute, delete the reference
+                    deleteEdgeReference(instanceVertex, edgeLabel, attrType.getTypeCategory(), isOwned);
                     break;
 
-                    case STRUCT:
-                        //If its struct attribute, delete the reference
-                        deleteEdgeReference(instanceVertex, edgeLabel, attrType.getTypeCategory(), false);
+                case STRUCT:
+                    //If its struct attribute, delete the reference
+                    deleteEdgeReference(instanceVertex, edgeLabel, attrType.getTypeCategory(), false);
                     break;
 
-                    case ARRAY:
-                        //For array attribute, if the element is struct/class, delete all the references
-                        AtlasArrayType arrType  = (AtlasArrayType) attrType;
-                        AtlasType      elemType = arrType.getElementType();
-
-                        if (AtlasGraphUtilsV1.isReference(elemType.getTypeCategory())) {
-                            Iterator<AtlasEdge> edges = graphHelper.getOutGoingEdgesByLabel(instanceVertex, edgeLabel);
-
-                            if (edges != null) {
-                                while (edges.hasNext()) {
-                                    AtlasEdge edge = edges.next();
-
-                                    deleteEdgeReference(edge, elemType.getTypeCategory(), isOwned, false, instanceVertex);
-                                }
+                case ARRAY:
+                    //For array attribute, if the element is struct/class, delete all the references
+                    AtlasArrayType arrType = (AtlasArrayType) attrType;
+                    AtlasType elemType = arrType.getElementType();
+                    if (AtlasGraphUtilsV1.isReference(elemType.getTypeCategory())) {
+                        Iterator<AtlasEdge> edges = graphHelper.getOutGoingEdgesByLabel(instanceVertex, edgeLabel);
+                        if (edges != null) {
+                            while (edges.hasNext()) {
+                                AtlasEdge edge = edges.next();
+                                deleteEdgeReference(edge, elemType.getTypeCategory(), isOwned, false);
                             }
                         }
+                    }
                     break;
 
-                    case MAP:
-                        //For map attribute, if the value type is struct/class, delete all the references
-                        AtlasMapType mapType           = (AtlasMapType) attrType;
-                        AtlasType    keyType           = mapType.getKeyType();
-                        TypeCategory valueTypeCategory = mapType.getValueType().getTypeCategory();
-                        String       propertyName      = AtlasGraphUtilsV1.getQualifiedAttributePropertyKey(structType, attributeInfo.getName());
-
-                        if (AtlasGraphUtilsV1.isReference(valueTypeCategory)) {
-                            List<Object> keys = EntityGraphMapper.getArrayElementsProperty(keyType, instanceVertex, propertyName);
-
-                            if (keys != null) {
-                                for (Object key : keys) {
-                                    String mapEdgeLabel = GraphHelper.getQualifiedNameForMapKey(edgeLabel, (String) key);
+                case MAP:
+                    //For map attribute, if the value type is struct/class, delete all the references
+                    AtlasMapType mapType = (AtlasMapType) attrType;
+                    AtlasType keyType = mapType.getKeyType();
+                    TypeCategory valueTypeCategory = mapType.getValueType().getTypeCategory();
+                    String propertyName = AtlasGraphUtilsV1.getQualifiedAttributePropertyKey(structType, attributeInfo.getName());
 
-                                    deleteEdgeReference(instanceVertex, mapEdgeLabel, valueTypeCategory, isOwned);
-                                }
+                    if (AtlasGraphUtilsV1.isReference(valueTypeCategory)) {
+                        List<Object> keys = EntityGraphMapper.getArrayElementsProperty(keyType, instanceVertex, propertyName);
+                        if (keys != null) {
+                            for (Object key : keys) {
+                                String mapEdgeLabel = GraphHelper.getQualifiedNameForMapKey(edgeLabel, (String) key);
+                                deleteEdgeReference(instanceVertex, mapEdgeLabel, valueTypeCategory, isOwned);
                             }
                         }
-                     break;
+                    }
                 }
             }
         }
@@ -472,11 +373,11 @@ public abstract class DeleteHandlerV1 {
         deleteVertex(instanceVertex, force);
     }
 
-    public void deleteEdgeReference(AtlasVertex outVertex, String edgeLabel, TypeCategory typeCategory, boolean isOwned) throws AtlasBaseException {
+    public void deleteEdgeReference(AtlasVertex outVertex, String edgeLabel, TypeCategory typeCategory,
+        boolean isOwned) throws AtlasBaseException {
         AtlasEdge edge = graphHelper.getEdgeForLabel(outVertex, edgeLabel);
-
         if (edge != null) {
-            deleteEdgeReference(edge, typeCategory, isOwned, false, outVertex);
+            deleteEdgeReference(edge, typeCategory, isOwned, false);
         }
     }
 
@@ -486,23 +387,20 @@ public abstract class DeleteHandlerV1 {
      * @throws AtlasException
      */
     private void deleteAllTraits(AtlasVertex instanceVertex) throws AtlasBaseException {
-        String       typeName   = GraphHelper.getTypeName(instanceVertex);
         List<String> traitNames = GraphHelper.getTraitNames(instanceVertex);
-
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Deleting traits {} for {}", traitNames, string(instanceVertex));
-        }
+        LOG.debug("Deleting traits {} for {}", traitNames, string(instanceVertex));
+        String typeName = GraphHelper.getTypeName(instanceVertex);
 
         for (String traitNameToBeDeleted : traitNames) {
             String relationshipLabel = GraphHelper.getTraitLabel(typeName, traitNameToBeDeleted);
-
             deleteEdgeReference(instanceVertex, relationshipLabel, TypeCategory.CLASSIFICATION, false);
         }
     }
 
     protected AtlasAttribute getAttributeForEdge(String edgeLabel) throws AtlasBaseException {
-        AtlasEdgeLabel  atlasEdgeLabel   = new AtlasEdgeLabel(edgeLabel);
-        AtlasType       parentType       = typeRegistry.getType(atlasEdgeLabel.getTypeName());
+        AtlasEdgeLabel atlasEdgeLabel = new AtlasEdgeLabel(edgeLabel);
+
+        AtlasType parentType = typeRegistry.getType(atlasEdgeLabel.getTypeName());
         AtlasStructType parentStructType = (AtlasStructType) parentType;
 
         return parentStructType.getAttribute(atlasEdgeLabel.getAttributeName());
@@ -520,161 +418,148 @@ public abstract class DeleteHandlerV1 {
      * @throws AtlasException
      */
     protected void deleteEdgeBetweenVertices(AtlasVertex outVertex, AtlasVertex inVertex, AtlasAttribute attribute) throws AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Removing edge from {} to {} with attribute name {}", string(outVertex), string(inVertex), attribute.getName());
-        }
+        LOG.debug("Removing edge from {} to {} with attribute name {}", string(outVertex), string(inVertex),
+            attribute.getName());
+        String typeName = GraphHelper.getTypeName(outVertex);
+        String outId = GraphHelper.getGuid(outVertex);
 
-        final String             typeName = GraphHelper.getTypeName(outVertex);
-        final String             outId    = GraphHelper.getGuid(outVertex);
-        final AtlasEntity.Status state    = getState(outVertex);
+        AtlasObjectId objId = new AtlasObjectId(outId, typeName);
+        AtlasEntity.Status state = AtlasGraphUtilsV1.getState(outVertex);
 
-        if (state == DELETED || (outId != null && RequestContextV1.get().isDeletedEntity(outId))) {
+        if (state == AtlasEntity.Status.DELETED || (outId != null && RequestContextV1.get().isDeletedEntity(objId))) {
             //If the reference vertex is marked for deletion, skip updating the reference
             return;
         }
 
-        AtlasStructType   parentType   = (AtlasStructType) typeRegistry.getType(typeName);
-        String            propertyName = AtlasGraphUtilsV1.getQualifiedAttributePropertyKey(parentType, attribute.getName());
-        String            edgeLabel    = EDGE_LABEL_PREFIX + propertyName;
-        AtlasEdge         edge         = null;
-        AtlasAttributeDef attrDef      = attribute.getAttributeDef();
-        AtlasType         attrType     = attribute.getAttributeType();
+        AtlasStructType parentType = (AtlasStructType) typeRegistry.getType(typeName);
+        String propertyName = AtlasGraphUtilsV1.getQualifiedAttributePropertyKey(parentType, attribute.getName());
+        String edgeLabel = EDGE_LABEL_PREFIX + propertyName;
+        AtlasEdge edge = null;
 
-        switch (attrType.getTypeCategory()) {
-            case OBJECT_ID_TYPE: {
-                //If its class attribute, its the only edge between two vertices
-                if (attrDef.getIsOptional()) {
-                    edge = graphHelper.getEdgeForLabel(outVertex, edgeLabel);
+        AtlasAttributeDef attrDef = attribute.getAttributeDef();
+        AtlasType attrType = attribute.getAttributeType();
 
-                    if (shouldUpdateInverseReferences) {
-                        GraphHelper.setProperty(outVertex, propertyName, null);
-                    }
-                } else {
-                    // Cannot unset a required attribute.
-                    throw new AtlasBaseException("Cannot unset required attribute " + propertyName + " on " + GraphHelper.vertexString(outVertex) + " edge = " + edgeLabel);
+        switch (attrType.getTypeCategory()) {
+        case OBJECT_ID_TYPE:
+            //If its class attribute, its the only edge between two vertices
+            if (attrDef.getIsOptional()) {
+                edge = graphHelper.getEdgeForLabel(outVertex, edgeLabel);
+                if (shouldUpdateInverseReferences) {
+                    GraphHelper.setProperty(outVertex, propertyName, null);
                 }
+            } else {
+                // Cannot unset a required attribute.
+                throw new AtlasBaseException("Cannot unset required attribute " + propertyName +
+                    " on " + GraphHelper.vertexString(outVertex) + " edge = " + edgeLabel);
             }
             break;
 
-            case ARRAY: {
-                //If its array attribute, find the right edge between the two vertices and update array property
-                List<String> elements = GraphHelper.getListProperty(outVertex, propertyName);
-
-                if (elements != null) {
-                    elements = new ArrayList<>(elements);   //Make a copy, else list.remove reflects on titan.getProperty()
-
-                    for (String elementEdgeId : elements) {
-                        AtlasEdge elementEdge = graphHelper.getEdgeByEdgeId(outVertex, edgeLabel, elementEdgeId);
+        case ARRAY:
+            //If its array attribute, find the right edge between the two vertices and update array property
+            List<String> elements = GraphHelper.getListProperty(outVertex, propertyName);
+            if (elements != null) {
+                elements = new ArrayList<>(elements);   //Make a copy, else list.remove reflects on titan.getProperty()
+                for (String elementEdgeId : elements) {
+                    AtlasEdge elementEdge = graphHelper.getEdgeByEdgeId(outVertex, edgeLabel, elementEdgeId);
+                    if (elementEdge == null) {
+                        continue;
+                    }
 
-                        if (elementEdge == null) {
-                            continue;
+                    AtlasVertex elementVertex = elementEdge.getInVertex();
+                    if (elementVertex.equals(inVertex)) {
+                        edge = elementEdge;
+
+                        //TODO element.size includes deleted items as well. should exclude
+                        if (!attrDef.getIsOptional()
+                            && elements.size() <= attrDef.getValuesMinCount()) {
+                            // Deleting this edge would violate the attribute's lower bound.
+                            throw new AtlasBaseException(
+                                "Cannot remove array element from required attribute " +
+                                    propertyName + " on "
+                                    + GraphHelper.getVertexDetails(outVertex) + " " + GraphHelper.getEdgeDetails(elementEdge));
                         }
 
-                        AtlasVertex elementVertex = elementEdge.getInVertex();
+                        if (shouldUpdateInverseReferences) {
+                            //if composite attribute, remove the reference as well. else, just remove the edge
+                            //for example, when table is deleted, process still references the table
+                            //but when column is deleted, table will not reference the deleted column
+                            LOG.debug("Removing edge {} from the array attribute {}", string(elementEdge),
+                                attribute.getName());
+                            // Remove all occurrences of the edge ID from the list.
+                            // This prevents dangling edge IDs (i.e. edge IDs for deleted edges)
+                            // from the remaining in the list if there are duplicates.
+                            elements.removeAll(Collections.singletonList(elementEdge.getId().toString()));
+                            GraphHelper.setProperty(outVertex, propertyName, elements);
+                            break;
 
-                        if (elementVertex.equals(inVertex)) {
-                            edge = elementEdge;
-
-                            //TODO element.size includes deleted items as well. should exclude
-                            if (!attrDef.getIsOptional() && elements.size() <= attrDef.getValuesMinCount()) {
-                                // Deleting this edge would violate the attribute's lower bound.
-                                throw new AtlasBaseException("Cannot remove array element from required attribute " + propertyName + " on " + GraphHelper.getVertexDetails(outVertex) + " " + GraphHelper.getEdgeDetails(elementEdge));
-                            }
-
-                            if (shouldUpdateInverseReferences) {
-                                //if composite attribute, remove the reference as well. else, just remove the edge
-                                //for example, when table is deleted, process still references the table
-                                //but when column is deleted, table will not reference the deleted column
-                                if (LOG.isDebugEnabled()) {
-                                    LOG.debug("Removing edge {} from the array attribute {}", string(elementEdge), attribute.getName());
-                                }
-
-                                // Remove all occurrences of the edge ID from the list.
-                                // This prevents dangling edge IDs (i.e. edge IDs for deleted edges)
-                                // from the remaining in the list if there are duplicates.
-                                elements.removeAll(Collections.singletonList(elementEdge.getId().toString()));
-                                GraphHelper.setProperty(outVertex, propertyName, elements);
-                                break;
-                            }
                         }
                     }
                 }
             }
             break;
 
-            case MAP: {
-                //If its map attribute, find the right edge between two vertices and update map property
-                List<String> keys = GraphHelper.getListProperty(outVertex, propertyName);
-
-                if (keys != null) {
-                    keys = new ArrayList<>(keys);   //Make a copy, else list.remove reflects on titan.getProperty()
-
-                    for (String key : keys) {
-                        String    keyPropertyName = GraphHelper.getQualifiedNameForMapKey(propertyName, key);
-                        String    mapEdgeId       = GraphHelper.getSingleValuedProperty(outVertex, keyPropertyName, String.class);
-                        AtlasEdge mapEdge         = graphHelper.getEdgeByEdgeId(outVertex, keyPropertyName, mapEdgeId);
-
-                        if (mapEdge != null) {
-                            AtlasVertex mapVertex = mapEdge.getInVertex();
-
-                            if (mapVertex.getId().toString().equals(inVertex.getId().toString())) {
-                                //TODO keys.size includes deleted items as well. should exclude
-                                if (attrDef.getIsOptional() || keys.size() > attrDef.getValuesMinCount()) {
-                                    edge = mapEdge;
-                                } else {
-                                    // Deleting this entry would violate the attribute's lower bound.
-                                    throw new AtlasBaseException("Cannot remove map entry " + keyPropertyName + " from required attribute " + propertyName + " on " + GraphHelper.getVertexDetails(outVertex) + " " + GraphHelper.getEdgeDetails(mapEdge));
-                                }
-
-                                if (shouldUpdateInverseReferences) {
-                                    //remove this key
-                                    if (LOG.isDebugEnabled()) {
-                                        LOG.debug("Removing edge {}, key {} from the map attribute {}", string(mapEdge), key, attribute.getName());
-                                    }
-
-                                    keys.remove(key);
-                                    GraphHelper.setProperty(outVertex, propertyName, keys);
-                                    GraphHelper.setProperty(outVertex, keyPropertyName, null);
-                                }
-                                break;
+        case MAP:
+            //If its map attribute, find the right edge between two vertices and update map property
+            List<String> keys = GraphHelper.getListProperty(outVertex, propertyName);
+            if (keys != null) {
+                keys = new ArrayList<>(keys);   //Make a copy, else list.remove reflects on titan.getProperty()
+                for (String key : keys) {
+                    String keyPropertyName = GraphHelper.getQualifiedNameForMapKey(propertyName, key);
+                    String mapEdgeId = GraphHelper.getSingleValuedProperty(outVertex, keyPropertyName, String.class);
+                    AtlasEdge mapEdge = graphHelper.getEdgeByEdgeId(outVertex, keyPropertyName, mapEdgeId);
+                    if(mapEdge != null) {
+                        AtlasVertex mapVertex = mapEdge.getInVertex();
+                        if (mapVertex.getId().toString().equals(inVertex.getId().toString())) {
+                            //TODO keys.size includes deleted items as well. should exclude
+                            if (attrDef.getIsOptional() || keys.size() > attrDef.getValuesMinCount()) {
+                                edge = mapEdge;
+                            } else {
+                                // Deleting this entry would violate the attribute's lower bound.
+                                throw new AtlasBaseException(
+                                    "Cannot remove map entry " + keyPropertyName + " from required attribute " +
+                                        propertyName + " on " + GraphHelper.getVertexDetails(outVertex) + " " + GraphHelper.getEdgeDetails(mapEdge));
+                            }
+
+                            if (shouldUpdateInverseReferences) {
+                                //remove this key
+                                LOG.debug("Removing edge {}, key {} from the map attribute {}", string(mapEdge), key,
+                                    attribute.getName());
+                                keys.remove(key);
+                                GraphHelper.setProperty(outVertex, propertyName, keys);
+                                GraphHelper.setProperty(outVertex, keyPropertyName, null);
                             }
+                            break;
                         }
                     }
                 }
             }
             break;
 
-            case STRUCT:
-            case CLASSIFICATION:
+        case STRUCT:
+        case CLASSIFICATION:
             break;
 
-            default:
-                throw new IllegalStateException("There can't be an edge from " + GraphHelper.getVertexDetails(outVertex) + " to " + GraphHelper.getVertexDetails(inVertex) + " with attribute name " + attribute.getName() + " which is not class/array/map attribute. found " + attrType.getTypeCategory().name());
+        default:
+            throw new IllegalStateException("There can't be an edge from " + GraphHelper.getVertexDetails(outVertex) + " to "
+                + GraphHelper.getVertexDetails(inVertex) + " with attribute name " + attribute.getName() + " which is not class/array/map attribute. found " + attrType.getTypeCategory().name());
         }
 
         if (edge != null) {
             deleteEdge(edge, false);
-
             RequestContextV1 requestContext = RequestContextV1.get();
-
-            if (! requestContext.isUpdatedEntity(outId)) {
-                GraphHelper.setProperty(outVertex, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY, requestContext.getRequestTime());
-                GraphHelper.setProperty(outVertex, Constants.MODIFIED_BY_KEY, requestContext.getUser());
-
-                requestContext.recordEntityUpdate(entityRetriever.toAtlasObjectId(outVertex));
-            }
+            GraphHelper.setProperty(outVertex, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY,
+                requestContext.getRequestTime());
+            GraphHelper.setProperty(outVertex, Constants.MODIFIED_BY_KEY, requestContext.getUser());
+            requestContext.recordEntityUpdate(new AtlasObjectId(outId, typeName));
         }
     }
 
     protected void deleteVertex(AtlasVertex instanceVertex, boolean force) throws AtlasBaseException {
         //Update external references(incoming edges) to this vertex
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Setting the external references to {} to null(removing edges)", string(instanceVertex));
-        }
+        LOG.debug("Setting the external references to {} to null(removing edges)", string(instanceVertex));
 
         for (AtlasEdge edge : (Iterable<AtlasEdge>) instanceVertex.getEdges(AtlasEdgeDirection.IN)) {
-            AtlasEntity.Status edgeState = getState(edge);
-
+            AtlasEntity.Status edgeState = AtlasGraphUtilsV1.getState(edge);
             if (edgeState == AtlasEntity.Status.ACTIVE) {
                 //Delete only the active edge references
                 AtlasAttribute attribute = getAttributeForEdge(edge.getLabel());
@@ -682,7 +567,6 @@ public abstract class DeleteHandlerV1 {
                 deleteEdgeBetweenVertices(edge.getOutVertex(), edge.getInVertex(), attribute);
             }
         }
-
         _deleteVertex(instanceVertex, force);
     }
 }