diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationEndpoint.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationEndpoint.java
index 6683fbeed0..32ad0ec6f2 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationEndpoint.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationEndpoint.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -27,17 +27,18 @@ import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.activemq.artemis.api.core.ActiveMQException;
-import org.apache.activemq.artemis.api.core.Message;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.core.config.Configuration;
-import org.apache.activemq.artemis.core.io.IOCriticalErrorListener;
-import org.apache.activemq.artemis.core.io.SequentialFile;
+import org.apache.activemq.artemis.core.journal.IOCriticalErrorListener;
 import org.apache.activemq.artemis.core.journal.Journal;
 import org.apache.activemq.artemis.core.journal.Journal.JournalState;
 import org.apache.activemq.artemis.core.journal.JournalLoadInformation;
+import org.apache.activemq.artemis.core.journal.SequentialFile;
 import org.apache.activemq.artemis.core.journal.impl.FileWrapperJournal;
 import org.apache.activemq.artemis.core.journal.impl.JournalFile;
 import org.apache.activemq.artemis.core.paging.PagedMessage;
@@ -46,14 +47,14 @@ import org.apache.activemq.artemis.core.paging.impl.Page;
 import org.apache.activemq.artemis.core.paging.impl.PagingManagerImpl;
 import org.apache.activemq.artemis.core.paging.impl.PagingStoreFactoryNIO;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
-import org.apache.activemq.artemis.core.persistence.impl.journal.AbstractJournalStorageManager.JournalContent;
+import org.apache.activemq.artemis.core.persistence.impl.journal.JournalStorageManager.JournalContent;
 import org.apache.activemq.artemis.core.persistence.impl.journal.LargeServerMessageInSync;
 import org.apache.activemq.artemis.core.protocol.core.Channel;
 import org.apache.activemq.artemis.core.protocol.core.ChannelHandler;
 import org.apache.activemq.artemis.core.protocol.core.Packet;
 import org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ActiveMQExceptionMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.BackupReplicationStartFailedMessage;
+import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ActiveMQExceptionMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationAddMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationAddTXMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationCommitMessage;
@@ -67,7 +68,6 @@ import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.Replicatio
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationPageWriteMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationPrepareMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationResponseMessage;
-import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationResponseMessageV2;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationStartSyncMessage;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationStartSyncMessage.SyncDataType;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationSyncFileMessage;
@@ -75,20 +75,18 @@ import org.apache.activemq.artemis.core.replication.ReplicationManager.ADD_OPERA
 import org.apache.activemq.artemis.core.server.ActiveMQComponent;
 import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
-
+import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.cluster.qourum.SharedNothingBackupQuorum;
 import org.apache.activemq.artemis.core.server.impl.ActiveMQServerImpl;
 import org.apache.activemq.artemis.core.server.impl.SharedNothingBackupActivation;
-import org.apache.activemq.artemis.utils.OrderedExecutorFactory;
-import org.jboss.logging.Logger;
 
 /**
  * Handles all the synchronization necessary for replication on the backup side (that is the
  * backup's side of the "remote backup" use case).
  */
-public final class ReplicationEndpoint implements ChannelHandler, ActiveMQComponent {
-
-   private static final Logger logger = Logger.getLogger(ReplicationEndpoint.class);
+public final class ReplicationEndpoint implements ChannelHandler, ActiveMQComponent
+{
+   private static final boolean trace = ActiveMQServerLogger.LOGGER.isTraceEnabled();
 
    private final IOCriticalErrorListener criticalErrorListener;
    private final ActiveMQServerImpl server;
@@ -103,20 +101,23 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * Files reserved in each journal for synchronization of existing data from the 'live' server.
     */
-   private final Map<JournalContent, Map<Long, JournalSyncFile>> filesReservedForSync = new HashMap<>();
+   private final Map<JournalContent, Map<Long, JournalSyncFile>> filesReservedForSync =
+      new HashMap<JournalContent, Map<Long, JournalSyncFile>>();
 
    /**
     * Used to hold the real Journals before the backup is synchronized. This field should be
     * {@code null} on an up-to-date server.
     */
-   private Map<JournalContent, Journal> journalsHolder = new HashMap<>();
+   private Map<JournalContent, Journal> journalsHolder = new HashMap<JournalContent, Journal>();
 
    private StorageManager storageManager;
 
    private PagingManager pageManager;
 
-   private final ConcurrentMap<SimpleString, ConcurrentMap<Integer, Page>> pageIndex = new ConcurrentHashMap<>();
-   private final ConcurrentMap<Long, ReplicatedLargeMessage> largeMessages = new ConcurrentHashMap<>();
+   private final ConcurrentMap<SimpleString, ConcurrentMap<Integer, Page>> pageIndex =
+      new ConcurrentHashMap<SimpleString, ConcurrentMap<Integer, Page>>();
+   private final ConcurrentMap<Long, ReplicatedLargeMessage> largeMessages =
+      new ConcurrentHashMap<Long, ReplicatedLargeMessage>();
 
    // Used on tests, to simulate failures on delete pages
    private boolean deletePages = true;
@@ -127,10 +128,9 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    private Executor executor;
 
    // Constructors --------------------------------------------------
-   public ReplicationEndpoint(final ActiveMQServerImpl server,
-                              IOCriticalErrorListener criticalErrorListener,
-                              boolean wantedFailBack,
-                              SharedNothingBackupActivation activation) {
+   public ReplicationEndpoint(final ActiveMQServerImpl server, IOCriticalErrorListener criticalErrorListener,
+                              boolean wantedFailBack, SharedNothingBackupActivation activation)
+   {
       this.server = server;
       this.criticalErrorListener = criticalErrorListener;
       this.wantedFailBack = wantedFailBack;
@@ -139,13 +139,19 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
 
    // Public --------------------------------------------------------
 
-   public synchronized void registerJournal(final byte id, final Journal journal) {
-      if (journals == null || id >= journals.length) {
+   public synchronized void registerJournal(final byte id, final Journal journal)
+   {
+      if (journals == null || id >= journals.length)
+      {
          Journal[] oldJournals = journals;
          journals = new Journal[id + 1];
 
-         if (oldJournals != null) {
-            System.arraycopy(oldJournals, 0, journals, 0, oldJournals.length);
+         if (oldJournals != null)
+         {
+            for (int i = 0; i < oldJournals.length; i++)
+            {
+               journals[i] = oldJournals[i];
+            }
          }
       }
 
@@ -153,80 +159,102 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    }
 
    @Override
-   public void handlePacket(final Packet packet) {
-      if (logger.isTraceEnabled()) {
-         logger.trace("handlePacket::handling " + packet);
-      }
+   public void handlePacket(final Packet packet)
+   {
       PacketImpl response = new ReplicationResponseMessage();
       final byte type = packet.getType();
 
-      try {
-         if (!started) {
-            if (logger.isTraceEnabled()) {
-               logger.trace("handlePacket::ignoring " + packet);
-            }
-
+      try
+      {
+         if (!started)
+         {
             return;
          }
 
-         if (type == PacketImpl.REPLICATION_APPEND) {
+         if (type == PacketImpl.REPLICATION_APPEND)
+         {
             handleAppendAddRecord((ReplicationAddMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_APPEND_TX) {
+         }
+         else if (type == PacketImpl.REPLICATION_APPEND_TX)
+         {
             handleAppendAddTXRecord((ReplicationAddTXMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_DELETE) {
+         }
+         else if (type == PacketImpl.REPLICATION_DELETE)
+         {
             handleAppendDelete((ReplicationDeleteMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_DELETE_TX) {
+         }
+         else if (type == PacketImpl.REPLICATION_DELETE_TX)
+         {
             handleAppendDeleteTX((ReplicationDeleteTXMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_PREPARE) {
+         }
+         else if (type == PacketImpl.REPLICATION_PREPARE)
+         {
             handlePrepare((ReplicationPrepareMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_COMMIT_ROLLBACK) {
+         }
+         else if (type == PacketImpl.REPLICATION_COMMIT_ROLLBACK)
+         {
             handleCommitRollback((ReplicationCommitMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_PAGE_WRITE) {
+         }
+         else if (type == PacketImpl.REPLICATION_PAGE_WRITE)
+         {
             handlePageWrite((ReplicationPageWriteMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_PAGE_EVENT) {
+         }
+         else if (type == PacketImpl.REPLICATION_PAGE_EVENT)
+         {
             handlePageEvent((ReplicationPageEventMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_LARGE_MESSAGE_BEGIN) {
+         }
+         else if (type == PacketImpl.REPLICATION_LARGE_MESSAGE_BEGIN)
+         {
             handleLargeMessageBegin((ReplicationLargeMessageBeginMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_LARGE_MESSAGE_WRITE) {
+         }
+         else if (type == PacketImpl.REPLICATION_LARGE_MESSAGE_WRITE)
+         {
             handleLargeMessageWrite((ReplicationLargeMessageWriteMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_LARGE_MESSAGE_END) {
+         }
+         else if (type == PacketImpl.REPLICATION_LARGE_MESSAGE_END)
+         {
             handleLargeMessageEnd((ReplicationLargeMessageEndMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_START_FINISH_SYNC) {
-            response = handleStartReplicationSynchronization((ReplicationStartSyncMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_SYNC_FILE) {
+         }
+         else if (type == PacketImpl.REPLICATION_START_FINISH_SYNC)
+         {
+            handleStartReplicationSynchronization((ReplicationStartSyncMessage) packet);
+         }
+         else if (type == PacketImpl.REPLICATION_SYNC_FILE)
+         {
             handleReplicationSynchronization((ReplicationSyncFileMessage) packet);
-         } else if (type == PacketImpl.REPLICATION_SCHEDULED_FAILOVER) {
+         }
+         else if (type == PacketImpl.REPLICATION_SCHEDULED_FAILOVER)
+         {
             handleLiveStopping((ReplicationLiveIsStoppingMessage) packet);
-         } else if (type == PacketImpl.BACKUP_REGISTRATION_FAILED) {
+         }
+         else if (type == PacketImpl.BACKUP_REGISTRATION_FAILED)
+         {
             handleFatalError((BackupReplicationStartFailedMessage) packet);
-         } else {
+         }
+         else
+         {
             ActiveMQServerLogger.LOGGER.invalidPacketForReplication(packet);
          }
-      } catch (ActiveMQException e) {
-         logger.warn(e.getMessage(), e);
+      }
+      catch (ActiveMQException e)
+      {
          ActiveMQServerLogger.LOGGER.errorHandlingReplicationPacket(e, packet);
          response = new ActiveMQExceptionMessage(e);
-      } catch (Exception e) {
-         logger.warn(e.getMessage(), e);
-         ActiveMQServerLogger.LOGGER.errorHandlingReplicationPacket(e, packet);
-         response = new ActiveMQExceptionMessage(ActiveMQMessageBundle.BUNDLE.replicationUnhandledError(e));
       }
-
-      if (response != null) {
-         if (logger.isTraceEnabled()) {
-            logger.trace("Returning " + response);
-         }
-
-         channel.send(response);
-      } else {
-         logger.trace("Response is null, ignoring response");
+      catch (Exception e)
+      {
+         ActiveMQServerLogger.LOGGER.errorHandlingReplicationPacket(e, packet);
+         response =
+            new ActiveMQExceptionMessage(ActiveMQMessageBundle.BUNDLE.replicationUnhandledError(e));
       }
+      channel.send(response);
    }
 
    /**
     * @param packet
     */
-   private void handleFatalError(BackupReplicationStartFailedMessage packet) {
+   private void handleFatalError(BackupReplicationStartFailedMessage packet)
+   {
       ActiveMQServerLogger.LOGGER.errorStartingReplication(packet.getRegistrationProblem());
       server.stopTheServer(false);
    }
@@ -235,19 +263,21 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     * @param packet
     * @throws ActiveMQException
     */
-   private void handleLiveStopping(ReplicationLiveIsStoppingMessage packet) throws ActiveMQException {
+   private void handleLiveStopping(ReplicationLiveIsStoppingMessage packet) throws ActiveMQException
+   {
       activation.remoteFailOver(packet.isFinalMessage());
    }
 
-   @Override
-   public boolean isStarted() {
+   public boolean isStarted()
+   {
       return started;
    }
 
-   @Override
-   public synchronized void start() throws Exception {
+   public synchronized void start() throws Exception
+   {
       Configuration config = server.getConfiguration();
-      try {
+      try
+      {
          storageManager = server.getStorageManager();
          storageManager.start();
 
@@ -256,65 +286,81 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
          journalsHolder.put(JournalContent.BINDINGS, storageManager.getBindingsJournal());
          journalsHolder.put(JournalContent.MESSAGES, storageManager.getMessageJournal());
 
-         for (JournalContent jc : EnumSet.allOf(JournalContent.class)) {
+         for (JournalContent jc : EnumSet.allOf(JournalContent.class))
+         {
             filesReservedForSync.put(jc, new HashMap<Long, JournalSyncFile>());
             // We only need to load internal structures on the backup...
             journalLoadInformation[jc.typeByte] = journalsHolder.get(jc).loadSyncOnly(JournalState.SYNCING);
          }
 
-         pageManager = new PagingManagerImpl(new PagingStoreFactoryNIO(storageManager, config.getPagingLocation(), config.getJournalBufferSize_NIO(), server.getScheduledPool(), server.getExecutorFactory(), config.isJournalSyncNonTransactional(), criticalErrorListener), server.getAddressSettingsRepository());
+         pageManager =
+            new PagingManagerImpl(new PagingStoreFactoryNIO(storageManager, config.getPagingDirectory(),
+                                                            config.getJournalBufferSize_NIO(),
+                                                            server.getScheduledPool(),
+                                                            server.getExecutorFactory(),
+                                                            config.isJournalSyncNonTransactional(), criticalErrorListener),
+                                  server.getAddressSettingsRepository());
 
          pageManager.start();
 
          started = true;
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          if (server.isStarted())
             throw e;
       }
    }
 
-   @Override
-   public synchronized void stop() throws Exception {
-      if (!started) {
+   public synchronized void stop() throws Exception
+   {
+      if (!started)
+      {
          return;
       }
 
-      logger.trace("Stopping endpoint");
-
-      started = false;
-
-      OrderedExecutorFactory.flushExecutor(executor);
-
       // Channel may be null if there isn't a connection to a live server
-      if (channel != null) {
+      if (channel != null)
+      {
          channel.close();
       }
 
-      for (ReplicatedLargeMessage largeMessage : largeMessages.values()) {
+      for (ReplicatedLargeMessage largeMessage : largeMessages.values())
+      {
          largeMessage.releaseResources();
       }
       largeMessages.clear();
 
-      for (Entry<JournalContent, Map<Long, JournalSyncFile>> entry : filesReservedForSync.entrySet()) {
-         for (JournalSyncFile filesReserved : entry.getValue().values()) {
+      for (Entry<JournalContent, Map<Long, JournalSyncFile>> entry : filesReservedForSync
+         .entrySet())
+      {
+         for (JournalSyncFile filesReserved : entry.getValue().values())
+         {
             filesReserved.close();
          }
       }
 
       filesReservedForSync.clear();
-      if (journals != null) {
-         for (Journal j : journals) {
+      if (journals != null)
+      {
+         for (Journal j : journals)
+         {
             if (j instanceof FileWrapperJournal)
                j.stop();
          }
       }
 
-      for (ConcurrentMap<Integer, Page> map : pageIndex.values()) {
-         for (Page page : map.values()) {
-            try {
+      for (ConcurrentMap<Integer, Page> map : pageIndex.values())
+      {
+         for (Page page : map.values())
+         {
+            try
+            {
                page.sync();
-               page.close(false);
-            } catch (Exception e) {
+               page.close();
+            }
+            catch (Exception e)
+            {
                ActiveMQServerLogger.LOGGER.errorClosingPageOnReplication(e);
             }
          }
@@ -322,6 +368,17 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
       pageManager.stop();
 
       pageIndex.clear();
+      final CountDownLatch latch = new CountDownLatch(1);
+      executor.execute(new Runnable()
+      {
+
+         @Override
+         public void run()
+         {
+            latch.countDown();
+         }
+      });
+      latch.await(30, TimeUnit.SECONDS);
 
       // Storage needs to be the last to stop
       storageManager.stop();
@@ -329,78 +386,107 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
       started = false;
    }
 
-   public Channel getChannel() {
+
+   public Channel getChannel()
+   {
       return channel;
    }
 
-   public void setChannel(final Channel channel) {
+   public void setChannel(final Channel channel)
+   {
       this.channel = channel;
    }
 
-   private void finishSynchronization(String liveID) throws Exception {
-      if (logger.isTraceEnabled()) {
-         logger.trace("BACKUP-SYNC-START: finishSynchronization::" + liveID);
+   public void compareJournalInformation(final JournalLoadInformation[] journalInformation) throws ActiveMQException
+   {
+      if (!activation.isRemoteBackupUpToDate())
+      {
+         throw ActiveMQMessageBundle.BUNDLE.journalsNotInSync();
       }
-      for (JournalContent jc : EnumSet.allOf(JournalContent.class)) {
-         Journal journal = journalsHolder.remove(jc);
-         if (logger.isTraceEnabled()) {
-            logger.trace("getting lock on " + jc + ", journal = " + journal);
+
+      if (journalLoadInformation == null || journalLoadInformation.length != journalInformation.length)
+      {
+         throw ActiveMQMessageBundle.BUNDLE.replicationTooManyJournals();
+      }
+
+      for (int i = 0; i < journalInformation.length; i++)
+      {
+         if (!journalInformation[i].equals(journalLoadInformation[i]))
+         {
+            ActiveMQServerLogger.LOGGER.journalcomparisonMismatch(journalParametersToString(journalInformation));
+            throw ActiveMQMessageBundle.BUNDLE.replicationTooManyJournals();
          }
-         registerJournal(jc.typeByte, journal);
+      }
+
+   }
+
+   /**
+    * Used on tests only. To simulate missing page deletes
+    */
+   public void setDeletePages(final boolean deletePages)
+   {
+      this.deletePages = deletePages;
+   }
+
+   /**
+    * @param journalInformation
+    */
+   private String journalParametersToString(final JournalLoadInformation[] journalInformation)
+   {
+      return "**********************************************************\n" + "parameters:\n" +
+         "BindingsImpl = " +
+         journalInformation[0] +
+         "\n" +
+         "Messaging = " +
+         journalInformation[1] +
+         "\n" +
+         "**********************************************************" +
+         "\n" +
+         "Expected:" +
+         "\n" +
+         "BindingsImpl = " +
+         journalLoadInformation[0] +
+         "\n" +
+         "Messaging = " +
+         journalLoadInformation[1] +
+         "\n" +
+         "**********************************************************";
+   }
+
+   private void finishSynchronization(String liveID) throws Exception
+   {
+      for (JournalContent jc : EnumSet.allOf(JournalContent.class))
+      {
+         Journal journal = journalsHolder.remove(jc);
          journal.synchronizationLock();
-         try {
-            if (logger.isTraceEnabled()) {
-               logger.trace("lock acquired on " + jc);
-            }
+         try
+         {
             // files should be already in place.
             filesReservedForSync.remove(jc);
-            if (logger.isTraceEnabled()) {
-               logger.trace("stopping journal for " + jc);
-            }
+            registerJournal(jc.typeByte, journal);
             journal.stop();
-            if (logger.isTraceEnabled()) {
-               logger.trace("starting journal for " + jc);
-            }
             journal.start();
-            if (logger.isTraceEnabled()) {
-               logger.trace("loadAndSync " + jc);
-            }
             journal.loadSyncOnly(JournalState.SYNCING_UP_TO_DATE);
-         } finally {
-            if (logger.isTraceEnabled()) {
-               logger.trace("unlocking " + jc);
-            }
+         }
+         finally
+         {
             journal.synchronizationUnlock();
          }
       }
-
-      if (logger.isTraceEnabled()) {
-         logger.trace("Sync on large messages...");
-      }
       ByteBuffer buffer = ByteBuffer.allocate(4 * 1024);
-      for (Entry<Long, ReplicatedLargeMessage> entry : largeMessages.entrySet()) {
+      for (Entry<Long, ReplicatedLargeMessage> entry : largeMessages.entrySet())
+      {
          ReplicatedLargeMessage lm = entry.getValue();
-         if (lm instanceof LargeServerMessageInSync) {
+         if (lm instanceof LargeServerMessageInSync)
+         {
             LargeServerMessageInSync lmSync = (LargeServerMessageInSync) lm;
-            if (logger.isTraceEnabled()) {
-               logger.trace("lmSync on " + lmSync.toString());
-            }
             lmSync.joinSyncedData(buffer);
          }
       }
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("setRemoteBackupUpToDate and liveIDSet for " + liveID);
-      }
-
       journalsHolder = null;
       backupQuorum.liveIDSet(liveID);
       activation.setRemoteBackupUpToDate();
-
-      if (logger.isTraceEnabled()) {
-         logger.trace("Backup is synchronized / BACKUP-SYNC-DONE");
-      }
-
       ActiveMQServerLogger.LOGGER.backupServerSynched(server);
       return;
    }
@@ -411,14 +497,18 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     * @param msg
     * @throws Exception
     */
-   private void handleReplicationSynchronization(ReplicationSyncFileMessage msg) throws Exception {
-      long id = msg.getId();
+   private synchronized void handleReplicationSynchronization(ReplicationSyncFileMessage msg) throws Exception
+   {
+      Long id = Long.valueOf(msg.getId());
       byte[] data = msg.getData();
       SequentialFile channel1;
-      switch (msg.getFileType()) {
-         case LARGE_MESSAGE: {
-            ReplicatedLargeMessage largeMessage = lookupLargeMessage(id, false, false);
-            if (!(largeMessage instanceof LargeServerMessageInSync)) {
+      switch (msg.getFileType())
+      {
+         case LARGE_MESSAGE:
+         {
+            ReplicatedLargeMessage largeMessage = lookupLargeMessage(id, false);
+            if (!(largeMessage instanceof LargeServerMessageInSync))
+            {
                ActiveMQServerLogger.LOGGER.largeMessageIncompatible();
                return;
             }
@@ -426,15 +516,18 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
             channel1 = largeMessageInSync.getSyncFile();
             break;
          }
-         case PAGE: {
+         case PAGE:
+         {
             Page page = getPage(msg.getPageStore(), (int) msg.getId());
             channel1 = page.getFile();
             break;
          }
-         case JOURNAL: {
+         case JOURNAL:
+         {
             JournalSyncFile journalSyncFile = filesReservedForSync.get(msg.getJournalContent()).get(id);
             FileChannel channel2 = journalSyncFile.getChannel();
-            if (data == null) {
+            if (data == null)
+            {
                channel2.close();
                return;
             }
@@ -445,14 +538,17 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
             throw ActiveMQMessageBundle.BUNDLE.replicationUnhandledFileType(msg.getFileType());
       }
 
-      if (data == null) {
+      if (data == null)
+      {
+         channel1.close();
          return;
       }
 
-      if (!channel1.isOpen()) {
-         channel1.open();
+      if (!channel1.isOpen())
+      {
+         channel1.open(1, false);
       }
-      channel1.writeDirect(ByteBuffer.wrap(data), false);
+      channel1.writeDirect(ByteBuffer.wrap(data), true);
    }
 
    /**
@@ -460,76 +556,82 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     * {@link FileWrapperJournal} in place to store messages while synchronization is going on.
     *
     * @param packet
-    * @return if the incoming packet indicates the synchronization is finished then return an acknowledgement otherwise
-    * return an empty response
     * @throws Exception
     */
-   private ReplicationResponseMessageV2 handleStartReplicationSynchronization(final ReplicationStartSyncMessage packet) throws Exception {
-
-      if (logger.isTraceEnabled()) {
-         logger.trace("handleStartReplicationSynchronization:: nodeID = " + packet);
+   private void handleStartReplicationSynchronization(final ReplicationStartSyncMessage packet) throws Exception
+   {
+      if (activation.isRemoteBackupUpToDate())
+      {
+         throw ActiveMQMessageBundle.BUNDLE.replicationBackupUpToDate();
       }
-      ReplicationResponseMessageV2 replicationResponseMessage = new ReplicationResponseMessageV2();
-      if (!started)
-         return replicationResponseMessage;
 
-      if (packet.isSynchronizationFinished()) {
-         finishSynchronization(packet.getNodeID());
-         replicationResponseMessage.setSynchronizationIsFinishedAcknowledgement(true);
-         return replicationResponseMessage;
-      }
 
-      switch (packet.getDataType()) {
-         case LargeMessages:
-            for (long msgID : packet.getFileIds()) {
-               createLargeMessage(msgID, true);
-            }
-            break;
-         case JournalBindings:
-         case JournalMessages:
-            if (wantedFailBack && !packet.isServerToFailBack()) {
-               ActiveMQServerLogger.LOGGER.autoFailBackDenied();
-            }
+      synchronized (this)
+      {
+         if (!started)
+            return;
 
-            final JournalContent journalContent = SyncDataType.getJournalContentType(packet.getDataType());
-            final Journal journal = journalsHolder.get(journalContent);
+         if (packet.isSynchronizationFinished())
+         {
+            finishSynchronization(packet.getNodeID());
+            return;
+         }
 
-            if (packet.getNodeID() != null) {
-               // At the start of replication, we still do not know which is the nodeID that the live uses.
-               // This is the point where the backup gets this information.
-               backupQuorum.liveIDSet(packet.getNodeID());
-            }
-            Map<Long, JournalSyncFile> mapToFill = filesReservedForSync.get(journalContent);
+         switch (packet.getDataType())
+         {
+            case LargeMessages:
+               for (long msgID : packet.getFileIds())
+               {
+                  createLargeMessage(msgID, true);
+               }
+               break;
+            case JournalBindings:
+            case JournalMessages:
+               if (wantedFailBack && !packet.isServerToFailBack())
+               {
+                  ActiveMQServerLogger.LOGGER.autoFailBackDenied();
+               }
 
-            for (Entry<Long, JournalFile> entry : journal.createFilesForBackupSync(packet.getFileIds()).entrySet()) {
-               mapToFill.put(entry.getKey(), new JournalSyncFile(entry.getValue()));
-            }
-            FileWrapperJournal syncJournal = new FileWrapperJournal(journal);
-            registerJournal(journalContent.typeByte, syncJournal);
-            break;
-         default:
-            throw ActiveMQMessageBundle.BUNDLE.replicationUnhandledDataType();
-      }
+               final JournalContent journalContent = SyncDataType.getJournalContentType(packet.getDataType());
+               final Journal journal = journalsHolder.get(journalContent);
 
-      return replicationResponseMessage;
-   }
+               if (packet.getNodeID() != null)
+               {
+                  // At the start of replication, we still do not know which is the nodeID that the live uses.
+                  // This is the point where the backup gets this information.
+                  backupQuorum.liveIDSet(packet.getNodeID());
+               }
+               Map<Long, JournalSyncFile> mapToFill = filesReservedForSync.get(journalContent);
 
-   private void handleLargeMessageEnd(final ReplicationLargeMessageEndMessage packet) {
-      if (logger.isTraceEnabled()) {
-         logger.trace("handleLargeMessageEnd on " + packet.getMessageId());
+               for (Entry<Long, JournalFile> entry : journal.createFilesForBackupSync(packet.getFileIds()).entrySet())
+               {
+                  mapToFill.put(entry.getKey(), new JournalSyncFile(entry.getValue()));
+               }
+               FileWrapperJournal syncJournal = new FileWrapperJournal(journal);
+               registerJournal(journalContent.typeByte, syncJournal);
+               break;
+            default:
+               throw ActiveMQMessageBundle.BUNDLE.replicationUnhandledDataType();
+         }
       }
-      final ReplicatedLargeMessage message = lookupLargeMessage(packet.getMessageId(), true, false);
-      if (message != null) {
-         message.setPendingRecordID(packet.getPendingRecordId());
-         executor.execute(new Runnable() {
+   }
+
+   private void handleLargeMessageEnd(final ReplicationLargeMessageEndMessage packet)
+   {
+      final ReplicatedLargeMessage message = lookupLargeMessage(packet.getMessageId(), true);
+      if (message != null)
+      {
+         executor.execute(new Runnable()
+         {
             @Override
-            public void run() {
-               try {
-                  if (logger.isTraceEnabled()) {
-                     logger.trace("Deleting LargeMessage " + packet.getMessageId() + " on the executor @ handleLargeMessageEnd");
-                  }
+            public void run()
+            {
+               try
+               {
                   message.deleteFile();
-               } catch (Exception e) {
+               }
+               catch (Exception e)
+               {
                   ActiveMQServerLogger.LOGGER.errorDeletingLargeMessage(e, packet.getMessageId());
                }
             }
@@ -540,33 +642,34 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handleLargeMessageWrite(final ReplicationLargeMessageWriteMessage packet) throws Exception {
-      ReplicatedLargeMessage message = lookupLargeMessage(packet.getMessageId(), false, true);
-      if (message != null) {
+   private void handleLargeMessageWrite(final ReplicationLargeMessageWriteMessage packet) throws Exception
+   {
+      ReplicatedLargeMessage message = lookupLargeMessage(packet.getMessageId(), false);
+      if (message != null)
+      {
          message.addBytes(packet.getBody());
       }
    }
 
-   private ReplicatedLargeMessage lookupLargeMessage(final long messageId,
-                                                     final boolean delete,
-                                                     final boolean createIfNotExists) {
+   private ReplicatedLargeMessage lookupLargeMessage(final long messageId, final boolean delete)
+   {
       ReplicatedLargeMessage message;
 
-      if (delete) {
+      if (delete)
+      {
          message = largeMessages.remove(messageId);
-      } else {
+      }
+      else
+      {
          message = largeMessages.get(messageId);
-         if (message == null) {
-            if (createIfNotExists) {
-               createLargeMessage(messageId, false);
-               message = largeMessages.get(messageId);
-            } else {
-               // No warnings if it's a delete, as duplicate deletes may be sent repeatedly.
-               ActiveMQServerLogger.LOGGER.largeMessageNotAvailable(messageId);
-            }
+         if (message == null)
+         {
+            // No warnings if it's a delete, as duplicate deletes may be sent repeatedly.
+            ActiveMQServerLogger.LOGGER.largeMessageNotAvailable(messageId);
          }
       }
 
+
       return message;
 
    }
@@ -574,19 +677,22 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handleLargeMessageBegin(final ReplicationLargeMessageBeginMessage packet) {
+   private void handleLargeMessageBegin(final ReplicationLargeMessageBeginMessage packet)
+   {
       final long id = packet.getMessageId();
       createLargeMessage(id, false);
-      if (logger.isTraceEnabled()) {
-         logger.trace("Receiving Large Message Begin " + id + " on backup");
-      }
+      ActiveMQServerLogger.LOGGER.trace("Receiving Large Message " + id + " on backup");
    }
 
-   private void createLargeMessage(final long id, boolean liveToBackupSync) {
+   private void createLargeMessage(final long id, boolean liveToBackupSync)
+   {
       ReplicatedLargeMessage msg;
-      if (liveToBackupSync) {
+      if (liveToBackupSync)
+      {
          msg = new LargeServerMessageInSync(storageManager);
-      } else {
+      }
+      else
+      {
          msg = storageManager.createLargeMessage();
       }
 
@@ -598,11 +704,15 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handleCommitRollback(final ReplicationCommitMessage packet) throws Exception {
+   private void handleCommitRollback(final ReplicationCommitMessage packet) throws Exception
+   {
       Journal journalToUse = getJournal(packet.getJournalID());
-      if (packet.isRollback()) {
+      if (packet.isRollback())
+      {
          journalToUse.appendRollbackRecord(packet.getTxId(), noSync);
-      } else {
+      }
+      else
+      {
          journalToUse.appendCommitRecord(packet.getTxId(), noSync);
       }
    }
@@ -610,7 +720,8 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handlePrepare(final ReplicationPrepareMessage packet) throws Exception {
+   private void handlePrepare(final ReplicationPrepareMessage packet) throws Exception
+   {
       Journal journalToUse = getJournal(packet.getJournalID());
       journalToUse.appendPrepareRecord(packet.getTxId(), packet.getRecordData(), noSync);
    }
@@ -618,7 +729,8 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handleAppendDeleteTX(final ReplicationDeleteTXMessage packet) throws Exception {
+   private void handleAppendDeleteTX(final ReplicationDeleteTXMessage packet) throws Exception
+   {
       Journal journalToUse = getJournal(packet.getJournalID());
 
       journalToUse.appendDeleteRecordTransactional(packet.getTxId(), packet.getId(), packet.getRecordData());
@@ -627,7 +739,8 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handleAppendDelete(final ReplicationDeleteMessage packet) throws Exception {
+   private void handleAppendDelete(final ReplicationDeleteMessage packet) throws Exception
+   {
       Journal journalToUse = getJournal(packet.getJournalID());
       journalToUse.appendDeleteRecord(packet.getId(), noSync);
    }
@@ -635,13 +748,23 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handleAppendAddTXRecord(final ReplicationAddTXMessage packet) throws Exception {
+   private void handleAppendAddTXRecord(final ReplicationAddTXMessage packet) throws Exception
+   {
       Journal journalToUse = getJournal(packet.getJournalID());
 
-      if (packet.getOperation() == ADD_OPERATION_TYPE.UPDATE) {
-         journalToUse.appendUpdateRecordTransactional(packet.getTxId(), packet.getId(), packet.getRecordType(), packet.getRecordData());
-      } else {
-         journalToUse.appendAddRecordTransactional(packet.getTxId(), packet.getId(), packet.getRecordType(), packet.getRecordData());
+      if (packet.getOperation() == ADD_OPERATION_TYPE.UPDATE)
+      {
+         journalToUse.appendUpdateRecordTransactional(packet.getTxId(),
+                                                      packet.getId(),
+                                                      packet.getRecordType(),
+                                                      packet.getRecordData());
+      }
+      else
+      {
+         journalToUse.appendAddRecordTransactional(packet.getTxId(),
+                                                   packet.getId(),
+                                                   packet.getRecordType(),
+                                                   packet.getRecordData());
       }
    }
 
@@ -649,16 +772,22 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     * @param packet
     * @throws Exception
     */
-   private void handleAppendAddRecord(final ReplicationAddMessage packet) throws Exception {
+   private void handleAppendAddRecord(final ReplicationAddMessage packet) throws Exception
+   {
       Journal journalToUse = getJournal(packet.getJournalID());
-      if (packet.getRecord() == ADD_OPERATION_TYPE.UPDATE) {
-         if (logger.isTraceEnabled()) {
-            logger.trace("Endpoint appendUpdate id = " + packet.getId());
+      if (packet.getRecord() == ADD_OPERATION_TYPE.UPDATE)
+      {
+         if (ReplicationEndpoint.trace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("Endpoint appendUpdate id = " + packet.getId());
          }
          journalToUse.appendUpdateRecord(packet.getId(), packet.getJournalRecordType(), packet.getRecordData(), noSync);
-      } else {
-         if (logger.isTraceEnabled()) {
-            logger.trace("Endpoint append id = " + packet.getId());
+      }
+      else
+      {
+         if (ReplicationEndpoint.trace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("Endpoint append id = " + packet.getId());
          }
          journalToUse.appendAddRecord(packet.getId(), packet.getJournalRecordType(), packet.getRecordData(), noSync);
       }
@@ -667,22 +796,29 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handlePageEvent(final ReplicationPageEventMessage packet) throws Exception {
+   private void handlePageEvent(final ReplicationPageEventMessage packet) throws Exception
+   {
       ConcurrentMap<Integer, Page> pages = getPageMap(packet.getStoreName());
 
       Page page = pages.remove(packet.getPageNumber());
 
-      if (page == null) {
+      if (page == null)
+      {
          page = getPage(packet.getStoreName(), packet.getPageNumber());
       }
 
-      if (page != null) {
-         if (packet.isDelete()) {
-            if (deletePages) {
+      if (page != null)
+      {
+         if (packet.isDelete())
+         {
+            if (deletePages)
+            {
                page.delete(null);
             }
-         } else {
-            page.close(false);
+         }
+         else
+         {
+            page.close();
          }
       }
 
@@ -691,21 +827,25 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
    /**
     * @param packet
     */
-   private void handlePageWrite(final ReplicationPageWriteMessage packet) throws Exception {
+   private void handlePageWrite(final ReplicationPageWriteMessage packet) throws Exception
+   {
       PagedMessage pgdMessage = packet.getPagedMessage();
       pgdMessage.initMessage(storageManager);
-      Message msg = pgdMessage.getMessage();
-      Page page = getPage(msg.getAddressSimpleString(), packet.getPageNumber());
+      ServerMessage msg = pgdMessage.getMessage();
+      Page page = getPage(msg.getAddress(), packet.getPageNumber());
       page.write(pgdMessage);
    }
 
-   private ConcurrentMap<Integer, Page> getPageMap(final SimpleString storeName) {
+   private ConcurrentMap<Integer, Page> getPageMap(final SimpleString storeName)
+   {
       ConcurrentMap<Integer, Page> resultIndex = pageIndex.get(storeName);
 
-      if (resultIndex == null) {
-         resultIndex = new ConcurrentHashMap<>();
+      if (resultIndex == null)
+      {
+         resultIndex = new ConcurrentHashMap<Integer, Page>();
          ConcurrentMap<Integer, Page> mapResult = pageIndex.putIfAbsent(storeName, resultIndex);
-         if (mapResult != null) {
+         if (mapResult != null)
+         {
             resultIndex = mapResult;
          }
       }
@@ -713,12 +853,14 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
       return resultIndex;
    }
 
-   private Page getPage(final SimpleString storeName, final int pageId) throws Exception {
+   private Page getPage(final SimpleString storeName, final int pageId) throws Exception
+   {
       ConcurrentMap<Integer, Page> map = getPageMap(storeName);
 
       Page page = map.get(pageId);
 
-      if (page == null) {
+      if (page == null)
+      {
          page = newPage(pageId, storeName, map);
       }
 
@@ -732,10 +874,12 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     */
    private synchronized Page newPage(final int pageId,
                                      final SimpleString storeName,
-                                     final ConcurrentMap<Integer, Page> map) throws Exception {
+                                     final ConcurrentMap<Integer, Page> map) throws Exception
+   {
       Page page = map.get(pageId);
 
-      if (page == null) {
+      if (page == null)
+      {
          page = pageManager.getPageStore(storeName).createPage(pageId);
          page.open();
          map.put(pageId, page);
@@ -748,31 +892,36 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     * @param journalID
     * @return
     */
-   private Journal getJournal(final byte journalID) {
+   private Journal getJournal(final byte journalID)
+   {
       return journals[journalID];
    }
 
-   public static final class JournalSyncFile {
-
+   public static final class JournalSyncFile
+   {
       private FileChannel channel;
       private final File file;
       private FileOutputStream fos;
 
-      public JournalSyncFile(JournalFile jFile) throws Exception {
+      public JournalSyncFile(JournalFile jFile) throws Exception
+      {
          SequentialFile seqFile = jFile.getFile();
          file = seqFile.getJavaFile();
          seqFile.close();
       }
 
-      synchronized FileChannel getChannel() throws Exception {
-         if (channel == null) {
+      synchronized FileChannel getChannel() throws Exception
+      {
+         if (channel == null)
+         {
             fos = new FileOutputStream(file);
             channel = fos.getChannel();
          }
          return channel;
       }
 
-      synchronized void close() throws IOException {
+      synchronized void close() throws IOException
+      {
          if (fos != null)
             fos.close();
          if (channel != null)
@@ -780,7 +929,8 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
       }
 
       @Override
-      public String toString() {
+      public String toString()
+      {
          return "JournalSyncFile(file=" + file.getAbsolutePath() + ")";
       }
    }
@@ -791,14 +941,16 @@ public final class ReplicationEndpoint implements ChannelHandler, ActiveMQCompon
     *
     * @param backupQuorum
     */
-   public void setBackupQuorum(SharedNothingBackupQuorum backupQuorum) {
+   public synchronized void setBackupQuorum(SharedNothingBackupQuorum backupQuorum)
+   {
       this.backupQuorum = backupQuorum;
    }
 
    /**
     * @param executor2
     */
-   public void setExecutor(Executor executor2) {
+   public void setExecutor(Executor executor2)
+   {
       this.executor = executor2;
    }
 }