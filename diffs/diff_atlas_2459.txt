diff --git a/typesystem/src/main/java/org/apache/atlas/typesystem/types/TypeSystem.java b/typesystem/src/main/java/org/apache/atlas/typesystem/types/TypeSystem.java
index 14f1968c2..9e4aa79e5 100755
--- a/typesystem/src/main/java/org/apache/atlas/typesystem/types/TypeSystem.java
+++ b/typesystem/src/main/java/org/apache/atlas/typesystem/types/TypeSystem.java
@@ -18,9 +18,23 @@
 
 package org.apache.atlas.typesystem.types;
 
+import com.google.common.collect.ArrayListMultimap;
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
+import com.google.common.collect.Multimap;
+
+import org.apache.atlas.AtlasException;
+import org.apache.atlas.classification.InterfaceAudience;
+import org.apache.atlas.typesystem.TypesDef;
+import org.apache.atlas.typesystem.exception.TypeExistsException;
+import org.apache.atlas.typesystem.exception.TypeNotFoundException;
+
+import javax.inject.Singleton;
+
 import java.lang.reflect.Constructor;
 import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
@@ -28,28 +42,9 @@ import java.util.Set;
 import java.util.TimeZone;
 import java.util.concurrent.ConcurrentHashMap;
 
-import javax.inject.Singleton;
-
-import org.apache.atlas.ApplicationProperties;
-import org.apache.atlas.AtlasException;
-import org.apache.atlas.classification.InterfaceAudience;
-import org.apache.atlas.typesystem.TypesDef;
-import org.apache.atlas.typesystem.exception.TypeExistsException;
-import org.apache.atlas.typesystem.exception.TypeNotFoundException;
-import org.apache.atlas.typesystem.types.cache.DefaultTypeCacheProvider;
-import org.apache.atlas.typesystem.types.cache.ITypeCacheProvider;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.google.common.collect.ImmutableList;
-import com.google.common.collect.ImmutableSet;
-
 @Singleton
 @InterfaceAudience.Private
 public class TypeSystem {
-    private static final Logger LOG = LoggerFactory.getLogger(TypeSystem.class);
-    private static final String CACHE_PROVIDER_CLASS_PROPERTY = "atlas.typesystem.cache.provider";
-
     private static final TypeSystem INSTANCE = new TypeSystem();
     private static ThreadLocal<SimpleDateFormat> dateFormat = new ThreadLocal<SimpleDateFormat>() {
         @Override
@@ -60,9 +55,15 @@ public class TypeSystem {
         }
     };
 
-    private ITypeCacheProvider typeCache;
+    private Map<String, IDataType> types;
     private IdType idType;
-    private Map<String, IDataType> coreTypes;
+
+    /**
+     * An in-memory copy of type categories vs types for convenience.
+     */
+    private Multimap<DataTypes.TypeCategory, String> typeCategoriesToTypeNamesMap;
+
+    private ImmutableList<String> coreTypes;
 
     public TypeSystem() {
         initialize();
@@ -76,111 +77,69 @@ public class TypeSystem {
      * This is only used for testing purposes. Not intended for public use.
      */
     @InterfaceAudience.Private
-    public TypeSystem reset() {
-
-        typeCache.clear(); // clear all entries in cache
+    public void reset() {
         initialize();
-
-        return this;
     }
 
     private void initialize() {
-
-        initCacheProvider();
-        coreTypes = new ConcurrentHashMap<>();
+        types = new ConcurrentHashMap<>();
+        typeCategoriesToTypeNamesMap = ArrayListMultimap.create(DataTypes.TypeCategory.values().length, 10);
 
         registerPrimitiveTypes();
         registerCoreTypes();
-    }
-
-    /**
-     * Ideally a cache provider should have been injected in the TypeSystemProvider,
-     * but a singleton of TypeSystem is constructed privately within the class so that
-     * clients of TypeSystem would never instantiate a TypeSystem object directly in
-     * their code. As soon as a client makes a call to TypeSystem.getInstance(), they
-     * should have the singleton ready for consumption. To enable such an access pattern,
-     * it kind of becomes imperative to initialize the cache provider within the
-     * TypeSystem constructor (bypassing the GUICE way of injecting a cache provider)
-     */
-    private void initCacheProvider() {
-
-        // read the pluggable cache provider from Atlas configuration
-        final String defaultCacheProvider = DefaultTypeCacheProvider.class.getName();
-        Class cacheProviderClass;
-        try {
-            cacheProviderClass = ApplicationProperties.getClass(CACHE_PROVIDER_CLASS_PROPERTY,
-                defaultCacheProvider, ITypeCacheProvider.class);
-        } catch (AtlasException e) {
-            throw new RuntimeException("Error getting type cache provider implementation class", e);
-        }
-
-        try {
-            typeCache = (ITypeCacheProvider)cacheProviderClass.newInstance();
-        }
-        catch (Exception e) {
-            throw new RuntimeException("Error creating instance of type cache provider implementation class " + cacheProviderClass.getName(), e);
-        }
+        coreTypes = ImmutableList.copyOf(types.keySet());
     }
 
     public ImmutableList<String> getCoreTypes() {
-        return ImmutableList.copyOf(coreTypes.keySet());
+        return coreTypes;
     }
 
-    public ImmutableList<String> getTypeNames() throws AtlasException {
-        List<String> typeNames = new ArrayList<>(typeCache.getAllTypeNames());
+    public ImmutableList<String> getTypeNames() {
+        List<String> typeNames = new ArrayList<>(types.keySet());
+        typeNames.removeAll(getCoreTypes());
         return ImmutableList.copyOf(typeNames);
     }
 
-    public ImmutableList<String> getTypeNamesByCategory(DataTypes.TypeCategory typeCategory) throws AtlasException {
-        return ImmutableList.copyOf(typeCache.getTypeNames(typeCategory));
+    public ImmutableList<String> getTypeNamesByCategory(DataTypes.TypeCategory typeCategory) {
+        return ImmutableList.copyOf(typeCategoriesToTypeNamesMap.get(typeCategory));
     }
 
     private void registerPrimitiveTypes() {
+        types.put(DataTypes.BOOLEAN_TYPE.getName(), DataTypes.BOOLEAN_TYPE);
+        types.put(DataTypes.BYTE_TYPE.getName(), DataTypes.BYTE_TYPE);
+        types.put(DataTypes.SHORT_TYPE.getName(), DataTypes.SHORT_TYPE);
+        types.put(DataTypes.INT_TYPE.getName(), DataTypes.INT_TYPE);
+        types.put(DataTypes.LONG_TYPE.getName(), DataTypes.LONG_TYPE);
+        types.put(DataTypes.FLOAT_TYPE.getName(), DataTypes.FLOAT_TYPE);
+        types.put(DataTypes.DOUBLE_TYPE.getName(), DataTypes.DOUBLE_TYPE);
+        types.put(DataTypes.BIGINTEGER_TYPE.getName(), DataTypes.BIGINTEGER_TYPE);
+        types.put(DataTypes.BIGDECIMAL_TYPE.getName(), DataTypes.BIGDECIMAL_TYPE);
+        types.put(DataTypes.DATE_TYPE.getName(), DataTypes.DATE_TYPE);
+        types.put(DataTypes.STRING_TYPE.getName(), DataTypes.STRING_TYPE);
 
-        coreTypes.put(DataTypes.BOOLEAN_TYPE.getName(), DataTypes.BOOLEAN_TYPE);
-        coreTypes.put(DataTypes.BYTE_TYPE.getName(), DataTypes.BYTE_TYPE);
-        coreTypes.put(DataTypes.SHORT_TYPE.getName(), DataTypes.SHORT_TYPE);
-        coreTypes.put(DataTypes.INT_TYPE.getName(), DataTypes.INT_TYPE);
-        coreTypes.put(DataTypes.LONG_TYPE.getName(), DataTypes.LONG_TYPE);
-        coreTypes.put(DataTypes.FLOAT_TYPE.getName(), DataTypes.FLOAT_TYPE);
-        coreTypes.put(DataTypes.DOUBLE_TYPE.getName(), DataTypes.DOUBLE_TYPE);
-        coreTypes.put(DataTypes.BIGINTEGER_TYPE.getName(), DataTypes.BIGINTEGER_TYPE);
-        coreTypes.put(DataTypes.BIGDECIMAL_TYPE.getName(), DataTypes.BIGDECIMAL_TYPE);
-        coreTypes.put(DataTypes.DATE_TYPE.getName(), DataTypes.DATE_TYPE);
-        coreTypes.put(DataTypes.STRING_TYPE.getName(), DataTypes.STRING_TYPE);
+        typeCategoriesToTypeNamesMap.putAll(DataTypes.TypeCategory.PRIMITIVE, types.keySet());
     }
 
+
     /*
      * The only core OOB type we will define is the Struct to represent the Identity of an Instance.
      */
     private void registerCoreTypes() {
-
         idType = new IdType();
-        coreTypes.put(idType.getStructType().getName(), idType.getStructType());
     }
 
     public IdType getIdType() {
         return idType;
     }
 
-    public boolean isRegistered(String typeName) throws AtlasException {
-        return isCoreType(typeName) || typeCache.has(typeName);
-    }
-
-    protected boolean isCoreType(String typeName) {
-
-        return coreTypes.containsKey(typeName);
+    public boolean isRegistered(String typeName) {
+        return types.containsKey(typeName);
     }
 
     public <T> T getDataType(Class<T> cls, String name) throws AtlasException {
-
-        if (isCoreType(name)) {
-            return cls.cast(coreTypes.get(name));
-        }
-
-        if (typeCache.has(name)) {
+        if (types.containsKey(name)) {
             try {
-                return cls.cast(typeCache.get(name));
+                return cls.cast(types.get(name));
             } catch (ClassCastException cce) {
                 throw new AtlasException(cce);
             }
@@ -325,12 +284,13 @@ public class TypeSystem {
 
     public EnumType defineEnumType(EnumTypeDefinition eDef) throws AtlasException {
         assert eDef.name != null;
-        if (isRegistered(eDef.name)) {
+        if (types.containsKey(eDef.name)) {
             throw new AtlasException(String.format("Redefinition of type %s not supported", eDef.name));
         }
 
         EnumType eT = new EnumType(this, eDef.name, eDef.description, eDef.enumValues);
-        typeCache.put(eT);
+        types.put(eDef.name, eT);
+        typeCategoriesToTypeNamesMap.put(DataTypes.TypeCategory.ENUM, eDef.name);
         return eT;
     }
 
@@ -368,14 +328,14 @@ public class TypeSystem {
      *
      * This step should be called only after the types have been committed to the backend stores successfully.
      * @param typesAdded newly added types.
-     * @throws AtlasException
      */
-    public void commitTypes(Map<String, IDataType> typesAdded) throws AtlasException {
+    public void commitTypes(Map<String, IDataType> typesAdded) {
         for (Map.Entry<String, IDataType> typeEntry : typesAdded.entrySet()) {
             String typeName = typeEntry.getKey();
             IDataType type = typeEntry.getValue();
             //Add/replace the new type in the typesystem
-            typeCache.put(type);
+            types.put(typeName, type);
+            typeCategoriesToTypeNamesMap.put(type.getTypeCategory(), typeName);
         }
     }
 
@@ -408,12 +368,10 @@ public class TypeSystem {
         }
 
         private IDataType dataType(String name) throws AtlasException {
-
             if (transientTypes.containsKey(name)) {
                 return transientTypes.get(name);
             }
-
-            return TypeSystem.this.getDataType(IDataType.class, name);
+            return TypeSystem.this.types.get(name);
         }
 
         /*
@@ -424,7 +382,7 @@ public class TypeSystem {
         private void validateAndSetupShallowTypes(boolean update) throws AtlasException {
             for (EnumTypeDefinition eDef : enumDefs) {
                 assert eDef.name != null;
-                if (!update && (transientTypes.containsKey(eDef.name) || isRegistered(eDef.name))) {
+                if (!update && (transientTypes.containsKey(eDef.name) || types.containsKey(eDef.name))) {
                     throw new AtlasException(String.format("Redefinition of type %s not supported", eDef.name));
                 }
 
@@ -434,7 +392,7 @@ public class TypeSystem {
 
             for (StructTypeDefinition sDef : structDefs) {
                 assert sDef.typeName != null;
-                if (!update && (transientTypes.containsKey(sDef.typeName) || isRegistered(sDef.typeName))) {
+                if (!update && (transientTypes.containsKey(sDef.typeName) || types.containsKey(sDef.typeName))) {
                     throw new TypeExistsException(String.format("Cannot redefine type %s", sDef.typeName));
                 }
                 StructType sT = new StructType(this, sDef.typeName, sDef.typeDescription, sDef.attributeDefinitions.length);
@@ -445,7 +403,7 @@ public class TypeSystem {
             for (HierarchicalTypeDefinition<TraitType> traitDef : traitDefs) {
                 assert traitDef.typeName != null;
                 if (!update &&
-                        (transientTypes.containsKey(traitDef.typeName) || isRegistered(traitDef.typeName))) {
+                        (transientTypes.containsKey(traitDef.typeName) || types.containsKey(traitDef.typeName))) {
                     throw new TypeExistsException(String.format("Cannot redefine type %s", traitDef.typeName));
                 }
                 TraitType tT = new TraitType(this, traitDef.typeName, traitDef.typeDescription, traitDef.superTypes,
@@ -457,7 +415,7 @@ public class TypeSystem {
             for (HierarchicalTypeDefinition<ClassType> classDef : classDefs) {
                 assert classDef.typeName != null;
                 if (!update &&
-                        (transientTypes.containsKey(classDef.typeName) || isRegistered(classDef.typeName))) {
+                        (transientTypes.containsKey(classDef.typeName) || types.containsKey(classDef.typeName))) {
                     throw new TypeExistsException(String.format("Cannot redefine type %s", classDef.typeName));
                 }
 
@@ -578,13 +536,13 @@ public class TypeSystem {
             for (String traitTypeName : traitNameToDefMap.keySet()) {
                 traitTypes.add(getDataType(TraitType.class, traitTypeName));
             }
-            traitTypes = HierarchicalTypeDependencySorter.sortTypes(traitTypes);
+            Collections.sort(traitTypes);
 
             List<ClassType> classTypes = new ArrayList<>();
             for (String classTypeName : classNameToDefMap.keySet()) {
                 classTypes.add(getDataType(ClassType.class, classTypeName));
             }
-            classTypes = HierarchicalTypeDependencySorter.sortTypes(classTypes);
+            Collections.sort(classTypes);
 
             for (StructTypeDefinition structDef : structDefs) {
                 constructStructureType(structDef);
@@ -620,11 +578,11 @@ public class TypeSystem {
          * Step 5:
          * - Validate that the update can be done
          */
-        private void validateUpdateIsPossible() throws TypeUpdateException, AtlasException {
+        private void validateUpdateIsPossible() throws TypeUpdateException {
             //If the type is modified, validate that update can be done
             for (IDataType newType : transientTypes.values()) {
-                if (TypeSystem.this.isRegistered(newType.getName())) {
-                    IDataType oldType = TypeSystem.this.typeCache.get(newType.getName());
+                if (TypeSystem.this.types.containsKey(newType.getName())) {
+                    IDataType oldType = TypeSystem.this.types.get(newType.getName());
                     oldType.validateUpdate(newType);
                 }
             }
@@ -638,7 +596,7 @@ public class TypeSystem {
         }
 
         @Override
-        public ImmutableList<String> getTypeNames() throws AtlasException {
+        public ImmutableList<String> getTypeNames() {
             Set<String> typeNames = transientTypes.keySet();
             typeNames.addAll(TypeSystem.this.getTypeNames());
             return ImmutableList.copyOf(typeNames);
@@ -682,17 +640,17 @@ public class TypeSystem {
         @Override
         public StructType defineStructType(String name, boolean errorIfExists, AttributeDefinition... attrDefs)
         throws AtlasException {
-            throw new AtlasException("Internal Error: define type called on TransientTypeSystem");
+            throw new AtlasException("Internal Error: define type called on TrasientTypeSystem");
         }
 
         @Override
         public TraitType defineTraitType(HierarchicalTypeDefinition traitDef) throws AtlasException {
-            throw new AtlasException("Internal Error: define type called on TransientTypeSystem");
+            throw new AtlasException("Internal Error: define type called on TrasientTypeSystem");
         }
 
         @Override
         public ClassType defineClassType(HierarchicalTypeDefinition<ClassType> classDef) throws AtlasException {
-            throw new AtlasException("Internal Error: define type called on TransientTypeSystem");
+            throw new AtlasException("Internal Error: define type called on TrasientTypeSystem");
         }
 
         @Override
@@ -700,7 +658,7 @@ public class TypeSystem {
                 ImmutableList<StructTypeDefinition> structDefs,
                 ImmutableList<HierarchicalTypeDefinition<TraitType>> traitDefs,
                 ImmutableList<HierarchicalTypeDefinition<ClassType>> classDefs) throws AtlasException {
-            throw new AtlasException("Internal Error: define type called on TransientTypeSystem");
+            throw new AtlasException("Internal Error: define type called on TrasientTypeSystem");
         }
 
         @Override
@@ -724,22 +682,13 @@ public class TypeSystem {
         }
 
         @Override
-        public void commitTypes(Map<String, IDataType> typesAdded) throws AtlasException {
+        public void commitTypes(Map<String, IDataType> typesAdded) {
             TypeSystem.this.commitTypes(typesAdded);
         }
 
         public Map<String, IDataType> getTypesAdded() {
             return new HashMap<>(transientTypes);
         }
-
-        /**
-         * The core types do not change and they are registered
-         * once in the main type system.
-         */
-        @Override
-        public ImmutableList<String> getCoreTypes() {
-            return TypeSystem.this.getCoreTypes();
-        }
     }
 
     public class IdType {
@@ -747,8 +696,6 @@ public class TypeSystem {
         private static final String TYPENAME_ATTRNAME = "typeName";
         private static final String TYP_NAME = "__IdType";
 
-        private StructType type;
-
         private IdType() {
             AttributeDefinition idAttr =
                     new AttributeDefinition(ID_ATTRNAME, DataTypes.STRING_TYPE.getName(), Multiplicity.REQUIRED, false,
@@ -761,14 +708,16 @@ public class TypeSystem {
                 infos[0] = new AttributeInfo(TypeSystem.this, idAttr, null);
                 infos[1] = new AttributeInfo(TypeSystem.this, typNmAttr, null);
 
-                type = new StructType(TypeSystem.this, TYP_NAME, null, infos);
+                StructType type = new StructType(TypeSystem.this, TYP_NAME, null, infos);
+                TypeSystem.this.types.put(TYP_NAME, type);
+
             } catch (AtlasException me) {
                 throw new RuntimeException(me);
             }
         }
 
-        public StructType getStructType() {
-            return type;
+        public StructType getStructType() throws AtlasException {
+            return getDataType(StructType.class, TYP_NAME);
         }
 
         public String getName() {
@@ -785,5 +734,4 @@ public class TypeSystem {
     }
 
     public static final String ID_STRUCT_ID_ATTRNAME = IdType.ID_ATTRNAME;
-    public static final String ID_STRUCT_TYP_NAME = IdType.TYP_NAME;
 }