diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
index 4a09b08a4..f2e40f914 100755
--- a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
@@ -18,1054 +18,447 @@
 
 package org.apache.atlas.repository.graph;
 
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.base.Preconditions;
+import com.thinkaurelius.titan.core.Cardinality;
+import com.thinkaurelius.titan.core.PropertyKey;
+import com.thinkaurelius.titan.core.TitanGraph;
+import com.thinkaurelius.titan.core.schema.Mapping;
+import com.thinkaurelius.titan.core.schema.TitanGraphIndex;
+import com.thinkaurelius.titan.core.schema.TitanManagement;
+import com.tinkerpop.blueprints.Edge;
+import com.tinkerpop.blueprints.Vertex;
 import org.apache.atlas.ApplicationProperties;
-import org.apache.atlas.AtlasErrorCode;
 import org.apache.atlas.AtlasException;
 import org.apache.atlas.discovery.SearchIndexer;
-import org.apache.atlas.exception.AtlasBaseException;
 import org.apache.atlas.ha.HAConfiguration;
 import org.apache.atlas.listener.ActiveStateChangeHandler;
-import org.apache.atlas.listener.ChangedTypeDefs;
-import org.apache.atlas.listener.TypeDefChangeListener;
-import org.apache.atlas.model.TypeCategory;
-import org.apache.atlas.model.instance.AtlasEntity;
-import org.apache.atlas.model.typedef.AtlasBaseTypeDef;
-import org.apache.atlas.model.typedef.AtlasEntityDef;
-import org.apache.atlas.model.typedef.AtlasEnumDef;
-import org.apache.atlas.model.typedef.AtlasRelationshipDef;
-import org.apache.atlas.model.typedef.AtlasStructDef;
-import org.apache.atlas.model.typedef.AtlasStructDef.AtlasAttributeDef;
 import org.apache.atlas.repository.Constants;
+import org.apache.atlas.repository.IndexCreationException;
 import org.apache.atlas.repository.IndexException;
 import org.apache.atlas.repository.RepositoryException;
-import org.apache.atlas.repository.graphdb.*;
-import org.apache.atlas.repository.store.graph.v2.AtlasGraphUtilsV2;
-import org.apache.atlas.type.*;
-import org.apache.atlas.type.AtlasStructType.AtlasAttribute;
-import org.apache.atlas.type.AtlasType;
-import org.apache.atlas.type.AtlasTypeRegistry;
-import org.apache.atlas.type.AtlasTypeUtil;
-import org.apache.commons.collections.CollectionUtils;
+import org.apache.atlas.typesystem.types.AttributeInfo;
+import org.apache.atlas.typesystem.types.ClassType;
+import org.apache.atlas.typesystem.types.DataTypes;
+import org.apache.atlas.typesystem.types.IDataType;
+import org.apache.atlas.typesystem.types.Multiplicity;
+import org.apache.atlas.typesystem.types.StructType;
+import org.apache.atlas.typesystem.types.TraitType;
 import org.apache.commons.configuration.Configuration;
-import org.apache.solr.common.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.springframework.stereotype.Component;
-import org.springframework.core.annotation.Order;
 
 import javax.inject.Inject;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.*;
-
-import static org.apache.atlas.model.typedef.AtlasBaseTypeDef.*;
-import static org.apache.atlas.repository.Constants.*;
-import static org.apache.atlas.repository.graphdb.AtlasCardinality.LIST;
-import static org.apache.atlas.repository.graphdb.AtlasCardinality.SET;
-import static org.apache.atlas.repository.graphdb.AtlasCardinality.SINGLE;
-import static org.apache.atlas.repository.store.graph.v2.AtlasGraphUtilsV2.isReference;
-import static org.apache.atlas.type.AtlasStructType.UNIQUE_ATTRIBUTE_SHADE_PROPERTY_PREFIX;
-import static org.apache.atlas.type.AtlasTypeUtil.isArrayType;
-import static org.apache.atlas.type.AtlasTypeUtil.isMapType;
-
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 
 /**
  * Adds index for properties of a given type when its added before any instances are added.
  */
-@Component
-@Order(1)
-public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler, TypeDefChangeListener {
+public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler {
 
     private static final Logger LOG = LoggerFactory.getLogger(GraphBackedSearchIndexer.class);
 
-    private static final String VERTEX_ID_IN_IMPORT_KEY = "__vIdInImport";
-    private static final String EDGE_ID_IN_IMPORT_KEY   = "__eIdInImport";
-    private static final List<Class> INDEX_EXCLUSION_CLASSES = new ArrayList() {
-        {
+    private final TitanGraph titanGraph;
+
+    List<Class> MIXED_INDEX_EXCLUSIONS = new ArrayList() {{
             add(Boolean.class);
             add(BigDecimal.class);
             add(BigInteger.class);
-        }
-    };
-
-    // Added for type lookup when indexing the new typedefs
-    private final AtlasTypeRegistry typeRegistry;
-    private final List<IndexChangeListener> indexChangeListeners = new ArrayList<>();
-
-    //allows injection of a dummy graph for testing
-    private IAtlasGraphProvider provider;
-
-    private boolean     recomputeIndexedKeys = true;
-    private Set<String> vertexIndexKeys      = new HashSet<>();
-
-    public static boolean isValidSearchWeight(int searchWeight) {
-        if (searchWeight != -1 ) {
-            if (searchWeight < 1 || searchWeight > 10) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static boolean isStringAttribute(AtlasAttribute attribute) {
-        return AtlasBaseTypeDef.ATLAS_TYPE_STRING.equals(attribute.getTypeName());
-    }
-
-    public enum UniqueKind { NONE, GLOBAL_UNIQUE, PER_TYPE_UNIQUE }
+        }};
 
     @Inject
-    public GraphBackedSearchIndexer(AtlasTypeRegistry typeRegistry) throws AtlasException {
-        this(new AtlasGraphProvider(), ApplicationProperties.get(), typeRegistry);
+    public GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider) throws AtlasException {
+        this(graphProvider, ApplicationProperties.get());
     }
 
-    @VisibleForTesting
-    GraphBackedSearchIndexer(IAtlasGraphProvider provider, Configuration configuration, AtlasTypeRegistry typeRegistry)
+    GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider, Configuration configuration)
             throws IndexException, RepositoryException {
-        this.provider     = provider;
-        this.typeRegistry = typeRegistry;
-
-        //make sure solr index follows graph backed index listener
-        addIndexListener(new SolrIndexHelper(typeRegistry));
-
+        this.titanGraph = graphProvider.get();
         if (!HAConfiguration.isHAEnabled(configuration)) {
-            initialize(provider.get());
+            initialize();
         }
-        notifyInitializationStart();
-    }
-
-    public void addIndexListener(IndexChangeListener listener) {
-        indexChangeListeners.add(listener);
     }
 
-
     /**
-     * Initialize global indices for JanusGraph on server activation.
-     *
-     * Since the indices are shared state, we need to do this only from an active instance.
+     * Initializes the indices for the graph - create indices for Global Vertex Keys
      */
-    @Override
-    public void instanceIsActive() throws AtlasException {
-        LOG.info("Reacting to active: initializing index");
-        try {
-            initialize();
-        } catch (RepositoryException | IndexException e) {
-            throw new AtlasException("Error in reacting to active on initialization", e);
-        }
-    }
-
-    @Override
-    public void instanceIsPassive() {
-        LOG.info("Reacting to passive state: No action right now.");
-    }
-
-    @Override
-    public int getHandlerOrder() {
-        return HandlerOrder.GRAPH_BACKED_SEARCH_INDEXER.getOrder();
-    }
-
-    @Override
-    public void onChange(ChangedTypeDefs changedTypeDefs) throws AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Processing changed typedefs {}", changedTypeDefs);
-        }
-
-        AtlasGraphManagement management = null;
-
-        try {
-            management = provider.get().getManagementSystem();
-
-            // Update index for newly created types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getCreatedTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getCreatedTypeDefs()) {
-                    updateIndexForTypeDef(management, typeDef);
-                }
-            }
-
-            // Update index for updated types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getUpdatedTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getUpdatedTypeDefs()) {
-                    updateIndexForTypeDef(management, typeDef);
-                }
-            }
-
-            // Invalidate the property key for deleted types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getDeletedTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getDeletedTypeDefs()) {
-                    deleteIndexForType(management, typeDef);
-                }
-            }
-
-            //resolve index fields names for the new entity attributes.
-            resolveIndexFieldNames(management, changedTypeDefs);
-
-            createEdgeLabels(management, changedTypeDefs.getCreatedTypeDefs());
-            createEdgeLabels(management, changedTypeDefs.getUpdatedTypeDefs());
-
-            //Commit indexes
-            commit(management);
-        } catch (RepositoryException | IndexException e) {
-            LOG.error("Failed to update indexes for changed typedefs", e);
-            attemptRollback(changedTypeDefs, management);
-        }
-
-        notifyChangeListeners(changedTypeDefs);
-    }
-
-    @Override
-    public void onLoadCompletion() throws AtlasBaseException {
-        if(LOG.isDebugEnabled()) {
-            LOG.debug("Type definition load completed. Informing the completion to IndexChangeListeners.");
-        }
-
-        Collection<AtlasBaseTypeDef> typeDefs = new ArrayList<>();
-
-        typeDefs.addAll(typeRegistry.getAllEntityDefs());
-        typeDefs.addAll(typeRegistry.getAllBusinessMetadataDefs());
-
-        ChangedTypeDefs      changedTypeDefs = new ChangedTypeDefs(null, new ArrayList<>(typeDefs), null);
-        AtlasGraphManagement management      = null;
-
+    private void initialize() throws RepositoryException, IndexException {
+        TitanManagement management = titanGraph.getManagementSystem();
         try {
-            management = provider.get().getManagementSystem();
-
-            //resolve index fields names
-            resolveIndexFieldNames(management, changedTypeDefs);
-
-            //Commit indexes
-            commit(management);
-
-            notifyInitializationCompletion(changedTypeDefs);
-        } catch (RepositoryException | IndexException e) {
-            LOG.error("Failed to update indexes for changed typedefs", e);
-            attemptRollback(changedTypeDefs, management);
-        }
-    }
-
-    public Set<String> getVertexIndexKeys() {
-        if (recomputeIndexedKeys) {
-            AtlasGraphManagement management = null;
-
-            try {
-                management = provider.get().getManagementSystem();
-
-                if (management != null) {
-                    AtlasGraphIndex vertexIndex = management.getGraphIndex(VERTEX_INDEX);
-
-                    if (vertexIndex != null) {
-                        recomputeIndexedKeys = false;
-
-                        Set<String> indexKeys = new HashSet<>();
-
-                        for (AtlasPropertyKey fieldKey : vertexIndex.getFieldKeys()) {
-                            indexKeys.add(fieldKey.getName());
-                        }
-
-                        vertexIndexKeys = indexKeys;
-                    }
-
-                    management.commit();
-                }
-            } catch (Exception excp) {
-                LOG.error("getVertexIndexKeys(): failed to get indexedKeys from graph", excp);
-
-                if (management != null) {
-                    try {
-                        management.rollback();
-                    } catch (Exception e) {
-                        LOG.error("getVertexIndexKeys(): rollback failed", e);
-                    }
-                }
+            if (management.containsPropertyKey(Constants.VERTEX_TYPE_PROPERTY_KEY)) {
+                LOG.info("Global indexes already exist for graph");
+                management.commit();
+                return;
             }
-        }
 
-        return vertexIndexKeys;
-    }
+        /* This is called only once, which is the first time Atlas types are made indexable .*/
+            LOG.info("Indexes do not exist, Creating indexes for titanGraph.");
+            management.buildIndex(Constants.VERTEX_INDEX, Vertex.class).buildMixedIndex(Constants.BACKING_INDEX);
+            management.buildIndex(Constants.EDGE_INDEX, Edge.class).buildMixedIndex(Constants.BACKING_INDEX);
 
-    /**
-     * Initializes the indices for the graph - create indices for Global AtlasVertex Keys
-     */
-    private void initialize() throws RepositoryException, IndexException {
-        initialize(provider.get());
-    }
-    
-    /**
-     * Initializes the indices for the graph - create indices for Global AtlasVertex and AtlasEdge Keys
-     */
-    private void initialize(AtlasGraph graph) throws RepositoryException, IndexException {
-        AtlasGraphManagement management = graph.getManagementSystem();
+            // create a composite index for guid as its unique
+            createIndexes(management, Constants.GUID_PROPERTY_KEY, String.class, true,
+                    Cardinality.SINGLE, true, true);
 
-        try {
-            LOG.info("Creating indexes for graph.");
+            // create a composite index for entity state
+            createIndexes(management, Constants.TIMESTAMP_PROPERTY_KEY, Long.class, false, Cardinality.SINGLE, true, true);
 
-            if (management.getGraphIndex(VERTEX_INDEX) == null) {
-                management.createVertexMixedIndex(VERTEX_INDEX, BACKING_INDEX, Collections.emptyList());
+            // create a mixed index for entity state. Set systemProperty flag deliberately to false
+            // so that it doesnt create a composite index which has issues with
+            // titan 0.5.4 - Refer https://groups.google.com/forum/#!searchin/aureliusgraphs/hemanth/aureliusgraphs/bx7T843mzXU/fjAsclx7GAAJ
+            createStateMixedIndex(management);
 
-                LOG.info("Created index : {}", VERTEX_INDEX);
-            }
+            // create a composite index for entity state
+            createIndexes(management, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY, Long.class, false,
+                    Cardinality.SINGLE, false, false);
 
-            if (management.getGraphIndex(EDGE_INDEX) == null) {
-                management.createEdgeMixedIndex(EDGE_INDEX, BACKING_INDEX, Collections.emptyList());
+            // create a composite and mixed index for type since it can be combined with other keys
+            createIndexes(management, Constants.ENTITY_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE,
+                    true, true);
 
-                LOG.info("Created index : {}", EDGE_INDEX);
-            }
+            // create a composite and mixed index for type since it can be combined with other keys
+            createIndexes(management, Constants.SUPER_TYPES_PROPERTY_KEY, String.class, false, Cardinality.SET,
+                    true, true);
 
-            if (management.getGraphIndex(FULLTEXT_INDEX) == null) {
-                management.createFullTextMixedIndex(FULLTEXT_INDEX, BACKING_INDEX, Collections.emptyList());
+            // create a composite and mixed index for traitNames since it can be combined with other
+            // keys. Traits must be a set and not a list.
+            createIndexes(management, Constants.TRAIT_NAMES_PROPERTY_KEY, String.class, false, Cardinality.SET,
+                    true, true);
 
-                LOG.info("Created index : {}", FULLTEXT_INDEX);
-            }
+            // Index for full text search
+            createFullTextIndex(management);
 
-            // create vertex indexes
-            createCommonVertexIndex(management, GUID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, HISTORICAL_GUID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-
-            createCommonVertexIndex(management, TYPENAME_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, TYPESERVICETYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, VERTEX_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, VERTEX_ID_IN_IMPORT_KEY, UniqueKind.NONE, Long.class, SINGLE, true, false);
-
-            createCommonVertexIndex(management, ENTITY_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, SUPER_TYPES_PROPERTY_KEY, UniqueKind.NONE, String.class, SET, true, false);
-            createCommonVertexIndex(management, TIMESTAMP_PROPERTY_KEY, UniqueKind.NONE, Long.class, SINGLE, false, false);
-            createCommonVertexIndex(management, MODIFICATION_TIMESTAMP_PROPERTY_KEY, UniqueKind.NONE, Long.class, SINGLE, false, false);
-            createCommonVertexIndex(management, STATE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
-            createCommonVertexIndex(management, CREATED_BY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false, true);
-            createCommonVertexIndex(management, CLASSIFICATION_TEXT_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
-            createCommonVertexIndex(management, MODIFIED_BY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false, true);
-            createCommonVertexIndex(management, CLASSIFICATION_NAMES_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PROPAGATED_CLASSIFICATION_NAMES_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, TRAIT_NAMES_PROPERTY_KEY, UniqueKind.NONE, String.class, SET, true, true);
-            createCommonVertexIndex(management, PROPAGATED_TRAIT_NAMES_PROPERTY_KEY, UniqueKind.NONE, String.class, LIST, true, true);
-            createCommonVertexIndex(management, IS_INCOMPLETE_PROPERTY_KEY, UniqueKind.NONE, Integer.class, SINGLE, true, true);
-            createCommonVertexIndex(management, CUSTOM_ATTRIBUTES_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, LABELS_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-
-            createCommonVertexIndex(management, PATCH_ID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_DESCRIPTION_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_ACTION_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_STATE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-
-            // create vertex-centric index
-            createVertexCentricIndex(management, CLASSIFICATION_LABEL, AtlasEdgeDirection.BOTH, CLASSIFICATION_EDGE_NAME_PROPERTY_KEY, String.class, SINGLE);
-            createVertexCentricIndex(management, CLASSIFICATION_LABEL, AtlasEdgeDirection.BOTH, CLASSIFICATION_EDGE_IS_PROPAGATED_PROPERTY_KEY, Boolean.class, SINGLE);
-            createVertexCentricIndex(management, CLASSIFICATION_LABEL, AtlasEdgeDirection.BOTH, Arrays.asList(CLASSIFICATION_EDGE_NAME_PROPERTY_KEY, CLASSIFICATION_EDGE_IS_PROPAGATED_PROPERTY_KEY));
-
-            // create edge indexes
-            createEdgeIndex(management, RELATIONSHIP_GUID_PROPERTY_KEY, String.class, SINGLE, true);
-            createEdgeIndex(management, EDGE_ID_IN_IMPORT_KEY, String.class, SINGLE, true);
-
-            // create fulltext indexes
-            createFullTextIndex(management, ENTITY_TEXT_PROPERTY_KEY, String.class, SINGLE);
-
-            createPropertyKey(management, IS_PROXY_KEY, Boolean.class, SINGLE);
-            createPropertyKey(management, PROVENANCE_TYPE_KEY, Integer.class, SINGLE);
-            createPropertyKey(management, HOME_ID_KEY, String.class, SINGLE);
-
-            createEdgeLabel(management, Constants.TERM_ASSIGNMENT_LABEL);
-            createEdgeLabel(management, Constants.CLASSIFICATION_LABEL);
+            //Indexes for graph backed type system store
+            createTypeStoreIndexes(management);
 
             commit(management);
-
             LOG.info("Index creation for global keys complete.");
         } catch (Throwable t) {
-            LOG.error("GraphBackedSearchIndexer.initialize() failed", t);
-
             rollback(management);
             throw new RepositoryException(t);
         }
     }
 
-    private void resolveIndexFieldNames(AtlasGraphManagement managementSystem, ChangedTypeDefs changedTypeDefs) {
-        List<? extends AtlasBaseTypeDef> createdTypeDefs = changedTypeDefs.getCreatedTypeDefs();
-
-        if(createdTypeDefs != null) {
-            resolveIndexFieldNames(managementSystem, createdTypeDefs);
-        }
-
-        List<? extends AtlasBaseTypeDef> updatedTypeDefs = changedTypeDefs.getUpdatedTypeDefs();
-
-        if(updatedTypeDefs != null) {
-            resolveIndexFieldNames(managementSystem, updatedTypeDefs);
-        }
-    }
-
-    private void resolveIndexFieldNames(AtlasGraphManagement managementSystem, List<? extends AtlasBaseTypeDef> typeDefs) {
-        for(AtlasBaseTypeDef baseTypeDef: typeDefs) {
-            if(TypeCategory.ENTITY.equals(baseTypeDef.getCategory())) {
-                AtlasEntityType entityType = typeRegistry.getEntityTypeByName(baseTypeDef.getName());
-
-                resolveIndexFieldNames(managementSystem, entityType);
-            } else if(TypeCategory.BUSINESS_METADATA.equals(baseTypeDef.getCategory())) {
-                AtlasBusinessMetadataType businessMetadataType = typeRegistry.getBusinessMetadataTypeByName(baseTypeDef.getName());
-
-                resolveIndexFieldNames(managementSystem, businessMetadataType);
-            } else {
-                LOG.debug("Ignoring type definition {}", baseTypeDef.getName());
-            }
-        }
-    }
-
-    private void resolveIndexFieldNames(AtlasGraphManagement managementSystem, AtlasStructType structType) {
-        for(AtlasAttribute attribute: structType.getAllAttributes().values()) {
-            resolveIndexFieldName(managementSystem, attribute);
-        }
-    }
-
-    private void resolveIndexFieldName(AtlasGraphManagement managementSystem, AtlasAttribute attribute) {
-        try {
-            if (attribute.getIndexFieldName() == null && TypeCategory.PRIMITIVE.equals(attribute.getAttributeType().getTypeCategory())) {
-                AtlasStructType definedInType = attribute.getDefinedInType();
-                AtlasAttribute  baseInstance  = definedInType != null ? definedInType.getAttribute(attribute.getName()) : null;
-
-                if (baseInstance != null && baseInstance.getIndexFieldName() != null) {
-                    attribute.setIndexFieldName(baseInstance.getIndexFieldName());
-                } else if (isIndexApplicable(getPrimitiveClass(attribute.getTypeName()), toAtlasCardinality(attribute.getAttributeDef().getCardinality()))) {
-                    AtlasPropertyKey propertyKey = managementSystem.getPropertyKey(attribute.getVertexPropertyName());
-                    boolean isStringField = AtlasAttributeDef.IndexType.STRING.equals(attribute.getIndexType());
-                    if (propertyKey != null) {
-                        String indexFieldName = managementSystem.getIndexFieldName(Constants.VERTEX_INDEX, propertyKey, isStringField);
-
-                        attribute.setIndexFieldName(indexFieldName);
-
-                        if (baseInstance != null) {
-                            baseInstance.setIndexFieldName(indexFieldName);
-                        }
-
-                        typeRegistry.addIndexFieldName(attribute.getVertexPropertyName(), indexFieldName);
-
-                        LOG.info("Property {} is mapped to index field name {}", attribute.getQualifiedName(), attribute.getIndexFieldName());
-                    } else {
-                        LOG.warn("resolveIndexFieldName(attribute={}): propertyKey is null for vertextPropertyName={}", attribute.getQualifiedName(), attribute.getVertexPropertyName());
-                    }
-                }
-            }
-        } catch (Exception excp) {
-            LOG.warn("resolveIndexFieldName(attribute={}) failed.", attribute.getQualifiedName(), excp);
-        }
-    }
-
-    private void createCommonVertexIndex(AtlasGraphManagement management,
-                                         String propertyName,
-                                         UniqueKind uniqueKind,
-                                         Class propertyClass,
-                                         AtlasCardinality cardinality,
-                                         boolean createCompositeIndex,
-                                         boolean createCompositeIndexWithTypeAndSuperTypes) {
-        createCommonVertexIndex(management, propertyName, uniqueKind, propertyClass, cardinality, createCompositeIndex, createCompositeIndexWithTypeAndSuperTypes, false);
-    }
-
-    private void createCommonVertexIndex(AtlasGraphManagement management,
-                                         String propertyName,
-                                         UniqueKind uniqueKind,
-                                         Class propertyClass,
-                                         AtlasCardinality cardinality,
-                                         boolean createCompositeIndex,
-                                         boolean createCompositeIndexWithTypeAndSuperTypes,
-                                         boolean isStringField) {
-        if(isStringField && String.class.equals(propertyClass)) {
-
-            propertyName = AtlasAttribute.VERTEX_PROPERTY_PREFIX_STRING_INDEX_TYPE +propertyName;
-            LOG.debug("Creating the common attribute '{}' as string field.", propertyName);
-        }
-
-        final String indexFieldName = createVertexIndex(management,
-                                                        propertyName,
-                                                        uniqueKind,
-                                                        propertyClass,
-                                                        cardinality,
-                                                        createCompositeIndex,
-                                                        createCompositeIndexWithTypeAndSuperTypes, isStringField);
-        if(indexFieldName != null) {
-            typeRegistry.addIndexFieldName(propertyName, indexFieldName);
-        }
-    }
-
-    private void addIndexForType(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
-        if (typeDef instanceof AtlasEnumDef) {
-            // Only handle complex types like Struct, Classification and Entity
-            return;
-        }
-        if (typeDef instanceof AtlasStructDef) {
-            AtlasStructDef structDef = (AtlasStructDef) typeDef;
-            List<AtlasAttributeDef> attributeDefs = structDef.getAttributeDefs();
-            if (CollectionUtils.isNotEmpty(attributeDefs)) {
-                for (AtlasAttributeDef attributeDef : attributeDefs) {
-                    createIndexForAttribute(management, structDef, attributeDef);
-                }
+    private void createStateMixedIndex(TitanManagement management) {
+        PropertyKey propertyKey = management.getPropertyKey(Constants.STATE_PROPERTY_KEY);
+        if (propertyKey == null) {
+            propertyKey = management.makePropertyKey(Constants.STATE_PROPERTY_KEY).dataType(String.class).cardinality(Cardinality.SINGLE)
+                .make();
             }
-        } else if (!AtlasTypeUtil.isBuiltInType(typeDef.getName())){
-            throw new IllegalArgumentException("bad data type" + typeDef.getName());
-        }
+        enhanceMixedIndex(management, Constants.STATE_PROPERTY_KEY, String.class, Cardinality.SINGLE, propertyKey);
     }
 
-    private void deleteIndexForType(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
-        Preconditions.checkNotNull(typeDef, "Cannot process null typedef");
-
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Deleting indexes for type {}", typeDef.getName());
-        }
 
-        if (typeDef instanceof AtlasStructDef) {
-            AtlasStructDef          structDef     = (AtlasStructDef) typeDef;
-            List<AtlasAttributeDef> attributeDefs = structDef.getAttributeDefs();
+    private void createFullTextIndex(TitanManagement management) {
+        PropertyKey fullText =
+                management.makePropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY).dataType(String.class).make();
 
-            if (CollectionUtils.isNotEmpty(attributeDefs)) {
-                for (AtlasAttributeDef attributeDef : attributeDefs) {
-                    deleteIndexForAttribute(management, typeDef.getName(), attributeDef);
-                }
-            }
-        }
-
-        LOG.info("Completed deleting indexes for type {}", typeDef.getName());
+        management.buildIndex(Constants.FULLTEXT_INDEX, Vertex.class)
+                .addKey(fullText, com.thinkaurelius.titan.core.schema.Parameter.of("mapping", Mapping.TEXT))
+                .buildMixedIndex(Constants.BACKING_INDEX);
+        LOG.info("Created mixed index for {}", Constants.ENTITY_TEXT_PROPERTY_KEY);
     }
 
-    private void createIndexForAttribute(AtlasGraphManagement management, AtlasStructDef structDef, AtlasAttributeDef attributeDef) {
-        String           qualifiedName  = AtlasAttribute.getQualifiedAttributeName(structDef, attributeDef.getName());
-        final String     propertyName   = AtlasAttribute.generateVertexPropertyName(structDef, attributeDef, qualifiedName);
-        AtlasCardinality cardinality    = toAtlasCardinality(attributeDef.getCardinality());
-        boolean          isUnique       = attributeDef.getIsUnique();
-        boolean          isIndexable    = attributeDef.getIsIndexable();
-        String           attribTypeName = attributeDef.getTypeName();
-        boolean          isBuiltInType  = AtlasTypeUtil.isBuiltInType(attribTypeName);
-        boolean          isArrayType    = isArrayType(attribTypeName);
-        boolean          isMapType      = isMapType(attribTypeName);
-        final String     uniqPropName   = isUnique ? AtlasGraphUtilsV2.encodePropertyKey(structDef.getName() + "." + UNIQUE_ATTRIBUTE_SHADE_PROPERTY_PREFIX + attributeDef.getName()) : null;
-        final AtlasAttributeDef.IndexType indexType      = attributeDef.getIndexType();
-
-        try {
-            AtlasType atlasType     = typeRegistry.getType(structDef.getName());
-            AtlasType attributeType = typeRegistry.getType(attribTypeName);
-
-            if (isClassificationType(attributeType)) {
-                LOG.warn("Ignoring non-indexable attribute {}", attribTypeName);
-            }
-
-            if (isArrayType) {
-                createLabelIfNeeded(management, propertyName, attribTypeName);
-
-                AtlasArrayType arrayType   = (AtlasArrayType) attributeType;
-                boolean        isReference = isReference(arrayType.getElementType());
+    private void createTypeStoreIndexes(TitanManagement management) {
+        //Create unique index on typeName
+        createIndexes(management, Constants.TYPENAME_PROPERTY_KEY, String.class, true, Cardinality.SINGLE,
+                true, true);
 
-                if (!isReference) {
-                    createPropertyKey(management, propertyName, ArrayList.class, SINGLE);
-                }
-            }
-
-            if (isMapType) {
-                createLabelIfNeeded(management, propertyName, attribTypeName);
-
-                AtlasMapType mapType     = (AtlasMapType) attributeType;
-                boolean      isReference = isReference(mapType.getValueType());
-
-                if (!isReference) {
-                    createPropertyKey(management, propertyName, HashMap.class, SINGLE);
-                }
-            }
-
-            if (isEntityType(attributeType)) {
-                createEdgeLabel(management, propertyName);
-
-            } else if (isBuiltInType) {
-                if (isRelationshipType(atlasType)) {
-                    createEdgeIndex(management, propertyName, getPrimitiveClass(attribTypeName), cardinality, false);
-                } else {
-                    Class primitiveClassType = getPrimitiveClass(attribTypeName);
-                    boolean isStringField = false;
-                    if(primitiveClassType == String.class) {
-                        isStringField = AtlasAttributeDef.IndexType.STRING.equals(indexType);
-
-                    }
-                    createVertexIndex(management, propertyName, UniqueKind.NONE, getPrimitiveClass(attribTypeName), cardinality, isIndexable, false, isStringField);
-
-                    if (uniqPropName != null) {
-                        createVertexIndex(management, uniqPropName, UniqueKind.PER_TYPE_UNIQUE, getPrimitiveClass(attribTypeName), cardinality, isIndexable, true, isStringField);
-                    }
-                }
-            } else if (isEnumType(attributeType)) {
-                if (isRelationshipType(atlasType)) {
-                    createEdgeIndex(management, propertyName, String.class, cardinality, false);
-                } else {
-                    createVertexIndex(management, propertyName, UniqueKind.NONE, String.class, cardinality, isIndexable, false, false);
-
-                    if (uniqPropName != null) {
-                        createVertexIndex(management, uniqPropName, UniqueKind.PER_TYPE_UNIQUE, String.class, cardinality, isIndexable, true, false);
-                    }
-                }
-            } else if (isStructType(attributeType)) {
-                AtlasStructDef attribureStructDef = typeRegistry.getStructDefByName(attribTypeName);
-                updateIndexForTypeDef(management, attribureStructDef);
-            }
-        } catch (AtlasBaseException e) {
-            LOG.error("No type exists for {}", attribTypeName, e);
-        }
-    }
-
-    private void deleteIndexForAttribute(AtlasGraphManagement management, String typeName, AtlasAttributeDef attributeDef) {
-        final String propertyName = AtlasGraphUtilsV2.encodePropertyKey(typeName + "." + attributeDef.getName());
-
-        try {
-            if (management.containsPropertyKey(propertyName)) {
-                LOG.info("Deleting propertyKey {}, for attribute {}.{}", propertyName, typeName, attributeDef.getName());
-
-                management.deletePropertyKey(propertyName);
-            }
-        } catch (Exception excp) {
-            LOG.warn("Failed to delete propertyKey {}, for attribute {}.{}", propertyName, typeName, attributeDef.getName());
-        }
+        //create index on vertex type
+        createIndexes(management, Constants.VERTEX_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE,
+                true, true);
     }
 
     /**
-     * gets the encoded property name for the attribute passed in.
-     * @param baseTypeDef the type system of the attribute
-     * @param attributeDef the attribute definition
-     * @return the encoded property name for the attribute passed in.
+     * This is upon adding a new type to Store.
+     *
+     * @param dataTypes data type
+     * @throws org.apache.atlas.AtlasException
      */
-    public static String getEncodedPropertyName(AtlasStructDef baseTypeDef, AtlasAttributeDef attributeDef) {
-        return AtlasAttribute.getQualifiedAttributeName(baseTypeDef, attributeDef.getName());
-    }
-
-    private void createLabelIfNeeded(final AtlasGraphManagement management, final String propertyName, final String attribTypeName) {
-        // If any of the referenced typename is of type Entity or Struct then the edge label needs to be created
-        for (String typeName : AtlasTypeUtil.getReferencedTypeNames(attribTypeName)) {
-            if (typeRegistry.getEntityDefByName(typeName) != null || typeRegistry.getStructDefByName(typeName) != null) {
-                // Create the edge label upfront to avoid running into concurrent call issue (ATLAS-2092)
-                createEdgeLabel(management, propertyName);
+    @Override
+    public void onAdd(Collection<? extends IDataType> dataTypes) throws AtlasException {
+        TitanManagement management = titanGraph.getManagementSystem();
+        for (IDataType dataType : dataTypes) {
+            LOG.debug("Creating indexes for type name={}, definition={}", dataType.getName(), dataType.getClass());
+            try {
+                addIndexForType(management, dataType);
+                LOG.info("Index creation for type {} complete", dataType.getName());
+            } catch (Throwable throwable) {
+                LOG.error("Error creating index for type {}", dataType, throwable);
+                //Rollback indexes if any failure
+                rollback(management);
+                throw new IndexCreationException("Error while creating index for type " + dataType, throwable);
             }
         }
-    }
-
-    private boolean isEntityType(AtlasType type) {
-        return type instanceof AtlasEntityType;
-    }
 
-    private boolean isClassificationType(AtlasType type) {
-        return type instanceof AtlasClassificationType;
+        //Commit indexes
+        commit(management);
     }
 
-    private boolean isEnumType(AtlasType type) {
-        return type instanceof AtlasEnumType;
-    }
-
-    private boolean isStructType(AtlasType type) {
-        return type instanceof AtlasStructType;
-    }
-
-    private boolean isRelationshipType(AtlasType type) {
-        return type instanceof AtlasRelationshipType;
-    }
+    @Override
+    public void onChange(Collection<? extends IDataType> dataTypes) throws AtlasException {
+        onAdd(dataTypes);
+    }
+
+    private void addIndexForType(TitanManagement management, IDataType dataType) {
+        switch (dataType.getTypeCategory()) {
+        case PRIMITIVE:
+        case ENUM:
+        case ARRAY:
+        case MAP:
+            // do nothing since these are only attributes
+            // and not types like structs, traits or classes
+            break;
+
+        case STRUCT:
+            StructType structType = (StructType) dataType;
+            createIndexForFields(management, structType, structType.fieldMapping().fields);
+            break;
+
+        case TRAIT:
+            TraitType traitType = (TraitType) dataType;
+            createIndexForFields(management, traitType, traitType.fieldMapping().fields);
+            break;
 
-    public Class getPrimitiveClass(String attribTypeName) {
-        String attributeTypeName = attribTypeName.toLowerCase();
-
-        switch (attributeTypeName) {
-            case ATLAS_TYPE_BOOLEAN:
-                return Boolean.class;
-            case ATLAS_TYPE_BYTE:
-                return Byte.class;
-            case ATLAS_TYPE_SHORT:
-                return Short.class;
-            case ATLAS_TYPE_INT:
-                return Integer.class;
-            case ATLAS_TYPE_LONG:
-            case ATLAS_TYPE_DATE:
-                return Long.class;
-            case ATLAS_TYPE_FLOAT:
-                return Float.class;
-            case ATLAS_TYPE_DOUBLE:
-                return Double.class;
-            case ATLAS_TYPE_BIGINTEGER:
-                return BigInteger.class;
-            case ATLAS_TYPE_BIGDECIMAL:
-                return BigDecimal.class;
-            case ATLAS_TYPE_STRING:
-                return String.class;
-        }
+        case CLASS:
+            ClassType classType = (ClassType) dataType;
+            createIndexForFields(management, classType, classType.fieldMapping().fields);
+            break;
+
+        default:
+            throw new IllegalArgumentException("bad data type" + dataType);
+        }
+    }
+
+    private void createIndexForFields(TitanManagement management, IDataType dataType, Map<String, AttributeInfo> fields) {
+        for (AttributeInfo field : fields.values()) {
+            createIndexForAttribute(management, dataType.getName(), field);
+        }
+    }
+
+    private void createIndexForAttribute(TitanManagement management, String typeName, AttributeInfo field) {
+        final String propertyName = GraphHelper.encodePropertyKey(typeName + "." + field.name);
+        switch (field.dataType().getTypeCategory()) {
+        case PRIMITIVE:
+            Cardinality cardinality = getCardinality(field.multiplicity);
+            createIndexes(management, propertyName, getPrimitiveClass(field.dataType()), field.isUnique,
+                    cardinality, false, field.isIndexable);
+            break;
+
+        case ENUM:
+            cardinality = getCardinality(field.multiplicity);
+            createIndexes(management, propertyName, String.class, field.isUnique, cardinality, false, field.isIndexable);
+            break;
+
+        case ARRAY:
+        case MAP:
+            // todo - how do we overcome this limitation?
+            // IGNORE: Can only index single-valued property keys on vertices in Mixed Index
+            break;
+
+        case STRUCT:
+            StructType structType = (StructType) field.dataType();
+            createIndexForFields(management, structType, structType.fieldMapping().fields);
+            break;
+
+        case TRAIT:
+            // do nothing since this is NOT contained in other types
+            break;
+
+        case CLASS:
+            // this is only A reference, index the attribute for edge
+            // Commenting this out since we do not need an index for edge here
+            //createEdgeMixedIndex(propertyName);
+            break;
+
+        default:
+            throw new IllegalArgumentException("bad data type" + field.dataType().getName());
+        }
+    }
+
+    private Class getPrimitiveClass(IDataType dataType) {
+        if (dataType == DataTypes.STRING_TYPE) {
+            return String.class;
+        } else if (dataType == DataTypes.SHORT_TYPE) {
+            return Short.class;
+        } else if (dataType == DataTypes.INT_TYPE) {
+            return Integer.class;
+        } else if (dataType == DataTypes.BIGINTEGER_TYPE) {
+            return BigInteger.class;
+        } else if (dataType == DataTypes.BOOLEAN_TYPE) {
+            return Boolean.class;
+        } else if (dataType == DataTypes.BYTE_TYPE) {
+            return Byte.class;
+        } else if (dataType == DataTypes.LONG_TYPE) {
+            return Long.class;
+        } else if (dataType == DataTypes.FLOAT_TYPE) {
+            return Float.class;
+        } else if (dataType == DataTypes.DOUBLE_TYPE) {
+            return Double.class;
+        } else if (dataType == DataTypes.BIGDECIMAL_TYPE) {
+            return BigDecimal.class;
+        } else if (dataType == DataTypes.DATE_TYPE) {
+            //Indexing with date converted to long as of now since Titan is yet to add support for Date type with mixed indexes
+            return Long.class;
+        }
+
+
+        throw new IllegalArgumentException("unknown data type " + dataType);
+    }
 
-        throw new IllegalArgumentException(String.format("Unknown primitive typename %s", attribTypeName));
-    }
 
-    public AtlasCardinality toAtlasCardinality(AtlasAttributeDef.Cardinality cardinality) {
-        switch (cardinality) {
-            case SINGLE:
-                return SINGLE;
-            case LIST:
-                return LIST;
-            case SET:
-                return SET;
+    private Cardinality getCardinality(Multiplicity multiplicity) {
+        if (multiplicity == Multiplicity.OPTIONAL || multiplicity == Multiplicity.REQUIRED) {
+            return Cardinality.SINGLE;
+        } else if (multiplicity == Multiplicity.COLLECTION) {
+            return Cardinality.LIST;
+        } else if (multiplicity == Multiplicity.SET) {
+            return Cardinality.SET;
         }
-        // Should never reach this point
-        throw new IllegalArgumentException(String.format("Bad cardinality %s", cardinality));
-    }
 
-    private void createEdgeLabel(final AtlasGraphManagement management, final String propertyName) {
-        // Create the edge label upfront to avoid running into concurrent call issue (ATLAS-2092)
-        // ATLAS-2092 addresses this problem by creating the edge label upfront while type creation
-        // which resolves the race condition during the entity creation
-
-        String label = Constants.INTERNAL_PROPERTY_KEY_PREFIX + propertyName;
-
-        createEdgeLabelUsingLabelName(management, label);
+        // todo - default to LIST as this is the most forgiving
+        return Cardinality.LIST;
     }
 
-    private void createEdgeLabelUsingLabelName(final AtlasGraphManagement management, final String label) {
-        if (StringUtils.isEmpty(label)) {
-            return;
-        }
-
-        org.apache.atlas.repository.graphdb.AtlasEdgeLabel edgeLabel = management.getEdgeLabel(label);
+    private PropertyKey createIndexes(TitanManagement management, String propertyName,
+                                      Class propertyClass, boolean isUnique, Cardinality cardinality,
+                                      boolean createCompositeForAttribute, boolean createCompositeWithTypeandSuperTypes) {
+        PropertyKey propertyKey = management.getPropertyKey(propertyName);
+        if (propertyKey == null) {
+            propertyKey = management.makePropertyKey(propertyName).dataType(propertyClass).cardinality(cardinality)
+                    .make();
 
-        if (edgeLabel == null) {
-            management.makeEdgeLabel(label);
+            enhanceMixedIndex(management, propertyName, propertyClass, cardinality, propertyKey);
 
-            LOG.info("Created edge label {} ", label);
         }
-    }
-
-    private AtlasPropertyKey createPropertyKey(AtlasGraphManagement management, String propertyName, Class propertyClass, AtlasCardinality cardinality) {
-        AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
 
-        if (propertyKey == null) {
-            propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
+        if (createCompositeForAttribute) {
+            createCompositeIndex(management, propertyName, propertyClass, propertyKey, isUnique);
+        } else if (createCompositeWithTypeandSuperTypes) {
+            //Index with typename since typename+property key queries need to speed up
+            createCompositeIndexWithTypeName(management, propertyName, propertyClass, propertyKey);
+            createCompositeIndexWithSuperTypeName(management, propertyName, propertyClass, propertyKey);
         }
-
         return propertyKey;
     }
 
-    public String createVertexIndex(AtlasGraphManagement management, String propertyName, UniqueKind uniqueKind, Class propertyClass,
-                                  AtlasCardinality cardinality, boolean createCompositeIndex, boolean createCompositeIndexWithTypeAndSuperTypes, boolean isStringField) {
-        String indexFieldName = null;
+    private void createCompositeIndex(TitanManagement management, String propertyName, Class propertyClass,
+        PropertyKey propertyKey, boolean enforceUniqueness) {
+        LOG.debug("Creating composite index for property {} of type {} ", propertyName,
+            propertyClass.getName());
 
-        if (propertyName != null) {
-            AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
-
-            if (propertyKey == null) {
-                propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
-
-                if (isIndexApplicable(propertyClass, cardinality)) {
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug("Creating backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
-                    }
-
-                    indexFieldName = management.addMixedIndex(VERTEX_INDEX, propertyKey, isStringField);
-                    LOG.info("Created backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
-                }
-            }
-
-            if(indexFieldName == null && isIndexApplicable(propertyClass, cardinality)) {
-                indexFieldName = management.getIndexFieldName(VERTEX_INDEX, propertyKey, isStringField);
+        TitanGraphIndex existingIndex = management.getGraphIndex(propertyName);
+        if ( existingIndex == null) {
+            TitanManagement.IndexBuilder indexBuilder =
+                management.buildIndex(propertyName, Vertex.class).addKey(propertyKey);
+            if (enforceUniqueness) {
+                LOG.debug("Enabling unique index for property {} of type {} ", propertyName,
+                    propertyClass.getName());
+                indexBuilder.unique();
             }
-
-            if (propertyKey != null) {
-                if (createCompositeIndex || uniqueKind == UniqueKind.GLOBAL_UNIQUE || uniqueKind == UniqueKind.PER_TYPE_UNIQUE) {
-                    createVertexCompositeIndex(management, propertyClass, propertyKey, uniqueKind == UniqueKind.GLOBAL_UNIQUE);
-                }
-
-                if (createCompositeIndexWithTypeAndSuperTypes) {
-                    createVertexCompositeIndexWithTypeName(management, propertyClass, propertyKey, uniqueKind == UniqueKind.PER_TYPE_UNIQUE);
-                    createVertexCompositeIndexWithSuperTypeName(management, propertyClass, propertyKey);
-                }
-            } else {
-                LOG.warn("Index not created for {}: propertyKey is null", propertyName);
-            }
-        }
-
-        return indexFieldName;
-    }
-
-    private void createVertexCentricIndex(AtlasGraphManagement management, String edgeLabel, AtlasEdgeDirection edgeDirection,
-                                          String propertyName, Class propertyClass, AtlasCardinality cardinality) {
-        AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
-
-        if (propertyKey == null) {
-            propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
-        }
-
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating vertex-centric index for edge label: {} direction: {} for property: {} of type: {} ",
-                    edgeLabel, edgeDirection.name(), propertyName, propertyClass.getName());
-        }
-
-        final String indexName = edgeLabel + propertyKey.getName();
-
-        if (!management.edgeIndexExist(edgeLabel, indexName)) {
-            management.createEdgeIndex(edgeLabel, indexName, edgeDirection, Collections.singletonList(propertyKey));
-
-            LOG.info("Created vertex-centric index for edge label: {} direction: {} for property: {} of type: {}",
-                    edgeLabel, edgeDirection.name(), propertyName, propertyClass.getName());
+            indexBuilder.buildCompositeIndex();
         }
+        LOG.info("Created composite index for property {} of type {} ", propertyName, propertyClass.getName());
     }
 
-    private void createVertexCentricIndex(AtlasGraphManagement management, String edgeLabel, AtlasEdgeDirection edgeDirection, List<String> propertyNames) {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating vertex-centric index for edge label: {} direction: {} for properties: {}",
-                    edgeLabel, edgeDirection.name(), propertyNames);
-        }
-
-        String                 indexName    = edgeLabel;
-        List<AtlasPropertyKey> propertyKeys = new ArrayList<>();
-
-        for (String propertyName : propertyNames) {
-            AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
-
-            if (propertyKey != null) {
-                propertyKeys.add(propertyKey);
-                indexName = indexName + propertyKey.getName();
-            }
-        }
-
-        if (!management.edgeIndexExist(edgeLabel, indexName) && CollectionUtils.isNotEmpty(propertyKeys)) {
-            management.createEdgeIndex(edgeLabel, indexName, edgeDirection, propertyKeys);
-
-            LOG.info("Created vertex-centric index for edge label: {} direction: {} for properties: {}", edgeLabel, edgeDirection.name(), propertyNames);
-        }
+    private void createCompositeIndexWithTypeName(TitanManagement management, String propertyName, Class propertyClass,
+        PropertyKey propertyKey) {
+        createCompositeIndexWithSystemProperty(management, propertyName, propertyClass, propertyKey, Constants.ENTITY_TYPE_PROPERTY_KEY, Cardinality.SINGLE);
     }
 
-
-    private void createEdgeIndex(AtlasGraphManagement management, String propertyName, Class propertyClass,
-                                 AtlasCardinality cardinality, boolean createCompositeIndex) {
-        if (propertyName != null) {
-            AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
-
-            if (propertyKey == null) {
-                propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
-
-                if (isIndexApplicable(propertyClass, cardinality)) {
-                    if (LOG.isDebugEnabled()) {
-                        LOG.debug("Creating backing index for edge property {} of type {} ", propertyName, propertyClass.getName());
-                    }
-
-                    management.addMixedIndex(EDGE_INDEX, propertyKey, false);
-
-                    LOG.info("Created backing index for edge property {} of type {} ", propertyName, propertyClass.getName());
-                }
-            }
-
-            if (propertyKey != null) {
-                if (createCompositeIndex) {
-                    createEdgeCompositeIndex(management, propertyClass, propertyKey);
-                }
-            } else {
-                LOG.warn("Index not created for {}: propertyKey is null", propertyName);
-            }
-        }
+    private void createCompositeIndexWithSuperTypeName(TitanManagement management, String propertyName, Class propertyClass,
+        PropertyKey propertyKey) {
+        createCompositeIndexWithSystemProperty(management, propertyName, propertyClass, propertyKey, Constants.SUPER_TYPES_PROPERTY_KEY, Cardinality.SET);
     }
 
-    private AtlasPropertyKey createFullTextIndex(AtlasGraphManagement management, String propertyName, Class propertyClass,
-                                                 AtlasCardinality cardinality) {
-        AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
-
-        if (propertyKey == null) {
-            propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
-
-            if (isIndexApplicable(propertyClass, cardinality)) {
-                if (LOG.isDebugEnabled()) {
-                    LOG.debug("Creating backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
-                }
-
-                management.addMixedIndex(FULLTEXT_INDEX, propertyKey, false);
-
-                LOG.info("Created backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
-            }
-
-            LOG.info("Created index {}", FULLTEXT_INDEX);
-        }
-
-        return propertyKey;
-    }
-    
-    private void createVertexCompositeIndex(AtlasGraphManagement management, Class propertyClass, AtlasPropertyKey propertyKey,
-                                            boolean enforceUniqueness) {
-        String propertyName = propertyKey.getName();
-
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating composite index for property {} of type {}; isUnique={} ", propertyName, propertyClass.getName(), enforceUniqueness);
+    private void createCompositeIndexWithSystemProperty(TitanManagement management, String propertyName, Class propertyClass,
+        PropertyKey propertyKey, final String systemPropertyKey, Cardinality cardinality) {
+        LOG.debug("Creating composite index for property {} of type {} and {}", propertyName,
+            propertyClass.getName(), systemPropertyKey);
+        PropertyKey typePropertyKey = management.getPropertyKey(systemPropertyKey);
+        if (typePropertyKey == null) {
+            typePropertyKey = management.makePropertyKey(systemPropertyKey).
+                dataType(String.class).cardinality(cardinality)
+                .make();
         }
+        final String indexName = propertyName + systemPropertyKey;
+        TitanGraphIndex existingIndex = management.getGraphIndex(indexName);
 
-        AtlasGraphIndex existingIndex = management.getGraphIndex(propertyName);
-
-        if (existingIndex == null) {
-            management.createVertexCompositeIndex(propertyName, enforceUniqueness, Collections.singletonList(propertyKey));
-
-            LOG.info("Created composite index for property {} of type {}; isUnique={} ", propertyName, propertyClass.getName(), enforceUniqueness);
+        if ( existingIndex == null) {
+            TitanManagement.IndexBuilder indexBuilder =
+                management.buildIndex(indexName, Vertex.class).
+                    addKey(propertyKey).addKey(typePropertyKey);
+            indexBuilder.buildCompositeIndex();
+            LOG.info("Created composite index for property {} of type {} and {}", propertyName, propertyClass.getName(), systemPropertyKey);
         }
     }
 
-    private void createEdgeCompositeIndex(AtlasGraphManagement management, Class propertyClass, AtlasPropertyKey propertyKey) {
-        String propertyName = propertyKey.getName();
-
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating composite index for property {} of type {}", propertyName, propertyClass.getName());
-        }
-
-        AtlasGraphIndex existingIndex = management.getGraphIndex(propertyName);
-
-        if (existingIndex == null) {
-            management.createEdgeCompositeIndex(propertyName, false, Collections.singletonList(propertyKey));
-
-            LOG.info("Created composite index for property {} of type {}", propertyName, propertyClass.getName());
+    private void enhanceMixedIndex(TitanManagement management, String propertyName, Class propertyClass,
+                                   Cardinality cardinality, PropertyKey propertyKey) {
+        if (checkIfMixedIndexApplicable(propertyClass, cardinality)) {
+            //Use backing index
+            LOG.debug("Creating backing index for property {} of type {} ", propertyName, propertyClass.getName());
+            TitanGraphIndex vertexIndex = management.getGraphIndex(Constants.VERTEX_INDEX);
+            management.addIndexKey(vertexIndex, propertyKey);
+            LOG.info("Created backing index for property {} of type {} ", propertyName, propertyClass.getName());
         }
     }
 
-    private void createVertexCompositeIndexWithTypeName(AtlasGraphManagement management, Class propertyClass, AtlasPropertyKey propertyKey, boolean isUnique) {
-        createVertexCompositeIndexWithSystemProperty(management, propertyClass, propertyKey, ENTITY_TYPE_PROPERTY_KEY, SINGLE, isUnique);
-    }
-
-    private void createVertexCompositeIndexWithSuperTypeName(AtlasGraphManagement management, Class propertyClass, AtlasPropertyKey propertyKey) {
-        createVertexCompositeIndexWithSystemProperty(management, propertyClass, propertyKey, SUPER_TYPES_PROPERTY_KEY, SET, false);
-    }
-
-    private void createVertexCompositeIndexWithSystemProperty(AtlasGraphManagement management, Class propertyClass, AtlasPropertyKey propertyKey,
-                                                              final String systemPropertyKey, AtlasCardinality cardinality, boolean isUnique) {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating composite index for property {} of type {} and {}", propertyKey.getName(), propertyClass.getName(),  systemPropertyKey);
-        }
-
-        AtlasPropertyKey typePropertyKey = management.getPropertyKey(systemPropertyKey);
-        if (typePropertyKey == null) {
-            typePropertyKey = management.makePropertyKey(systemPropertyKey, String.class, cardinality);
-        }
-
-        final String indexName = propertyKey.getName() + systemPropertyKey;
-        AtlasGraphIndex existingIndex = management.getGraphIndex(indexName);
-
-        if (existingIndex == null) {
-            List<AtlasPropertyKey> keys = new ArrayList<>(2);
-            keys.add(typePropertyKey);
-            keys.add(propertyKey);
-            management.createVertexCompositeIndex(indexName, isUnique, keys);
-
-            LOG.info("Created composite index for property {} of type {} and {}", propertyKey.getName(), propertyClass.getName(), systemPropertyKey);
-        }
+    private boolean checkIfMixedIndexApplicable(Class propertyClass, Cardinality cardinality) {
+        return !(MIXED_INDEX_EXCLUSIONS.contains(propertyClass) || cardinality == Cardinality.LIST || cardinality ==
+                Cardinality.SET);
     }
 
-    private boolean isIndexApplicable(Class propertyClass, AtlasCardinality cardinality) {
-        return !(INDEX_EXCLUSION_CLASSES.contains(propertyClass) || cardinality.isMany());
-    }
-    
-    public void commit(AtlasGraphManagement management) throws IndexException {
+    public void commit(TitanManagement management) throws IndexException {
         try {
             management.commit();
-
-            recomputeIndexedKeys = true;
         } catch (Exception e) {
             LOG.error("Index commit failed", e);
             throw new IndexException("Index commit failed ", e);
         }
     }
 
-    public void rollback(AtlasGraphManagement management) throws IndexException {
+    public void rollback(TitanManagement management) throws IndexException {
         try {
             management.rollback();
-
-            recomputeIndexedKeys = true;
         } catch (Exception e) {
             LOG.error("Index rollback failed ", e);
             throw new IndexException("Index rollback failed ", e);
         }
     }
 
-    private void attemptRollback(ChangedTypeDefs changedTypeDefs, AtlasGraphManagement management)
-            throws AtlasBaseException {
-        if (null != management) {
-            try {
-                rollback(management);
-            } catch (IndexException e) {
-                LOG.error("Index rollback has failed", e);
-                throw new AtlasBaseException(AtlasErrorCode.INDEX_ROLLBACK_FAILED, e,
-                        changedTypeDefs.toString());
-            }
-        }
-    }
-
-    private void updateIndexForTypeDef(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
-        Preconditions.checkNotNull(typeDef, "Cannot index on null typedefs");
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating indexes for type name={}, definition={}", typeDef.getName(), typeDef.getClass());
-        }
-        addIndexForType(management, typeDef);
-        LOG.info("Index creation for type {} complete", typeDef.getName());
-    }
-
-    private void notifyChangeListeners(ChangedTypeDefs changedTypeDefs) {
-        for (IndexChangeListener indexChangeListener : indexChangeListeners) {
-            try {
-                indexChangeListener.onChange(changedTypeDefs);
-            } catch (Throwable t) {
-                LOG.error("Error encountered in notifying the index change listener {}.", indexChangeListener.getClass().getName(), t);
-                //we need to throw exception if any of the listeners throw execption.
-                throw new RuntimeException("Error encountered in notifying the index change listener " + indexChangeListener.getClass().getName(), t);
-            }
-        }
-    }
-
-    private void notifyInitializationStart() {
-        for (IndexChangeListener indexChangeListener : indexChangeListeners) {
-            try {
-                indexChangeListener.onInitStart();
-            } catch (Throwable t) {
-                LOG.error("Error encountered in notifying the index change listener {}.", indexChangeListener.getClass().getName(), t);
-                //we need to throw exception if any of the listeners throw execption.
-                throw new RuntimeException("Error encountered in notifying the index change listener " + indexChangeListener.getClass().getName(), t);
-            }
-        }
-    }
-
-    private void notifyInitializationCompletion(ChangedTypeDefs changedTypeDefs) {
-        for (IndexChangeListener indexChangeListener : indexChangeListeners) {
-            try {
-                indexChangeListener.onInitCompletion(changedTypeDefs);
-            } catch (Throwable t) {
-                LOG.error("Error encountered in notifying the index change listener {}.", indexChangeListener.getClass().getName(), t);
-                //we need to throw exception if any of the listeners throw execption.
-                throw new RuntimeException("Error encountered in notifying the index change listener " + indexChangeListener.getClass().getName(), t);
-            }
+    /**
+     * Initialize global indices for Titan graph on server activation.
+     *
+     * Since the indices are shared state, we need to do this only from an active instance.
+     */
+    @Override
+    public void instanceIsActive() throws AtlasException {
+        LOG.info("Reacting to active: initializing index");
+        try {
+            initialize();
+        } catch (RepositoryException e) {
+            throw new AtlasException("Error in reacting to active on initialization", e);
+        } catch (IndexException e) {
+            throw new AtlasException("Error in reacting to active on initialization", e);
         }
     }
 
-
-    private void createEdgeLabels(AtlasGraphManagement management, List<? extends AtlasBaseTypeDef> typeDefs) {
-        if (CollectionUtils.isEmpty(typeDefs)) {
-            return;
-        }
-
-        for (AtlasBaseTypeDef typeDef : typeDefs) {
-            if (typeDef instanceof AtlasEntityDef) {
-                AtlasEntityDef entityDef = (AtlasEntityDef) typeDef;
-                createEdgeLabelsForStruct(management, entityDef);
-            } else if (typeDef instanceof AtlasRelationshipDef) {
-                createEdgeLabels(management, (AtlasRelationshipDef) typeDef);
-            }
-        }
+    @Override
+    public void instanceIsPassive() {
+        LOG.info("Reacting to passive state: No action right now.");
     }
 
-    private void createEdgeLabelsForStruct(AtlasGraphManagement management, AtlasEntityDef entityDef) {
-        try {
-            AtlasType type = typeRegistry.getType(entityDef.getName());
-            if (!(type instanceof AtlasEntityType)) {
-                return;
-            }
-
-            AtlasEntityType entityType = (AtlasEntityType) type;
-            for (AtlasAttributeDef attributeDef : entityDef.getAttributeDefs()) {
-                AtlasAttribute attribute = entityType.getAttribute(attributeDef.getName());
-                if (attribute.getAttributeType().getTypeCategory() == TypeCategory.STRUCT) {
-                    String relationshipLabel = attribute.getRelationshipEdgeLabel();
-                    createEdgeLabelUsingLabelName(management, relationshipLabel);
-                }
-            }
-        } catch (AtlasBaseException e) {
-            LOG.error("Error fetching type: {}", entityDef.getName(), e);
+    /* Commenting this out since we do not need an index for edge label here
+    private void createEdgeMixedIndex(String propertyName) {
+        EdgeLabel edgeLabel = management.getEdgeLabel(propertyName);
+        if (edgeLabel == null) {
+            edgeLabel = management.makeEdgeLabel(propertyName).make();
+            management.buildEdgeIndex(edgeLabel, propertyName, Direction.BOTH, Order.DEFAULT);
+            LOG.info("Created index for edge label {}", propertyName);
         }
-    }
-
-    private void createEdgeLabels(AtlasGraphManagement management, AtlasRelationshipDef relationshipDef) {
-        String relationshipTypeName = relationshipDef.getName();
-        AtlasRelationshipType relationshipType = typeRegistry.getRelationshipTypeByName(relationshipTypeName);
-        String relationshipLabel = relationshipType.getRelationshipLabel();
-
-        createEdgeLabelUsingLabelName(management, relationshipLabel);
-    }
+    }*/
 }