diff --git a/asterixdb/asterix-app/src/main/java/org/apache/asterix/app/active/ActiveEntityEventsListener.java b/asterixdb/asterix-app/src/main/java/org/apache/asterix/app/active/ActiveEntityEventsListener.java
index c6f41bfd0c..caf4bec588 100644
--- a/asterixdb/asterix-app/src/main/java/org/apache/asterix/app/active/ActiveEntityEventsListener.java
+++ b/asterixdb/asterix-app/src/main/java/org/apache/asterix/app/active/ActiveEntityEventsListener.java
@@ -21,6 +21,7 @@ package org.apache.asterix.app.active;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.EnumSet;
+import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
@@ -37,8 +38,8 @@ import org.apache.asterix.active.IActiveEntityEventSubscriber;
 import org.apache.asterix.active.IRetryPolicy;
 import org.apache.asterix.active.IRetryPolicyFactory;
 import org.apache.asterix.active.NoRetryPolicyFactory;
+import org.apache.asterix.active.message.ActiveManagerMessage;
 import org.apache.asterix.active.message.ActivePartitionMessage;
-import org.apache.asterix.active.message.ActivePartitionMessage.Event;
 import org.apache.asterix.active.message.StatsRequestMessage;
 import org.apache.asterix.common.api.IClusterManagementWork.ClusterState;
 import org.apache.asterix.common.api.IMetadataLockManager;
@@ -67,7 +68,6 @@ import org.apache.hyracks.api.job.JobStatus;
 public abstract class ActiveEntityEventsListener implements IActiveEntityController {
 
     private static final Logger LOGGER = Logger.getLogger(ActiveEntityEventsListener.class.getName());
-    private static final Level level = Level.INFO;
     private static final ActiveEvent STATE_CHANGED = new ActiveEvent(null, Kind.STATE_CHANGED, null, null);
     private static final EnumSet<ActivityState> TRANSITION_STATES = EnumSet.of(ActivityState.RESUMING,
             ActivityState.STARTING, ActivityState.STOPPING, ActivityState.RECOVERING);
@@ -111,6 +111,7 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
         this.appCtx = appCtx;
         this.clusterStateManager = appCtx.getClusterStateManager();
         this.metadataProvider = new MetadataProvider(appCtx, null);
+        metadataProvider.setConfig(new HashMap<>());
         this.hcc = hcc;
         this.entityId = entityId;
         this.datasets = datasets;
@@ -129,7 +130,7 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
     }
 
     protected synchronized void setState(ActivityState newState) {
-        LOGGER.log(level, "State of " + getEntityId() + "is being set to " + newState + " from " + state);
+        LOGGER.log(Level.WARNING, "State is being set to " + newState + " from " + state);
         this.prevState = state;
         this.state = newState;
         if (newState == ActivityState.SUSPENDED) {
@@ -141,7 +142,7 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
     @Override
     public synchronized void notify(ActiveEvent event) {
         try {
-            LOGGER.log(level, "EventListener is notified.");
+            LOGGER.warning("EventListener is notified.");
             ActiveEvent.Kind eventKind = event.getEventKind();
             switch (eventKind) {
                 case JOB_CREATED:
@@ -157,7 +158,7 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
                     handle((ActivePartitionMessage) event.getEventObject());
                     break;
                 default:
-                    LOGGER.log(Level.FINE, "Unhandled feed event notification: " + event);
+                    LOGGER.log(Level.WARNING, "Unhandled feed event notification: " + event);
                     break;
             }
             notifySubscribers(event);
@@ -171,24 +172,22 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
     }
 
     protected synchronized void handle(ActivePartitionMessage message) {
-        if (message.getEvent() == Event.RUNTIME_REGISTERED) {
+        if (message.getEvent() == ActivePartitionMessage.ACTIVE_RUNTIME_REGISTERED) {
             numRegistered++;
             if (numRegistered == locations.getLocations().length) {
                 setState(ActivityState.RUNNING);
             }
-        } else if (message.getEvent() == Event.RUNTIME_DEREGISTERED) {
+        } else if (message.getEvent() == ActivePartitionMessage.ACTIVE_RUNTIME_DEREGISTERED) {
             numRegistered--;
         }
     }
 
     @SuppressWarnings("unchecked")
     protected void finish(ActiveEvent event) throws HyracksDataException {
-        LOGGER.log(level, "the job " + jobId + " finished");
         jobId = null;
         Pair<JobStatus, List<Exception>> status = (Pair<JobStatus, List<Exception>>) event.getEventObject();
         JobStatus jobStatus = status.getLeft();
         List<Exception> exceptions = status.getRight();
-        LOGGER.log(level, "The job finished with status: " + jobStatus);
         if (jobStatus.equals(JobStatus.FAILURE)) {
             jobFailure = exceptions.isEmpty() ? new RuntimeDataException(ErrorCode.UNREPORTED_TASK_FAILURE_EXCEPTION)
                     : exceptions.get(0);
@@ -272,10 +271,10 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
     @SuppressWarnings("unchecked")
     @Override
     public void refreshStats(long timeout) throws HyracksDataException {
-        LOGGER.log(level, "refreshStats called");
+        LOGGER.log(Level.WARNING, "refreshStats called");
         synchronized (this) {
             if (state != ActivityState.RUNNING || isFetchingStats) {
-                LOGGER.log(level,
+                LOGGER.log(Level.WARNING,
                         "returning immediately since state = " + state + " and fetchingStats = " + isFetchingStats);
                 return;
             } else {
@@ -288,7 +287,8 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
         List<INcAddressedMessage> requests = new ArrayList<>();
         List<String> ncs = Arrays.asList(locations.getLocations());
         for (int i = 0; i < ncs.size(); i++) {
-            requests.add(new StatsRequestMessage(new ActiveRuntimeId(entityId, runtimeName, i), reqId));
+            requests.add(new StatsRequestMessage(ActiveManagerMessage.REQUEST_STATS,
+                    new ActiveRuntimeId(entityId, runtimeName, i), reqId));
         }
         try {
             List<String> responses = (List<String>) messageBroker.sendSyncRequestToNCs(reqId, ncs, requests, timeout);
@@ -348,52 +348,42 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
 
     @Override
     public synchronized void recover() throws HyracksDataException {
-        LOGGER.log(level, "Recover is called on " + entityId);
+        LOGGER.log(Level.WARNING, "Recover is called on " + entityId);
         if (recoveryTask != null) {
-            LOGGER.log(level, "But recovery task for " + entityId + " is already there!! throwing an exception");
+            LOGGER.log(Level.WARNING,
+                    "But recovery task for " + entityId + " is already there!! throwing an exception");
             throw new RuntimeDataException(ErrorCode.DOUBLE_RECOVERY_ATTEMPTS);
         }
         if (retryPolicyFactory == NoRetryPolicyFactory.INSTANCE) {
-            LOGGER.log(level, "But it has no recovery policy, so it is set to permanent failure");
+            LOGGER.log(Level.WARNING, "But it has no recovery policy, so it is set to permanent failure");
             setState(ActivityState.PERMANENTLY_FAILED);
         } else {
             ExecutorService executor = appCtx.getServiceContext().getControllerService().getExecutor();
             IRetryPolicy policy = retryPolicyFactory.create(this);
             cancelRecovery = false;
             setState(ActivityState.TEMPORARILY_FAILED);
-            LOGGER.log(level, "Recovery task has been submitted");
-            recoveryTask = executor.submit(() -> {
-                String nameBefore = Thread.currentThread().getName();
-                try {
-                    Thread.currentThread().setName("RecoveryTask (" + entityId + ")");
-                    doRecover(policy);
-                } finally {
-                    Thread.currentThread().setName(nameBefore);
-                }
-                return null;
-            });
+            LOGGER.log(Level.WARNING, "Recovery task has been submitted");
+            recoveryTask = executor.submit(() -> doRecover(policy));
         }
     }
 
     protected Void doRecover(IRetryPolicy policy)
             throws AlgebricksException, HyracksDataException, InterruptedException {
-        LOGGER.log(level, "Actual Recovery task has started");
+        LOGGER.log(Level.WARNING, "Actual Recovery task has started");
         if (getState() != ActivityState.TEMPORARILY_FAILED) {
-            LOGGER.log(level, "but its state is not temp failure and so we're just returning");
+            LOGGER.log(Level.WARNING, "but its state is not temp failure and so we're just returning");
             return null;
         }
-        LOGGER.log(level, "calling the policy");
+        LOGGER.log(Level.WARNING, "calling the policy");
         while (policy.retry()) {
             synchronized (this) {
                 if (cancelRecovery) {
                     recoveryTask = null;
-                    notifyAll();
                     return null;
                 }
                 while (clusterStateManager.getState() != ClusterState.ACTIVE) {
                     if (cancelRecovery) {
                         recoveryTask = null;
-                        notifyAll();
                         return null;
                     }
                     wait();
@@ -409,18 +399,11 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
             }
             synchronized (this) {
                 try {
-                    if (cancelRecovery) {
-                        recoveryTask = null;
-                        notifyAll();
-                        return null;
-                    }
                     setState(ActivityState.RECOVERING);
                     doStart(metadataProvider);
-                    recoveryTask = null;
-                    notifyAll();
                     return null;
                 } catch (Exception e) {
-                    LOGGER.log(level, "Attempt to revive " + entityId + " failed", e);
+                    LOGGER.log(Level.WARNING, "Attempt to revive " + entityId + " failed", e);
                     setState(ActivityState.TEMPORARILY_FAILED);
                     recoverFailure = e;
                 } finally {
@@ -429,14 +412,6 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
                 notifyAll();
             }
         }
-        // Recovery task is essntially over now either through failure or through cancellation(stop)
-        synchronized (this) {
-            recoveryTask = null;
-            notifyAll();
-            if (state != ActivityState.TEMPORARILY_FAILED) {
-                return null;
-            }
-        }
         IMetadataLockManager lockManager = metadataProvider.getApplicationContext().getMetadataLockManager();
         try {
             lockManager.acquireActiveEntityWriteLock(metadataProvider.getLocks(),
@@ -448,6 +423,7 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
             synchronized (this) {
                 if (state == ActivityState.TEMPORARILY_FAILED) {
                     setState(ActivityState.PERMANENTLY_FAILED);
+                    recoveryTask = null;
                 }
                 notifyAll();
             }
@@ -489,40 +465,49 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
             throws HyracksDataException, AlgebricksException;
 
     @Override
-    public synchronized void stop(MetadataProvider metadataProvider) throws HyracksDataException, InterruptedException {
-        waitForNonTransitionState();
-        if (state != ActivityState.RUNNING && state != ActivityState.PERMANENTLY_FAILED
-                && state != ActivityState.TEMPORARILY_FAILED) {
-            throw new RuntimeDataException(ErrorCode.ACTIVE_ENTITY_CANNOT_BE_STOPPED, entityId, state);
-        }
-        if (state == ActivityState.TEMPORARILY_FAILED || state == ActivityState.PERMANENTLY_FAILED) {
-            if (recoveryTask != null) {
+    public void stop(MetadataProvider metadataProvider) throws HyracksDataException, InterruptedException {
+        Future<Void> aRecoveryTask = null;
+        synchronized (this) {
+            waitForNonTransitionState();
+            if (state != ActivityState.RUNNING && state != ActivityState.PERMANENTLY_FAILED
+                    && state != ActivityState.TEMPORARILY_FAILED) {
+                throw new RuntimeDataException(ErrorCode.ACTIVE_ENTITY_CANNOT_BE_STOPPED, entityId, state);
+            }
+            if (state == ActivityState.TEMPORARILY_FAILED || state == ActivityState.PERMANENTLY_FAILED) {
+                if (recoveryTask != null) {
+                    aRecoveryTask = recoveryTask;
+                    cancelRecovery = true;
+                    recoveryTask.cancel(true);
+                }
+                setState(ActivityState.STOPPED);
+                try {
+                    setRunning(metadataProvider, false);
+                } catch (Exception e) {
+                    LOGGER.log(Level.SEVERE, "Failed to set the entity state as not running " + entityId, e);
+                    throw HyracksDataException.create(e);
+                }
+            } else if (state == ActivityState.RUNNING) {
                 setState(ActivityState.STOPPING);
-                cancelRecovery = true;
-                recoveryTask.cancel(true);
-                while (recoveryTask != null) {
-                    wait();
+                try {
+                    doStop(metadataProvider);
+                    setRunning(metadataProvider, false);
+                } catch (Exception e) {
+                    setState(ActivityState.PERMANENTLY_FAILED);
+                    LOGGER.log(Level.SEVERE, "Failed to stop the entity " + entityId, e);
+                    throw HyracksDataException.create(e);
                 }
+            } else {
+                throw new RuntimeDataException(ErrorCode.ACTIVE_ENTITY_CANNOT_BE_STOPPED, entityId, state);
             }
-            setState(ActivityState.STOPPED);
-            try {
-                setRunning(metadataProvider, false);
-            } catch (Exception e) {
-                LOGGER.log(Level.SEVERE, "Failed to set the entity state as not running " + entityId, e);
-                throw HyracksDataException.create(e);
-            }
-        } else if (state == ActivityState.RUNNING) {
-            setState(ActivityState.STOPPING);
-            try {
-                doStop(metadataProvider);
-                setRunning(metadataProvider, false);
-            } catch (Exception e) {
-                setState(ActivityState.PERMANENTLY_FAILED);
-                LOGGER.log(Level.SEVERE, "Failed to stop the entity " + entityId, e);
-                throw HyracksDataException.create(e);
+        }
+        try {
+            if (aRecoveryTask != null) {
+                aRecoveryTask.get();
             }
-        } else {
-            throw new RuntimeDataException(ErrorCode.ACTIVE_ENTITY_CANNOT_BE_STOPPED, entityId, state);
+        } catch (InterruptedException e) {
+            throw e;
+        } catch (Exception e) {
+            throw HyracksDataException.create(e);
         }
     }
 
@@ -531,10 +516,10 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
         WaitForStateSubscriber subscriber;
         Future<Void> suspendTask;
         synchronized (this) {
-            LOGGER.log(level, "suspending entity " + entityId);
-            LOGGER.log(level, "Waiting for ongoing activities");
+            LOGGER.log(Level.WARNING, "suspending entity " + entityId);
+            LOGGER.log(Level.WARNING, "Waiting for ongoing activities");
             waitForNonTransitionState();
-            LOGGER.log(level, "Proceeding with suspension. Current state is " + state);
+            LOGGER.log(Level.WARNING, "Proceeding with suspension. Current state is " + state);
             if (state == ActivityState.STOPPED || state == ActivityState.PERMANENTLY_FAILED) {
                 suspended = true;
                 return;
@@ -552,12 +537,12 @@ public abstract class ActiveEntityEventsListener implements IActiveEntityControl
                     EnumSet.of(ActivityState.SUSPENDED, ActivityState.TEMPORARILY_FAILED));
             suspendTask = metadataProvider.getApplicationContext().getServiceContext().getControllerService()
                     .getExecutor().submit(() -> doSuspend(metadataProvider));
-            LOGGER.log(level, "Suspension task has been submitted");
+            LOGGER.log(Level.WARNING, "Suspension task has been submitted");
         }
         try {
-            LOGGER.log(level, "Waiting for suspension task to complete");
+            LOGGER.log(Level.WARNING, "Waiting for suspension task to complete");
             suspendTask.get();
-            LOGGER.log(level, "waiting for state to become SUSPENDED or TEMPORARILY_FAILED");
+            LOGGER.log(Level.WARNING, "waiting for state to become SUSPENDED or TEMPORARILY_FAILED");
             subscriber.sync();
         } catch (Exception e) {
             synchronized (this) {