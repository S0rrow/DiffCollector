diff --git a/modules/orchestrator/orchestrator-core/src/main/java/org/apache/airavata/orchestrator/core/impl/EmbeddedGFACJobSubmitter.java b/modules/orchestrator/orchestrator-core/src/main/java/org/apache/airavata/orchestrator/core/impl/EmbeddedGFACJobSubmitter.java
index cde97bdcc..d3852baa1 100644
--- a/modules/orchestrator/orchestrator-core/src/main/java/org/apache/airavata/orchestrator/core/impl/EmbeddedGFACJobSubmitter.java
+++ b/modules/orchestrator/orchestrator-core/src/main/java/org/apache/airavata/orchestrator/core/impl/EmbeddedGFACJobSubmitter.java
@@ -21,36 +21,40 @@
 package org.apache.airavata.orchestrator.core.impl;
 
 
-import java.io.File;
-import java.net.URL;
-import java.util.*;
-
 import org.apache.airavata.client.api.AiravataAPI;
-import org.apache.airavata.client.api.exception.AiravataAPIInvocationException;
 import org.apache.airavata.common.utils.AiravataJobState;
 import org.apache.airavata.common.utils.ServerSettings;
 import org.apache.airavata.commons.gfac.type.ApplicationDescription;
 import org.apache.airavata.commons.gfac.type.HostDescription;
 import org.apache.airavata.commons.gfac.type.ServiceDescription;
 import org.apache.airavata.gfac.Constants;
-import org.apache.airavata.gfac.cpi.GFacAPI;
+import org.apache.airavata.gfac.GFacAPI;
 import org.apache.airavata.gfac.GFacConfiguration;
+import org.apache.airavata.gfac.GFacException;
 import org.apache.airavata.gfac.context.ApplicationContext;
 import org.apache.airavata.gfac.context.JobExecutionContext;
 import org.apache.airavata.gfac.context.MessageContext;
 import org.apache.airavata.gfac.scheduler.HostScheduler;
-import org.apache.airavata.model.experiment.ConfigurationData;
 import org.apache.airavata.orchestrator.core.context.OrchestratorContext;
 import org.apache.airavata.orchestrator.core.exception.OrchestratorException;
 import org.apache.airavata.orchestrator.core.gfac.GFACInstance;
 import org.apache.airavata.orchestrator.core.job.JobSubmitter;
+import org.apache.airavata.orchestrator.core.utils.OrchestratorConstants;
 import org.apache.airavata.orchestrator.core.utils.OrchestratorUtils;
+import org.apache.airavata.registry.api.AiravataRegistry2;
 import org.apache.airavata.registry.api.JobRequest;
-import org.apache.airavata.registry.cpi.DataType;
-import org.apache.airavata.registry.cpi.DependentDataType;
-import org.apache.airavata.registry.cpi.TopLevelDataType;
+import org.apache.airavata.registry.api.exception.RegistryException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
+import org.xml.sax.SAXException;
+
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.xpath.XPathExpressionException;
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.util.List;
+import java.util.Properties;
 
 /**
  * This is the simplest implementation for JobSubmitter,
@@ -63,17 +67,16 @@ public class EmbeddedGFACJobSubmitter implements JobSubmitter {
     private OrchestratorContext orchestratorContext;
 
 
-    public void initialize(OrchestratorContext orchestratorContext) throws OrchestratorException {
+    public void initialize(OrchestratorContext orchestratorContext)  throws OrchestratorException {
         this.orchestratorContext = orchestratorContext;
     }
 
-    public GFACInstance selectGFACInstance() throws OrchestratorException {
+    public GFACInstance selectGFACInstance()  throws OrchestratorException {
         return null;  //To change body of implemented methods use File | Settings | File Templates.
     }
 
 
-	 //FIXME: (MEP) why are you passing in a GFACInstance?  It isn't used. 
-    public boolean submitJob(GFACInstance gfac, List<String> experimentIDList) throws OrchestratorException {
+    public boolean submitJob(GFACInstance gfac, List<String> experimentIDList)  throws OrchestratorException {
 
         for (int i = 0; i < experimentIDList.size(); i++) {
             try {
@@ -87,101 +90,51 @@ public class EmbeddedGFACJobSubmitter implements JobSubmitter {
         return true;
     }
 
-	 //FIXME: (MEP) This method is pretty gruesome.  If we really expect multiple implementations of the JobSubmitter
-	 // interface and at least some of them will need to do the stuff in this method, then we need a parent class GenericJobSubmitterImpl.java (maybe abstract) that includes launchGfacWithJobRequest() so that subclasses can inherit it.
-    private void launchGfacWithJobRequest(JobRequest jobRequest) throws OrchestratorException {
-        String experimentID = OrchestratorUtils.getUniqueID(jobRequest);
-        ConfigurationData configurationData = (ConfigurationData)
-                orchestratorContext.getNewRegistry().get(DataType.EXPERIMENT_CONFIGURATION_DATA, experimentID);
-
-        String serviceName = configurationData.getApplicationId();
-
-        if (serviceName == null) {
-            throw new OrchestratorException("Error executing the job because there is not Application Name in this Experiment");
-        }
-
+    private void launchGfacWithJobRequest(JobRequest jobRequest) throws RegistryException, ParserConfigurationException, IOException, SAXException, XPathExpressionException, GFacException {
+        String serviceName = jobRequest.getServiceDescription().getType().getName();
         //todo submit the jobs
 
-        AiravataAPI airavataAPI = null;
-        try {
-
-            airavataAPI = orchestratorContext.getOrchestratorConfiguration().getAiravataAPI();
-            //FIXME: (MEP) Why do all of this validation here?  Is it needed?  Why would you get an empty job request?
-            //FIXME: (MEP) If you do need this, it should go into a utility class or something similar that does the validation.
-            HostDescription hostDescription = jobRequest.getHostDescription();
-            if (hostDescription == null) {
-                List<HostDescription> registeredHosts = new ArrayList<HostDescription>();
-                Map<String, ApplicationDescription> applicationDescriptors = airavataAPI.getApplicationManager().getApplicationDescriptors(serviceName);
-                for (String hostDescName : applicationDescriptors.keySet()) {
-                    registeredHosts.add(airavataAPI.getApplicationManager().getHostDescription(hostDescName));
-                }
-                Class<? extends HostScheduler> aClass = Class.forName(ServerSettings.getHostScheduler()).asSubclass(HostScheduler.class);
-                HostScheduler hostScheduler = aClass.newInstance();
-                hostDescription = hostScheduler.schedule(registeredHosts);
-            }
-
-            ServiceDescription serviceDescription = jobRequest.getServiceDescription();
-            if (serviceDescription == null) {
-                try {
-                    serviceDescription = airavataAPI.getApplicationManager().getServiceDescription(jobRequest.getServiceName());
-                } catch (AiravataAPIInvocationException e) {
-                    String error = "Error retrieving document from Registry: " + jobRequest.getServiceName();
-                    throw new OrchestratorException(error, e);
-                }
-            }
-
-            ApplicationDescription applicationDescription = jobRequest.getApplicationDescription();
-            if (applicationDescription == null) {
-                applicationDescription = airavataAPI.getApplicationManager().getApplicationDescription(serviceName, hostDescription.getType().getHostName());
-            }
-            // When we run getInParameters we set the actualParameter object, this has to be fixed
-            //FIXME: will these class loaders work correctly in Thrift?
-            //FIXME: gfac-config.xml is only under src/test.
-            URL resource = EmbeddedGFACJobSubmitter.class.getClassLoader().getResource("gfac-config.xml");
-            Properties configurationProperties = ServerSettings.getProperties();
-            GFacConfiguration gFacConfiguration = GFacConfiguration.create(new File(resource.getPath()), airavataAPI, configurationProperties);
+        //after successfully submitting the jobs set the status of the job to submitted
+        String experimentID = OrchestratorUtils.getUniqueID(jobRequest);
+        orchestratorContext.getRegistry().changeStatus(experimentID, AiravataJobState.State.SUBMITTED);
+        AiravataAPI airavataAPI = orchestratorContext.getOrchestratorConfiguration().getAiravataAPI();
+        ServiceDescription serviceDescription = jobRequest.getServiceDescription();
 
-            JobExecutionContext jobExecutionContext = new JobExecutionContext(gFacConfiguration, serviceName);
-            //Here we get only the contextheader information sent specific for this node
-            //Add security context
+        ApplicationDescription applicationDescription = jobRequest.getApplicationDescription();
 
+        // When we run getInParameters we set the actualParameter object, this has to be fixed
+        URL resource = EmbeddedGFACJobSubmitter.class.getClassLoader().getResource("gfac-config.xml");
+        Properties configurationProperties = ServerSettings.getProperties();
+        GFacConfiguration gFacConfiguration = GFacConfiguration.create(new File(resource.getPath()), airavataAPI, configurationProperties);
 
-            ApplicationContext applicationContext = new ApplicationContext();
-            applicationContext.setApplicationDeploymentDescription(applicationDescription);
-            applicationContext.setHostDescription(hostDescription);
-            applicationContext.setServiceDescription(serviceDescription);
+        JobExecutionContext jobExecutionContext = new JobExecutionContext(gFacConfiguration, serviceName);
+        //Here we get only the contextheader information sent specific for this node
+        //Add security context
 
-            jobExecutionContext.setApplicationContext(applicationContext);
 
+        ApplicationContext applicationContext = new ApplicationContext();
+        applicationContext.setApplicationDeploymentDescription(applicationDescription);
+        applicationContext.setHostDescription(jobRequest.getHostDescription());
+        applicationContext.setServiceDescription(serviceDescription);
 
-            Map<String, String> experimentInputs = configurationData.getExperimentInputs();
+        jobExecutionContext.setApplicationContext(applicationContext);
 
-            jobExecutionContext.setInMessageContext(new MessageContext(OrchestratorUtils.getMessageContext(experimentInputs,
-                    serviceDescription.getType().getInputParametersArray())));
+        jobExecutionContext.setOutMessageContext(new MessageContext(jobRequest.getOutputParameters()));
+        jobExecutionContext.setInMessageContext(new MessageContext(jobRequest.getInputParameters()));
 
-            HashMap<String, Object> outputData = new HashMap<String, Object>();
-            jobExecutionContext.setOutMessageContext(new MessageContext(outputData));
+        jobExecutionContext.setProperty(Constants.PROP_TOPIC, experimentID);
+        jobExecutionContext.setProperty(Constants.PROP_BROKER_URL, orchestratorContext.getOrchestratorConfiguration().getBrokerURL().toString());
 
-            jobExecutionContext.setProperty(Constants.PROP_TOPIC, experimentID);
-            jobExecutionContext.setExperimentID(experimentID);
-            //FIXME: (MEP) GFacAPI.submitJob() throws a GFacException that isn't caught here. You want to catch this before updating the registry.
-            GFacAPI gfacAPI1 = new GFacAPI();
-            gfacAPI1.submitJob(jobExecutionContext);
-            //FIXME: (MEP) It may be better to change the registry status in GFacAPI rather then here.
-            orchestratorContext.getRegistry().changeStatus(experimentID, AiravataJobState.State.SUBMITTED);
-        } catch (Exception e) {
-            throw new OrchestratorException("Error launching the Job", e);
-        }
+        GFacAPI gfacAPI1 = new GFacAPI();
+        gfacAPI1.submitJob(jobExecutionContext);
     }
 
-	 //FIXME: (MEP) I suggest putting this into a separate JobSubmitter implementation.  If so, launchGfacWithJobRequest() needs to be in an inherited parent.
     public boolean directJobSubmit(JobRequest request) throws OrchestratorException {
         try {
             launchGfacWithJobRequest(request);
         } catch (Exception e) {
-            String error = "Error launching the job : " + OrchestratorUtils.getUniqueID(request);
-            logger.error(error);
-            throw new OrchestratorException(error);
+            logger.error("Error launching the job : " + OrchestratorUtils.getUniqueID(request));
+
         }
         return true;
     }