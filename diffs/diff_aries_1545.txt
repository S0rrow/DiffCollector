diff --git a/blueprint-core/src/main/java/org/apache/geronimo/blueprint/container/ServiceRecipe.java b/blueprint-core/src/main/java/org/apache/geronimo/blueprint/container/ServiceRecipe.java
index e2c62973a..b0815b407 100644
--- a/blueprint-core/src/main/java/org/apache/geronimo/blueprint/container/ServiceRecipe.java
+++ b/blueprint-core/src/main/java/org/apache/geronimo/blueprint/container/ServiceRecipe.java
@@ -24,7 +24,6 @@ import java.util.Hashtable;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.geronimo.blueprint.BlueprintConstants;
 import org.apache.geronimo.blueprint.ExtendedBlueprintContainer;
@@ -33,6 +32,7 @@ import org.apache.geronimo.blueprint.di.AbstractRecipe;
 import org.apache.geronimo.blueprint.di.CollectionRecipe;
 import org.apache.geronimo.blueprint.di.MapRecipe;
 import org.apache.geronimo.blueprint.di.Recipe;
+import org.apache.geronimo.blueprint.di.RefRecipe;
 import org.apache.geronimo.blueprint.di.Repository;
 import org.apache.geronimo.blueprint.utils.JavaUtils;
 import org.apache.geronimo.blueprint.utils.ReflectionUtils;
@@ -42,6 +42,9 @@ import org.osgi.framework.ServiceFactory;
 import org.osgi.framework.ServiceReference;
 import org.osgi.framework.ServiceRegistration;
 import org.osgi.service.blueprint.container.ComponentDefinitionException;
+import org.osgi.service.blueprint.reflect.BeanMetadata;
+import org.osgi.service.blueprint.reflect.ComponentMetadata;
+import org.osgi.service.blueprint.reflect.Metadata;
 import org.osgi.service.blueprint.reflect.RefMetadata;
 import org.osgi.service.blueprint.reflect.ServiceMetadata;
 import org.slf4j.Logger;
@@ -57,20 +60,21 @@ public class ServiceRecipe extends AbstractRecipe {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(ServiceRecipe.class);
 
-    private final ExtendedBlueprintContainer blueprintContainer;
-    private final ServiceMetadata metadata;
-    private final Recipe serviceRecipe;
-    private final CollectionRecipe listenersRecipe;
-    private final MapRecipe propertiesRecipe;
-    private final List<Recipe> explicitDependencies;
+    private ExtendedBlueprintContainer blueprintContainer;
+    private ServiceMetadata metadata;
+    private Recipe serviceRecipe;
+    private CollectionRecipe listenersRecipe;
+    private MapRecipe propertiesRecipe;
+    private List<Recipe> explicitDependencies;
 
     private Map properties;
-    private final AtomicBoolean registered = new AtomicBoolean();
-    private volatile ServiceRegistration registration;
+    private boolean registered;
+    private ServiceRegistration registration;
     private Map registrationProperties;
     private List<ServiceListener> listeners;
-    private volatile Object service;
-    
+    private Object service;
+    private boolean prototypeService;
+
     public ServiceRecipe(String name,
                          ExtendedBlueprintContainer blueprintContainer,
                          ServiceMetadata metadata,
@@ -87,25 +91,9 @@ public class ServiceRecipe extends AbstractRecipe {
         this.propertiesRecipe = propertiesRecipe;
         this.explicitDependencies = explicitDependencies;
     }
-    
-    public Recipe getServiceRecipe() {
-        return serviceRecipe;
-    }
-
-    public CollectionRecipe getListenersRecipe() {
-        return listenersRecipe;
-    }
 
     @Override
-    public List<Recipe> getConstructorDependencies() {
-        List<Recipe> recipes = new ArrayList<Recipe>();
-        if (explicitDependencies != null) {
-            recipes.addAll(explicitDependencies);
-        }
-        return recipes;
-    }
-    
-    public List<Recipe> getDependencies() {
+    public List<Recipe> getNestedRecipes() {
         List<Recipe> recipes = new ArrayList<Recipe>();
         if (serviceRecipe != null) {
             recipes.add(serviceRecipe);
@@ -115,36 +103,34 @@ public class ServiceRecipe extends AbstractRecipe {
         }
         if (propertiesRecipe != null) {
             recipes.add(propertiesRecipe);
-        }        
-        recipes.addAll(getConstructorDependencies());        
+        }
+        if (explicitDependencies != null) {
+            recipes.addAll(explicitDependencies);
+        }
         return recipes;
     }
 
     protected Object internalCreate() throws ComponentDefinitionException {
+        if (explicitDependencies != null) {
+            for (Recipe recipe : explicitDependencies) {
+                recipe.create();
+            }
+        }
         ServiceRegistrationProxy proxy = new ServiceRegistrationProxy();
-        addPartialObject(proxy);
-        internalGetService(null, null); // null bundle means we don't want to retrieve the actual service when used with a ServiceFactory
+        addObject(proxy, true);
+        getService();
         return proxy;
     }
 
-    public boolean isRegistered() {
-        return registered.get();
-    }
-
-    public void register() {
-        if (registered.compareAndSet(false, true)) {
-            createExplicitDependencies();
-            
+    public synchronized void register() {
+        if (!isRegistered()) {
+            registered = true;
             Hashtable props = new Hashtable();
             if (properties == null) {
-                properties = (Map) createRecipe(propertiesRecipe);
+                properties = (Map) createSimpleRecipe(propertiesRecipe);
             }
             props.putAll(properties);
-            if (metadata.getRanking() == 0) {
-                props.remove(Constants.SERVICE_RANKING);
-            } else {
-                props.put(Constants.SERVICE_RANKING, metadata.getRanking());
-            }
+            props.put(Constants.SERVICE_RANKING, metadata.getRanking());
             String componentName = getComponentName();
             if (componentName != null) {
                 props.put(BlueprintConstants.COMPONENT_NAME_PROPERTY, componentName);
@@ -161,34 +147,16 @@ public class ServiceRecipe extends AbstractRecipe {
             LOGGER.debug("Registering service {} with interfaces {} and properties {}",
                          new Object[] { name, classes, props });
 
+            registration = blueprintContainer.getBundleContext().registerService(classArray, new TriggerServiceFactory(), props);
             registrationProperties = props;
-            registration = blueprintContainer.registerService(classArray, new TriggerServiceFactory(), props);            
         }
     }
 
-    public void unregister() {
-        if (registered.compareAndSet(true, false)) {
-            LOGGER.debug("Unregistering service {}", name);
-            // This method needs to allow reentrance, so if we need to make sure the registration is
-            // set to null before actually unregistering the service
-            ServiceRegistration reg = registration;
-            if (listeners != null) {
-                LOGGER.debug("Calling listeners for service unregistration");
-                for (ServiceListener listener : listeners) {
-                    listener.unregister(service, registrationProperties);
-                }
-            }
-            if (reg != null) {
-                reg.unregister();
-            }
-            // We need to do this hack in order to support reantrancy
-            if (registration == reg) {
-                registration = null;
-            }
-        }
+    public synchronized boolean isRegistered() {
+        return registered;
     }
 
-    protected ServiceReference getReference() {
+    public synchronized ServiceReference getReference() {
         if (registration == null) {
             throw new IllegalStateException("Service is not registered");
         } else {
@@ -196,7 +164,7 @@ public class ServiceRecipe extends AbstractRecipe {
         }
     }
 
-    protected void setProperties(Dictionary props) {
+    public synchronized void setProperties(Dictionary props) {
         if (registration == null) {
             throw new IllegalStateException("Service is not registered");
         } else {
@@ -206,151 +174,144 @@ public class ServiceRecipe extends AbstractRecipe {
     }
 
 
-    protected Object internalGetService() {
-        return internalGetService(blueprintContainer.getBundleContext().getBundle(), null);
-    }
-
-    /**
-     * Create the service object.
-     * We need to synchronize the access to the repository,
-     * but not on this ServiceRecipe instance to avoid deadlock.
-     * When using internalCreate(), no other lock but the on the repository
-     * should be held.
-     *
-     * @param bundle
-     * @param registration
-     * @return
-     */
-    private Object internalGetService(Bundle bundle, ServiceRegistration registration) {
-        LOGGER.debug("Retrieving service for bundle {} and service registration {}", bundle, registration);
-        if (this.service == null) {
-            synchronized (blueprintContainer.getRepository().getInstanceLock()) {
-                if (this.service == null) {
-                    createService();
+    public synchronized void unregister() {
+        if (isRegistered()) {
+            registered = false;
+            LOGGER.debug("Unregistering service {}", name);
+            // This method needs to allow reentrance, so if we need to make sure the registration is
+            // set to null before actually unregistering the service
+            ServiceRegistration reg = registration;
+            if (listeners != null) {
+                LOGGER.debug("Calling listeners for service unregistration");
+                for (ServiceListener listener : listeners) {
+                    listener.unregister(prototypeService || service instanceof ServiceFactory ? null : service, registrationProperties);
                 }
             }
-        }
-        Object service = this.service;
-        // We need the real service ...
-        if (bundle != null) {
-            if (service instanceof ServiceFactory) {
-                service = ((ServiceFactory) service).getService(bundle, registration);
-            }
-            if (service == null) {
-                throw new IllegalStateException("service is null");
+            reg.unregister();
+            // We need to do this hack in order to support reantrancy
+            if (registration == reg) {
+                registration = null;
             }
-            // Check if the service actually implement all the requested interfaces
-            validateClasses(service);
-        // We're not really interested in the service, but perform some sanity checks nonetheless
-        } else {
-             if (!(service instanceof ServiceFactory)) {
-                 // Check if the service actually implement all the requested interfaces
-                 validateClasses(service);
-             }
         }
-        return service;
+    }
+    
+    public Object getService() {
+        return getService(blueprintContainer.getBundleContext().getBundle(), null);
     }
 
-    private void createService() {
-        try {
-            LOGGER.debug("Creating service instance");
-            service = createRecipe(serviceRecipe);
-            LOGGER.debug("Service created: {}", service);
-            // When the service is first requested, we need to create listeners and call them
-            if (listeners == null) {
-                LOGGER.debug("Creating listeners");
-                if (listenersRecipe != null) {
-                    listeners = (List) createRecipe(listenersRecipe);
-                } else {
-                    listeners = Collections.emptyList();
-                }
-                LOGGER.debug("Listeners created: {}", listeners);
-                if (registered.get()) {
-                    LOGGER.debug("Calling listeners for initial service registration");
-                    for (ServiceListener listener : listeners) {
-                        listener.register(service, registrationProperties);
-                    }
-                } else {
-                    LOGGER.debug("Calling listeners for initial service unregistration");
-                    for (ServiceListener listener : listeners) {
-                        listener.unregister(service, registrationProperties);
+    public Object getService(Bundle bundle, ServiceRegistration registration) {
+        LOGGER.debug("Retrieving service for bundle {} and service registration {}", bundle, registration);
+        // Create initial service
+        synchronized (this) {
+            if (this.service == null) {
+                try {
+                    prototypeService = isPrototypeService(metadata.getServiceComponent());
+                    LOGGER.debug("Creating service instance");
+                    this.service = createInstance();
+                    LOGGER.debug("Service created: {}", this.service);
+                    // When the service is first requested, we need to create listeners and call them
+                    if (listeners == null) {
+                        LOGGER.debug("Creating listeners");
+                        if (listenersRecipe != null) {
+                            listeners = (List) createSimpleRecipe(listenersRecipe);
+                        } else {
+                            listeners = Collections.emptyList();
+                        }
+                        LOGGER.debug("Listeners created: {}", listeners);
+                        LOGGER.debug("Calling listeners for service registration");
+                        for (ServiceListener listener : listeners) {
+                            listener.register(prototypeService || service instanceof ServiceFactory ? null : service,
+                                              registrationProperties);
+                        }
                     }
+                } catch (RuntimeException e) {
+                    LOGGER.error("Error retrieving service from " + this, e);
+                    throw e;
                 }
             }
-        } catch (RuntimeException e) {
-            LOGGER.error("Error retrieving service from " + this, e);
-            throw e;
         }
-    }
-    
-    private void validateClasses(Object service) {
-        // Check if the service actually implement all the requested interfaces
-        if (metadata.getAutoExport() == ServiceMetadata.AUTO_EXPORT_DISABLED) {
-            Set<String> allClasses = new HashSet<String>();
-            ReflectionUtils.getSuperClasses(allClasses, service.getClass());
-            ReflectionUtils.getImplementedInterfaces(allClasses, service.getClass());
-            Set<String> classes = getClasses();
-            classes.removeAll(allClasses);
-            if (!classes.isEmpty()) {
-                throw new ComponentDefinitionException("The service implementation does not implement the required interfaces: " + classes);
-            }
+        Object service = this.service;
+        if (service instanceof ServiceFactory) {
+            service = ((ServiceFactory) service).getService(bundle, registration);
+        } else {
+            service = createInstance();
+            LOGGER.debug("Created service instance for bundle: " + bundle + " " + service.hashCode());
         }
-    }
-
-    public synchronized Object getService(Bundle bundle, ServiceRegistration registration) {
-        /** getService() can get called before registerService() returns with the registration object.
-         *  So we need to set the registration object in case registration listeners call 
-         *  getServiceReference(). 
-         */
-        if (this.registration == null) {
-            this.registration = registration;
+        if (service == null) {
+            throw new IllegalStateException("service is null");
         }
-        return internalGetService(bundle, registration);
+        return service;
     }
 
-    public synchronized void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
+    public void ungetService(Bundle bundle, ServiceRegistration registration, Object service) {
         if (this.service instanceof ServiceFactory) {
             ((ServiceFactory) this.service).ungetService(bundle, registration, service);
         }
+        if (prototypeService) {
+            destroyInstance(service);
+            LOGGER.debug("Destroyed service instance for bundle: " + bundle);
+        }
     }
 
     private Set<String> getClasses() {
         Set<String> classes;
-        switch (metadata.getAutoExport()) {
+        switch (metadata.getAutoExportMode()) {
             case ServiceMetadata.AUTO_EXPORT_INTERFACES:
-                classes = ReflectionUtils.getImplementedInterfaces(new HashSet<String>(), internalGetService().getClass());
+                classes = ReflectionUtils.getImplementedInterfaces(new HashSet<String>(), getService().getClass());
                 break;
             case ServiceMetadata.AUTO_EXPORT_CLASS_HIERARCHY:
-                classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), internalGetService().getClass());
+                classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), getService().getClass());
                 break;
             case ServiceMetadata.AUTO_EXPORT_ALL_CLASSES:
-                classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), internalGetService().getClass());
-                classes = ReflectionUtils.getImplementedInterfaces(classes, internalGetService().getClass());
+                classes = ReflectionUtils.getSuperClasses(new HashSet<String>(), getService().getClass());
+                classes = ReflectionUtils.getImplementedInterfaces(classes, getService().getClass());
                 break;
             default:
-                classes = new HashSet<String>(metadata.getInterfaces());
+                classes = new HashSet<String>(metadata.getInterfaceNames());
                 break;
         }
         return classes;
     }
 
-    private void createExplicitDependencies() {
-        if (explicitDependencies != null) {
-            for (Recipe recipe : explicitDependencies) {
-                createRecipe(recipe);
-            }
-        }
+    private Object createInstance() {
+        return createSimpleRecipe(serviceRecipe);
     }
-    
-    private Object createRecipe(Recipe recipe) {
+
+    private Object createSimpleRecipe(Recipe recipe) {
         String name = recipe.getName();
         Repository repo = blueprintContainer.getRepository();
         if (repo.getRecipe(name) != recipe) {
             repo.putRecipe(name, recipe);
         }
-        return repo.create(name);
+        BlueprintObjectInstantiator graph = new BlueprintObjectInstantiator(blueprintContainer, repo);
+        return graph.create(name);
+    }
+
+    private void destroyInstance(Object instance) {
+        Recipe recipe = serviceRecipe;
+        Repository objectRepository = blueprintContainer.getRepository();
+        if (recipe instanceof RefRecipe) {
+            recipe = objectRepository.getRecipe(((RefRecipe) recipe).getIdRef());
+        }
+        ((BeanRecipe) recipe).destroyInstance(instance);
     }
-   
+
+    private boolean isPrototypeService(Metadata value) {
+        ComponentMetadata metadata = null;
+        if (value instanceof RefMetadata) {
+            RefMetadata ref = (RefMetadata) value;
+            metadata = blueprintContainer.getComponentDefinitionRegistry().getComponentDefinition(ref.getComponentId());
+        } else if (value instanceof ComponentMetadata) {
+            metadata = (ComponentMetadata) value;
+        }
+        if (metadata instanceof BeanMetadata) {
+            BeanMetadata bean = (BeanMetadata) metadata;
+            return BeanMetadata.SCOPE_PROTOTYPE.equals(bean.getScope());
+        } else {
+            return false;
+        }
+    }
+
     private String getComponentName() {
         if (metadata.getServiceComponent() instanceof RefMetadata) {
             RefMetadata ref = (RefMetadata) metadata.getServiceComponent();
@@ -394,9 +355,9 @@ public class ServiceRecipe extends AbstractRecipe {
         }
 
         public void updateProperties(Dictionary properties) {
-            Hashtable table = JavaUtils.getProperties(ServiceRecipe.this.getReference());
+            Hashtable table = JavaUtils.getProperties(getReference());
             JavaUtils.copy(table, properties);
-            ServiceRecipe.this.setProperties(table);
+            setProperties(table);
         }        
     }
 