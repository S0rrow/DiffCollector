diff --git a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java
index 877b9a6641..165c3b8964 100644
--- a/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java
+++ b/server/base/src/main/java/org/apache/accumulo/server/fs/VolumeManagerImpl.java
@@ -16,15 +16,12 @@
  */
 package org.apache.accumulo.server.fs;
 
-import static com.google.common.base.Preconditions.checkNotNull;
-
 import java.io.IOException;
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.net.URI;
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Collections;
 import java.util.EnumSet;
 import java.util.HashMap;
@@ -37,14 +34,12 @@ import org.apache.accumulo.core.conf.DefaultConfiguration;
 import org.apache.accumulo.core.conf.Property;
 import org.apache.accumulo.core.data.Key;
 import org.apache.accumulo.core.data.KeyExtent;
-import org.apache.accumulo.core.file.rfile.RFile;
+import org.apache.accumulo.core.file.FileUtil;
 import org.apache.accumulo.core.util.CachedConfiguration;
-import org.apache.accumulo.core.volume.NonConfiguredVolume;
-import org.apache.accumulo.core.volume.Volume;
-import org.apache.accumulo.core.volume.VolumeConfiguration;
+import org.apache.accumulo.server.ServerConstants;
+import org.apache.accumulo.server.client.HdfsZooInstance;
 import org.apache.accumulo.server.conf.ServerConfiguration;
 import org.apache.commons.lang.NotImplementedException;
-import org.apache.commons.lang.StringUtils;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.ContentSummary;
 import org.apache.hadoop.fs.FSDataInputStream;
@@ -59,50 +54,34 @@ import org.apache.hadoop.hdfs.DistributedFileSystem;
 import org.apache.hadoop.util.Progressable;
 import org.apache.log4j.Logger;
 
-import com.google.common.collect.HashMultimap;
-import com.google.common.collect.Multimap;
-
 public class VolumeManagerImpl implements VolumeManager {
 
   private static final Logger log = Logger.getLogger(VolumeManagerImpl.class);
 
-  Map<String,Volume> volumesByName;
-  Multimap<URI,Volume> volumesByFileSystemUri;
-  Volume defaultVolume;
+  Map<String,? extends FileSystem> volumes;
+  FileSystem defaultVolume;
   AccumuloConfiguration conf;
   VolumeChooser chooser;
 
-  protected VolumeManagerImpl(Map<String,Volume> volumes, Volume defaultVolume, AccumuloConfiguration conf) {
-    this.volumesByName = volumes;
-    this.defaultVolume = defaultVolume;
-    // We may have multiple directories used in a single FileSystem (e.g. testing)
-    this.volumesByFileSystemUri = HashMultimap.create();
-    invertVolumesByFileSystem(volumesByName, volumesByFileSystemUri);
+  protected VolumeManagerImpl(Map<String,? extends FileSystem> volumes, String defaultVolume, AccumuloConfiguration conf) {
+    this.volumes = volumes;
+    this.defaultVolume = volumes.get(defaultVolume);
     this.conf = conf;
     ensureSyncIsEnabled();
     chooser = Property.createInstanceFromPropertyName(conf, Property.GENERAL_VOLUME_CHOOSER, VolumeChooser.class, new RandomVolumeChooser());
   }
 
-  private void invertVolumesByFileSystem(Map<String,Volume> forward, Multimap<URI,Volume> inverted) {
-    for (Volume volume : forward.values()) {
-      inverted.put(volume.getFileSystem().getUri(), volume);
-    }
-  }
-
-  public static org.apache.accumulo.server.fs.VolumeManager getLocal(String localBasePath) throws IOException {
-    AccumuloConfiguration accConf = DefaultConfiguration.getDefaultConfiguration();
-    Volume defaultLocalVolume = VolumeConfiguration.create(FileSystem.getLocal(CachedConfiguration.getInstance()), localBasePath);
-
-    // The default volume gets placed in the map, but local filesystem is only used for testing purposes
-    return new VolumeManagerImpl(Collections.singletonMap(DEFAULT, defaultLocalVolume), defaultLocalVolume, accConf);
+  public static org.apache.accumulo.server.fs.VolumeManager getLocal() throws IOException {
+    return new VolumeManagerImpl(Collections.singletonMap("", FileSystem.getLocal(CachedConfiguration.getInstance())), "",
+        DefaultConfiguration.getDefaultConfiguration());
   }
 
   @Override
   public void close() throws IOException {
     IOException ex = null;
-    for (Volume volume : volumesByName.values()) {
+    for (FileSystem fs : volumes.values()) {
       try {
-        volume.getFileSystem().close();
+        fs.close();
       } catch (IOException e) {
         ex = e;
       }
@@ -114,20 +93,14 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public FSDataOutputStream create(Path path) throws IOException {
-    checkNotNull(path);
-
-    Volume v = getVolumeByPath(path);
-
-    return v.getFileSystem().create(path);
+    FileSystem fs = getFileSystemByPath(path);
+    return fs.create(path);
   }
 
   @Override
   public FSDataOutputStream create(Path path, boolean overwrite) throws IOException {
-    checkNotNull(path);
-
-    Volume v = getVolumeByPath(path);
-
-    return v.getFileSystem().create(path, overwrite);
+    FileSystem fs = getFileSystemByPath(path);
+    return fs.create(path, overwrite);
   }
 
   private static long correctBlockSize(Configuration conf, long blockSize) {
@@ -148,27 +121,22 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public FSDataOutputStream create(Path path, boolean overwrite, int bufferSize, short replication, long blockSize) throws IOException {
-    checkNotNull(path);
-
-    Volume v = getVolumeByPath(path);
-    FileSystem fs = v.getFileSystem();
-    blockSize = correctBlockSize(fs.getConf(), blockSize);
-    bufferSize = correctBufferSize(fs.getConf(), bufferSize);
-    return fs.create(path, overwrite, bufferSize, replication, blockSize);
+    FileSystem fs = getFileSystemByPath(path);
+    if (bufferSize == 0) {
+      fs.getConf().getInt("io.file.buffer.size", 4096);
+    }
+    return fs.create(path, overwrite, bufferSize, replication, correctBlockSize(fs.getConf(), blockSize));
   }
 
   @Override
   public boolean createNewFile(Path path) throws IOException {
-    checkNotNull(path);
-
-    Volume v = getVolumeByPath(path);
-    return v.getFileSystem().createNewFile(path);
+    FileSystem fs = getFileSystemByPath(path);
+    return fs.createNewFile(path);
   }
 
   @Override
   public FSDataOutputStream createSyncable(Path logPath, int bufferSize, short replication, long blockSize) throws IOException {
-    Volume v = getVolumeByPath(logPath);
-    FileSystem fs = v.getFileSystem();
+    FileSystem fs = getFileSystemByPath(logPath);
     blockSize = correctBlockSize(fs.getConf(), blockSize);
     bufferSize = correctBufferSize(fs.getConf(), bufferSize);
     try {
@@ -206,18 +174,28 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public boolean delete(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().delete(path, false);
+    return getFileSystemByPath(path).delete(path, false);
   }
 
   @Override
   public boolean deleteRecursively(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().delete(path, true);
+    return getFileSystemByPath(path).delete(path, true);
   }
 
   protected void ensureSyncIsEnabled() {
-    for (Entry<String,Volume> entry : getFileSystems().entrySet()) {
+    for (Entry<String,? extends FileSystem> entry : getFileSystems().entrySet()) {
       final String volumeName = entry.getKey();
-      FileSystem fs = entry.getValue().getFileSystem();
+      FileSystem fs = entry.getValue();
+
+      if (ViewFSUtils.isViewFS(fs)) {
+        try {
+          FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path("/")).getFileSystem(fs.getConf());
+          log.debug("resolved " + fs.getUri() + " to " + resolvedFs.getUri() + " for sync check");
+          fs = resolvedFs;
+        } catch (IOException e) {
+          log.warn("Failed to resolve " + fs.getUri(), e);
+        }
+      }
 
       if (fs instanceof DistributedFileSystem) {
         final String DFS_DURABLE_SYNC = "dfs.durable.sync", DFS_SUPPORT_APPEND = "dfs.support.append";
@@ -277,38 +255,19 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public boolean exists(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().exists(path);
+    return getFileSystemByPath(path).exists(path);
   }
 
   @Override
   public FileStatus getFileStatus(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().getFileStatus(path);
+    return getFileSystemByPath(path).getFileStatus(path);
   }
 
   @Override
-  public Volume getVolumeByPath(Path path) {
+  public FileSystem getFileSystemByPath(Path path) {
     if (path.toString().contains(":")) {
       try {
-        FileSystem desiredFs = path.getFileSystem(CachedConfiguration.getInstance());
-        URI desiredFsUri = desiredFs.getUri();
-        Collection<Volume> candidateVolumes = volumesByFileSystemUri.get(desiredFsUri);
-        if (null != candidateVolumes) {
-          for (Volume candidateVolume : candidateVolumes) {
-            if (candidateVolume.isValidPath(path)) {
-              return candidateVolume;
-            }
-          }
-
-          // For the same reason as we can have multiple Volumes within a single filesystem
-          // we could also not find a matching one. We should still provide a Volume with the
-          // correct FileSystem even though we don't know what the proper base dir is
-          // e.g. Files on volumes that are now removed
-          log.debug("Found candidate Volumes for Path but none of the Paths are valid on the candidates: " + path);
-        }
-
-        log.debug("Could not determine volume for Path: " + path);
-
-        return new NonConfiguredVolume(desiredFs);
+        return path.getFileSystem(CachedConfiguration.getInstance());
       } catch (IOException ex) {
         throw new RuntimeException(ex);
       }
@@ -317,31 +276,29 @@ public class VolumeManagerImpl implements VolumeManager {
     return defaultVolume;
   }
 
-  private Map<String,Volume> getFileSystems() {
-    return volumesByName;
+  private Map<String,? extends FileSystem> getFileSystems() {
+    return volumes;
   }
 
   @Override
   public FileStatus[] listStatus(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().listStatus(path);
+    return getFileSystemByPath(path).listStatus(path);
   }
 
   @Override
   public boolean mkdirs(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().mkdirs(path);
+    return getFileSystemByPath(path).mkdirs(path);
   }
 
   @Override
   public FSDataInputStream open(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().open(path);
+    return getFileSystemByPath(path).open(path);
   }
 
   @Override
   public boolean rename(Path path, Path newPath) throws IOException {
-    Volume srcVolume = getVolumeByPath(path);
-    Volume destVolume = getVolumeByPath(newPath);
-    FileSystem source = srcVolume.getFileSystem();
-    FileSystem dest = destVolume.getFileSystem();
+    FileSystem source = getFileSystemByPath(path);
+    FileSystem dest = getFileSystemByPath(newPath);
     if (source != dest) {
       throw new NotImplementedException("Cannot rename files across volumes: " + path + " -> " + newPath);
     }
@@ -350,15 +307,14 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public boolean moveToTrash(Path path) throws IOException {
-    FileSystem fs = getVolumeByPath(path).getFileSystem();
+    FileSystem fs = getFileSystemByPath(path);
     Trash trash = new Trash(fs, fs.getConf());
     return trash.moveToTrash(path);
   }
 
   @Override
   public short getDefaultReplication(Path path) {
-    Volume v = getVolumeByPath(path);
-    FileSystem fs = v.getFileSystem();
+    FileSystem fs = getFileSystemByPath(path);
     try {
       // try calling hadoop 2 method
       Method method = fs.getClass().getMethod("getDefaultReplication", Path.class);
@@ -380,44 +336,47 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public boolean isFile(Path path) throws IOException {
-    return getVolumeByPath(path).getFileSystem().isFile(path);
+    return getFileSystemByPath(path).isFile(path);
   }
 
   public static VolumeManager get() throws IOException {
-    AccumuloConfiguration conf = ServerConfiguration.getSiteConfiguration();
+    AccumuloConfiguration conf = ServerConfiguration.getSystemConfiguration(HdfsZooInstance.getInstance());
     return get(conf);
   }
 
   static private final String DEFAULT = "";
 
   public static VolumeManager get(AccumuloConfiguration conf) throws IOException {
-    final Map<String,Volume> volumes = new HashMap<String,Volume>();
-    final Configuration hadoopConf = CachedConfiguration.getInstance();
-
-    // The "default" Volume for Accumulo (in case no volumes are specified)
-    for (String volumeUriOrDir : VolumeConfiguration.getVolumeUris(conf)) {
-      if (volumeUriOrDir.equals(DEFAULT))
-        // Cannot re-define the default volume
-        throw new IllegalArgumentException();
-
-      if (volumeUriOrDir.startsWith("viewfs"))
+    Map<String,FileSystem> fileSystems = new HashMap<String,FileSystem>();
+    Configuration hadoopConf = CachedConfiguration.getInstance();
+    fileSystems.put(DEFAULT, FileUtil.getFileSystem(hadoopConf, conf));
+    for (String space : ServerConstants.getConfiguredBaseDirs(conf)) {
+      if (space.equals(DEFAULT))
         throw new IllegalArgumentException();
 
-      // We require a URI here, fail if it doesn't look like one
-      if (volumeUriOrDir.contains(":")) {
-        volumes.put(volumeUriOrDir, VolumeConfiguration.create(new Path(volumeUriOrDir), hadoopConf));
+      if (space.contains(":")) {
+        fileSystems.put(space, new Path(space).getFileSystem(hadoopConf));
       } else {
-        throw new IllegalArgumentException("Expected fully qualified URI for " + Property.INSTANCE_VOLUMES.getKey() + " got " + volumeUriOrDir);
+        throw new IllegalArgumentException("Expected fully qualified URI for " + Property.INSTANCE_VOLUMES.getKey() + " got " + space);
       }
     }
 
-    return new VolumeManagerImpl(volumes, VolumeConfiguration.getDefaultVolume(hadoopConf, conf), conf);
+    return new VolumeManagerImpl(fileSystems, DEFAULT, conf);
   }
 
   @Override
   public boolean isReady() throws IOException {
-    for (Volume volume : getFileSystems().values()) {
-      FileSystem fs = volume.getFileSystem();
+    for (FileSystem fs : getFileSystems().values()) {
+
+      if (ViewFSUtils.isViewFS(fs)) {
+        try {
+          FileSystem resolvedFs = ViewFSUtils.resolvePath(fs, new Path("/")).getFileSystem(fs.getConf());
+          log.debug("resolved " + fs.getUri() + " to " + resolvedFs.getUri() + " for ready check");
+          fs = resolvedFs;
+        } catch (IOException e) {
+          log.warn("Failed to resolve " + fs.getUri(), e);
+        }
+      }
 
       if (!(fs instanceof DistributedFileSystem))
         continue;
@@ -462,7 +421,7 @@ public class VolumeManagerImpl implements VolumeManager {
 
   @Override
   public FileStatus[] globStatus(Path pathPattern) throws IOException {
-    return getVolumeByPath(pathPattern).getFileSystem().globStatus(pathPattern);
+    return getFileSystemByPath(pathPattern).globStatus(pathPattern);
   }
 
   @Override
@@ -511,53 +470,24 @@ public class VolumeManagerImpl implements VolumeManager {
     return getFullPath(FileType.TABLE, path);
   }
 
-  private static final String RFILE_SUFFIX = "." + RFile.EXTENSION;
-
   @Override
   public Path getFullPath(FileType fileType, String path) {
-    int colon = path.indexOf(':');
-    if (colon > -1) {
-      // Check if this is really an absolute path or if this is a 1.4 style relative path for a WAL
-      if (fileType == FileType.WAL && path.charAt(colon + 1) != '/') {
-        path = path.substring(path.indexOf('/'));
-      } else {
-        return new Path(path);
-      }
-    }
+    if (path.contains(":"))
+      return new Path(path);
 
+    // normalize the path
+    Path fullPath = new Path(ServerConstants.getDefaultBaseDir(), fileType.getDirectory());
     if (path.startsWith("/"))
       path = path.substring(1);
-
-    // ACCUMULO-2974 To ensure that a proper absolute path is created, the caller needs to include the table ID
-    // in the relative path. Fail when this doesn't appear to happen.
-    if (FileType.TABLE == fileType) {
-      // Trailing slash doesn't create an additional element
-      String[] pathComponents = StringUtils.split(path, Path.SEPARATOR_CHAR);
-
-      // Is an rfile
-      if (path.endsWith(RFILE_SUFFIX)) {
-        if (pathComponents.length < 3) {
-          throw new IllegalArgumentException("Fewer components in file path than expected");
-        }
-      } else {
-        // is a directory
-        if (pathComponents.length < 2) {
-          throw new IllegalArgumentException("Fewer components in directory path than expected");
-        }
-      }
-    }
-
-    // normalize the path
-    Path fullPath = new Path(defaultVolume.getBasePath(), fileType.getDirectory());
     fullPath = new Path(fullPath, path);
 
-    FileSystem fs = getVolumeByPath(fullPath).getFileSystem();
+    FileSystem fs = getFileSystemByPath(fullPath);
     return fs.makeQualified(fullPath);
   }
 
   @Override
   public ContentSummary getContentSummary(Path dir) throws IOException {
-    return getVolumeByPath(dir).getFileSystem().getContentSummary(dir);
+    return getFileSystemByPath(dir).getContentSummary(dir);
   }
 
   @Override
@@ -565,14 +495,4 @@ public class VolumeManagerImpl implements VolumeManager {
     return chooser.choose(options);
   }
 
-  @Override
-  public Volume getDefaultVolume() {
-    return defaultVolume;
-  }
-
-  @Override
-  public Collection<Volume> getVolumes() {
-    return volumesByName.values();
-  }
-
 }