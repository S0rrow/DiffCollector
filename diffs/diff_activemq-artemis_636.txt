diff --git a/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java b/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java
index 006f05e9a3..c64374a238 100644
--- a/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java
+++ b/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/amq/AMQSession.java
@@ -28,8 +28,6 @@ import org.apache.activemq.artemis.core.paging.PagingStore;
 import org.apache.activemq.artemis.core.postoffice.RoutingStatus;
 import org.apache.activemq.artemis.core.protocol.openwire.OpenWireConnection;
 import org.apache.activemq.artemis.core.protocol.openwire.OpenWireMessageConverter;
-import org.apache.activemq.artemis.core.protocol.openwire.OpenWireProtocolManager;
-import org.apache.activemq.artemis.core.protocol.openwire.util.OpenWireUtil;
 import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.BindingQueryResult;
@@ -40,7 +38,9 @@ import org.apache.activemq.artemis.core.server.ServerConsumer;
 import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
 import org.apache.activemq.artemis.core.server.SlowConsumerDetectionListener;
+import org.apache.activemq.artemis.core.settings.impl.AddressFullMessagePolicy;
 import org.apache.activemq.artemis.spi.core.protocol.SessionCallback;
+import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
 import org.apache.activemq.artemis.utils.IDGenerator;
 import org.apache.activemq.artemis.utils.SimpleIDGenerator;
@@ -51,12 +51,12 @@ import org.apache.activemq.command.Message;
 import org.apache.activemq.command.MessageDispatch;
 import org.apache.activemq.command.ProducerAck;
 import org.apache.activemq.command.ProducerInfo;
-import org.apache.activemq.command.Response;
 import org.apache.activemq.command.SessionInfo;
 import org.apache.activemq.openwire.OpenWireFormat;
 import org.apache.activemq.wireformat.WireFormat;
 
 public class AMQSession implements SessionCallback {
+
    // ConsumerID is generated inside the session, 0, 1, 2, ... as many consumers as you have on the session
    protected final IDGenerator consumerIDGenerator = new SimpleIDGenerator(0);
 
@@ -75,20 +75,17 @@ public class AMQSession implements SessionCallback {
    // so we make a new one per AMQSession
    private final OpenWireMessageConverter converter;
 
-   private final OpenWireProtocolManager protocolManager;
-
    public AMQSession(ConnectionInfo connInfo,
                      SessionInfo sessInfo,
                      ActiveMQServer server,
                      OpenWireConnection connection,
-                     OpenWireProtocolManager protocolManager) {
+                     ScheduledExecutorService scheduledPool) {
       this.connInfo = connInfo;
       this.sessInfo = sessInfo;
 
       this.server = server;
       this.connection = connection;
-      this.protocolManager = protocolManager;
-      this.scheduledPool = protocolManager.getScheduledPool();
+      this.scheduledPool = scheduledPool;
       OpenWireFormat marshaller = (OpenWireFormat) connection.getMarshaller();
 
       this.converter = new OpenWireMessageConverter(marshaller.copy());
@@ -112,7 +109,7 @@ public class AMQSession implements SessionCallback {
       // now
 
       try {
-         coreSession = server.createSession(name, username, password, minLargeMessageSize, connection, true, false, false, false, null, this, true, connection.getOperationContext(), protocolManager.getPrefixes());
+         coreSession = server.createSession(name, username, password, minLargeMessageSize, connection, true, false, false, false, null, this, true, connection.getOperationContext());
 
          long sessionId = sessInfo.getSessionId().getValue();
          if (sessionId == -1) {
@@ -149,7 +146,7 @@ public class AMQSession implements SessionCallback {
 
       for (ActiveMQDestination openWireDest : dests) {
          if (openWireDest.isQueue()) {
-            SimpleString queueName = new SimpleString(OpenWireUtil.convertWildcard(openWireDest.getPhysicalName()));
+            SimpleString queueName = new SimpleString(openWireDest.getPhysicalName());
 
             if (!checkAutoCreateQueue(queueName, openWireDest.isTemporary())) {
                throw new InvalidDestinationException("Destination doesn't exist: " + queueName);
@@ -172,7 +169,7 @@ public class AMQSession implements SessionCallback {
          BindingQueryResult bindingQuery = server.bindingQuery(queueName);
          QueueQueryResult queueBinding = server.queueQuery(queueName);
 
-         boolean isAutoCreate = bindingQuery.isExists() ? true : bindingQuery.isAutoCreateQueues();
+         boolean isAutoCreate = bindingQuery.isExists() ?  true : bindingQuery.isAutoCreateJmsQueues();
 
          if (!queueBinding.isExists()) {
             if (isAutoCreate) {
@@ -208,7 +205,7 @@ public class AMQSession implements SessionCallback {
    }
 
    @Override
-   public boolean isWritable(ReadyListener callback, Object protocolContext) {
+   public boolean isWritable(ReadyListener callback) {
       return connection.isWritable(callback);
    }
 
@@ -301,103 +298,108 @@ public class AMQSession implements SessionCallback {
          originalCoreMsg.putStringProperty(org.apache.activemq.artemis.api.core.Message.HDR_DUPLICATE_DETECTION_ID.toString(), messageSend.getMessageId().toString());
       }
 
-      boolean shouldBlockProducer = producerInfo.getWindowSize() > 0 || messageSend.isResponseRequired();
+      Runnable runnable;
+
+      if (sendProducerAck) {
+         runnable = new Runnable() {
+            @Override
+            public void run() {
+               try {
+                  ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), messageSend.getSize());
+                  connection.dispatchSync(ack);
+               } catch (Exception e) {
+                  ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
+                  connection.sendException(e);
+               }
+
+            }
+         };
+      } else {
+         final Connection transportConnection = connection.getTransportConnection();
+
+         if (transportConnection == null) {
+            // I don't think this could happen, but just in case, avoiding races
+            runnable = null;
+         } else {
+            runnable = new Runnable() {
+               @Override
+               public void run() {
+                  transportConnection.setAutoRead(true);
+               }
+            };
+         }
+      }
+
+      internalSend(actualDestinations, originalCoreMsg, runnable);
+   }
 
-      final AtomicInteger count = new AtomicInteger(actualDestinations.length);
+   private void internalSend(ActiveMQDestination[] actualDestinations,
+                             ServerMessage originalCoreMsg,
+                             final Runnable onComplete) throws Exception {
 
-      final Exception[] anyException = new Exception[] {null};
+      Runnable runToUse;
 
-      if (shouldBlockProducer) {
-         connection.getContext().setDontSendReponse(true);
+      if (actualDestinations.length <= 1 || onComplete == null) {
+         // if onComplete is null, this will be null ;)
+         runToUse = onComplete;
+      } else {
+         final AtomicInteger count = new AtomicInteger(actualDestinations.length);
+         runToUse = new Runnable() {
+            @Override
+            public void run() {
+               if (count.decrementAndGet() == 0) {
+                  onComplete.run();
+               }
+            }
+         };
       }
 
+      SimpleString[] addresses = new SimpleString[actualDestinations.length];
+      PagingStore[] pagingStores = new PagingStore[actualDestinations.length];
+
+      // We fillup addresses, pagingStores and we will throw failure if that's the case
       for (int i = 0; i < actualDestinations.length; i++) {
          ActiveMQDestination dest = actualDestinations[i];
-         SimpleString address = new SimpleString(dest.getPhysicalName());
+         addresses[i] = new SimpleString(dest.getPhysicalName());
+         pagingStores[i] = server.getPagingManager().getPageStore(addresses[i]);
+         if (pagingStores[i].getAddressFullMessagePolicy() == AddressFullMessagePolicy.FAIL && pagingStores[i].isFull()) {
+            throw new ResourceAllocationException("Queue is full");
+         }
+      }
+
+      for (int i = 0; i < actualDestinations.length; i++) {
+
          ServerMessage coreMsg = originalCoreMsg.copy();
-         coreMsg.setAddress(address);
+
+         coreMsg.setAddress(addresses[i]);
+
+         PagingStore store = pagingStores[i];
+
+         if (store.isFull()) {
+            connection.getTransportConnection().setAutoRead(false);
+         }
 
          if (actualDestinations[i].isQueue()) {
             checkAutoCreateQueue(new SimpleString(actualDestinations[i].getPhysicalName()), actualDestinations[i].isTemporary());
+         }
+
+         if (actualDestinations[i].isQueue()) {
             coreMsg.putByteProperty(org.apache.activemq.artemis.api.core.Message.HDR_ROUTING_TYPE, RoutingType.ANYCAST.getType());
          } else {
             coreMsg.putByteProperty(org.apache.activemq.artemis.api.core.Message.HDR_ROUTING_TYPE, RoutingType.MULTICAST.getType());
          }
-         PagingStore store = server.getPagingManager().getPageStore(address);
-
-
-         this.connection.disableTtl();
-         if (shouldBlockProducer) {
-            if (!store.checkMemory(() -> {
-               try {
-                  RoutingStatus result = getCoreSession().send(coreMsg, false, dest.isTemporary());
-
-                  if (result == RoutingStatus.NO_BINDINGS && dest.isQueue()) {
-                     throw new InvalidDestinationException("Cannot publish to a non-existent Destination: " + dest);
-                  }
-               } catch (Exception e) {
-                  if (anyException[0] == null) {
-                     anyException[0] = e;
-                  }
-               }
-               connection.enableTtl();
-               if (count.decrementAndGet() == 0) {
-                  if (anyException[0] != null) {
-                     this.connection.getContext().setDontSendReponse(false);
-                     ActiveMQServerLogger.LOGGER.warn(anyException[0].getMessage(), anyException[0]);
-                     connection.sendException(anyException[0]);
-                  } else {
-                     if (sendProducerAck) {
-                        try {
-                           ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), messageSend.getSize());
-                           connection.dispatchAsync(ack);
-                        } catch (Exception e) {
-                           this.connection.getContext().setDontSendReponse(false);
-                           ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
-                           connection.sendException(e);
-                        }
-                     } else {
-                        connection.getContext().setDontSendReponse(false);
-                        try {
-                           Response response = new Response();
-                           response.setCorrelationId(messageSend.getCommandId());
-                           connection.dispatchAsync(response);
-                        } catch (Exception e) {
-                           ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
-                           connection.sendException(e);
-                        }
-                     }
-                  }
-               }
-            })) {
-               this.connection.getContext().setDontSendReponse(false);
-               connection.enableTtl();
-               throw new ResourceAllocationException("Queue is full " + address);
-            }
-         } else {
-            //non-persistent messages goes here, by default we stop reading from
-            //transport
-            connection.getTransportConnection().setAutoRead(false);
-            if (!store.checkMemory(() -> {
-               connection.getTransportConnection().setAutoRead(true);
-               connection.enableTtl();
-            })) {
-               connection.getTransportConnection().setAutoRead(true);
-               connection.enableTtl();
-               throw new ResourceAllocationException("Queue is full " + address);
-            }
+         RoutingStatus result = getCoreSession().send(coreMsg, false, actualDestinations[i].isTemporary());
 
-            RoutingStatus result = getCoreSession().send(coreMsg, false, dest.isTemporary());
-            if (result == RoutingStatus.NO_BINDINGS && dest.isQueue()) {
-               throw new InvalidDestinationException("Cannot publish to a non-existent Destination: " + dest);
-            }
+         if (result == RoutingStatus.NO_BINDINGS && actualDestinations[i].isQueue()) {
+            throw new InvalidDestinationException("Cannot publish to a non-existent Destination: " + actualDestinations[i]);
+         }
 
-            if (count.decrementAndGet() == 0) {
-               if (sendProducerAck) {
-                  ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), messageSend.getSize());
-                  connection.dispatchAsync(ack);
-               }
-            }
+         if (runToUse != null) {
+            // if the timeout is >0, it will wait this much milliseconds
+            // before running the the runToUse
+            // this will eventually unblock blocked destinations
+            // playing flow control
+            store.checkMemory(runToUse);
          }
       }
    }