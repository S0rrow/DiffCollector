diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/cursor/impl/PageCursorProviderImpl.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/cursor/impl/PageCursorProviderImpl.java
index ef57e1c769..318ac72d7d 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/cursor/impl/PageCursorProviderImpl.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/cursor/impl/PageCursorProviderImpl.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -24,8 +24,6 @@ import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.activemq.artemis.api.core.ActiveMQException;
-import org.apache.activemq.artemis.api.core.ActiveMQIOErrorException;
 import org.apache.activemq.artemis.core.filter.Filter;
 import org.apache.activemq.artemis.core.paging.PagedMessage;
 import org.apache.activemq.artemis.core.paging.PagingStore;
@@ -42,14 +40,14 @@ import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.core.transaction.impl.TransactionImpl;
 import org.apache.activemq.artemis.utils.FutureLatch;
 import org.apache.activemq.artemis.utils.SoftValueHashMap;
-
 /**
  * A PageProviderIMpl
  *
  * TODO: this may be moved entirely into PagingStore as there's an one-to-one relationship here
- * However I want to keep this isolated as much as possible during development
+ *       However I want to keep this isolated as much as possible during development
  */
-public class PageCursorProviderImpl implements PageCursorProvider {
+public class PageCursorProviderImpl implements PageCursorProvider
+{
    // Constants -----------------------------------------------------
 
    boolean isTrace = ActiveMQServerLogger.LOGGER.isTraceEnabled();
@@ -72,7 +70,7 @@ public class PageCursorProviderImpl implements PageCursorProvider {
 
    private final SoftValueHashMap<Long, PageCache> softCache;
 
-   private final ConcurrentMap<Long, PageSubscription> activeCursors = new ConcurrentHashMap<>();
+   private final ConcurrentMap<Long, PageSubscription> activeCursors = new ConcurrentHashMap<Long, PageSubscription>();
 
    // Static --------------------------------------------------------
 
@@ -81,40 +79,45 @@ public class PageCursorProviderImpl implements PageCursorProvider {
    public PageCursorProviderImpl(final PagingStore pagingStore,
                                  final StorageManager storageManager,
                                  final Executor executor,
-                                 final int maxCacheSize) {
+                                 final int maxCacheSize)
+   {
       this.pagingStore = pagingStore;
       this.storageManager = storageManager;
       this.executor = executor;
-      this.softCache = new SoftValueHashMap<>(maxCacheSize);
+      this.softCache = new SoftValueHashMap<Long, PageCache>(maxCacheSize);
    }
 
    // Public --------------------------------------------------------
 
-   @Override
-   public synchronized PageSubscription createSubscription(long cursorID, Filter filter, boolean persistent) {
-      if (ActiveMQServerLogger.LOGGER.isTraceEnabled()) {
+   public synchronized PageSubscription createSubscription(long cursorID, Filter filter, boolean persistent)
+   {
+      if (ActiveMQServerLogger.LOGGER.isTraceEnabled())
+      {
          ActiveMQServerLogger.LOGGER.trace(this.pagingStore.getAddress() + " creating subscription " + cursorID + " with filter " + filter, new Exception("trace"));
       }
 
-      if (activeCursors.containsKey(cursorID)) {
+      if (activeCursors.containsKey(cursorID))
+      {
          throw new IllegalStateException("Cursor " + cursorID + " had already been created");
       }
 
-      PageSubscription activeCursor = new PageSubscriptionImpl(this, pagingStore, storageManager, executor, filter, cursorID, persistent);
+      PageSubscription activeCursor =
+               new PageSubscriptionImpl(this, pagingStore, storageManager, executor, filter, cursorID, persistent);
       activeCursors.put(cursorID, activeCursor);
       return activeCursor;
    }
 
-   @Override
-   public synchronized PageSubscription getSubscription(long cursorID) {
+   public synchronized PageSubscription getSubscription(long cursorID)
+   {
       return activeCursors.get(cursorID);
    }
 
-   @Override
-   public PagedMessage getMessage(final PagePosition pos) throws ActiveMQException {
+   public PagedMessage getMessage(final PagePosition pos)
+   {
       PageCache cache = getPageCache(pos.getPageNr());
 
-      if (cache == null || pos.getMessageNr() >= cache.getNumberOfMessages()) {
+      if (cache == null || pos.getMessageNr() >= cache.getNumberOfMessages())
+      {
          // sanity check, this should never happen unless there's a bug
          throw new IllegalStateException("Invalid messageNumber passed = " + pos + " on " + cache);
       }
@@ -122,111 +125,138 @@ public class PageCursorProviderImpl implements PageCursorProvider {
       return cache.getMessage(pos.getMessageNr());
    }
 
-   @Override
    public PagedReference newReference(final PagePosition pos,
                                       final PagedMessage msg,
-                                      final PageSubscription subscription) {
+                                      final PageSubscription subscription)
+   {
       return new PagedReferenceImpl(pos, msg, subscription);
    }
 
-   @Override
-   public PageCache getPageCache(final long pageId) throws ActiveMQException {
-      try {
-         PageCache cache;
-         synchronized (softCache) {
-            if (pageId > pagingStore.getCurrentWritingPage()) {
+   public PageCache getPageCache(final long pageId)
+   {
+      try
+      {
+         boolean needToRead = false;
+         PageCache cache = null;
+         synchronized (softCache)
+         {
+            if (pageId > pagingStore.getCurrentWritingPage())
+            {
                return null;
             }
 
             cache = softCache.get(pageId);
-            if (cache == null) {
-               if (!pagingStore.checkPageFileExists((int) pageId)) {
+            if (cache == null)
+            {
+               if (!pagingStore.checkPageFileExists((int)pageId))
+               {
                   return null;
                }
 
                cache = createPageCache(pageId);
+               needToRead = true;
                // anyone reading from this cache will have to wait reading to finish first
                // we also want only one thread reading this cache
-               if (isTrace) {
-                  ActiveMQServerLogger.LOGGER.trace("adding " + pageId + " into cursor = " + this.pagingStore.getAddress());
+               cache.lock();
+               if (isTrace)
+               {
+                  ActiveMQServerLogger.LOGGER.trace("adding " + pageId +  " into cursor = " + this.pagingStore.getAddress());
                }
-               readPage((int) pageId, cache);
                softCache.put(pageId, cache);
             }
          }
 
-         return cache;
-      }
-      catch (Throwable e) {
-         throw new ActiveMQIOErrorException("Couldn't complete paging due to an IO Exception on Paging - " + e.getMessage(), e);
-      }
-   }
-
-   private void readPage(int pageId, PageCache cache) throws Exception {
-      Page page = null;
-      try {
-         page = pagingStore.createPage(pageId);
+         // Reading is done outside of the synchronized block, however
+         // the page stays locked until the entire reading is finished
+         if (needToRead)
+         {
+            Page page = null;
+            try
+            {
+               page = pagingStore.createPage((int)pageId);
 
-         storageManager.beforePageRead();
-         page.open();
+               storageManager.beforePageRead();
+               page.open();
 
-         List<PagedMessage> pgdMessages = page.read(storageManager);
-         cache.setMessages(pgdMessages.toArray(new PagedMessage[pgdMessages.size()]));
-      }
-      finally {
-         try {
-            if (page != null) {
-               page.close();
+               List<PagedMessage> pgdMessages = page.read(storageManager);
+               cache.setMessages(pgdMessages.toArray(new PagedMessage[pgdMessages.size()]));
+            }
+            finally
+            {
+               try
+               {
+                  if (page != null)
+                  {
+                     page.close();
+                  }
+               }
+               catch (Throwable ignored)
+               {
+               }
+               storageManager.afterPageRead();
+               cache.unlock();
             }
          }
-         catch (Throwable ignored) {
-         }
-         storageManager.afterPageRead();
+
+         return cache;
+      }
+      catch (Exception e)
+      {
+         throw new RuntimeException("Couldn't complete paging due to an IO Exception on Paging - " + e.getMessage(), e);
       }
    }
 
-   @Override
-   public void addPageCache(PageCache cache) {
-      synchronized (softCache) {
+   public void addPageCache(PageCache cache)
+   {
+      synchronized (softCache)
+      {
          softCache.put(cache.getPageId(), cache);
       }
    }
 
-   @Override
-   public void setCacheMaxSize(final int size) {
+   public void setCacheMaxSize(final int size)
+   {
       softCache.setMaxElements(size);
    }
 
-   @Override
-   public int getCacheSize() {
-      synchronized (softCache) {
+   public int getCacheSize()
+   {
+      synchronized (softCache)
+      {
          return softCache.size();
       }
    }
 
-   public void clearCache() {
-      synchronized (softCache) {
+   public void clearCache()
+   {
+      synchronized (softCache)
+      {
          softCache.clear();
       }
    }
 
-   @Override
-   public void processReload() throws Exception {
+   public void processReload() throws Exception
+   {
       Collection<PageSubscription> cursorList = this.activeCursors.values();
-      for (PageSubscription cursor : cursorList) {
+      for (PageSubscription cursor : cursorList)
+      {
          cursor.processReload();
       }
 
-      if (!cursorList.isEmpty()) {
+      if (!cursorList.isEmpty())
+      {
          // https://issues.jboss.org/browse/JBPAPP-10338 if you ack out of order,
          // the min page could be beyond the first page.
          // we have to reload any previously acked message
          long cursorsMinPage = checkMinPage(cursorList);
 
          // checkMinPage will return MaxValue if there aren't any pages or any cursors
-         if (cursorsMinPage != Long.MAX_VALUE) {
-            for (long startPage = pagingStore.getFirstPage(); startPage < cursorsMinPage; startPage++) {
-               for (PageSubscription cursor : cursorList) {
+         if (cursorsMinPage != Long.MAX_VALUE)
+         {
+            for (long startPage = pagingStore.getFirstPage(); startPage < cursorsMinPage; startPage++)
+            {
+               for (PageSubscription cursor : cursorList)
+               {
                   cursor.reloadPageInfo(startPage);
                }
             }
@@ -237,44 +267,50 @@ public class PageCursorProviderImpl implements PageCursorProvider {
 
    }
 
-   @Override
-   public void stop() {
-      for (PageSubscription cursor : activeCursors.values()) {
+   public void stop()
+   {
+      for (PageSubscription cursor : activeCursors.values())
+      {
          cursor.stop();
       }
 
       waitForFuture();
    }
 
-   private void waitForFuture() {
+   private void waitForFuture()
+   {
       FutureLatch future = new FutureLatch();
 
       executor.execute(future);
 
-      while (!future.await(10000)) {
+      while (!future.await(10000))
+      {
          ActiveMQServerLogger.LOGGER.timedOutStoppingPagingCursor(future, executor);
       }
    }
 
-   @Override
-   public void flushExecutors() {
-      for (PageSubscription cursor : activeCursors.values()) {
+   public void flushExecutors()
+   {
+      for (PageSubscription cursor : activeCursors.values())
+      {
          cursor.flushExecutors();
       }
       waitForFuture();
    }
 
-   @Override
-   public void close(PageSubscription cursor) {
+   public void close(PageSubscription cursor)
+   {
       activeCursors.remove(cursor.getId());
 
       scheduleCleanup();
    }
 
    @Override
-   public void scheduleCleanup() {
+   public void scheduleCleanup()
+   {
 
-      if (!cleanupEnabled || scheduledCleanup.intValue() > 2) {
+      if (!cleanupEnabled || scheduledCleanup.intValue() > 2)
+      {
          // Scheduled cleanup was already scheduled before.. never mind!
          // or we have cleanup disabled
          return;
@@ -282,14 +318,17 @@ public class PageCursorProviderImpl implements PageCursorProvider {
 
       scheduledCleanup.incrementAndGet();
 
-      executor.execute(new Runnable() {
-         @Override
-         public void run() {
+      executor.execute(new Runnable()
+      {
+         public void run()
+         {
             storageManager.setContext(storageManager.newSingleThreadContext());
-            try {
+            try
+            {
                cleanup();
             }
-            finally {
+            finally
+            {
                storageManager.clearContext();
                scheduledCleanup.decrementAndGet();
             }
@@ -303,61 +342,74 @@ public class PageCursorProviderImpl implements PageCursorProvider {
     * Hence the PagingStore will be holding a write lock, meaning no messages are going to be paged at this time.
     * So, we shouldn't lock anything after this method, to avoid dead locks between the writeLock and any synchronization with the CursorProvider.
     */
-   @Override
-   public void onPageModeCleared() {
+   public void onPageModeCleared()
+   {
       ArrayList<PageSubscription> subscriptions = cloneSubscriptions();
 
       Transaction tx = new TransactionImpl(storageManager);
-      for (PageSubscription sub : subscriptions) {
-         try {
+      for (PageSubscription sub : subscriptions)
+      {
+         try
+         {
             sub.onPageModeCleared(tx);
          }
-         catch (Exception e) {
+         catch (Exception e)
+         {
             ActiveMQServerLogger.LOGGER.warn("Error while cleaning paging on queue " + sub.getQueue().getName(), e);
          }
       }
 
-      try {
+      try
+      {
          tx.commit();
       }
-      catch (Exception e) {
+      catch (Exception e)
+      {
          ActiveMQServerLogger.LOGGER.warn("Error while cleaning page, during the commit", e);
       }
    }
 
-   @Override
-   public void disableCleanup() {
+   public void disableCleanup()
+   {
       this.cleanupEnabled = false;
    }
 
-   @Override
-   public void resumeCleanup() {
+   public void resumeCleanup()
+   {
       this.cleanupEnabled = true;
    }
 
-   @Override
-   public void cleanup() {
-      ArrayList<Page> depagedPages = new ArrayList<>();
 
-      while (true) {
-         if (pagingStore.lock(100)) {
+   public void cleanup()
+   {
+      ArrayList<Page> depagedPages = new ArrayList<Page>();
+
+      while (true)
+      {
+         if (pagingStore.lock(100))
+         {
             break;
          }
          if (!pagingStore.isStarted())
             return;
       }
 
-      synchronized (this) {
-         try {
-            if (!pagingStore.isStarted()) {
+      synchronized (this)
+      {
+         try
+         {
+            if (!pagingStore.isStarted())
+            {
                return;
             }
 
-            if (pagingStore.getNumberOfPages() == 0) {
+            if (pagingStore.getNumberOfPages() == 0)
+            {
                return;
             }
 
-            if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+            if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+            {
                ActiveMQServerLogger.LOGGER.debug("Asserting cleanup for address " + this.pagingStore.getAddress());
             }
 
@@ -367,19 +419,23 @@ public class PageCursorProviderImpl implements PageCursorProvider {
 
             // if the current page is being written...
             // on that case we need to move to verify it in a different way
-            if (minPage == pagingStore.getCurrentWritingPage() && pagingStore.getCurrentPage().getNumberOfMessages() > 0) {
+            if (minPage == pagingStore.getCurrentWritingPage() && pagingStore.getCurrentPage().getNumberOfMessages() > 0)
+            {
                boolean complete = checkPageCompletion(cursorList, minPage);
 
-               if (!pagingStore.isStarted()) {
+               if (!pagingStore.isStarted())
+               {
                   return;
                }
 
                // All the pages on the cursor are complete.. so we will cleanup everything and store a bookmark
-               if (complete) {
+               if (complete)
+               {
 
-                  if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+                  if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+                  {
                      ActiveMQServerLogger.LOGGER.debug("Address " + pagingStore.getAddress() +
-                                                          " is leaving page mode as all messages are consumed and acknowledged from the page store");
+                        " is leaving page mode as all messages are consumed and acknowledged from the page store");
                   }
 
                   pagingStore.forceAnotherPage();
@@ -392,67 +448,85 @@ public class PageCursorProviderImpl implements PageCursorProvider {
                }
             }
 
-            for (long i = pagingStore.getFirstPage(); i < minPage; i++) {
-               if (!checkPageCompletion(cursorList, i)) {
+            for (long i = pagingStore.getFirstPage(); i < minPage; i++)
+            {
+               if (!checkPageCompletion(cursorList, i))
+               {
                   break;
                }
                Page page = pagingStore.depage();
-               if (page == null) {
+               if (page == null)
+               {
                   break;
                }
                depagedPages.add(page);
             }
 
-            if (pagingStore.getNumberOfPages() == 0 || pagingStore.getNumberOfPages() == 1 && pagingStore.getCurrentPage().getNumberOfMessages() == 0) {
+            if (pagingStore.getNumberOfPages() == 0 || pagingStore.getNumberOfPages() == 1 &&
+               pagingStore.getCurrentPage().getNumberOfMessages() == 0)
+            {
                pagingStore.stopPaging();
             }
-            else {
-               if (ActiveMQServerLogger.LOGGER.isTraceEnabled()) {
+            else
+            {
+               if (ActiveMQServerLogger.LOGGER.isTraceEnabled())
+               {
                   ActiveMQServerLogger.LOGGER.trace("Couldn't cleanup page on address " + this.pagingStore.getAddress() +
-                                                       " as numberOfPages == " +
-                                                       pagingStore.getNumberOfPages() +
-                                                       " and currentPage.numberOfMessages = " +
-                                                       pagingStore.getCurrentPage().getNumberOfMessages());
+                     " as numberOfPages == " +
+                     pagingStore.getNumberOfPages() +
+                     " and currentPage.numberOfMessages = " +
+                     pagingStore.getCurrentPage().getNumberOfMessages());
                }
             }
          }
-         catch (Exception ex) {
+         catch (Exception ex)
+         {
             ActiveMQServerLogger.LOGGER.problemCleaningPageAddress(ex, pagingStore.getAddress());
             return;
          }
-         finally {
+         finally
+         {
             pagingStore.unlock();
          }
       }
 
-      try {
-         for (Page depagedPage : depagedPages) {
+      try
+      {
+         for (Page depagedPage : depagedPages)
+         {
             PageCache cache;
             PagedMessage[] pgdMessages;
-            synchronized (softCache) {
-               cache = softCache.get((long) depagedPage.getPageId());
+            synchronized (softCache)
+            {
+               cache = softCache.get((long)depagedPage.getPageId());
             }
 
-            if (isTrace) {
+            if (isTrace)
+            {
                ActiveMQServerLogger.LOGGER.trace("Removing page " + depagedPage.getPageId() + " from page-cache");
             }
 
-            if (cache == null) {
+            if (cache == null)
+            {
                // The page is not on cache any more
                // We need to read the page-file before deleting it
                // to make sure we remove any large-messages pending
                storageManager.beforePageRead();
 
                List<PagedMessage> pgdMessagesList = null;
-               try {
+               try
+               {
                   depagedPage.open();
                   pgdMessagesList = depagedPage.read(storageManager);
                }
-               finally {
-                  try {
+               finally
+               {
+                  try
+                  {
                      depagedPage.close();
                   }
-                  catch (Exception e) {
+                  catch (Exception e)
+                  {
                   }
 
                   storageManager.afterPageRead();
@@ -460,57 +534,69 @@ public class PageCursorProviderImpl implements PageCursorProvider {
                depagedPage.close();
                pgdMessages = pgdMessagesList.toArray(new PagedMessage[pgdMessagesList.size()]);
             }
-            else {
+            else
+            {
                pgdMessages = cache.getMessages();
             }
 
             depagedPage.delete(pgdMessages);
             onDeletePage(depagedPage);
 
-            synchronized (softCache) {
-               softCache.remove((long) depagedPage.getPageId());
+            synchronized (softCache)
+            {
+               softCache.remove((long)depagedPage.getPageId());
             }
          }
       }
-      catch (Exception ex) {
+      catch (Exception ex)
+      {
          ActiveMQServerLogger.LOGGER.problemCleaningPageAddress(ex, pagingStore.getAddress());
          return;
       }
 
    }
 
-   private boolean checkPageCompletion(ArrayList<PageSubscription> cursorList, long minPage) {
+
+   private boolean checkPageCompletion(ArrayList<PageSubscription> cursorList, long minPage)
+   {
       boolean complete = true;
 
-      for (PageSubscription cursor : cursorList) {
-         if (!cursor.isComplete(minPage)) {
-            if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+      for (PageSubscription cursor : cursorList)
+      {
+         if (!cursor.isComplete(minPage))
+         {
+            if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+            {
                ActiveMQServerLogger.LOGGER.debug("Cursor " + cursor + " was considered incomplete at page " + minPage);
             }
 
             complete = false;
             break;
          }
-         else {
-            if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+         else
+         {
+            if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+            {
                ActiveMQServerLogger.LOGGER.debug("Cursor " + cursor + "was considered **complete** at page " + minPage);
             }
          }
       }
       return complete;
    }
-
    /**
     * @return
     */
-   private synchronized ArrayList<PageSubscription> cloneSubscriptions() {
-      ArrayList<PageSubscription> cursorList = new ArrayList<>(activeCursors.values());
+   private synchronized ArrayList<PageSubscription> cloneSubscriptions()
+   {
+      ArrayList<PageSubscription> cursorList = new ArrayList<PageSubscription>(activeCursors.values());
       return cursorList;
    }
 
-   protected void onDeletePage(Page deletedPage) throws Exception {
+   protected void onDeletePage(Page deletedPage) throws Exception
+   {
       List<PageSubscription> subscriptions = cloneSubscriptions();
-      for (PageSubscription subs : subscriptions) {
+      for (PageSubscription subs: subscriptions)
+      {
          subs.onDeletePage(deletedPage);
       }
    }
@@ -520,28 +606,35 @@ public class PageCursorProviderImpl implements PageCursorProvider {
     * @param currentPage
     * @throws Exception
     */
-   protected void storeBookmark(ArrayList<PageSubscription> cursorList, Page currentPage) throws Exception {
-      try {
+   protected void storeBookmark(ArrayList<PageSubscription> cursorList, Page currentPage) throws Exception
+   {
+      try
+      {
          // First step: Move every cursor to the next bookmarked page (that was just created)
-         for (PageSubscription cursor : cursorList) {
+         for (PageSubscription cursor : cursorList)
+         {
             cursor.confirmPosition(new PagePositionImpl(currentPage.getPageId(), -1));
          }
 
-         while (!storageManager.waitOnOperations(5000)) {
+         while (!storageManager.waitOnOperations(5000))
+         {
             ActiveMQServerLogger.LOGGER.problemCompletingOperations(storageManager.getContext());
          }
       }
-      finally {
-         for (PageSubscription cursor : cursorList) {
+      finally
+      {
+         for (PageSubscription cursor : cursorList)
+         {
             cursor.enableAutoCleanup();
          }
       }
    }
 
-   @Override
-   public void printDebug() {
+   public void printDebug()
+   {
       System.out.println("Debug information for PageCursorProviderImpl:");
-      for (PageCache cache : softCache.values()) {
+      for (PageCache cache : softCache.values())
+      {
          System.out.println("Cache " + cache);
       }
    }
@@ -551,8 +644,9 @@ public class PageCursorProviderImpl implements PageCursorProvider {
    // Protected -----------------------------------------------------
 
    /* Protected as we may let test cases to instrument the test */
-   protected PageCacheImpl createPageCache(final long pageId) throws Exception {
-      return new PageCacheImpl(pagingStore.createPage((int) pageId));
+   protected PageCacheImpl createPageCache(final long pageId) throws Exception
+   {
+      return new PageCacheImpl(pagingStore.createPage((int)pageId));
    }
 
    // Private -------------------------------------------------------
@@ -560,22 +654,27 @@ public class PageCursorProviderImpl implements PageCursorProvider {
    /**
     * This method is synchronized because we want it to be atomic with the cursors being used
     */
-   private long checkMinPage(Collection<PageSubscription> cursorList) {
+   private long checkMinPage(Collection<PageSubscription> cursorList)
+   {
       long minPage = Long.MAX_VALUE;
 
-      for (PageSubscription cursor : cursorList) {
+      for (PageSubscription cursor : cursorList)
+      {
          long firstPage = cursor.getFirstPage();
-         if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+         if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+         {
             ActiveMQServerLogger.LOGGER.debug(this.pagingStore.getAddress() + " has a cursor " + cursor + " with first page=" + firstPage);
          }
 
          // the cursor will return -1 if the cursor is empty
-         if (firstPage >= 0 && firstPage < minPage) {
+         if (firstPage >= 0 && firstPage < minPage)
+         {
             minPage = firstPage;
          }
       }
 
-      if (ActiveMQServerLogger.LOGGER.isDebugEnabled()) {
+      if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+      {
          ActiveMQServerLogger.LOGGER.debug(this.pagingStore.getAddress() + " has minPage=" + minPage);
       }
 