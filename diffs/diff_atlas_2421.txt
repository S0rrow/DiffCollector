diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java b/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java
index a3dc7e5fa..7ef5c508d 100644
--- a/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java
@@ -17,13 +17,11 @@
  */
 package org.apache.atlas.repository.graph;
 
-import com.google.inject.Inject;
 import com.thinkaurelius.titan.core.SchemaViolationException;
 import com.tinkerpop.blueprints.Direction;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;
 import org.apache.atlas.AtlasException;
-import org.apache.atlas.RequestContext;
 import org.apache.atlas.repository.Constants;
 import org.apache.atlas.repository.RepositoryException;
 import org.apache.atlas.typesystem.IReferenceableInstance;
@@ -43,8 +41,8 @@ import org.apache.atlas.typesystem.types.Multiplicity;
 import org.apache.atlas.typesystem.types.ObjectGraphWalker;
 import org.apache.atlas.typesystem.types.TraitType;
 import org.apache.atlas.typesystem.types.TypeSystem;
-import org.apache.atlas.typesystem.types.TypeUtils;
 import org.apache.atlas.utils.MD5Utils;
+import org.apache.commons.lang3.tuple.Pair;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -54,71 +52,63 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
-import java.util.HashSet;
+import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-
-import static org.apache.atlas.repository.graph.GraphHelper.string;
 
 public final class TypedInstanceToGraphMapper {
 
     private static final Logger LOG = LoggerFactory.getLogger(TypedInstanceToGraphMapper.class);
     private final Map<Id, Vertex> idToVertexMap = new HashMap<>();
     private final TypeSystem typeSystem = TypeSystem.getInstance();
-    private static final GraphHelper graphHelper = GraphHelper.getInstance();
 
-    private DeleteHandler deleteHandler;
-    private GraphToTypedInstanceMapper graphToTypedInstanceMapper;
+    private final GraphToTypedInstanceMapper graphToTypedInstanceMapper;
 
-    @Inject
-    public TypedInstanceToGraphMapper(GraphToTypedInstanceMapper graphToTypedInstanceMapper, DeleteHandler deleteHandler) {
-        this.graphToTypedInstanceMapper = graphToTypedInstanceMapper;
-        this.deleteHandler = deleteHandler;
-    }
+    private static final GraphHelper graphHelper = GraphHelper.getInstance();
 
     private final String SIGNATURE_HASH_PROPERTY_KEY = Constants.INTERNAL_PROPERTY_KEY_PREFIX + "signature";
 
     public enum Operation {
         CREATE,
         UPDATE_PARTIAL,
-        UPDATE_FULL
+        UPDATE_FULL,
+        DELETE
     }
 
-    void mapTypedInstanceToGraph(Operation operation, ITypedReferenceableInstance... typedInstances)
-            throws AtlasException {
+    public TypedInstanceToGraphMapper(GraphToTypedInstanceMapper graphToTypedInstanceMapper) {
+        this.graphToTypedInstanceMapper = graphToTypedInstanceMapper;
+    }
 
-        RequestContext requestContext = RequestContext.get();
+    String[] mapTypedInstanceToGraph(Operation operation, ITypedReferenceableInstance... typedInstances)
+        throws AtlasException {
+        List<String> guids = new ArrayList<>();
         for (ITypedReferenceableInstance typedInstance : typedInstances) {
-            LOG.debug("Adding/updating entity {}", typedInstance);
             Collection<IReferenceableInstance> newInstances = walkClassInstances(typedInstance);
-            TypeUtils.Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> instancesPair =
+            Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> instancesPair =
                     createVerticesAndDiscoverInstances(newInstances);
-            List<ITypedReferenceableInstance> entitiesToCreate = instancesPair.left;
-            List<ITypedReferenceableInstance> entitiesToUpdate = instancesPair.right;
 
             switch (operation) {
-            case CREATE:
-                List<String> ids = addOrUpdateAttributesAndTraits(operation, entitiesToCreate);
-                addFullTextProperty(entitiesToCreate);
-                requestContext.recordCreatedEntities(ids);
-                break;
-
-            case UPDATE_FULL:
-            case UPDATE_PARTIAL:
-                ids = addOrUpdateAttributesAndTraits(Operation.CREATE, entitiesToCreate);
-                requestContext.recordCreatedEntities(ids);
-                ids = addOrUpdateAttributesAndTraits(operation, entitiesToUpdate);
-                requestContext.recordUpdatedEntities(ids);
-
-                addFullTextProperty(entitiesToCreate);
-                addFullTextProperty(entitiesToUpdate);
-                break;
-
-            default:
-                throw new UnsupportedOperationException("Not handled - " + operation);
+                case CREATE:
+                    addOrUpdateAttributesAndTraits(operation, instancesPair.getLeft());
+                    addFullTextProperty(instancesPair.getLeft());
+                    break;
+
+                case UPDATE_FULL:
+                case UPDATE_PARTIAL:
+                    List<ITypedReferenceableInstance> instancesForUpdate = instancesPair.getLeft();
+                    instancesForUpdate.addAll(instancesPair.getRight());
+                    addOrUpdateAttributesAndTraits(operation, instancesForUpdate);
+                    addFullTextProperty(instancesForUpdate);
+                    break;
+
+                case DELETE:
+                    throw new UnsupportedOperationException("Not handled - " + operation);
             }
+
+            //Return guid for
+            addToGuids(typedInstance, guids);
         }
+        return guids.toArray(new String[guids.size()]);
     }
 
     private Collection<IReferenceableInstance> walkClassInstances(ITypedReferenceableInstance typedInstance)
@@ -126,7 +116,7 @@ public final class TypedInstanceToGraphMapper {
 
         EntityProcessor entityProcessor = new EntityProcessor();
         try {
-            LOG.debug("Walking the object graph for instance {}", typedInstance.toShortString());
+            LOG.debug("Walking the object graph for instance {}", typedInstance.getTypeName());
             new ObjectGraphWalker(typeSystem, entityProcessor, typedInstance).walk();
         } catch (AtlasException me) {
             throw new RepositoryException("TypeSystem error when walking the ObjectGraph", me);
@@ -136,23 +126,20 @@ public final class TypedInstanceToGraphMapper {
         return entityProcessor.getInstances();
     }
 
-    private List<String> addOrUpdateAttributesAndTraits(Operation operation, List<ITypedReferenceableInstance> instances) throws AtlasException {
-        List<String> guids = new ArrayList<>();
+    private void addOrUpdateAttributesAndTraits(Operation operation, List<ITypedReferenceableInstance> instances) throws AtlasException {
         for (ITypedReferenceableInstance instance : instances) {
             try {
                 //new vertex, set all the properties
-                String guid = addOrUpdateAttributesAndTraits(operation, instance);
-                guids.add(guid);
+                addOrUpdateAttributesAndTraits(operation, instance);
             } catch (SchemaViolationException e) {
                 throw new EntityExistsException(instance, e);
             }
         }
-        return guids;
     }
 
-    private String addOrUpdateAttributesAndTraits(Operation operation, ITypedReferenceableInstance typedInstance)
+    private void addOrUpdateAttributesAndTraits(Operation operation, ITypedReferenceableInstance typedInstance)
             throws AtlasException {
-        LOG.debug("Adding/Updating typed instance {}", typedInstance.toShortString());
+        LOG.debug("Adding/Updating typed instance {}", typedInstance.getTypeName());
 
         Id id = typedInstance.getId();
         if (id == null) { // oops
@@ -171,91 +158,80 @@ public final class TypedInstanceToGraphMapper {
             //TODO - Handle Trait updates
             addTraits(typedInstance, instanceVertex, classType);
         }
-        return getId(typedInstance)._getId();
     }
 
-    void mapInstanceToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
-                             Map<String, AttributeInfo> fields, boolean mapOnlyUniqueAttributes, Operation operation)
+    private void mapInstanceToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+                                     Map<String, AttributeInfo> fields, boolean mapOnlyUniqueAttributes, Operation operation)
             throws AtlasException {
-
-        LOG.debug("Mapping instance {} to vertex {}", typedInstance.toShortString(), string(instanceVertex));
+        LOG.debug("Mapping instance {} of {} to vertex {}", typedInstance, typedInstance.getTypeName(),
+                instanceVertex);
         for (AttributeInfo attributeInfo : fields.values()) {
             if (mapOnlyUniqueAttributes && !attributeInfo.isUnique) {
                 continue;
             }
-            mapAttributeToVertex(typedInstance, instanceVertex, attributeInfo, operation);
+            mapAttributesToVertex(typedInstance, instanceVertex, attributeInfo, operation);
         }
-        GraphHelper.setProperty(instanceVertex, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY,
-                RequestContext.get().getRequestTime());
     }
 
-    void mapAttributeToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
-                              AttributeInfo attributeInfo, Operation operation) throws AtlasException {
+    void mapAttributesToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+                               AttributeInfo attributeInfo, Operation operation) throws AtlasException {
         Object attrValue = typedInstance.get(attributeInfo.name);
-        LOG.debug("Mapping attribute {} = {}", attributeInfo.name, attrValue);
+        LOG.debug("mapping attribute {} = {}", attributeInfo.name, attrValue);
+        final String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+        String edgeLabel = GraphHelper.getEdgeLabel(typedInstance, attributeInfo);
 
         if (attrValue != null  || operation == Operation.UPDATE_FULL) {
             switch (attributeInfo.dataType().getTypeCategory()) {
-            case PRIMITIVE:
-            case ENUM:
-                mapPrimitiveOrEnumToVertex(typedInstance, instanceVertex, attributeInfo);
-                break;
-
-            case ARRAY:
-                mapArrayCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
-                break;
-
-            case MAP:
-                mapMapCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
-                break;
-
-            case STRUCT:
-            case CLASS:
-                String edgeLabel = GraphHelper.getEdgeLabel(typedInstance, attributeInfo);
-
-                Edge currentEdge = GraphHelper.getEdgeForLabel(instanceVertex, edgeLabel);
-                String newEdgeId = addOrUpdateReference(instanceVertex, attributeInfo, attributeInfo.dataType(),
-                        attrValue, currentEdge, edgeLabel, operation);
-
-                if (currentEdge != null && !currentEdge.getId().toString().equals(newEdgeId)) {
-                    deleteHandler.deleteReference(currentEdge, attributeInfo.dataType().getTypeCategory(),
-                            attributeInfo.isComposite);
-                }
-                break;
-
-            case TRAIT:
-                // do NOTHING - this is taken care of earlier
-                break;
-
-            default:
-                throw new IllegalArgumentException("Unknown type category: " + attributeInfo.dataType().getTypeCategory());
+                case PRIMITIVE:
+                case ENUM:
+                    mapPrimitiveOrEnumToVertex(typedInstance, instanceVertex, attributeInfo);
+                    break;
+
+                case ARRAY:
+                    mapArrayCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
+                    break;
+
+                case MAP:
+                    mapMapCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
+                    break;
+
+                case STRUCT:
+                case CLASS:
+                    Iterator<Edge> outGoingEdgesIterator =
+                            GraphHelper.getOutGoingEdgesByLabel(instanceVertex, edgeLabel).iterator();
+                    String currentEntry =
+                            outGoingEdgesIterator.hasNext() ? outGoingEdgesIterator.next().getId().toString() : null;
+                    addOrUpdateCollectionEntry(instanceVertex, attributeInfo, attributeInfo.dataType(), attrValue,
+                            currentEntry, propertyName, operation);
+                    break;
+
+                case TRAIT:
+                    // do NOTHING - this is taken care of earlier
+                    break;
+
+                default:
+                    throw new IllegalArgumentException("Unknown type category: " + attributeInfo.dataType().getTypeCategory());
             }
         }
     }
 
-    private TypeUtils.Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> createVerticesAndDiscoverInstances(
+    private Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> createVerticesAndDiscoverInstances(
             Collection<IReferenceableInstance> instances) throws AtlasException {
 
         List<ITypedReferenceableInstance> instancesToCreate = new ArrayList<>();
         List<ITypedReferenceableInstance> instancesToUpdate = new ArrayList<>();
 
         for (IReferenceableInstance instance : instances) {
-            LOG.debug("Discovering instance to create/update for {}", instance.toShortString());
-            ITypedReferenceableInstance newInstance;
             Id id = instance.getId();
-
             if (!idToVertexMap.containsKey(id)) {
                 Vertex instanceVertex;
                 if (id.isAssigned()) {  // has a GUID
-                    LOG.debug("Instance has an assigned id {}", instance.getId()._getId());
                     instanceVertex = graphHelper.getVertexForGUID(id.id);
                     if (!(instance instanceof ReferenceableInstance)) {
                         throw new IllegalStateException(
-                                String.format("%s is not of type ITypedReferenceableInstance", instance.toShortString()));
+                                String.format("%s is not of type ITypedReferenceableInstance", instance));
                     }
-                    newInstance = (ITypedReferenceableInstance) instance;
-                    instancesToUpdate.add(newInstance);
-
+                    instancesToUpdate.add((ITypedReferenceableInstance) instance);
                 } else {
                     //Check if there is already an instance with the same unique attribute value
                     ClassType classType = typeSystem.getDataType(ClassType.class, instance.getTypeName());
@@ -263,30 +239,31 @@ public final class TypedInstanceToGraphMapper {
 
                     //no entity with the given unique attribute, create new
                     if (instanceVertex == null) {
-                        LOG.debug("Creating new vertex for instance {}", instance.toShortString());
-                        newInstance = classType.convert(instance, Multiplicity.REQUIRED);
+                        ITypedReferenceableInstance newInstance = classType.convert(instance, Multiplicity.REQUIRED);
                         instanceVertex = graphHelper.createVertexWithIdentity(newInstance, classType.getAllSuperTypeNames());
                         instancesToCreate.add(newInstance);
 
                         //Map only unique attributes for cases of circular references
                         mapInstanceToVertex(newInstance, instanceVertex, classType.fieldMapping().fields, true, Operation.CREATE);
-
                     } else {
-                        LOG.debug("Re-using existing vertex {} for instance {}", string(instanceVertex), instance.toShortString());
                         if (!(instance instanceof ReferenceableInstance)) {
                             throw new IllegalStateException(
-                                    String.format("%s is not of type ITypedReferenceableInstance", instance.toShortString()));
+                                    String.format("%s is not of type ITypedReferenceableInstance", instance));
                         }
-                        newInstance = (ITypedReferenceableInstance) instance;
-                        instancesToUpdate.add(newInstance);
+                        instancesToUpdate.add((ITypedReferenceableInstance) instance);
                     }
                 }
 
-                //Set the id in the new instance
                 idToVertexMap.put(id, instanceVertex);
             }
         }
-        return TypeUtils.Pair.of(instancesToCreate, instancesToUpdate);
+        return Pair.of(instancesToCreate, instancesToUpdate);
+    }
+
+    private void addToGuids(ITypedReferenceableInstance typedInstance, List<String> guids) {
+        Vertex instanceVertex = idToVertexMap.get(typedInstance.getId());
+        String guid = instanceVertex.getProperty(Constants.GUID_PROPERTY_KEY);
+        guids.add(guid);
     }
 
     private void addFullTextProperty(List<ITypedReferenceableInstance> instances) throws AtlasException {
@@ -298,8 +275,7 @@ public final class TypedInstanceToGraphMapper {
         }
     }
 
-    private void addTraits(ITypedReferenceableInstance typedInstance, Vertex instanceVertex, ClassType classType)
-            throws AtlasException {
+    private void addTraits(ITypedReferenceableInstance typedInstance, Vertex instanceVertex, ClassType classType) throws AtlasException {
         for (String traitName : typedInstance.getTraits()) {
             LOG.debug("mapping trait {}", traitName);
             GraphHelper.addProperty(instanceVertex, Constants.TRAIT_NAMES_PROPERTY_KEY, traitName);
@@ -310,158 +286,141 @@ public final class TypedInstanceToGraphMapper {
         }
     }
 
-    /******************************************** ARRAY **************************************************/
+    /******************************************** STRUCT **************************************************/
 
-    private void mapArrayCollectionToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
-                                            AttributeInfo attributeInfo, Operation operation) throws AtlasException {
-        LOG.debug("Mapping instance {} for array attribute {} vertex {}", typedInstance.toShortString(),
-                attributeInfo.name, string(instanceVertex));
+    private Pair<Vertex, Edge> updateStructVertex(ITypedStruct structInstance, Edge relEdge, Operation operation) throws AtlasException {
+        //Already existing vertex. Update
+        Vertex structInstanceVertex = relEdge.getVertex(Direction.IN);
 
-        List newElements = (List) typedInstance.get(attributeInfo.name);
-        boolean newAttributeEmpty = (newElements == null || newElements.isEmpty());
+        // Update attributes
+        final MessageDigest digester = MD5Utils.getDigester();
+        String newSignature = structInstance.getSignatureHash(digester);
+        String curSignature = structInstanceVertex.getProperty(SIGNATURE_HASH_PROPERTY_KEY);
 
-        if (newAttributeEmpty && operation != Operation.UPDATE_FULL) {
-            return;
+        if (!newSignature.equals(curSignature)) {
+            //Update struct vertex instance only if there is a change
+            LOG.debug("Updating struct {} since signature has changed {} {} ", structInstance, curSignature, newSignature);
+            mapInstanceToVertex(structInstance, structInstanceVertex, structInstance.fieldMapping().fields, false, operation);
+            GraphHelper.setProperty(structInstanceVertex, SIGNATURE_HASH_PROPERTY_KEY, String.valueOf(newSignature));
         }
+        return Pair.of(structInstanceVertex, relEdge);
+    }
 
-        String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
-        List<String> currentElements = instanceVertex.getProperty(propertyName);
-        IDataType elementType = ((DataTypes.ArrayType) attributeInfo.dataType()).getElemType();
-        List<String> newElementsCreated = new ArrayList<>();
-
-        if (!newAttributeEmpty) {
-            if (newElements != null && !newElements.isEmpty()) {
-                int index = 0;
-                for (; index < newElements.size(); index++) {
-                    String currentElement = (currentElements != null && index < currentElements.size()) ?
-                            currentElements.get(index) : null;
-                    LOG.debug("Adding/updating element at position {}, current element {}, new element {}", index,
-                            currentElement, newElements.get(index));
-                    String newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
-                            newElements.get(index), currentElement, propertyName, operation);
-                    newElementsCreated.add(newEntry);
-                }
-            }
-        }
+    private Pair<Vertex, Edge> addStructVertex(ITypedStruct structInstance, Vertex instanceVertex, AttributeInfo attributeInfo, String edgeLabel) throws AtlasException {
+        // add a new vertex for the struct or trait instance
+        Vertex structInstanceVertex = graphHelper.createVertexWithoutIdentity(structInstance.getTypeName(), null,
+                Collections.<String>emptySet()); // no super types for struct type
+        LOG.debug("created vertex {} for struct {} value {}", structInstanceVertex, attributeInfo.name, structInstance);
 
-        // for dereference on way out
-        GraphHelper.setProperty(instanceVertex, propertyName, newElementsCreated);
+        // map all the attributes to this new vertex
+        mapInstanceToVertex(structInstance, structInstanceVertex, structInstance.fieldMapping().fields, false, Operation.CREATE);
+        // add an edge to the newly created vertex from the parent
+        Edge relEdge = graphHelper.addEdge(instanceVertex, structInstanceVertex, edgeLabel);
 
-        removeUnusedEntries(currentElements, newElementsCreated, elementType, attributeInfo);
+        return Pair.of(structInstanceVertex, relEdge);
     }
 
-    private void removeUnusedEntries(List<String> currentEntries, List<String> newEntries, IDataType entryType,
-                                     AttributeInfo attributeInfo) throws AtlasException {
-        if (currentEntries == null || currentEntries.isEmpty()) {
-            return;
-        }
+    /******************************************** ARRAY **************************************************/
 
-        LOG.debug("Removing unused entries from the old collection");
-        if (entryType.getTypeCategory() == DataTypes.TypeCategory.STRUCT
-                || entryType.getTypeCategory() == DataTypes.TypeCategory.CLASS) {
+    private void mapArrayCollectionToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+        AttributeInfo attributeInfo, Operation operation) throws AtlasException {
+        LOG.debug("Mapping instance {} to vertex {} for name {}", typedInstance.getTypeName(), instanceVertex,
+                attributeInfo.name);
+        List newElements = (List) typedInstance.get(attributeInfo.name);
+        boolean empty = (newElements == null || newElements.isEmpty());
+        if (!empty  || operation == Operation.UPDATE_FULL) {
+            String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+            List<String> currentEntries = instanceVertex.getProperty(propertyName);
 
-            //Get map of edge id to edge
-            Map<String, Edge> edgeMap = new HashMap<>();
-            getEdges(currentEntries, edgeMap);
-            getEdges(newEntries, edgeMap);
+            IDataType elementType = ((DataTypes.ArrayType) attributeInfo.dataType()).getElemType();
+            List<String> newEntries = new ArrayList<>();
 
-            //Get final set of in vertices
-            Set<String> newInVertices = new HashSet<>();
-            for (String edgeId : newEntries) {
-                Vertex inVertex = edgeMap.get(edgeId).getVertex(Direction.IN);
-                newInVertices.add(inVertex.getId().toString());
-            }
+            if (newElements != null && !newElements.isEmpty()) {
+                int index = 0;
+                for (; index < newElements.size(); index++) {
+                    String currentEntry =
+                            (currentEntries != null && index < currentEntries.size()) ? currentEntries.get(index) : null;
+                    String newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
+                            newElements.get(index), currentEntry, propertyName, operation);
+                    newEntries.add(newEntry);
+                }
 
-            //Remove the edges for (current edges - new edges)
-            List<String> cloneElements = new ArrayList<>(currentEntries);
-            cloneElements.removeAll(newEntries);
-            LOG.debug("Removing unused entries from the old collection - {}", cloneElements);
-
-            if (!cloneElements.isEmpty()) {
-                for (String edgeIdForDelete : cloneElements) {
-                    Edge edge = edgeMap.get(edgeIdForDelete);
-                    Vertex inVertex = edge.getVertex(Direction.IN);
-                    if (newInVertices.contains(inVertex.getId().toString())) {
-                        //If the edge.inVertex is in the new set of in vertices, just delete the edge
-                        deleteHandler.deleteEdge(edge, true);
-                    } else {
-                        //else delete the edge + vertex
-                        deleteHandler.deleteReference(edge, entryType.getTypeCategory(), attributeInfo.isComposite);
+                //Remove extra entries in the list
+                if (currentEntries != null) {
+                    if (index < currentEntries.size()) {
+                        for (; index < currentEntries.size(); index++) {
+                            removeUnusedReference(currentEntries.get(index), attributeInfo, elementType);
+                        }
                     }
                 }
             }
-        }
-    }
 
-    private void getEdges(List<String> edgeIds, Map<String, Edge> edgeMap) {
-        if (edgeIds == null) {
-            return;
-        }
-
-        for (String edgeId : edgeIds) {
-            if (!edgeMap.containsKey(edgeId)) {
-                edgeMap.put(edgeId, graphHelper.getEdgeById(edgeId));
-            }
+            // for dereference on way out
+            GraphHelper.setProperty(instanceVertex, propertyName, newEntries);
         }
     }
 
-
     /******************************************** MAP **************************************************/
 
     private void mapMapCollectionToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
-                                          AttributeInfo attributeInfo, Operation operation) throws AtlasException {
-        LOG.debug("Mapping instance {} to vertex {} for attribute {}", typedInstance.toShortString(), string(instanceVertex),
+        AttributeInfo attributeInfo, Operation operation) throws AtlasException {
+        LOG.debug("Mapping instance {} to vertex {} for name {}", typedInstance.getTypeName(), instanceVertex,
                 attributeInfo.name);
-        @SuppressWarnings("unchecked") Map<Object, Object> newAttribute =
-                (Map<Object, Object>) typedInstance.get(attributeInfo.name);
+        @SuppressWarnings("unchecked") Map<Object, Object> collection =
+            (Map<Object, Object>) typedInstance.get(attributeInfo.name);
+        boolean empty = (collection == null || collection.isEmpty());
+        if (!empty  || operation == Operation.UPDATE_FULL) {
 
-        boolean newAttributeEmpty = (newAttribute == null || newAttribute.isEmpty());
-        if (newAttributeEmpty && operation != Operation.UPDATE_FULL) {
-            return;
-        }
+            String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+            IDataType elementType = ((DataTypes.MapType) attributeInfo.dataType()).getValueType();
 
-        IDataType elementType = ((DataTypes.MapType) attributeInfo.dataType()).getValueType();
-        String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
-        List<String> currentElements = new ArrayList<>();
-        List<String> newElementsCreated = new ArrayList<>();
-        List<String> newKeysCreated = new ArrayList<>();
+            if (!empty) {
+                for (Map.Entry entry : collection.entrySet()) {
+                    String myPropertyName = propertyName + "." + entry.getKey().toString();
 
-        if (!newAttributeEmpty) {
-            for (Map.Entry entry : newAttribute.entrySet()) {
-                String propertyNameForKey = GraphHelper.getQualifiedNameForMapKey(propertyName, entry.getKey().toString());
-                newKeysCreated.add(entry.getKey().toString());
+                    String currentEntry = instanceVertex.getProperty(myPropertyName);
+                    String newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
+                            entry.getValue(), currentEntry, myPropertyName, operation);
 
-                String currentEntry = instanceVertex.getProperty(propertyNameForKey);
-                if (currentEntry != null) {
-                    currentElements.add(currentEntry);
+                    //Add/Update/Remove property value
+                    GraphHelper.setProperty(instanceVertex, myPropertyName, newEntry);
                 }
 
-                String newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
-                        entry.getValue(), currentEntry, propertyNameForKey, operation);
+                //Remove unused key references
+                List<Object> origKeys = instanceVertex.getProperty(propertyName);
+                if (origKeys != null) {
+                    if (collection != null) {
+                        origKeys.removeAll(collection.keySet());
+                    }
+                    for (Object unusedKey : origKeys) {
+                        String edgeLabel = GraphHelper.getEdgeLabel(typedInstance, attributeInfo) + "." + unusedKey;
+                        if (instanceVertex.getEdges(Direction.OUT, edgeLabel).iterator().hasNext()) {
+                            Edge edge = instanceVertex.getEdges(Direction.OUT, edgeLabel).iterator().next();
+                            removeUnusedReference(edge.getId().toString(), attributeInfo,
+                                    ((DataTypes.MapType) attributeInfo.dataType()).getValueType());
+                        }
+                    }
+                }
 
-                //Add/Update/Remove property value
-                GraphHelper.setProperty(instanceVertex, propertyNameForKey, newEntry);
-                newElementsCreated.add(newEntry);
             }
-        }
-
-        // for dereference on way out
-        GraphHelper.setProperty(instanceVertex, propertyName, newKeysCreated);
 
-        removeUnusedEntries(currentElements, newElementsCreated, elementType, attributeInfo);
+            // for dereference on way out
+            GraphHelper.setProperty(instanceVertex, propertyName, collection == null ? null : new ArrayList(collection.keySet()));
+        }
     }
 
     /******************************************** ARRAY & MAP **************************************************/
 
     private String addOrUpdateCollectionEntry(Vertex instanceVertex, AttributeInfo attributeInfo,
-                                              IDataType elementType, Object newAttributeValue, String currentValue,
-                                              String propertyName, Operation operation)
-            throws AtlasException {
+                                              IDataType elementType, Object newVal, String curVal, String propertyName,
+                                              Operation operation)
+        throws AtlasException {
 
+        final String edgeLabel = GraphHelper.EDGE_LABEL_PREFIX + propertyName;
         switch (elementType.getTypeCategory()) {
         case PRIMITIVE:
         case ENUM:
-            return newAttributeValue != null ? newAttributeValue.toString() : null;
+            return newVal != null ? newVal.toString() : null;
 
         case ARRAY:
         case MAP:
@@ -470,113 +429,66 @@ public final class TypedInstanceToGraphMapper {
             return null;
 
         case STRUCT:
-        case CLASS:
-            final String edgeLabel = GraphHelper.EDGE_LABEL_PREFIX + propertyName;
-            Edge currentEdge = graphHelper.getEdgeById(currentValue);
-            return addOrUpdateReference(instanceVertex, attributeInfo, elementType, newAttributeValue, currentEdge,
-                    edgeLabel, operation);
-
-        default:
-            throw new IllegalArgumentException("Unknown type category: " + elementType.getTypeCategory());
-        }
-    }
-
-    private String addOrUpdateReference(Vertex instanceVertex, AttributeInfo attributeInfo,
-                                        IDataType attributeType, Object newAttributeValue, Edge currentEdge,
-                                        String edgeLabel, Operation operation) throws AtlasException {
-        switch (attributeType.getTypeCategory()) {
-        case STRUCT:
-            return addOrUpdateStruct(instanceVertex, attributeInfo, (ITypedStruct) newAttributeValue, currentEdge,
-                    edgeLabel, operation);
+            return addOrUpdateStruct(instanceVertex, attributeInfo, elementType, (ITypedStruct) newVal, curVal, edgeLabel, operation);
 
         case CLASS:
-            return addOrUpdateClassVertex(instanceVertex, currentEdge,
-                    (ITypedReferenceableInstance) newAttributeValue, attributeInfo, edgeLabel);
+            return addOrUpdateClassVertex(instanceVertex, attributeInfo, elementType,
+                    (ITypedReferenceableInstance) newVal, curVal, edgeLabel, operation);
 
         default:
-            throw new IllegalArgumentException("Unknown type category: " + attributeType.getTypeCategory());
+            throw new IllegalArgumentException("Unknown type category: " + elementType.getTypeCategory());
         }
     }
-    /******************************************** STRUCT **************************************************/
 
-    private String addOrUpdateStruct(Vertex instanceVertex, AttributeInfo attributeInfo,
-                                     ITypedStruct newAttributeValue, Edge currentEdge,
+    private String addOrUpdateStruct(Vertex instanceVertex, AttributeInfo attributeInfo, IDataType elementType,
+                                     ITypedStruct structAttr, String curVal,
                                      String edgeLabel, Operation operation) throws AtlasException {
-        String newEdgeId = null;
-        if (currentEdge != null && newAttributeValue != null) {
+        Pair<Vertex, Edge> vertexEdgePair = null;
+        if (curVal != null && structAttr == null) {
+            //remove edge
+            removeUnusedReference(curVal, attributeInfo, elementType);
+        } else if (curVal != null && structAttr != null) {
             //update
-            updateStructVertex(newAttributeValue, currentEdge, operation);
-            newEdgeId = currentEdge.getId().toString();
-        } else if (currentEdge == null && newAttributeValue != null) {
+            Edge edge = graphHelper.getOutGoingEdgeById(curVal);
+            vertexEdgePair = updateStructVertex(structAttr, edge, operation);
+        } else if (structAttr != null) {
             //add
-            Edge newEdge = addStructVertex(newAttributeValue, instanceVertex, attributeInfo, edgeLabel);
-            newEdgeId = newEdge.getId().toString();
+            vertexEdgePair = addStructVertex(structAttr, instanceVertex, attributeInfo, edgeLabel);
         }
-        return newEdgeId;
-    }
 
-    private Edge addStructVertex(ITypedStruct structInstance, Vertex instanceVertex,
-                                 AttributeInfo attributeInfo, String edgeLabel) throws AtlasException {
-        // add a new vertex for the struct or trait instance
-        Vertex structInstanceVertex = graphHelper.createVertexWithoutIdentity(structInstance.getTypeName(), null,
-                Collections.<String>emptySet()); // no super types for struct type
-        LOG.debug("created vertex {} for struct {} value {}", string(structInstanceVertex), attributeInfo.name,
-                structInstance.toShortString());
-
-        // map all the attributes to this new vertex
-        mapInstanceToVertex(structInstance, structInstanceVertex, structInstance.fieldMapping().fields, false,
-                Operation.CREATE);
-        // add an edge to the newly created vertex from the parent
-        Edge newEdge = graphHelper.addEdge(instanceVertex, structInstanceVertex, edgeLabel);
-
-        return newEdge;
+        return (vertexEdgePair != null) ? vertexEdgePair.getRight().getId().toString() : null;
     }
 
-    private void updateStructVertex(ITypedStruct newAttributeValue, Edge currentEdge,
-                                    Operation operation) throws AtlasException {
-        //Already existing vertex. Update
-        Vertex structInstanceVertex = currentEdge.getVertex(Direction.IN);
-
-        LOG.debug("Updating struct vertex {} with struct {}", string(structInstanceVertex), newAttributeValue.toShortString());
-
-        // Update attributes
-        final MessageDigest digester = MD5Utils.getDigester();
-        String newSignature = newAttributeValue.getSignatureHash(digester);
-        String curSignature = structInstanceVertex.getProperty(SIGNATURE_HASH_PROPERTY_KEY);
-
-        if (!newSignature.equals(curSignature)) {
-            //Update struct vertex instance only if there is a change
-            LOG.debug("Updating struct {} since signature has changed {} {} ", newAttributeValue, curSignature, newSignature);
-            mapInstanceToVertex(newAttributeValue, structInstanceVertex, newAttributeValue.fieldMapping().fields, false, operation);
-            GraphHelper.setProperty(structInstanceVertex, SIGNATURE_HASH_PROPERTY_KEY, String.valueOf(newSignature));
+    private String addOrUpdateClassVertex(Vertex instanceVertex, AttributeInfo attributeInfo, IDataType elementType,
+                                          ITypedReferenceableInstance newVal, String curVal,
+                                          String edgeLabel, Operation operation) throws AtlasException {
+        Vertex toVertex = getClassVertex(newVal);
+        if(toVertex == null && newVal != null) {
+            LOG.error("Could not find vertex for Class Reference " + newVal);
+            throw new EntityNotFoundException("Could not find vertex for Class Reference " + newVal);
         }
-    }
-
-    /******************************************** CLASS **************************************************/
 
-    private String addOrUpdateClassVertex(Vertex instanceVertex, Edge currentEdge,
-                                          ITypedReferenceableInstance newAttributeValue, AttributeInfo attributeInfo,
-                                          String edgeLabel) throws AtlasException {
-        Vertex newReferenceVertex = getClassVertex(newAttributeValue);
-        if(newReferenceVertex == null && newAttributeValue != null) {
-            LOG.error("Could not find vertex for Class Reference " + newAttributeValue);
-            throw new EntityNotFoundException("Could not find vertex for Class Reference " + newAttributeValue);
+        Pair<Vertex, Edge> vertexEdgePair = null;
+        if (curVal != null && newVal == null) {
+            //remove edge
+            removeUnusedReference(curVal, attributeInfo, elementType);
+        } else if (curVal != null && newVal != null) {
+            Edge edge = graphHelper.getOutGoingEdgeById(curVal);
+            Id classRefId = getId(newVal);
+            vertexEdgePair = updateClassEdge(classRefId, newVal, instanceVertex, edge, toVertex, attributeInfo, elementType, edgeLabel, operation);
+        } else if (newVal != null){
+            vertexEdgePair = addClassEdge(instanceVertex, toVertex, edgeLabel);
         }
 
-        String newEdgeId = null;
-        if (currentEdge != null && newAttributeValue != null) {
-            newEdgeId = updateClassEdge(instanceVertex, currentEdge, newAttributeValue, newReferenceVertex,
-                    attributeInfo, edgeLabel);
-        } else if (currentEdge == null && newAttributeValue != null){
-            Edge newEdge = addClassEdge(instanceVertex, newReferenceVertex, edgeLabel);
-            newEdgeId = newEdge.getId().toString();
-        }
-        return newEdgeId;
+        return (vertexEdgePair != null) ? vertexEdgePair.getRight().getId().toString() : null;
     }
 
-    private Edge addClassEdge(Vertex instanceVertex, Vertex toVertex, String edgeLabel) throws AtlasException {
-        // add an edge to the class vertex from the instance
-        return graphHelper.addEdge(instanceVertex, toVertex, edgeLabel);
+    /******************************************** CLASS **************************************************/
+
+    private Pair<Vertex, Edge> addClassEdge(Vertex instanceVertex, Vertex toVertex, String edgeLabel) throws AtlasException {
+            // add an edge to the class vertex from the instance
+          Edge edge = graphHelper.addEdge(instanceVertex, toVertex, edgeLabel);
+          return Pair.of(toVertex, edge);
     }
 
     private Vertex getClassVertex(ITypedReferenceableInstance typedReference) throws EntityNotFoundException {
@@ -595,10 +507,10 @@ public final class TypedInstanceToGraphMapper {
     }
 
     private Id getId(ITypedReferenceableInstance typedReference) throws EntityNotFoundException {
-        if (typedReference == null) {
-            throw new IllegalArgumentException("typedReference must be non-null");
+        Id id = null;
+        if (typedReference != null) {
+            id = typedReference instanceof Id ? (Id) typedReference : typedReference.getId();
         }
-        Id id = typedReference instanceof Id ? (Id) typedReference : typedReference.getId();
 
         if (id.isUnassigned()) {
             Vertex classVertex = idToVertexMap.get(id);
@@ -609,36 +521,47 @@ public final class TypedInstanceToGraphMapper {
     }
 
 
-    private String updateClassEdge(Vertex instanceVertex, Edge currentEdge,
-                                   ITypedReferenceableInstance newAttributeValue,
-                                   Vertex newVertex, AttributeInfo attributeInfo,
-                                   String edgeLabel) throws AtlasException {
-        LOG.debug("Updating {} for reference attribute {}", string(currentEdge), attributeInfo.name);
+    private Pair<Vertex, Edge> updateClassEdge(Id id, final ITypedReferenceableInstance typedInstance,
+                                               Vertex instanceVertex, Edge edge, Vertex toVertex,
+                                               AttributeInfo attributeInfo, IDataType dataType,
+                                               String edgeLabel, Operation operation) throws AtlasException {
+        Pair<Vertex, Edge> result = Pair.of(toVertex, edge);
+        Edge newEdge = edge;
         // Update edge if it exists
-        Vertex currentVertex = currentEdge.getVertex(Direction.IN);
-        String currentEntityId = GraphHelper.getIdFromVertex(currentVertex);
-        String newEntityId = getId(newAttributeValue).id;
-        String newEdgeId = currentEdge.getId().toString();
-        if (!currentEntityId.equals(newEntityId)) {
-            // add an edge to the class vertex from the instance
-            if (newVertex != null) {
-                Edge newEdge = graphHelper.getOrCreateEdge(instanceVertex, newVertex, edgeLabel);
-                newEdgeId = newEdge.getId().toString();
+        Vertex invertex = edge.getVertex(Direction.IN);
+        String currentGUID = invertex.getProperty(Constants.GUID_PROPERTY_KEY);
+        Id currentId = new Id(currentGUID, 0, (String) invertex.getProperty(Constants.ENTITY_TYPE_PROPERTY_KEY));
+        if (!currentId.equals(id)) {
+             // add an edge to the class vertex from the instance
+            if(toVertex != null) {
+                newEdge = graphHelper.addEdge(instanceVertex, toVertex, edgeLabel);
+                result = Pair.of(toVertex, newEdge);
             }
+            removeUnusedReference(edge.getId().toString(), attributeInfo, dataType);
         }
 
-        return newEdgeId;
+        if (attributeInfo.isComposite) {
+            //Update the attributes also if composite
+            if (typedInstance.fieldMapping() != null) {
+                //In case of Id instance, fieldMapping is null
+                mapInstanceToVertex(typedInstance, toVertex, typedInstance.fieldMapping().fields , false, operation);
+                //Update full text for the updated composite vertex
+                addFullTextProperty(new ArrayList<ITypedReferenceableInstance>() {{ add(typedInstance); }});
+            }
+        }
+
+        return result;
     }
 
     /******************************************** TRAITS ****************************************************/
 
     void mapTraitInstanceToVertex(ITypedStruct traitInstance, IDataType entityType, Vertex parentInstanceVertex)
-            throws AtlasException {
+        throws AtlasException {
         // add a new vertex for the struct or trait instance
         final String traitName = traitInstance.getTypeName();
         Vertex traitInstanceVertex = graphHelper.createVertexWithoutIdentity(traitInstance.getTypeName(), null,
                 typeSystem.getDataType(TraitType.class, traitName).getAllSuperTypeNames());
-        LOG.debug("created vertex {} for trait {}", string(traitInstanceVertex), traitName);
+        LOG.debug("created vertex {} for trait {}", traitInstanceVertex, traitName);
 
         // map all the attributes to this newly created vertex
         mapInstanceToVertex(traitInstance, traitInstanceVertex, traitInstance.fieldMapping().fields, false, Operation.CREATE);
@@ -689,6 +612,22 @@ public final class TypedInstanceToGraphMapper {
             }
         }
 
+
         GraphHelper.setProperty(instanceVertex, vertexPropertyName, propertyValue);
     }
+
+    private Edge removeUnusedReference(String edgeId, AttributeInfo attributeInfo, IDataType<?> elementType) {
+        //Remove edges for property values which do not exist any more
+        Edge removedRelation = null;
+        switch (elementType.getTypeCategory()) {
+        case STRUCT:
+            removedRelation = graphHelper.removeRelation(edgeId, true);
+            //Remove the vertex from state so that further processing no longer uses this
+            break;
+        case CLASS:
+            removedRelation = graphHelper.removeRelation(edgeId, attributeInfo.isComposite);
+            break;
+        }
+        return removedRelation;
+    }
 }