diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java b/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java
index 47ae5e142..7ef5c508d 100644
--- a/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/TypedInstanceToGraphMapper.java
@@ -17,26 +17,13 @@
  */
 package org.apache.atlas.repository.graph;
 
-import static org.apache.atlas.repository.graph.GraphHelper.string;
-
-import java.security.MessageDigest;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
+import com.thinkaurelius.titan.core.SchemaViolationException;
+import com.tinkerpop.blueprints.Direction;
+import com.tinkerpop.blueprints.Edge;
+import com.tinkerpop.blueprints.Vertex;
 import org.apache.atlas.AtlasException;
-import org.apache.atlas.RequestContext;
 import org.apache.atlas.repository.Constants;
 import org.apache.atlas.repository.RepositoryException;
-import org.apache.atlas.repository.graphdb.AtlasEdge;
-import org.apache.atlas.repository.graphdb.AtlasSchemaViolationException;
-import org.apache.atlas.repository.graphdb.AtlasVertex;
 import org.apache.atlas.typesystem.IReferenceableInstance;
 import org.apache.atlas.typesystem.ITypedInstance;
 import org.apache.atlas.typesystem.ITypedReferenceableInstance;
@@ -54,71 +41,74 @@ import org.apache.atlas.typesystem.types.Multiplicity;
 import org.apache.atlas.typesystem.types.ObjectGraphWalker;
 import org.apache.atlas.typesystem.types.TraitType;
 import org.apache.atlas.typesystem.types.TypeSystem;
-import org.apache.atlas.typesystem.types.TypeUtils;
 import org.apache.atlas.utils.MD5Utils;
+import org.apache.commons.lang3.tuple.Pair;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.inject.Inject;
+import java.security.MessageDigest;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 
 public final class TypedInstanceToGraphMapper {
 
     private static final Logger LOG = LoggerFactory.getLogger(TypedInstanceToGraphMapper.class);
-    private final Map<Id, AtlasVertex> idToVertexMap = new HashMap<>();
+    private final Map<Id, Vertex> idToVertexMap = new HashMap<>();
     private final TypeSystem typeSystem = TypeSystem.getInstance();
-    private static final GraphHelper graphHelper = GraphHelper.getInstance();
 
-    private DeleteHandler deleteHandler;
-    private GraphToTypedInstanceMapper graphToTypedInstanceMapper;
+    private final GraphToTypedInstanceMapper graphToTypedInstanceMapper;
 
-    @Inject
-    public TypedInstanceToGraphMapper(GraphToTypedInstanceMapper graphToTypedInstanceMapper, DeleteHandler deleteHandler) {
-        this.graphToTypedInstanceMapper = graphToTypedInstanceMapper;
-        this.deleteHandler = deleteHandler;
-    }
+    private static final GraphHelper graphHelper = GraphHelper.getInstance();
 
     private final String SIGNATURE_HASH_PROPERTY_KEY = Constants.INTERNAL_PROPERTY_KEY_PREFIX + "signature";
 
     public enum Operation {
         CREATE,
         UPDATE_PARTIAL,
-        UPDATE_FULL
+        UPDATE_FULL,
+        DELETE
     }
 
-    void mapTypedInstanceToGraph(Operation operation, ITypedReferenceableInstance... typedInstances)
-            throws AtlasException {
+    public TypedInstanceToGraphMapper(GraphToTypedInstanceMapper graphToTypedInstanceMapper) {
+        this.graphToTypedInstanceMapper = graphToTypedInstanceMapper;
+    }
 
-        RequestContext requestContext = RequestContext.get();
+    String[] mapTypedInstanceToGraph(Operation operation, ITypedReferenceableInstance... typedInstances)
+        throws AtlasException {
+        List<String> guids = new ArrayList<>();
         for (ITypedReferenceableInstance typedInstance : typedInstances) {
-            LOG.debug("Adding/updating entity {}", typedInstance);
             Collection<IReferenceableInstance> newInstances = walkClassInstances(typedInstance);
-            TypeUtils.Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> instancesPair =
+            Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> instancesPair =
                     createVerticesAndDiscoverInstances(newInstances);
-            List<ITypedReferenceableInstance> entitiesToCreate = instancesPair.left;
-            List<ITypedReferenceableInstance> entitiesToUpdate = instancesPair.right;
-            FullTextMapper fulltextMapper = new FullTextMapper(graphToTypedInstanceMapper);
+
             switch (operation) {
-            case CREATE:
-                List<String> ids = addOrUpdateAttributesAndTraits(operation, entitiesToCreate);
-                addFullTextProperty(entitiesToCreate, fulltextMapper);
-                requestContext.recordEntityCreate(ids);
-                break;
-
-            case UPDATE_FULL:
-            case UPDATE_PARTIAL:
-                ids = addOrUpdateAttributesAndTraits(Operation.CREATE, entitiesToCreate);
-                requestContext.recordEntityCreate(ids);
-                ids = addOrUpdateAttributesAndTraits(operation, entitiesToUpdate);
-                requestContext.recordEntityUpdate(ids);
-
-                addFullTextProperty(entitiesToCreate, fulltextMapper);
-                addFullTextProperty(entitiesToUpdate, fulltextMapper);
-                break;
-
-            default:
-                throw new UnsupportedOperationException("Not handled - " + operation);
+                case CREATE:
+                    addOrUpdateAttributesAndTraits(operation, instancesPair.getLeft());
+                    addFullTextProperty(instancesPair.getLeft());
+                    break;
+
+                case UPDATE_FULL:
+                case UPDATE_PARTIAL:
+                    List<ITypedReferenceableInstance> instancesForUpdate = instancesPair.getLeft();
+                    instancesForUpdate.addAll(instancesPair.getRight());
+                    addOrUpdateAttributesAndTraits(operation, instancesForUpdate);
+                    addFullTextProperty(instancesForUpdate);
+                    break;
+
+                case DELETE:
+                    throw new UnsupportedOperationException("Not handled - " + operation);
             }
+
+            //Return guid for
+            addToGuids(typedInstance, guids);
         }
+        return guids.toArray(new String[guids.size()]);
     }
 
     private Collection<IReferenceableInstance> walkClassInstances(ITypedReferenceableInstance typedInstance)
@@ -126,7 +116,7 @@ public final class TypedInstanceToGraphMapper {
 
         EntityProcessor entityProcessor = new EntityProcessor();
         try {
-            LOG.debug("Walking the object graph for instance {}", typedInstance.toShortString());
+            LOG.debug("Walking the object graph for instance {}", typedInstance.getTypeName());
             new ObjectGraphWalker(typeSystem, entityProcessor, typedInstance).walk();
         } catch (AtlasException me) {
             throw new RepositoryException("TypeSystem error when walking the ObjectGraph", me);
@@ -136,30 +126,27 @@ public final class TypedInstanceToGraphMapper {
         return entityProcessor.getInstances();
     }
 
-    private List<String> addOrUpdateAttributesAndTraits(Operation operation, List<ITypedReferenceableInstance> instances) throws AtlasException {
-        List<String> guids = new ArrayList<>();
+    private void addOrUpdateAttributesAndTraits(Operation operation, List<ITypedReferenceableInstance> instances) throws AtlasException {
         for (ITypedReferenceableInstance instance : instances) {
             try {
                 //new vertex, set all the properties
-                String guid = addOrUpdateAttributesAndTraits(operation, instance);
-                guids.add(guid);
-            } catch (AtlasSchemaViolationException e) {
+                addOrUpdateAttributesAndTraits(operation, instance);
+            } catch (SchemaViolationException e) {
                 throw new EntityExistsException(instance, e);
             }
         }
-        return guids;
     }
 
-    private String addOrUpdateAttributesAndTraits(Operation operation, ITypedReferenceableInstance typedInstance)
+    private void addOrUpdateAttributesAndTraits(Operation operation, ITypedReferenceableInstance typedInstance)
             throws AtlasException {
-        LOG.debug("Adding/Updating typed instance {}", typedInstance.toShortString());
+        LOG.debug("Adding/Updating typed instance {}", typedInstance.getTypeName());
 
         Id id = typedInstance.getId();
         if (id == null) { // oops
             throw new RepositoryException("id cannot be null");
         }
 
-        AtlasVertex instanceVertex = idToVertexMap.get(id);
+        Vertex instanceVertex = idToVertexMap.get(id);
 
         // add the attributes for the instance
         ClassType classType = typeSystem.getDataType(ClassType.class, typedInstance.getTypeName());
@@ -171,91 +158,80 @@ public final class TypedInstanceToGraphMapper {
             //TODO - Handle Trait updates
             addTraits(typedInstance, instanceVertex, classType);
         }
-        return getId(typedInstance)._getId();
     }
 
-    void mapInstanceToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,
-                             Map<String, AttributeInfo> fields, boolean mapOnlyUniqueAttributes, Operation operation)
+    private void mapInstanceToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+                                     Map<String, AttributeInfo> fields, boolean mapOnlyUniqueAttributes, Operation operation)
             throws AtlasException {
-
-        LOG.debug("Mapping instance {} to vertex {}", typedInstance.toShortString(), string(instanceVertex));
+        LOG.debug("Mapping instance {} of {} to vertex {}", typedInstance, typedInstance.getTypeName(),
+                instanceVertex);
         for (AttributeInfo attributeInfo : fields.values()) {
             if (mapOnlyUniqueAttributes && !attributeInfo.isUnique) {
                 continue;
             }
-            mapAttributeToVertex(typedInstance, instanceVertex, attributeInfo, operation);
+            mapAttributesToVertex(typedInstance, instanceVertex, attributeInfo, operation);
         }
-        GraphHelper.setProperty(instanceVertex, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY,
-                RequestContext.get().getRequestTime());
     }
 
-    void mapAttributeToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,
-                              AttributeInfo attributeInfo, Operation operation) throws AtlasException {
+    void mapAttributesToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+                               AttributeInfo attributeInfo, Operation operation) throws AtlasException {
         Object attrValue = typedInstance.get(attributeInfo.name);
-        LOG.debug("Mapping attribute {} = {}", attributeInfo.name, attrValue);
+        LOG.debug("mapping attribute {} = {}", attributeInfo.name, attrValue);
+        final String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+        String edgeLabel = GraphHelper.getEdgeLabel(typedInstance, attributeInfo);
 
         if (attrValue != null  || operation == Operation.UPDATE_FULL) {
             switch (attributeInfo.dataType().getTypeCategory()) {
-            case PRIMITIVE:
-            case ENUM:
-                mapPrimitiveOrEnumToVertex(typedInstance, instanceVertex, attributeInfo);
-                break;
-
-            case ARRAY:
-                mapArrayCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
-                break;
-
-            case MAP:
-                mapMapCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
-                break;
-
-            case STRUCT:
-            case CLASS:
-                String edgeLabel = graphHelper.getEdgeLabel(typedInstance, attributeInfo);
-
-                AtlasEdge currentEdge = graphHelper.getEdgeForLabel(instanceVertex, edgeLabel);
-                AtlasEdge newEdge = addOrUpdateReference(instanceVertex, attributeInfo, attributeInfo.dataType(),
-                        attrValue, currentEdge, edgeLabel, operation);
-
-                if (currentEdge != null && !currentEdge.equals(newEdge)) {
-                    deleteHandler.deleteEdgeReference(currentEdge, attributeInfo.dataType().getTypeCategory(),
-                            attributeInfo.isComposite, true);
-                }
-                break;
-
-            case TRAIT:
-                // do NOTHING - this is taken care of earlier
-                break;
-
-            default:
-                throw new IllegalArgumentException("Unknown type category: " + attributeInfo.dataType().getTypeCategory());
+                case PRIMITIVE:
+                case ENUM:
+                    mapPrimitiveOrEnumToVertex(typedInstance, instanceVertex, attributeInfo);
+                    break;
+
+                case ARRAY:
+                    mapArrayCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
+                    break;
+
+                case MAP:
+                    mapMapCollectionToVertex(typedInstance, instanceVertex, attributeInfo, operation);
+                    break;
+
+                case STRUCT:
+                case CLASS:
+                    Iterator<Edge> outGoingEdgesIterator =
+                            GraphHelper.getOutGoingEdgesByLabel(instanceVertex, edgeLabel).iterator();
+                    String currentEntry =
+                            outGoingEdgesIterator.hasNext() ? outGoingEdgesIterator.next().getId().toString() : null;
+                    addOrUpdateCollectionEntry(instanceVertex, attributeInfo, attributeInfo.dataType(), attrValue,
+                            currentEntry, propertyName, operation);
+                    break;
+
+                case TRAIT:
+                    // do NOTHING - this is taken care of earlier
+                    break;
+
+                default:
+                    throw new IllegalArgumentException("Unknown type category: " + attributeInfo.dataType().getTypeCategory());
             }
         }
     }
 
-    private TypeUtils.Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> createVerticesAndDiscoverInstances(
+    private Pair<List<ITypedReferenceableInstance>, List<ITypedReferenceableInstance>> createVerticesAndDiscoverInstances(
             Collection<IReferenceableInstance> instances) throws AtlasException {
 
         List<ITypedReferenceableInstance> instancesToCreate = new ArrayList<>();
         List<ITypedReferenceableInstance> instancesToUpdate = new ArrayList<>();
 
         for (IReferenceableInstance instance : instances) {
-            LOG.debug("Discovering instance to create/update for {}", instance.toShortString());
-            ITypedReferenceableInstance newInstance;
             Id id = instance.getId();
-
             if (!idToVertexMap.containsKey(id)) {
-                AtlasVertex instanceVertex;
+                Vertex instanceVertex;
                 if (id.isAssigned()) {  // has a GUID
-                    LOG.debug("Instance has an assigned id {}", instance.getId()._getId());
                     instanceVertex = graphHelper.getVertexForGUID(id.id);
                     if (!(instance instanceof ReferenceableInstance)) {
                         throw new IllegalStateException(
-                                String.format("%s is not of type ITypedReferenceableInstance", instance.toShortString()));
+                                String.format("%s is not of type ITypedReferenceableInstance", instance));
                     }
-                    newInstance = (ITypedReferenceableInstance) instance;
-                    instancesToUpdate.add(newInstance);
-
+                    instancesToUpdate.add((ITypedReferenceableInstance) instance);
                 } else {
                     //Check if there is already an instance with the same unique attribute value
                     ClassType classType = typeSystem.getDataType(ClassType.class, instance.getTypeName());
@@ -263,42 +239,43 @@ public final class TypedInstanceToGraphMapper {
 
                     //no entity with the given unique attribute, create new
                     if (instanceVertex == null) {
-                        LOG.debug("Creating new vertex for instance {}", instance.toShortString());
-                        newInstance = classType.convert(instance, Multiplicity.REQUIRED);
+                        ITypedReferenceableInstance newInstance = classType.convert(instance, Multiplicity.REQUIRED);
                         instanceVertex = graphHelper.createVertexWithIdentity(newInstance, classType.getAllSuperTypeNames());
                         instancesToCreate.add(newInstance);
 
                         //Map only unique attributes for cases of circular references
                         mapInstanceToVertex(newInstance, instanceVertex, classType.fieldMapping().fields, true, Operation.CREATE);
-
                     } else {
-                        LOG.debug("Re-using existing vertex {} for instance {}", string(instanceVertex), instance.toShortString());
                         if (!(instance instanceof ReferenceableInstance)) {
                             throw new IllegalStateException(
-                                    String.format("%s is not of type ITypedReferenceableInstance", instance.toShortString()));
+                                    String.format("%s is not of type ITypedReferenceableInstance", instance));
                         }
-                        newInstance = (ITypedReferenceableInstance) instance;
-                        instancesToUpdate.add(newInstance);
+                        instancesToUpdate.add((ITypedReferenceableInstance) instance);
                     }
                 }
 
-                //Set the id in the new instance
                 idToVertexMap.put(id, instanceVertex);
             }
         }
-        return TypeUtils.Pair.of(instancesToCreate, instancesToUpdate);
+        return Pair.of(instancesToCreate, instancesToUpdate);
     }
 
-    private void addFullTextProperty(List<ITypedReferenceableInstance> instances, FullTextMapper fulltextMapper) throws AtlasException {
+    private void addToGuids(ITypedReferenceableInstance typedInstance, List<String> guids) {
+        Vertex instanceVertex = idToVertexMap.get(typedInstance.getId());
+        String guid = instanceVertex.getProperty(Constants.GUID_PROPERTY_KEY);
+        guids.add(guid);
+    }
+
+    private void addFullTextProperty(List<ITypedReferenceableInstance> instances) throws AtlasException {
+        FullTextMapper fulltextMapper = new FullTextMapper(graphToTypedInstanceMapper);
         for (ITypedReferenceableInstance typedInstance : instances) { // Traverse
-            AtlasVertex instanceVertex = getClassVertex(typedInstance);
+            Vertex instanceVertex = getClassVertex(typedInstance);
             String fullText = fulltextMapper.mapRecursive(instanceVertex, true);
             GraphHelper.setProperty(instanceVertex, Constants.ENTITY_TEXT_PROPERTY_KEY, fullText);
         }
     }
 
-    private void addTraits(ITypedReferenceableInstance typedInstance, AtlasVertex instanceVertex, ClassType classType)
-            throws AtlasException {
+    private void addTraits(ITypedReferenceableInstance typedInstance, Vertex instanceVertex, ClassType classType) throws AtlasException {
         for (String traitName : typedInstance.getTraits()) {
             LOG.debug("mapping trait {}", traitName);
             GraphHelper.addProperty(instanceVertex, Constants.TRAIT_NAMES_PROPERTY_KEY, traitName);
@@ -309,185 +286,141 @@ public final class TypedInstanceToGraphMapper {
         }
     }
 
-    /******************************************** ARRAY **************************************************/
+    /******************************************** STRUCT **************************************************/
 
-    private void mapArrayCollectionToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,
-                                            AttributeInfo attributeInfo, Operation operation) throws AtlasException {
-        LOG.debug("Mapping instance {} for array attribute {} vertex {}", typedInstance.toShortString(),
-                attributeInfo.name, string(instanceVertex));
+    private Pair<Vertex, Edge> updateStructVertex(ITypedStruct structInstance, Edge relEdge, Operation operation) throws AtlasException {
+        //Already existing vertex. Update
+        Vertex structInstanceVertex = relEdge.getVertex(Direction.IN);
 
-        List newElements = (List) typedInstance.get(attributeInfo.name);
-        boolean newAttributeEmpty = (newElements == null || newElements.isEmpty());
+        // Update attributes
+        final MessageDigest digester = MD5Utils.getDigester();
+        String newSignature = structInstance.getSignatureHash(digester);
+        String curSignature = structInstanceVertex.getProperty(SIGNATURE_HASH_PROPERTY_KEY);
 
-        if (newAttributeEmpty && operation != Operation.UPDATE_FULL) {
-            return;
+        if (!newSignature.equals(curSignature)) {
+            //Update struct vertex instance only if there is a change
+            LOG.debug("Updating struct {} since signature has changed {} {} ", structInstance, curSignature, newSignature);
+            mapInstanceToVertex(structInstance, structInstanceVertex, structInstance.fieldMapping().fields, false, operation);
+            GraphHelper.setProperty(structInstanceVertex, SIGNATURE_HASH_PROPERTY_KEY, String.valueOf(newSignature));
         }
+        return Pair.of(structInstanceVertex, relEdge);
+    }
+
+    private Pair<Vertex, Edge> addStructVertex(ITypedStruct structInstance, Vertex instanceVertex, AttributeInfo attributeInfo, String edgeLabel) throws AtlasException {
+        // add a new vertex for the struct or trait instance
+        Vertex structInstanceVertex = graphHelper.createVertexWithoutIdentity(structInstance.getTypeName(), null,
+                Collections.<String>emptySet()); // no super types for struct type
+        LOG.debug("created vertex {} for struct {} value {}", structInstanceVertex, attributeInfo.name, structInstance);
+
+        // map all the attributes to this new vertex
+        mapInstanceToVertex(structInstance, structInstanceVertex, structInstance.fieldMapping().fields, false, Operation.CREATE);
+        // add an edge to the newly created vertex from the parent
+        Edge relEdge = graphHelper.addEdge(instanceVertex, structInstanceVertex, edgeLabel);
 
-        IDataType elementType = ((DataTypes.ArrayType) attributeInfo.dataType()).getElemType();
-        String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
-        
-        List<Object> currentElements = GraphHelper.getArrayElementsProperty(elementType, instanceVertex, propertyName);
-        
-        List<Object> newElementsCreated = new ArrayList<>();
+        return Pair.of(structInstanceVertex, relEdge);
+    }
+
+    /******************************************** ARRAY **************************************************/
+
+    private void mapArrayCollectionToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+        AttributeInfo attributeInfo, Operation operation) throws AtlasException {
+        LOG.debug("Mapping instance {} to vertex {} for name {}", typedInstance.getTypeName(), instanceVertex,
+                attributeInfo.name);
+        List newElements = (List) typedInstance.get(attributeInfo.name);
+        boolean empty = (newElements == null || newElements.isEmpty());
+        if (!empty  || operation == Operation.UPDATE_FULL) {
+            String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+            List<String> currentEntries = instanceVertex.getProperty(propertyName);
+
+            IDataType elementType = ((DataTypes.ArrayType) attributeInfo.dataType()).getElemType();
+            List<String> newEntries = new ArrayList<>();
 
-        if (!newAttributeEmpty) {
             if (newElements != null && !newElements.isEmpty()) {
                 int index = 0;
                 for (; index < newElements.size(); index++) {
-                    Object currentElement = (currentElements != null && index < currentElements.size()) ?
-                            currentElements.get(index) : null;
-                    LOG.debug("Adding/updating element at position {}, current element {}, new element {}", index,
-                            currentElement, newElements.get(index));
-                    Object newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
-                            newElements.get(index), currentElement, propertyName, operation);
-                    newElementsCreated.add(newEntry);
+                    String currentEntry =
+                            (currentEntries != null && index < currentEntries.size()) ? currentEntries.get(index) : null;
+                    String newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
+                            newElements.get(index), currentEntry, propertyName, operation);
+                    newEntries.add(newEntry);
                 }
-            }
-        }
 
-        if(GraphHelper.isReference(elementType)) {
-
-            List<AtlasEdge> additionalEdges = removeUnusedEntries(instanceVertex, propertyName, (List)currentElements,
-                    (List)newElementsCreated, elementType, attributeInfo);
-            newElementsCreated.addAll(additionalEdges);
-        }
-
-        // for dereference on way out
-        GraphHelper.setArrayElementsProperty(elementType, instanceVertex, propertyName, newElementsCreated);
-    }
-
-    //Removes unused edges from the old collection, compared to the new collection
-    private List<AtlasEdge> removeUnusedEntries(AtlasVertex instanceVertex, String edgeLabel,
-                                             Collection<AtlasEdge> currentEntries,
-                                             Collection<AtlasEdge> newEntries,
-                                             IDataType entryType, AttributeInfo attributeInfo) throws AtlasException {
-        if (currentEntries != null && !currentEntries.isEmpty()) {
-            LOG.debug("Removing unused entries from the old collection");
-            if (entryType.getTypeCategory() == DataTypes.TypeCategory.STRUCT
-                    || entryType.getTypeCategory() == DataTypes.TypeCategory.CLASS) {
-
-                //Remove the edges for (current edges - new edges)
-                List<AtlasEdge> cloneElements = new ArrayList<>(currentEntries);
-                cloneElements.removeAll(newEntries);
-                List<AtlasEdge> additionalElements = new ArrayList<>();
-                LOG.debug("Removing unused entries from the old collection - {}", cloneElements);
-
-                if (!cloneElements.isEmpty()) {
-                    for (AtlasEdge edge : cloneElements) {
-                        boolean deleted = deleteHandler.deleteEdgeReference(edge, entryType.getTypeCategory(),
-                                attributeInfo.isComposite, true);
-                        if (!deleted) {
-                            additionalElements.add(edge);
+                //Remove extra entries in the list
+                if (currentEntries != null) {
+                    if (index < currentEntries.size()) {
+                        for (; index < currentEntries.size(); index++) {
+                            removeUnusedReference(currentEntries.get(index), attributeInfo, elementType);
                         }
                     }
                 }
-                return additionalElements;
             }
+
+            // for dereference on way out
+            GraphHelper.setProperty(instanceVertex, propertyName, newEntries);
         }
-        return new ArrayList<>();
     }
 
     /******************************************** MAP **************************************************/
 
-    private void mapMapCollectionToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,
-                                          AttributeInfo attributeInfo, Operation operation) throws AtlasException {
-        LOG.debug("Mapping instance {} to vertex {} for attribute {}", typedInstance.toShortString(), string(instanceVertex),
+    private void mapMapCollectionToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
+        AttributeInfo attributeInfo, Operation operation) throws AtlasException {
+        LOG.debug("Mapping instance {} to vertex {} for name {}", typedInstance.getTypeName(), instanceVertex,
                 attributeInfo.name);
-        @SuppressWarnings("unchecked") Map<Object, Object> newAttribute =
-                (Map<Object, Object>) typedInstance.get(attributeInfo.name);
+        @SuppressWarnings("unchecked") Map<Object, Object> collection =
+            (Map<Object, Object>) typedInstance.get(attributeInfo.name);
+        boolean empty = (collection == null || collection.isEmpty());
+        if (!empty  || operation == Operation.UPDATE_FULL) {
 
-        boolean newAttributeEmpty = (newAttribute == null || newAttribute.isEmpty());
-        if (newAttributeEmpty && operation != Operation.UPDATE_FULL) {
-            return;
-        }
+            String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+            IDataType elementType = ((DataTypes.MapType) attributeInfo.dataType()).getValueType();
 
-        IDataType elementType = ((DataTypes.MapType) attributeInfo.dataType()).getValueType();
-        String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);
+            if (!empty) {
+                for (Map.Entry entry : collection.entrySet()) {
+                    String myPropertyName = propertyName + "." + entry.getKey().toString();
 
-        Map<String, Object> currentMap = new HashMap<>();
-        Map<String, Object> newMap = new HashMap<>();
+                    String currentEntry = instanceVertex.getProperty(myPropertyName);
+                    String newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
+                            entry.getValue(), currentEntry, myPropertyName, operation);
 
-        List<String> currentKeys = GraphHelper.getListProperty(instanceVertex, propertyName);
-        if (currentKeys != null && !currentKeys.isEmpty()) {
-            for (String key : currentKeys) {
-                String propertyNameForKey = GraphHelper.getQualifiedNameForMapKey(propertyName, key);
-                Object propertyValueForKey = GraphHelper.getMapValueProperty(elementType, instanceVertex, propertyNameForKey);
-                currentMap.put(key, propertyValueForKey);
-            }
-        }
-
-        if (!newAttributeEmpty) {
-            for (Map.Entry<Object,Object> entry : newAttribute.entrySet()) {
-                String keyStr = entry.getKey().toString();
-                String propertyNameForKey = GraphHelper.getQualifiedNameForMapKey(propertyName, keyStr);
-
-                Object newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
-                        entry.getValue(), currentMap.get(keyStr), propertyNameForKey, operation);
-
-                //Add/Update/Remove property value
-                GraphHelper.setMapValueProperty(elementType, instanceVertex, propertyNameForKey, newEntry);
-                newMap.put(keyStr, newEntry);
-            }
-        }
-
-        Map<String, Object> additionalMap =
-                removeUnusedMapEntries(instanceVertex, propertyName, currentMap, newMap, elementType, attributeInfo);
-
-        Set<String> newKeys = new HashSet<>(newMap.keySet());
-        newKeys.addAll(additionalMap.keySet());
-
-
-        // for dereference on way out
-        GraphHelper.setListProperty(instanceVertex, propertyName, new ArrayList<>(newKeys));
-    }
-
-    //Remove unused entries from map
-    private Map<String, Object> removeUnusedMapEntries(
-            AtlasVertex instanceVertex, String propertyName,
-            Map<String, Object> currentMap,
-            Map<String, Object> newMap, IDataType elementType,
-            AttributeInfo attributeInfo)
-                    throws AtlasException {
-
-        Map<String, Object> additionalMap = new HashMap<>();
-        for (String currentKey : currentMap.keySet()) {
-
-            boolean shouldDeleteKey = !newMap.containsKey(currentKey);
-            if (GraphHelper.isReference(elementType)) {
-
-                //Delete the edge reference if its not part of new edges created/updated
-                AtlasEdge currentEdge = (AtlasEdge)currentMap.get(currentKey);
-
-                if (!newMap.values().contains(currentEdge)) {
+                    //Add/Update/Remove property value
+                    GraphHelper.setProperty(instanceVertex, myPropertyName, newEntry);
+                }
 
-                    boolean deleted =
-                            deleteHandler.deleteEdgeReference(currentEdge, elementType.getTypeCategory(), attributeInfo.isComposite, true);
-                    if (!deleted) {
-                        additionalMap.put(currentKey, currentEdge);
-                        shouldDeleteKey = false;
+                //Remove unused key references
+                List<Object> origKeys = instanceVertex.getProperty(propertyName);
+                if (origKeys != null) {
+                    if (collection != null) {
+                        origKeys.removeAll(collection.keySet());
+                    }
+                    for (Object unusedKey : origKeys) {
+                        String edgeLabel = GraphHelper.getEdgeLabel(typedInstance, attributeInfo) + "." + unusedKey;
+                        if (instanceVertex.getEdges(Direction.OUT, edgeLabel).iterator().hasNext()) {
+                            Edge edge = instanceVertex.getEdges(Direction.OUT, edgeLabel).iterator().next();
+                            removeUnusedReference(edge.getId().toString(), attributeInfo,
+                                    ((DataTypes.MapType) attributeInfo.dataType()).getValueType());
+                        }
                     }
                 }
-            }
 
-            if (shouldDeleteKey) {
-                String propertyNameForKey = GraphHelper.getQualifiedNameForMapKey(propertyName, currentKey);
-                GraphHelper.setProperty(instanceVertex, propertyNameForKey, null);
             }
+
+            // for dereference on way out
+            GraphHelper.setProperty(instanceVertex, propertyName, collection == null ? null : new ArrayList(collection.keySet()));
         }
-        return additionalMap;
     }
 
     /******************************************** ARRAY & MAP **************************************************/
 
-    private Object addOrUpdateCollectionEntry(AtlasVertex instanceVertex, AttributeInfo attributeInfo,
-                                              IDataType elementType, Object newAttributeValue, Object currentValue,
-                                              String propertyName, Operation operation)
-            throws AtlasException {
+    private String addOrUpdateCollectionEntry(Vertex instanceVertex, AttributeInfo attributeInfo,
+                                              IDataType elementType, Object newVal, String curVal, String propertyName,
+                                              Operation operation)
+        throws AtlasException {
 
+        final String edgeLabel = GraphHelper.EDGE_LABEL_PREFIX + propertyName;
         switch (elementType.getTypeCategory()) {
         case PRIMITIVE:
         case ENUM:
-            return newAttributeValue != null ? newAttributeValue : null;
+            return newVal != null ? newVal.toString() : null;
 
         case ARRAY:
         case MAP:
@@ -496,117 +429,70 @@ public final class TypedInstanceToGraphMapper {
             return null;
 
         case STRUCT:
-        case CLASS:
-            final String edgeLabel = GraphHelper.EDGE_LABEL_PREFIX + propertyName;
-            return addOrUpdateReference(instanceVertex, attributeInfo, elementType, newAttributeValue, (AtlasEdge)currentValue,
-                    edgeLabel, operation);
-
-        default:
-            throw new IllegalArgumentException("Unknown type category: " + elementType.getTypeCategory());
-        }
-    }
-
-    private AtlasEdge addOrUpdateReference(AtlasVertex instanceVertex, AttributeInfo attributeInfo,
-                                        IDataType attributeType, Object newAttributeValue, AtlasEdge currentEdge,
-                                        String edgeLabel, Operation operation) throws AtlasException {
-        switch (attributeType.getTypeCategory()) {
-        case STRUCT:
-            return addOrUpdateStruct(instanceVertex, attributeInfo, (ITypedStruct) newAttributeValue, currentEdge,
-                    edgeLabel, operation);
+            return addOrUpdateStruct(instanceVertex, attributeInfo, elementType, (ITypedStruct) newVal, curVal, edgeLabel, operation);
 
         case CLASS:
-            return addOrUpdateClassVertex(instanceVertex, currentEdge,
-                    (ITypedReferenceableInstance) newAttributeValue, attributeInfo, edgeLabel);
+            return addOrUpdateClassVertex(instanceVertex, attributeInfo, elementType,
+                    (ITypedReferenceableInstance) newVal, curVal, edgeLabel, operation);
 
         default:
-            throw new IllegalArgumentException("Unknown type category: " + attributeType.getTypeCategory());
+            throw new IllegalArgumentException("Unknown type category: " + elementType.getTypeCategory());
         }
     }
-    /******************************************** STRUCT **************************************************/
-
 
-    private AtlasEdge addOrUpdateStruct(AtlasVertex instanceVertex, AttributeInfo attributeInfo,
-            ITypedStruct newAttributeValue, AtlasEdge currentEdge,
-            String edgeLabel, Operation operation) throws AtlasException {
-        AtlasEdge newEdge = null;
-        if (GraphHelper.elementExists(currentEdge) && newAttributeValue != null) {
+    private String addOrUpdateStruct(Vertex instanceVertex, AttributeInfo attributeInfo, IDataType elementType,
+                                     ITypedStruct structAttr, String curVal,
+                                     String edgeLabel, Operation operation) throws AtlasException {
+        Pair<Vertex, Edge> vertexEdgePair = null;
+        if (curVal != null && structAttr == null) {
+            //remove edge
+            removeUnusedReference(curVal, attributeInfo, elementType);
+        } else if (curVal != null && structAttr != null) {
             //update
-            updateStructVertex(newAttributeValue, currentEdge, operation);
-            newEdge = currentEdge;
-        } else if (! GraphHelper.elementExists(currentEdge) && newAttributeValue != null) {
+            Edge edge = graphHelper.getOutGoingEdgeById(curVal);
+            vertexEdgePair = updateStructVertex(structAttr, edge, operation);
+        } else if (structAttr != null) {
             //add
-            newEdge = addStructVertex(newAttributeValue, instanceVertex, attributeInfo, edgeLabel);
+            vertexEdgePair = addStructVertex(structAttr, instanceVertex, attributeInfo, edgeLabel);
         }
-        return newEdge;
-    }
-
-    private AtlasEdge addStructVertex(ITypedStruct structInstance, AtlasVertex instanceVertex,
-                                 AttributeInfo attributeInfo, String edgeLabel) throws AtlasException {
-        // add a new vertex for the struct or trait instance
-        AtlasVertex structInstanceVertex = graphHelper.createVertexWithoutIdentity(structInstance.getTypeName(), null,
-                Collections.<String>emptySet()); // no super types for struct type
-        LOG.debug("created vertex {} for struct {} value {}", string(structInstanceVertex), attributeInfo.name,
-                structInstance.toShortString());
 
-        // map all the attributes to this new vertex
-        mapInstanceToVertex(structInstance, structInstanceVertex, structInstance.fieldMapping().fields, false,
-                Operation.CREATE);
-        // add an edge to the newly created vertex from the parent
-        AtlasEdge newEdge = graphHelper.getOrCreateEdge(instanceVertex, structInstanceVertex, edgeLabel);
-
-        return newEdge;
+        return (vertexEdgePair != null) ? vertexEdgePair.getRight().getId().toString() : null;
     }
 
-    private void updateStructVertex(ITypedStruct newAttributeValue, AtlasEdge currentEdge,
-            Operation operation) throws AtlasException {
-        //Already existing vertex. Update
-        AtlasVertex structInstanceVertex = currentEdge.getInVertex();
-
-        LOG.debug("Updating struct vertex {} with struct {}", string(structInstanceVertex), newAttributeValue.toShortString());
-
-        // Update attributes
-        final MessageDigest digester = MD5Utils.getDigester();
-        String newSignature = newAttributeValue.getSignatureHash(digester);
-        String curSignature = GraphHelper.getSingleValuedProperty(structInstanceVertex, SIGNATURE_HASH_PROPERTY_KEY, String.class);
-
-        if (!newSignature.equals(curSignature)) {
-            //Update struct vertex instance only if there is a change
-            LOG.debug("Updating struct {} since signature has changed {} {} ", newAttributeValue, curSignature, newSignature);
-            mapInstanceToVertex(newAttributeValue, structInstanceVertex, newAttributeValue.fieldMapping().fields, false, operation);
-            GraphHelper.setProperty(structInstanceVertex, SIGNATURE_HASH_PROPERTY_KEY, String.valueOf(newSignature));
+    private String addOrUpdateClassVertex(Vertex instanceVertex, AttributeInfo attributeInfo, IDataType elementType,
+                                          ITypedReferenceableInstance newVal, String curVal,
+                                          String edgeLabel, Operation operation) throws AtlasException {
+        Vertex toVertex = getClassVertex(newVal);
+        if(toVertex == null && newVal != null) {
+            LOG.error("Could not find vertex for Class Reference " + newVal);
+            throw new EntityNotFoundException("Could not find vertex for Class Reference " + newVal);
         }
-    }
 
-    /******************************************** CLASS **************************************************/
-
-    private AtlasEdge addOrUpdateClassVertex(AtlasVertex instanceVertex, AtlasEdge currentEdge,
-            ITypedReferenceableInstance newAttributeValue, AttributeInfo attributeInfo,
-            String edgeLabel) throws AtlasException {
-        AtlasVertex newReferenceVertex = getClassVertex(newAttributeValue);
-        if( ! GraphHelper.elementExists(newReferenceVertex) && newAttributeValue != null) {
-            LOG.error("Could not find vertex for Class Reference " + newAttributeValue);
-            throw new EntityNotFoundException("Could not find vertex for Class Reference " + newAttributeValue);
+        Pair<Vertex, Edge> vertexEdgePair = null;
+        if (curVal != null && newVal == null) {
+            //remove edge
+            removeUnusedReference(curVal, attributeInfo, elementType);
+        } else if (curVal != null && newVal != null) {
+            Edge edge = graphHelper.getOutGoingEdgeById(curVal);
+            Id classRefId = getId(newVal);
+            vertexEdgePair = updateClassEdge(classRefId, newVal, instanceVertex, edge, toVertex, attributeInfo, elementType, edgeLabel, operation);
+        } else if (newVal != null){
+            vertexEdgePair = addClassEdge(instanceVertex, toVertex, edgeLabel);
         }
 
-        AtlasEdge newEdge = null;
-        if (GraphHelper.elementExists(currentEdge) && newAttributeValue != null) {
-            newEdge = updateClassEdge(instanceVertex, currentEdge, newAttributeValue, newReferenceVertex,
-                    attributeInfo, edgeLabel);
-        } else if (! GraphHelper.elementExists(currentEdge) && newAttributeValue != null){
-            newEdge = addClassEdge(instanceVertex, newReferenceVertex, edgeLabel);
-
-        }
-        return newEdge;
+        return (vertexEdgePair != null) ? vertexEdgePair.getRight().getId().toString() : null;
     }
 
+    /******************************************** CLASS **************************************************/
 
-    private AtlasEdge addClassEdge(AtlasVertex instanceVertex, AtlasVertex toVertex, String edgeLabel) throws AtlasException {
-        // add an edge to the class vertex from the instance
-        return graphHelper.getOrCreateEdge(instanceVertex, toVertex, edgeLabel);
+    private Pair<Vertex, Edge> addClassEdge(Vertex instanceVertex, Vertex toVertex, String edgeLabel) throws AtlasException {
+            // add an edge to the class vertex from the instance
+          Edge edge = graphHelper.addEdge(instanceVertex, toVertex, edgeLabel);
+          return Pair.of(toVertex, edge);
     }
 
-    private AtlasVertex getClassVertex(ITypedReferenceableInstance typedReference) throws EntityNotFoundException {
-        AtlasVertex referenceVertex = null;
+    private Vertex getClassVertex(ITypedReferenceableInstance typedReference) throws EntityNotFoundException {
+        Vertex referenceVertex = null;
         Id id = null;
         if (typedReference != null) {
             id = typedReference instanceof Id ? (Id) typedReference : typedReference.getId();
@@ -621,62 +507,73 @@ public final class TypedInstanceToGraphMapper {
     }
 
     private Id getId(ITypedReferenceableInstance typedReference) throws EntityNotFoundException {
-        if (typedReference == null) {
-            throw new IllegalArgumentException("typedReference must be non-null");
+        Id id = null;
+        if (typedReference != null) {
+            id = typedReference instanceof Id ? (Id) typedReference : typedReference.getId();
         }
-        Id id = typedReference instanceof Id ? (Id) typedReference : typedReference.getId();
 
         if (id.isUnassigned()) {
-            AtlasVertex classVertex = idToVertexMap.get(id);
-            String guid = GraphHelper.getIdFromVertex(classVertex);
+            Vertex classVertex = idToVertexMap.get(id);
+            String guid = classVertex.getProperty(Constants.GUID_PROPERTY_KEY);
             id = new Id(guid, 0, typedReference.getTypeName());
         }
         return id;
     }
 
 
-    private AtlasEdge updateClassEdge(AtlasVertex instanceVertex, AtlasEdge currentEdge,
-            ITypedReferenceableInstance newAttributeValue,
-            AtlasVertex newVertex, AttributeInfo attributeInfo,
-            String edgeLabel) throws AtlasException {
-        LOG.debug("Updating {} for reference attribute {}", string(currentEdge), attributeInfo.name);
+    private Pair<Vertex, Edge> updateClassEdge(Id id, final ITypedReferenceableInstance typedInstance,
+                                               Vertex instanceVertex, Edge edge, Vertex toVertex,
+                                               AttributeInfo attributeInfo, IDataType dataType,
+                                               String edgeLabel, Operation operation) throws AtlasException {
+        Pair<Vertex, Edge> result = Pair.of(toVertex, edge);
+        Edge newEdge = edge;
         // Update edge if it exists
-        AtlasVertex currentVertex = currentEdge.getInVertex();
-        String currentEntityId = GraphHelper.getIdFromVertex(currentVertex);
-        String newEntityId = getId(newAttributeValue).id;
-        AtlasEdge newEdge = currentEdge;
-        if (!currentEntityId.equals(newEntityId)) {
-            // add an edge to the class vertex from the instance
-            if (newVertex != null) {
-                newEdge = graphHelper.getOrCreateEdge(instanceVertex, newVertex, edgeLabel);
+        Vertex invertex = edge.getVertex(Direction.IN);
+        String currentGUID = invertex.getProperty(Constants.GUID_PROPERTY_KEY);
+        Id currentId = new Id(currentGUID, 0, (String) invertex.getProperty(Constants.ENTITY_TYPE_PROPERTY_KEY));
+        if (!currentId.equals(id)) {
+             // add an edge to the class vertex from the instance
+            if(toVertex != null) {
+                newEdge = graphHelper.addEdge(instanceVertex, toVertex, edgeLabel);
+                result = Pair.of(toVertex, newEdge);
+            }
+            removeUnusedReference(edge.getId().toString(), attributeInfo, dataType);
+        }
 
+        if (attributeInfo.isComposite) {
+            //Update the attributes also if composite
+            if (typedInstance.fieldMapping() != null) {
+                //In case of Id instance, fieldMapping is null
+                mapInstanceToVertex(typedInstance, toVertex, typedInstance.fieldMapping().fields , false, operation);
+                //Update full text for the updated composite vertex
+                addFullTextProperty(new ArrayList<ITypedReferenceableInstance>() {{ add(typedInstance); }});
             }
         }
 
-        return newEdge;
+        return result;
     }
 
     /******************************************** TRAITS ****************************************************/
 
-    void mapTraitInstanceToVertex(ITypedStruct traitInstance, IDataType entityType, AtlasVertex parentInstanceVertex)
-            throws AtlasException {
-        // add a new AtlasVertex for the struct or trait instance
+    void mapTraitInstanceToVertex(ITypedStruct traitInstance, IDataType entityType, Vertex parentInstanceVertex)
+        throws AtlasException {
+        // add a new vertex for the struct or trait instance
         final String traitName = traitInstance.getTypeName();
-        AtlasVertex traitInstanceVertex = graphHelper.createVertexWithoutIdentity(traitInstance.getTypeName(), null,
+        Vertex traitInstanceVertex = graphHelper.createVertexWithoutIdentity(traitInstance.getTypeName(), null,
                 typeSystem.getDataType(TraitType.class, traitName).getAllSuperTypeNames());
-        LOG.debug("created vertex {} for trait {}", string(traitInstanceVertex), traitName);
+        LOG.debug("created vertex {} for trait {}", traitInstanceVertex, traitName);
 
-        // map all the attributes to this newly created AtlasVertex
+        // map all the attributes to this newly created vertex
         mapInstanceToVertex(traitInstance, traitInstanceVertex, traitInstance.fieldMapping().fields, false, Operation.CREATE);
 
-        // add an edge to the newly created AtlasVertex from the parent
+        // add an edge to the newly created vertex from the parent
         String relationshipLabel = GraphHelper.getTraitLabel(entityType.getName(), traitName);
-        graphHelper.getOrCreateEdge(parentInstanceVertex, traitInstanceVertex, relationshipLabel);
+        graphHelper.addEdge(parentInstanceVertex, traitInstanceVertex, relationshipLabel);
     }
 
     /******************************************** PRIMITIVES **************************************************/
 
-    private void mapPrimitiveOrEnumToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,
+    private void mapPrimitiveOrEnumToVertex(ITypedInstance typedInstance, Vertex instanceVertex,
                                             AttributeInfo attributeInfo) throws AtlasException {
         Object attrValue = typedInstance.get(attributeInfo.name);
 
@@ -708,15 +605,29 @@ public final class TypedInstanceToGraphMapper {
         } else if (attributeInfo.dataType() == DataTypes.DATE_TYPE) {
             final Date dateVal = typedInstance.getDate(attributeInfo.name);
             //Convert Property value to Long  while persisting
-            if(dateVal != null) {
-                propertyValue = dateVal.getTime();
-            }
+            propertyValue = dateVal.getTime();
         } else if (attributeInfo.dataType().getTypeCategory() == DataTypes.TypeCategory.ENUM) {
             if (attrValue != null) {
                 propertyValue = ((EnumValue)attrValue).value;
             }
         }
 
+
         GraphHelper.setProperty(instanceVertex, vertexPropertyName, propertyValue);
     }
+
+    private Edge removeUnusedReference(String edgeId, AttributeInfo attributeInfo, IDataType<?> elementType) {
+        //Remove edges for property values which do not exist any more
+        Edge removedRelation = null;
+        switch (elementType.getTypeCategory()) {
+        case STRUCT:
+            removedRelation = graphHelper.removeRelation(edgeId, true);
+            //Remove the vertex from state so that further processing no longer uses this
+            break;
+        case CLASS:
+            removedRelation = graphHelper.removeRelation(edgeId, attributeInfo.isComposite);
+            break;
+        }
+        return removedRelation;
+    }
 }