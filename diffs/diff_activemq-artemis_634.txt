diff --git a/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/mapped/MappedFile.java b/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/mapped/MappedFile.java
index adfc4fef7b..72221f4706 100644
--- a/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/mapped/MappedFile.java
+++ b/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/mapped/MappedFile.java
@@ -20,19 +20,18 @@ import java.io.File;
 import java.io.IOException;
 import java.nio.BufferUnderflowException;
 import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
 import java.nio.MappedByteBuffer;
 
 import io.netty.buffer.ByteBuf;
-import io.netty.buffer.UnpooledUnsafeDirectByteBufWrapper;
 import io.netty.util.internal.PlatformDependent;
-import org.apache.activemq.artemis.core.buffers.impl.ChannelBufferWrapper;
-import org.apache.activemq.artemis.core.journal.EncodingSupport;
 
 final class MappedFile implements AutoCloseable {
 
+   private static final ByteBuffer ZERO_PAGE = ByteBuffer.allocateDirect(MappedByteBufferCache.PAGE_SIZE).order(ByteOrder.nativeOrder());
+
    private final MappedByteBufferCache cache;
-   private final UnpooledUnsafeDirectByteBufWrapper byteBufWrapper;
-   private final ChannelBufferWrapper channelBufferWrapper;
+   private final int zerosMaxPage;
    private MappedByteBuffer lastMapped;
    private long lastMappedStart;
    private long lastMappedLimit;
@@ -46,8 +45,7 @@ final class MappedFile implements AutoCloseable {
       this.lastMappedLimit = -1;
       this.position = 0;
       this.length = this.cache.fileSize();
-      this.byteBufWrapper = new UnpooledUnsafeDirectByteBufWrapper();
-      this.channelBufferWrapper = new ChannelBufferWrapper(this.byteBufWrapper, false);
+      this.zerosMaxPage = Math.min(ZERO_PAGE.capacity(), (int) Math.min(Integer.MAX_VALUE, cache.overlapBytes()));
    }
 
    public static MappedFile of(File file, long chunckSize, long overlapSize) throws IOException {
@@ -60,30 +58,29 @@ final class MappedFile implements AutoCloseable {
 
    private int checkOffset(long offset, int bytes) throws BufferUnderflowException, IOException {
       if (!MappedByteBufferCache.inside(offset, lastMappedStart, lastMappedLimit)) {
-         return updateOffset(offset, bytes);
-      } else {
-         final int bufferPosition = (int) (offset - lastMappedStart);
-         return bufferPosition;
-      }
-   }
-
-   private int updateOffset(long offset, int bytes) throws BufferUnderflowException, IOException {
-      try {
-         final int index = cache.indexFor(offset);
-         final long mappedPosition = cache.mappedPositionFor(index);
-         final long mappedLimit = cache.mappedLimitFor(mappedPosition);
-         if (offset + bytes > mappedLimit) {
-            throw new IOException("mapping overflow!");
+         try {
+            final int index = cache.indexFor(offset);
+            final long mappedPosition = cache.mappedPositionFor(index);
+            final long mappedLimit = cache.mappedLimitFor(mappedPosition);
+            if (offset + bytes > mappedLimit) {
+               throw new IOException("mapping overflow!");
+            }
+            lastMapped = cache.acquireMappedByteBuffer(index);
+            lastMappedStart = mappedPosition;
+            lastMappedLimit = mappedLimit;
+            final int bufferPosition = (int) (offset - mappedPosition);
+            return bufferPosition;
+         }
+         catch (IllegalStateException e) {
+            throw new IOException(e);
          }
-         lastMapped = cache.acquireMappedByteBuffer(index);
-         lastMappedStart = mappedPosition;
-         lastMappedLimit = mappedLimit;
-         final int bufferPosition = (int) (offset - mappedPosition);
+         catch (IllegalArgumentException e) {
+            throw new BufferUnderflowException();
+         }
+      }
+      else {
+         final int bufferPosition = (int) (offset - lastMappedStart);
          return bufferPosition;
-      } catch (IllegalStateException e) {
-         throw new IOException(e);
-      } catch (IllegalArgumentException e) {
-         throw new BufferUnderflowException();
       }
    }
 
@@ -104,10 +101,12 @@ final class MappedFile implements AutoCloseable {
       if (dst.hasMemoryAddress()) {
          final long dstAddress = dst.memoryAddress() + dstStart;
          PlatformDependent.copyMemory(srcAddress, dstAddress, dstLength);
-      } else if (dst.hasArray()) {
+      }
+      else if (dst.hasArray()) {
          final byte[] dstArray = dst.array();
          PlatformDependent.copyMemory(srcAddress, dstArray, dstStart, dstLength);
-      } else {
+      }
+      else {
          throw new IllegalArgumentException("unsupported byte buffer");
       }
       position += dstLength;
@@ -128,7 +127,8 @@ final class MappedFile implements AutoCloseable {
       if (dst.isDirect()) {
          final long dstAddress = PlatformDependent.directBufferAddress(dst) + dstStart;
          PlatformDependent.copyMemory(srcAddress, dstAddress, dstLength);
-      } else {
+      }
+      else {
          final byte[] dstArray = dst.array();
          PlatformDependent.copyMemory(srcAddress, dstArray, dstStart, dstLength);
       }
@@ -146,17 +146,19 @@ final class MappedFile implements AutoCloseable {
     * then the position is updated with the number of bytes actually read.
     */
    public int read(ByteBuf dst, int dstStart, int dstLength) throws IOException {
-      final int remaining = (int) Math.min(this.length - this.position, Integer.MAX_VALUE);
+      final int remaining = (int) Math.min(this.length - this.position, (long) Integer.MAX_VALUE);
       final int read = Math.min(remaining, dstLength);
       final int bufferPosition = checkOffset(position, read);
       final long srcAddress = PlatformDependent.directBufferAddress(lastMapped) + bufferPosition;
       if (dst.hasMemoryAddress()) {
          final long dstAddress = dst.memoryAddress() + dstStart;
          PlatformDependent.copyMemory(srcAddress, dstAddress, read);
-      } else if (dst.hasArray()) {
+      }
+      else if (dst.hasArray()) {
          final byte[] dstArray = dst.array();
          PlatformDependent.copyMemory(srcAddress, dstArray, dstStart, read);
-      } else {
+      }
+      else {
          throw new IllegalArgumentException("unsupported byte buffer");
       }
       position += read;
@@ -170,14 +172,15 @@ final class MappedFile implements AutoCloseable {
     * then the position is updated with the number of bytes actually read.
     */
    public int read(ByteBuffer dst, int dstStart, int dstLength) throws IOException {
-      final int remaining = (int) Math.min(this.length - this.position, Integer.MAX_VALUE);
+      final int remaining = (int) Math.min(this.length - this.position, (long) Integer.MAX_VALUE);
       final int read = Math.min(remaining, dstLength);
       final int bufferPosition = checkOffset(position, read);
       final long srcAddress = PlatformDependent.directBufferAddress(lastMapped) + bufferPosition;
       if (dst.isDirect()) {
          final long dstAddress = PlatformDependent.directBufferAddress(dst) + dstStart;
          PlatformDependent.copyMemory(srcAddress, dstAddress, read);
-      } else {
+      }
+      else {
          final byte[] dstArray = dst.array();
          PlatformDependent.copyMemory(srcAddress, dstArray, dstStart, read);
       }
@@ -185,26 +188,6 @@ final class MappedFile implements AutoCloseable {
       return read;
    }
 
-   /**
-    * Writes an encoded sequence of bytes to this file from the given buffer.
-    * <p>
-    * <p> Bytes are written starting at this file's current position,
-    */
-   public void write(EncodingSupport encodingSupport) throws IOException {
-      final int encodedSize = encodingSupport.getEncodeSize();
-      final int bufferPosition = checkOffset(position, encodedSize);
-      this.byteBufWrapper.wrap(this.lastMapped, bufferPosition, encodedSize);
-      try {
-         encodingSupport.encode(this.channelBufferWrapper);
-      } finally {
-         this.byteBufWrapper.reset();
-      }
-      position += encodedSize;
-      if (position > this.length) {
-         this.length = position;
-      }
-   }
-
    /**
     * Writes a sequence of bytes to this file from the given buffer.
     * <p>
@@ -216,10 +199,12 @@ final class MappedFile implements AutoCloseable {
       if (src.hasMemoryAddress()) {
          final long srcAddress = src.memoryAddress() + srcStart;
          PlatformDependent.copyMemory(srcAddress, destAddress, srcLength);
-      } else if (src.hasArray()) {
+      }
+      else if (src.hasArray()) {
          final byte[] srcArray = src.array();
          PlatformDependent.copyMemory(srcArray, srcStart, destAddress, srcLength);
-      } else {
+      }
+      else {
          throw new IllegalArgumentException("unsupported byte buffer");
       }
       position += srcLength;
@@ -239,7 +224,8 @@ final class MappedFile implements AutoCloseable {
       if (src.isDirect()) {
          final long srcAddress = PlatformDependent.directBufferAddress(src) + srcStart;
          PlatformDependent.copyMemory(srcAddress, destAddress, srcLength);
-      } else {
+      }
+      else {
          final byte[] srcArray = src.array();
          PlatformDependent.copyMemory(srcArray, srcStart, destAddress, srcLength);
       }
@@ -260,10 +246,12 @@ final class MappedFile implements AutoCloseable {
       if (src.hasMemoryAddress()) {
          final long srcAddress = src.memoryAddress() + srcStart;
          PlatformDependent.copyMemory(srcAddress, destAddress, srcLength);
-      } else if (src.hasArray()) {
+      }
+      else if (src.hasArray()) {
          final byte[] srcArray = src.array();
          PlatformDependent.copyMemory(srcArray, srcStart, destAddress, srcLength);
-      } else {
+      }
+      else {
          throw new IllegalArgumentException("unsupported byte buffer");
       }
       position += srcLength;
@@ -283,7 +271,8 @@ final class MappedFile implements AutoCloseable {
       if (src.isDirect()) {
          final long srcAddress = PlatformDependent.directBufferAddress(src) + srcStart;
          PlatformDependent.copyMemory(srcAddress, destAddress, srcLength);
-      } else {
+      }
+      else {
          final byte[] srcArray = src.array();
          PlatformDependent.copyMemory(srcArray, srcStart, destAddress, srcLength);
       }
@@ -299,20 +288,21 @@ final class MappedFile implements AutoCloseable {
     * <p> Bytes are written starting at this file's current position,
     */
    public void zeros(long offset, int count) throws IOException {
-      while (count > 0) {
-         //do not need to validate the bytes count
-         final int bufferPosition = checkOffset(offset, 0);
-         final int endZerosPosition = (int)Math.min((long)bufferPosition + count, lastMapped.capacity());
-         final int zeros = endZerosPosition - bufferPosition;
+      final long targetOffset = offset + count;
+      final int zerosBulkCopies = count / zerosMaxPage;
+      final long srcAddress = PlatformDependent.directBufferAddress(ZERO_PAGE);
+      for (int i = 0; i < zerosBulkCopies; i++) {
+         final int bufferPosition = checkOffset(offset, zerosMaxPage);
          final long destAddress = PlatformDependent.directBufferAddress(lastMapped) + bufferPosition;
-         PlatformDependent.setMemory(destAddress, zeros, (byte) 0);
-         offset += zeros;
-         count -= zeros;
-         //TODO need to call force on each write?
-         //this.force();
+         PlatformDependent.copyMemory(srcAddress, destAddress, zerosMaxPage);
+         offset += zerosMaxPage;
       }
-      if (offset > this.length) {
-         this.length = offset;
+      final int remainingToBeZeroes = (int) (targetOffset - offset);
+      final int bufferPosition = checkOffset(offset, remainingToBeZeroes);
+      final long destAddress = PlatformDependent.directBufferAddress(lastMapped) + bufferPosition;
+      PlatformDependent.copyMemory(srcAddress, destAddress, remainingToBeZeroes);
+      if (targetOffset > this.length) {
+         this.length = targetOffset;
       }
    }
 
@@ -338,4 +328,4 @@ final class MappedFile implements AutoCloseable {
    public void closeAndResize(long length) {
       cache.closeAndResize(length);
    }
-}
+}
\ No newline at end of file