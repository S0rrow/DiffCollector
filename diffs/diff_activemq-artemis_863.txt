diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java
index 8e6e33ce31..e050e9499d 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/FileLockNodeManager.java
@@ -22,17 +22,11 @@ import java.io.RandomAccessFile;
 import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.nio.channels.FileLock;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
 
 import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.core.server.ActivateCallback;
 import org.apache.activemq.artemis.core.server.ActiveMQLockAcquisitionTimeoutException;
-import org.apache.activemq.artemis.core.server.ActiveMQScheduledComponent;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.NodeManager;
 import org.apache.activemq.artemis.utils.UUID;
@@ -60,9 +54,7 @@ public class FileLockNodeManager extends NodeManager {
 
    private static final long LOCK_ACCESS_FAILURE_WAIT_TIME = 2000;
 
-   private static final int LOCK_MONITOR_TIMEOUT_MILLIES = 2000;
-
-   private volatile FileLock liveLock;
+   private FileLock liveLock;
 
    private FileLock backupLock;
 
@@ -72,23 +64,13 @@ public class FileLockNodeManager extends NodeManager {
 
    protected boolean interrupted = false;
 
-   private ScheduledExecutorService scheduledPool;
-
-   public FileLockNodeManager(final File directory, boolean replicatedBackup, ScheduledExecutorService scheduledPool) {
-      super(replicatedBackup, directory);
-      this.scheduledPool = scheduledPool;
-   }
-
    public FileLockNodeManager(final File directory, boolean replicatedBackup) {
       super(replicatedBackup, directory);
-      this.scheduledPool = null;
    }
 
-   public FileLockNodeManager(final File directory, boolean replicatedBackup, long lockAcquisitionTimeout,
-         ScheduledExecutorService scheduledPool) {
+   public FileLockNodeManager(final File directory, boolean replicatedBackup, long lockAcquisitionTimeout) {
       super(replicatedBackup, directory);
 
-      this.scheduledPool = scheduledPool;
       this.lockAcquisitionTimeout = lockAcquisitionTimeout;
    }
 
@@ -108,16 +90,7 @@ public class FileLockNodeManager extends NodeManager {
    protected synchronized void setUpServerLockFile() throws IOException {
       super.setUpServerLockFile();
 
-      if (lockChannels[0] == null || !lockChannels[0].isOpen()) {
-         File fileLock = newFile(NodeManager.SERVER_LOCK_NAME);
-         if (!fileLock.exists()) {
-            fileLock.createNewFile();
-         }
-         RandomAccessFile randomFileLock = new RandomAccessFile(fileLock, "rw");
-         lockChannels[0] = randomFileLock.getChannel();
-      }
-
-      for (int i = 1; i < 3; i++) {
+      for (int i = 0; i < 3; i++) {
          if (lockChannels[i] != null && lockChannels[i].isOpen()) {
             continue;
          }
@@ -133,14 +106,12 @@ public class FileLockNodeManager extends NodeManager {
    @Override
    public synchronized void stop() throws Exception {
       for (FileChannel channel : lockChannels) {
-         if (channel != null && channel.isOpen()) {
-            try {
-               channel.close();
-            } catch (Throwable e) {
-               // I do not want to interrupt a shutdown. If anything is wrong here, just log it
-               // it could be a critical error or something like that throwing the system down
-               logger.warn(e.getMessage(), e);
-            }
+         try {
+            channel.close();
+         } catch (Throwable e) {
+            // I do not want to interrupt a shutdown. If anything is wrong here, just log it
+            // it could be a critical error or something like that throwing the system down
+            logger.warn(e.getMessage(), e);
          }
       }
 
@@ -242,7 +213,6 @@ public class FileLockNodeManager extends NodeManager {
          public void activationComplete() {
             try {
                setLive();
-               startLockMonitoring();
             } catch (Exception e) {
                ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
             }
@@ -252,7 +222,6 @@ public class FileLockNodeManager extends NodeManager {
 
    @Override
    public void pauseLiveServer() throws Exception {
-      stopLockMonitoring();
       setPaused();
       if (liveLock != null) {
          liveLock.release();
@@ -261,7 +230,6 @@ public class FileLockNodeManager extends NodeManager {
 
    @Override
    public void crashLiveServer() throws Exception {
-      stopLockMonitoring();
       if (liveLock != null) {
          liveLock.release();
          liveLock = null;
@@ -418,117 +386,4 @@ public class FileLockNodeManager extends NodeManager {
       return null;
    }
 
-   private synchronized void startLockMonitoring() {
-      logger.debug("Starting the lock monitor");
-      if (monitorLock == null) {
-         monitorLock = new MonitorLock(scheduledPool, LOCK_MONITOR_TIMEOUT_MILLIES, LOCK_MONITOR_TIMEOUT_MILLIES, TimeUnit.MILLISECONDS, false);
-         monitorLock.start();
-      } else {
-         logger.debug("Lock monitor was already started");
-      }
-   }
-
-   private synchronized void stopLockMonitoring() {
-      logger.debug("Stopping the lock monitor");
-      if (monitorLock != null) {
-         monitorLock.stop();
-         monitorLock = null;
-      } else {
-         logger.debug("The lock monitor was already stopped");
-      }
-   }
-
-   private void notifyLostLock() {
-      // Additional check we are not initializing or have no locking object anymore
-      // because of a shutdown
-      if (lockListeners != null && liveLock != null) {
-         Set<LockListener> lockListenersSnapshot = null;
-
-         // Snapshot of the set because I'm not sure if we can trigger concurrent
-         // modification exception here if we don't
-         synchronized (lockListeners) {
-            lockListenersSnapshot = new HashSet<>(lockListeners);
-         }
-
-         lockListenersSnapshot.forEach(lockListener -> {
-            try {
-               lockListener.lostLock();
-            } catch (Exception e) {
-               // Need to notify everyone so ignore any exception
-            }
-         });
-      }
-   }
-
-   public void registerLockListener(LockListener lockListener) {
-      lockListeners.add(lockListener);
-   }
-
-   public void unregisterLockListener(LockListener lockListener) {
-      lockListeners.remove(lockListener);
-   }
-
-   protected final Set<LockListener> lockListeners = Collections.synchronizedSet(new HashSet<LockListener>());
-
-   private MonitorLock monitorLock;
-
-   public abstract class LockListener {
-      protected abstract void lostLock() throws Exception;
-
-      protected void unregisterListener() {
-         lockListeners.remove(this);
-      }
-   }
-
-
-   public class MonitorLock extends ActiveMQScheduledComponent {
-      public MonitorLock(ScheduledExecutorService scheduledExecutorService,
-                            long initialDelay,
-                            long checkPeriod,
-                            TimeUnit timeUnit,
-                            boolean onDemand) {
-         super(scheduledExecutorService, initialDelay, checkPeriod, timeUnit, onDemand);
-      }
-
-
-      @Override
-      public void run() {
-
-         boolean lostLock = true;
-         try {
-            if (liveLock == null) {
-               logger.debug("Livelock is null");
-            }
-            lostLock = (liveLock != null && !liveLock.isValid()) || liveLock == null;
-            if (!lostLock) {
-               logger.debug("Server still has the lock, double check status is live");
-               // Java always thinks the lock is still valid even when there is no filesystem
-               // so we do another check
-
-               // Should be able to retrieve the status unless something is wrong
-               // When EFS is gone, this locks. Which can be solved but is a lot of threading
-               // work where we need to
-               // manage the timeout ourselves and interrupt the thread used to claim the lock.
-               byte state = getState();
-               if (state == LIVE) {
-                  logger.debug("Status is set to live");
-               } else {
-                  logger.debug("Status is not live");
-               }
-            }
-         } catch (Exception exception) {
-            // If something went wrong we probably lost the lock
-            logger.error(exception.getMessage(), exception);
-            lostLock = true;
-         }
-
-         if (lostLock) {
-            logger.warn("Lost the lock according to the monitor, notifying listeners");
-            notifyLostLock();
-         }
-
-      }
-
-   }
-
 }