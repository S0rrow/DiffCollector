diff --git a/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/InjectTypeCastForSwitchCaseRule.java b/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/InjectTypeCastForSwitchCaseRule.java
index 683d29faab..2b70dcfa51 100644
--- a/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/InjectTypeCastForSwitchCaseRule.java
+++ b/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/InjectTypeCastForSwitchCaseRule.java
@@ -22,11 +22,10 @@ package org.apache.asterix.optimizer.rules;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
-import java.util.Set;
 
 import org.apache.asterix.dataflow.data.common.TypeResolverUtil;
 import org.apache.asterix.lang.common.util.FunctionUtil;
-import org.apache.asterix.om.functions.BuiltinFunctions;
+import org.apache.asterix.om.functions.AsterixBuiltinFunctions;
 import org.apache.asterix.om.typecomputer.base.TypeCastUtils;
 import org.apache.asterix.om.types.IAType;
 import org.apache.commons.lang3.mutable.Mutable;
@@ -39,23 +38,14 @@ import org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;
 import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;
 import org.apache.hyracks.algebricks.core.algebra.expressions.IVariableTypeEnvironment;
 import org.apache.hyracks.algebricks.core.algebra.expressions.ScalarFunctionCallExpression;
-import org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;
 import org.apache.hyracks.algebricks.core.rewriter.base.IAlgebraicRewriteRule;
 
-import com.google.common.collect.ImmutableSet;
-
 /**
- * This rule injects casts for function parameters if they have heterogeneous return types:
- * <ul>
- *     <li>for "THEN" and "ELSE" branches of a switch-case function</li>
- *     <li>for parameters of "if missing/null" functions  (if-missing(), if-null(), if-missing-or-null())</li>
- * </ul>
+ * This rule injects cast functions for "THEN" and "ELSE" branches of a switch-case function if
+ * different "THEN" and "ELSE" branches have heterogeneous return types.
  */
 public class InjectTypeCastForSwitchCaseRule implements IAlgebraicRewriteRule {
 
-    private static final Set<FunctionIdentifier> IF_FUNCTIONS =
-            ImmutableSet.of(BuiltinFunctions.IF_MISSING, BuiltinFunctions.IF_NULL, BuiltinFunctions.IF_MISSING_OR_NULL);
-
     @Override
     public boolean rewritePost(Mutable<ILogicalOperator> opRef, IOptimizationContext context)
             throws AlgebricksException {
@@ -90,67 +80,35 @@ public class InjectTypeCastForSwitchCaseRule implements IAlgebraicRewriteRule {
                 rewritten = true;
             }
         }
-        FunctionIdentifier funcId = func.getFunctionIdentifier();
-        if (funcId.equals(BuiltinFunctions.SWITCH_CASE)) {
-            if (rewriteSwitchCase(op, func, context)) {
-                rewritten = true;
-            }
-        } else if (IF_FUNCTIONS.contains(funcId)) {
-            if (rewriteFunction(op, func, context)) {
-                rewritten = true;
-            }
+        if (!func.getFunctionIdentifier().equals(AsterixBuiltinFunctions.SWITCH_CASE)) {
+            return rewritten;
         }
-        return rewritten;
+        return rewriteSwitchCase(op, func, context);
     }
 
     // Injects casts that cast types for different "THEN" and "ELSE" branches.
     private boolean rewriteSwitchCase(ILogicalOperator op, AbstractFunctionCallExpression func,
             IOptimizationContext context) throws AlgebricksException {
-        IVariableTypeEnvironment env = op.computeInputTypeEnvironment(context);
+        IVariableTypeEnvironment env = context.getOutputTypeEnvironment(op.getInputs().get(0).getValue());
         IAType producedType = (IAType) env.getType(func);
         List<Mutable<ILogicalExpression>> argRefs = func.getArguments();
         int argSize = argRefs.size();
         boolean rewritten = false;
         for (int argIndex = 2; argIndex < argSize; argIndex += (argIndex + 2 == argSize) ? 1 : 2) {
             Mutable<ILogicalExpression> argRef = argRefs.get(argIndex);
-            if (rewriteFunctionArgument(argRef, producedType, env)) {
+            IAType type = (IAType) env.getType(argRefs.get(argIndex).getValue());
+            if (TypeResolverUtil.needsCast(producedType, type)) {
+                ILogicalExpression argExpr = argRef.getValue();
+                // Injects a cast call to cast the data type to the produced type of the switch-case function call.
+                ScalarFunctionCallExpression castFunc = new ScalarFunctionCallExpression(
+                        FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.CAST_TYPE),
+                        new ArrayList<>(Collections.singletonList(new MutableObject<>(argExpr))));
+                TypeCastUtils.setRequiredAndInputTypes(castFunc, producedType, type);
+                argRef.setValue(castFunc);
                 rewritten = true;
             }
         }
         return rewritten;
     }
 
-    // Injects casts that cast types for all function parameters
-    private boolean rewriteFunction(ILogicalOperator op, AbstractFunctionCallExpression func,
-            IOptimizationContext context) throws AlgebricksException {
-        IVariableTypeEnvironment env = op.computeInputTypeEnvironment(context);
-        IAType producedType = (IAType) env.getType(func);
-        List<Mutable<ILogicalExpression>> argRefs = func.getArguments();
-        int argSize = argRefs.size();
-        boolean rewritten = false;
-        for (int argIndex = 0; argIndex < argSize; argIndex++) {
-            Mutable<ILogicalExpression> argRef = argRefs.get(argIndex);
-            if (rewriteFunctionArgument(argRef, producedType, env)) {
-                rewritten = true;
-            }
-        }
-        return rewritten;
-    }
-
-    private boolean rewriteFunctionArgument(Mutable<ILogicalExpression> argRef, IAType funcOutputType,
-            IVariableTypeEnvironment env) throws AlgebricksException {
-        ILogicalExpression argExpr = argRef.getValue();
-        IAType type = (IAType) env.getType(argExpr);
-        if (TypeResolverUtil.needsCast(funcOutputType, type)) {
-            // Injects a cast call to cast the data type to the produced type of the function call.
-            ScalarFunctionCallExpression castFunc =
-                    new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(BuiltinFunctions.CAST_TYPE),
-                            new ArrayList<>(Collections.singletonList(new MutableObject<>(argExpr))));
-            castFunc.setSourceLocation(argExpr.getSourceLocation());
-            TypeCastUtils.setRequiredAndInputTypes(castFunc, funcOutputType, type);
-            argRef.setValue(castFunc);
-            return true;
-        }
-        return false;
-    }
 }