diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/SharedNothingBackupQuorum.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/SharedNothingBackupQuorum.java
index 029767b30c..ca7326dade 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/SharedNothingBackupQuorum.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/cluster/qourum/SharedNothingBackupQuorum.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -21,22 +21,20 @@ import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 
 import org.apache.activemq.artemis.api.core.ActiveMQException;
-import org.apache.activemq.artemis.api.core.TransportConfiguration;
-import org.apache.activemq.artemis.api.core.client.SessionFailureListener;
+import org.apache.activemq.artemis.api.core.ActiveMQExceptionType;
 import org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryInternal;
 import org.apache.activemq.artemis.core.client.impl.Topology;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.protocol.core.CoreRemotingConnection;
 import org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage;
+import org.apache.activemq.artemis.core.remoting.FailureListener;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
-import org.apache.activemq.artemis.core.server.NetworkHealthCheck;
 import org.apache.activemq.artemis.core.server.NodeManager;
 
-public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener {
-
-   private TransportConfiguration liveTransportConfiguration;
-
-   public enum BACKUP_ACTIVATION {
+public class SharedNothingBackupQuorum implements Quorum, FailureListener
+{
+   public enum BACKUP_ACTIVATION
+   {
       FAIL_OVER, FAILURE_REPLICATING, ALREADY_REPLICATING, STOP;
    }
 
@@ -48,13 +46,6 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
 
    private final StorageManager storageManager;
    private final ScheduledExecutorService scheduledPool;
-   private final int quorumSize;
-
-   private final int voteRetries;
-
-   private final long voteRetryWait;
-
-   private final Object voteGuard = new Object();
 
    private CountDownLatch latch;
 
@@ -62,32 +53,21 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
 
    private CoreRemotingConnection connection;
 
-   private final NetworkHealthCheck networkHealthCheck;
-
    /**
     * This is a safety net in case the live sends the first {@link ReplicationLiveIsStoppingMessage}
     * with code {@link org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage.LiveStopping#STOP_CALLED} and crashes before sending the second with
     * {@link org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ReplicationLiveIsStoppingMessage.LiveStopping#FAIL_OVER}.
-    * <p>
+    * <p/>
     * If the second message does come within this dead line, we fail over anyway.
     */
    public static final int WAIT_TIME_AFTER_FIRST_LIVE_STOPPING_MSG = 60;
 
-   public SharedNothingBackupQuorum(StorageManager storageManager,
-                                    NodeManager nodeManager,
-                                    ScheduledExecutorService scheduledPool,
-                                    NetworkHealthCheck networkHealthCheck,
-                                    int quorumSize,
-                                    int voteRetries,
-                                    long voteRetryWait) {
+   public SharedNothingBackupQuorum(StorageManager storageManager, NodeManager nodeManager, ScheduledExecutorService scheduledPool)
+   {
       this.storageManager = storageManager;
       this.scheduledPool = scheduledPool;
-      this.quorumSize = quorumSize;
       this.latch = new CountDownLatch(1);
       this.nodeManager = nodeManager;
-      this.networkHealthCheck = networkHealthCheck;
-      this.voteRetries = voteRetries;
-      this.voteRetryWait = voteRetryWait;
    }
 
    private volatile BACKUP_ACTIVATION signal;
@@ -97,58 +77,56 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
     */
    private static final int LATCH_TIMEOUT = 30;
 
+   private static final int RECONNECT_ATTEMPTS = 5;
+
    private final Object decisionGuard = new Object();
 
    @Override
-   public String getName() {
+   public String getName()
+   {
       return "SharedNothingBackupQuorum";
    }
 
-   public void decideOnAction(Topology topology) {
+   public void decideOnAction(Topology topology)
+   {
       //we may get called via multiple paths so need to guard
-      synchronized (decisionGuard) {
-         if (signal == BACKUP_ACTIVATION.FAIL_OVER) {
-            if (networkHealthCheck != null && !networkHealthCheck.check()) {
-               signal = BACKUP_ACTIVATION.FAILURE_REPLICATING;
-            }
+      synchronized (decisionGuard)
+      {
+         if (signal == BACKUP_ACTIVATION.FAIL_OVER)
+         {
             return;
          }
-         if (!isLiveDown()) {
-            //lost connection but don't know if live is down so restart as backup as we can't replicate any more
-            ActiveMQServerLogger.LOGGER.restartingAsBackupBasedOnQuorumVoteResults();
-            signal = BACKUP_ACTIVATION.FAILURE_REPLICATING;
-         } else {
-            // live is assumed to be down, backup fails-over
-            ActiveMQServerLogger.LOGGER.failingOverBasedOnQuorumVoteResults();
-            signal = BACKUP_ACTIVATION.FAIL_OVER;
-         }
-
-         /* use NetworkHealthCheck to determine if node is isolated
-          * if there are no addresses/urls configured then ignore and rely on quorum vote only
-          */
-         if (networkHealthCheck != null && !networkHealthCheck.isEmpty()) {
-            if (networkHealthCheck.check()) {
-               // live is assumed to be down, backup fails-over
-               signal = BACKUP_ACTIVATION.FAIL_OVER;
-            } else {
-               ActiveMQServerLogger.LOGGER.serverIsolatedOnNetwork();
-               signal = BACKUP_ACTIVATION.FAILURE_REPLICATING;
+         if (!isLiveDown())
+         {
+            try
+            {
+               // no point in repeating all the reconnection logic
+               sessionFactory.connect(RECONNECT_ATTEMPTS, false);
+               return;
+            }
+            catch (ActiveMQException e)
+            {
+               if (e.getType() != ActiveMQExceptionType.NOT_CONNECTED)
+                  ActiveMQServerLogger.LOGGER.errorReConnecting(e);
             }
          }
+         // live is assumed to be down, backup fails-over
+         signal = BACKUP_ACTIVATION.FAIL_OVER;
       }
       latch.countDown();
    }
 
-   public void liveIDSet(String liveID) {
+   public void liveIDSet(String liveID)
+   {
       targetServerID = liveID;
       nodeManager.setNodeID(liveID);
-      liveTransportConfiguration = quorumManager.getLiveTransportConfiguration(targetServerID);
       //now we are replicating we can start waiting for disconnect notifications so we can fail over
-      // sessionFactory.addFailureListener(this);
+     // sessionFactory.addFailureListener(this);
    }
 
    @Override
-   public void setQuorumManager(QuorumManager quorumManager) {
+   public void setQuorumManager(QuorumManager quorumManager)
+   {
       this.quorumManager = quorumManager;
    }
 
@@ -160,14 +138,17 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
     * @param nodeID
     */
    @Override
-   public void nodeDown(Topology topology, long eventUID, String nodeID) {
-      if (targetServerID.equals(nodeID)) {
+   public void nodeDown(Topology topology, long eventUID, String nodeID)
+   {
+      if (targetServerID.equals(nodeID))
+      {
          decideOnAction(topology);
       }
    }
 
    @Override
-   public void nodeUp(Topology topology) {
+   public void nodeUp(Topology topology)
+   {
       //noop
    }
 
@@ -175,53 +156,56 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
     * if the connection to our replicated live goes down then decide on an action
     */
    @Override
-   public void connectionFailed(ActiveMQException exception, boolean failedOver) {
+   public void connectionFailed(ActiveMQException exception, boolean failedOver)
+   {
       decideOnAction(sessionFactory.getServerLocator().getTopology());
    }
 
    @Override
-   public void connectionFailed(final ActiveMQException me, boolean failedOver, String scaleDownTargetNodeID) {
+   public void connectionFailed(final ActiveMQException me, boolean failedOver, String scaleDownTargetNodeID)
+   {
       connectionFailed(me, failedOver);
    }
 
    @Override
-   public void beforeReconnect(ActiveMQException exception) {
-      //noop
-   }
-
-   @Override
-   public void close() {
+   public void close()
+   {
       causeExit(BACKUP_ACTIVATION.STOP);
    }
 
+
    /**
     * @param sessionFactory the session factory used to connect to the live server
     */
-   public void setSessionFactory(final ClientSessionFactoryInternal sessionFactory) {
+   public void setSessionFactory(final ClientSessionFactoryInternal sessionFactory)
+   {
       this.sessionFactory = sessionFactory;
-      this.connection = (CoreRemotingConnection) sessionFactory.getConnection();
+      this.connection = (CoreRemotingConnection)sessionFactory.getConnection();
       connection.addFailureListener(this);
-      //belts and braces, there are circumstances where the connection listener doesn't get called but the session does.
-      sessionFactory.addFailureListener(this);
    }
 
    /**
     * Releases the latch, causing the backup activation thread to fail-over.
-    * <p>
+    * <p/>
     * The use case is for when the 'live' has an orderly shutdown, in which case it informs the
     * backup that it should fail-over.
     */
-   public synchronized void failOver(ReplicationLiveIsStoppingMessage.LiveStopping finalMessage) {
+   public synchronized void failOver(ReplicationLiveIsStoppingMessage.LiveStopping finalMessage)
+   {
       removeListener();
       signal = BACKUP_ACTIVATION.FAIL_OVER;
-      if (finalMessage == ReplicationLiveIsStoppingMessage.LiveStopping.FAIL_OVER) {
+      if (finalMessage == ReplicationLiveIsStoppingMessage.LiveStopping.FAIL_OVER)
+      {
          latch.countDown();
       }
-      if (finalMessage == ReplicationLiveIsStoppingMessage.LiveStopping.STOP_CALLED) {
+      if (finalMessage == ReplicationLiveIsStoppingMessage.LiveStopping.STOP_CALLED)
+      {
          final CountDownLatch localLatch = latch;
-         scheduledPool.schedule(new Runnable() {
+         scheduledPool.schedule(new Runnable()
+         {
             @Override
-            public void run() {
+            public void run()
+            {
                localLatch.countDown();
             }
 
@@ -229,18 +213,22 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
       }
    }
 
-   public void notifyRegistrationFailed() {
+   public void notifyRegistrationFailed()
+   {
       signal = BACKUP_ACTIVATION.FAILURE_REPLICATING;
       latch.countDown();
    }
 
-   public void notifyAlreadyReplicating() {
+   public void notifyAlreadyReplicating()
+   {
       signal = BACKUP_ACTIVATION.ALREADY_REPLICATING;
       latch.countDown();
    }
 
-   private void removeListener() {
-      if (connection != null) {
+   private void removeListener()
+   {
+      if (connection != null)
+      {
          connection.removeFailureListener(this);
       }
    }
@@ -251,27 +239,34 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
     *
     * @return signal, indicating whether to stop or to fail-over
     */
-   public BACKUP_ACTIVATION waitForStatusChange() {
-      try {
+   public BACKUP_ACTIVATION waitForStatusChange()
+   {
+      try
+      {
          latch.await();
-      } catch (InterruptedException e) {
+      }
+      catch (InterruptedException e)
+      {
          return BACKUP_ACTIVATION.STOP;
       }
       return signal;
    }
 
+
    /**
     * Cause the Activation thread to exit and the server to be stopped.
     *
     * @param explicitSignal the state we want to set the quorum manager to return
     */
-   public synchronized void causeExit(BACKUP_ACTIVATION explicitSignal) {
+   public synchronized void causeExit(BACKUP_ACTIVATION explicitSignal)
+   {
       removeListener();
       this.signal = explicitSignal;
       latch.countDown();
    }
 
-   public synchronized void reset() {
+   public synchronized void reset()
+   {
       latch = new CountDownLatch(1);
    }
 
@@ -280,45 +275,26 @@ public class SharedNothingBackupQuorum implements Quorum, SessionFailureListener
     *
     * @return the voting decision
     */
-   private boolean isLiveDown() {
-      //lets assume live is not down
-      Boolean decision = false;
-      int voteAttempts = 0;
-      int size = quorumSize == -1 ? quorumManager.getMaxClusterSize() : quorumSize;
-
-      synchronized (voteGuard) {
-         while (!decision && voteAttempts++ < voteRetries) {
-            // a quick check to see if the live actually is dead
-            if (quorumManager.checkLive(liveTransportConfiguration)) {
-               //the live is still alive so we best not failover
-               return false;
-            }
-            //the live is dead so lets vote for quorum
-            QuorumVoteServerConnect quorumVote = new QuorumVoteServerConnect(size, targetServerID);
-
-            quorumManager.vote(quorumVote);
+   private boolean isLiveDown()
+   {
+      // we use 1 less than the max cluste size as we arent bothered about the replicated live node
+      int size = quorumManager.getMaxClusterSize() - 1;
 
-            try {
-               quorumVote.await(LATCH_TIMEOUT, TimeUnit.SECONDS);
-            } catch (InterruptedException interruption) {
-               // No-op. The best the quorum can do now is to return the latest number it has
-            }
+      QuorumVoteServerConnect quorumVote = new QuorumVoteServerConnect(size, storageManager);
 
-            quorumManager.voteComplete(quorumVote);
+      quorumManager.vote(quorumVote);
 
-            decision = quorumVote.getDecision();
-
-            if (decision) {
-               return decision;
-            }
-            try {
-               voteGuard.wait(voteRetryWait);
-            } catch (InterruptedException e) {
-               //nothing to do here
-            }
-         }
+      try
+      {
+         quorumVote.await(LATCH_TIMEOUT, TimeUnit.SECONDS);
+      }
+      catch (InterruptedException interruption)
+      {
+         // No-op. The best the quorum can do now is to return the latest number it has
       }
 
-      return decision;
+      quorumManager.voteComplete(quorumVote);
+
+      return quorumVote.getDecision();
    }
 }