diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java
index 0f0e9d5070..fcdced4d24 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java
@@ -19,29 +19,18 @@ package org.apache.activemq.artemis.protocol.amqp.proton;
 import java.util.Arrays;
 import java.util.List;
 
-import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
 import org.apache.activemq.artemis.api.core.RoutingType;
-import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.core.security.CheckType;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
 import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPInternalErrorException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPNotFoundException;
-import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPSecurityException;
 import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolMessageBundle;
-import org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASLResult;
-import org.apache.activemq.artemis.protocol.amqp.sasl.SASLResult;
-import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
 import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
 import org.apache.qpid.proton.amqp.transaction.TransactionalState;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
-import org.apache.qpid.proton.codec.ReadableBuffer;
 import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.Receiver;
 import org.jboss.logging.Logger;
@@ -56,7 +45,7 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
 
    protected final Receiver receiver;
 
-   protected SimpleString address;
+   protected String address;
 
    protected final AMQPSessionCallback sessionSPI;
 
@@ -92,85 +81,35 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
       super.initialise();
       org.apache.qpid.proton.amqp.messaging.Target target = (org.apache.qpid.proton.amqp.messaging.Target) receiver.getRemoteTarget();
 
-      // Match the settlement mode of the remote instead of relying on the default of MIXED.
-      receiver.setSenderSettleMode(receiver.getRemoteSenderSettleMode());
-
-      // We don't currently support SECOND so enforce that the answer is anlways FIRST
-      receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-
-      RoutingType defRoutingType;
-
       if (target != null) {
          if (target.getDynamic()) {
             // if dynamic we have to create the node (queue) and set the address on the target, the node is temporary and
             // will be deleted on closing of the session
-            address = SimpleString.toSimpleString(sessionSPI.tempQueueName());
-            defRoutingType = getRoutingType(target.getCapabilities(), address);
+            address = sessionSPI.tempQueueName();
 
             try {
-               sessionSPI.createTemporaryQueue(address, defRoutingType);
-            } catch (ActiveMQAMQPSecurityException e) {
-               throw e;
-            } catch (ActiveMQSecurityException e) {
-               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingTempDestination(e.getMessage());
+               sessionSPI.createTemporaryQueue(address, getRoutingType(target.getCapabilities()));
             } catch (Exception e) {
                throw new ActiveMQAMQPInternalErrorException(e.getMessage(), e);
             }
             expiryPolicy = target.getExpiryPolicy() != null ? target.getExpiryPolicy() : TerminusExpiryPolicy.LINK_DETACH;
-            target.setAddress(address.toString());
+            target.setAddress(address);
          } else {
             // the target will have an address unless the remote is requesting an anonymous
             // relay in which case the address in the incoming message's to field will be
             // matched on receive of the message.
-            address = SimpleString.toSimpleString(target.getAddress());
+            address = target.getAddress();
 
             if (address != null && !address.isEmpty()) {
-               defRoutingType = getRoutingType(target.getCapabilities(), address);
                try {
-                  if (!sessionSPI.checkAddressAndAutocreateIfPossible(address, defRoutingType)) {
+                  if (!sessionSPI.bindingQuery(address)) {
                      throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.addressDoesntExist();
                   }
                } catch (ActiveMQAMQPNotFoundException e) {
                   throw e;
                } catch (Exception e) {
-                  log.debug(e.getMessage(), e);
                   throw new ActiveMQAMQPInternalErrorException(e.getMessage(), e);
                }
-
-               try {
-                  sessionSPI.check(address, CheckType.SEND, new SecurityAuth() {
-                     @Override
-                     public String getUsername() {
-                        String username = null;
-                        SASLResult saslResult = connection.getSASLResult();
-                        if (saslResult != null) {
-                           username = saslResult.getUser();
-                        }
-
-                        return username;
-                     }
-
-                     @Override
-                     public String getPassword() {
-                        String password = null;
-                        SASLResult saslResult = connection.getSASLResult();
-                        if (saslResult != null) {
-                           if (saslResult instanceof PlainSASLResult) {
-                              password = ((PlainSASLResult) saslResult).getPassword();
-                           }
-                        }
-
-                        return password;
-                     }
-
-                     @Override
-                     public RemotingConnection getRemotingConnection() {
-                        return connection.connectionCallback.getProtonConnectionDelegate();
-                     }
-                  });
-               } catch (ActiveMQSecurityException e) {
-                  throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingProducer(e.getMessage());
-               }
             }
          }
 
@@ -178,26 +117,19 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
          if (remoteDesiredCapabilities != null) {
             List<Symbol> list = Arrays.asList(remoteDesiredCapabilities);
             if (list.contains(AmqpSupport.DELAYED_DELIVERY)) {
-               receiver.setOfferedCapabilities(new Symbol[]{AmqpSupport.DELAYED_DELIVERY});
+               receiver.setOfferedCapabilities(new Symbol[] {AmqpSupport.DELAYED_DELIVERY});
             }
          }
       }
       flow(amqpCredits, minCreditRefresh);
    }
 
-   public RoutingType getRoutingType(Receiver receiver, SimpleString address) {
-      org.apache.qpid.proton.amqp.messaging.Target target = (org.apache.qpid.proton.amqp.messaging.Target) receiver.getRemoteTarget();
-      return target != null ? getRoutingType(target.getCapabilities(), address) : getRoutingType((Symbol[]) null, address);
-   }
-
-   private RoutingType getRoutingType(Symbol[] symbols, SimpleString address) {
-      if (symbols != null) {
-         for (Symbol symbol : symbols) {
-            if (AmqpSupport.TEMP_TOPIC_CAPABILITY.equals(symbol) || AmqpSupport.TOPIC_CAPABILITY.equals(symbol)) {
-               return RoutingType.MULTICAST;
-            } else if (AmqpSupport.TEMP_QUEUE_CAPABILITY.equals(symbol) || AmqpSupport.QUEUE_CAPABILITY.equals(symbol)) {
-               return RoutingType.ANYCAST;
-            }
+   private RoutingType getRoutingType(Symbol[] symbols) {
+      for (Symbol symbol : symbols) {
+         if (AmqpSupport.TEMP_TOPIC_CAPABILITY.equals(symbol) || AmqpSupport.TOPIC_CAPABILITY.equals(symbol)) {
+            return RoutingType.MULTICAST;
+         } else if (AmqpSupport.TEMP_QUEUE_CAPABILITY.equals(symbol) || AmqpSupport.QUEUE_CAPABILITY.equals(symbol)) {
+            return RoutingType.ANYCAST;
          }
       }
 
@@ -205,64 +137,56 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
    }
 
    /*
-    * called when Proton receives a message to be delivered via a Delivery.
-    *
-    * This may be called more than once per deliver so we have to cache the buffer until we have received it all.
-    */
+   * called when Proton receives a message to be delivered via a Delivery.
+   *
+   * This may be called more than once per deliver so we have to cache the buffer until we have received it all.
+   *
+   * */
    @Override
    public void onMessage(Delivery delivery) throws ActiveMQAMQPException {
+      Receiver receiver;
       try {
-         Receiver receiver = ((Receiver) delivery.getLink());
 
-         if (receiver.current() != delivery) {
+         if (!delivery.isReadable()) {
             return;
          }
-
-         if (delivery.isAborted()) {
-            // Aborting implicitly remotely settles, so advance
-            // receiver to the next delivery and settle locally.
-            receiver.advance();
-            delivery.settle();
-
-            // Replenish the credit if not doing a drain
-            if (!receiver.getDrain()) {
-               receiver.flow(1);
-            }
-
+         if (delivery.isPartial()) {
             return;
-         } else if (delivery.isPartial()) {
+         }
+         receiver = ((Receiver) delivery.getLink());
+
+         if (delivery.isPartial()) {
             return;
          }
 
          Transaction tx = null;
-         ReadableBuffer data = receiver.recv();
+
+         byte[] data;
+
+         data = new byte[delivery.available()];
+         receiver.recv(data, 0, data.length);
          receiver.advance();
 
          if (delivery.getRemoteState() instanceof TransactionalState) {
+
             TransactionalState txState = (TransactionalState) delivery.getRemoteState();
             tx = this.sessionSPI.getTransaction(txState.getTxnId(), false);
          }
 
-         sessionSPI.serverSend(this, tx, receiver, delivery, address, delivery.getMessageFormat(), data);
+         sessionSPI.serverSend(tx, receiver, delivery, address, delivery.getMessageFormat(), data);
 
          flow(amqpCredits, minCreditRefresh);
       } catch (Exception e) {
          log.warn(e.getMessage(), e);
          Rejected rejected = new Rejected();
          ErrorCondition condition = new ErrorCondition();
-
-         if (e instanceof ActiveMQSecurityException) {
-            condition.setCondition(AmqpError.UNAUTHORIZED_ACCESS);
-         } else {
-            condition.setCondition(Symbol.valueOf("failed"));
-         }
-
+         condition.setCondition(Symbol.valueOf("failed"));
          condition.setDescription(e.getMessage());
          rejected.setError(condition);
-
-         delivery.disposition(rejected);
-         delivery.settle();
-         flow(amqpCredits, minCreditRefresh);
+         synchronized (connection.getLock()) {
+            delivery.disposition(rejected);
+            delivery.settle();
+         }
       }
    }
 
@@ -272,7 +196,7 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
       org.apache.qpid.proton.amqp.messaging.Target target = (org.apache.qpid.proton.amqp.messaging.Target) receiver.getRemoteTarget();
       if (target != null && target.getDynamic() && (target.getExpiryPolicy() == TerminusExpiryPolicy.LINK_DETACH || target.getExpiryPolicy() == TerminusExpiryPolicy.SESSION_END)) {
          try {
-            sessionSPI.removeTemporaryQueue(SimpleString.toSimpleString(target.getAddress()));
+            sessionSPI.removeTemporaryQueue(target.getAddress());
          } catch (Exception e) {
             //ignore on close, its temp anyway and will be removed later
          }
@@ -288,26 +212,18 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
    public void flow(int credits, int threshold) {
       // Use the SessionSPI to allocate producer credits, or default, always allocate credit.
       if (sessionSPI != null) {
-         if (receiver.getCredit() <= threshold) {
-            sessionSPI.offerProducerCredit(address, credits, threshold, receiver);
-         }
+         sessionSPI.offerProducerCredit(address, credits, threshold, receiver);
       } else {
-         connection.lock();
-         try {
+         synchronized (connection.getLock()) {
             receiver.flow(credits);
-         } finally {
-            connection.unlock();
          }
          connection.flush();
       }
    }
 
    public void drain(int credits) {
-      connection.lock();
-      try {
+      synchronized (connection.getLock()) {
          receiver.drain(credits);
-      } finally {
-         connection.unlock();
       }
       connection.flush();
    }