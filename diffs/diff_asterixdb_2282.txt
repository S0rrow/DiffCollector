diff --git a/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/input/record/reader/aws/AwsS3InputStreamFactory.java b/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/input/record/reader/aws/AwsS3InputStreamFactory.java
index e57b31aee3..9158a5780b 100644
--- a/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/input/record/reader/aws/AwsS3InputStreamFactory.java
+++ b/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/input/record/reader/aws/AwsS3InputStreamFactory.java
@@ -18,30 +18,30 @@
  */
 package org.apache.asterix.external.input.record.reader.aws;
 
-import static org.apache.asterix.external.util.ExternalDataConstants.AwsS3;
+import static org.apache.asterix.external.util.ExternalDataConstants.AwsS3Constants;
 
 import java.io.Serializable;
+import java.net.URI;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
 import org.apache.asterix.common.dataflow.ICcApplicationContext;
 import org.apache.asterix.common.exceptions.AsterixException;
-import org.apache.asterix.common.exceptions.CompilationException;
 import org.apache.asterix.common.exceptions.ErrorCode;
 import org.apache.asterix.external.api.AsterixInputStream;
 import org.apache.asterix.external.api.IInputStreamFactory;
 import org.apache.asterix.external.util.ExternalDataConstants;
-import org.apache.asterix.external.util.ExternalDataUtils;
 import org.apache.hyracks.algebricks.common.constraints.AlgebricksAbsolutePartitionConstraint;
 import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;
 import org.apache.hyracks.api.application.IServiceContext;
 import org.apache.hyracks.api.context.IHyracksTaskContext;
-import org.apache.hyracks.api.exceptions.HyracksDataException;
-import org.apache.hyracks.api.util.CleanupUtils;
 
-import software.amazon.awssdk.core.exception.SdkException;
+import software.amazon.awssdk.auth.credentials.AwsBasicCredentials;
+import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider;
+import software.amazon.awssdk.regions.Region;
 import software.amazon.awssdk.services.s3.S3Client;
+import software.amazon.awssdk.services.s3.S3ClientBuilder;
 import software.amazon.awssdk.services.s3.model.ListObjectsV2Request;
 import software.amazon.awssdk.services.s3.model.ListObjectsV2Response;
 import software.amazon.awssdk.services.s3.model.S3Object;
@@ -52,8 +52,7 @@ public class AwsS3InputStreamFactory implements IInputStreamFactory {
     private Map<String, String> configuration;
 
     // Files to read from
-    private final List<S3Object> filesOnly = new ArrayList<>();
-    private final List<PartitionWorkLoadBasedOnSize> partitionWorkLoadsBasedOnSize = new ArrayList<>();
+    private List<PartitionWorkLoadBasedOnSize> partitionWorkLoadsBasedOnSize = new ArrayList<>();
 
     private transient AlgebricksAbsolutePartitionConstraint partitionConstraint;
 
@@ -68,7 +67,7 @@ public class AwsS3InputStreamFactory implements IInputStreamFactory {
     }
 
     @Override
-    public AsterixInputStream createInputStream(IHyracksTaskContext ctx, int partition) throws HyracksDataException {
+    public AsterixInputStream createInputStream(IHyracksTaskContext ctx, int partition) {
         return new AwsS3InputStream(configuration, partitionWorkLoadsBasedOnSize.get(partition).getFilePaths());
     }
 
@@ -82,57 +81,51 @@ public class AwsS3InputStreamFactory implements IInputStreamFactory {
         this.configuration = configuration;
         ICcApplicationContext ccApplicationContext = (ICcApplicationContext) ctx.getApplicationContext();
 
-        String container = configuration.get(AwsS3.CONTAINER_NAME_FIELD_NAME);
+        String container = configuration.get(AwsS3Constants.CONTAINER_NAME_FIELD_NAME);
 
-        S3Client s3Client = ExternalDataUtils.AwsS3.buildAwsS3Client(configuration);
+        S3Client s3Client = buildAwsS3Client(configuration);
 
         // Get all objects in a bucket and extract the paths to files
         ListObjectsV2Request.Builder listObjectsBuilder = ListObjectsV2Request.builder().bucket(container);
-        String path = configuration.get(AwsS3.DEFINITION_FIELD_NAME);
+        String path = configuration.get(AwsS3Constants.DEFINITION_FIELD_NAME);
         if (path != null) {
             listObjectsBuilder.prefix(path + (!path.isEmpty() && !path.endsWith("/") ? "/" : ""));
         }
 
         ListObjectsV2Response listObjectsResponse;
+        List<S3Object> s3Objects = new ArrayList<>();
         boolean done = false;
         String newMarker = null;
 
-        String fileFormat = configuration.get(ExternalDataConstants.KEY_FORMAT);
-
-        try {
-            while (!done) {
-                // List the objects from the start, or from the last marker in case of truncated result
-                if (newMarker == null) {
-                    listObjectsResponse = s3Client.listObjectsV2(listObjectsBuilder.build());
-                } else {
-                    listObjectsResponse =
-                            s3Client.listObjectsV2(listObjectsBuilder.continuationToken(newMarker).build());
-                }
-
-                // Collect the paths to files only
-                collectFilesOnly(listObjectsResponse.contents(), fileFormat);
-
-                // Mark the flag as done if done, otherwise, get the marker of the previous response for the next request
-                if (!listObjectsResponse.isTruncated()) {
-                    done = true;
-                } else {
-                    newMarker = listObjectsResponse.nextContinuationToken();
-                }
+        while (!done) {
+            // List the objects from the start, or from the last marker in case of truncated result
+            if (newMarker == null) {
+                listObjectsResponse = s3Client.listObjectsV2(listObjectsBuilder.build());
+            } else {
+                listObjectsResponse = s3Client.listObjectsV2(listObjectsBuilder.continuationToken(newMarker).build());
             }
-        } catch (SdkException ex) {
-            throw new CompilationException(ErrorCode.EXTERNAL_SOURCE_ERROR, ex.getMessage());
-        } finally {
-            if (s3Client != null) {
-                CleanupUtils.close(s3Client, null);
+
+            // Collect all the provided objects
+            s3Objects.addAll(listObjectsResponse.contents());
+
+            // Mark the flag as done if done, otherwise, get the marker of the previous response for the next request
+            if (!listObjectsResponse.isTruncated()) {
+                done = true;
+            } else {
+                newMarker = listObjectsResponse.nextContinuationToken();
             }
         }
 
+        // Exclude the directories and get the files only
+        String fileFormat = configuration.get(ExternalDataConstants.KEY_FORMAT);
+        List<S3Object> fileObjects = getFilesOnly(s3Objects, fileFormat);
+
         // Partition constraints
         partitionConstraint = ccApplicationContext.getClusterStateManager().getClusterLocations();
         int partitionsCount = partitionConstraint.getLocations().length;
 
         // Distribute work load amongst the partitions
-        distributeWorkLoad(filesOnly, partitionsCount);
+        distributeWorkLoad(fileObjects, partitionsCount);
     }
 
     /**
@@ -140,17 +133,21 @@ public class AwsS3InputStreamFactory implements IInputStreamFactory {
      * a file if it does not end up with a "/" which is the separator in a folder structure.
      *
      * @param s3Objects List of returned objects
-     * @param fileFormat The expected file format
+     *
+     * @return A list of string paths that point to files only
      *
      * @throws AsterixException AsterixException
      */
-    private void collectFilesOnly(List<S3Object> s3Objects, String fileFormat) throws AsterixException {
+    private List<S3Object> getFilesOnly(List<S3Object> s3Objects, String fileFormat) throws AsterixException {
+        List<S3Object> filesOnly = new ArrayList<>();
         String fileExtension = getFileExtension(fileFormat);
         if (fileExtension == null) {
             throw AsterixException.create(ErrorCode.PROVIDER_STREAM_RECORD_READER_UNKNOWN_FORMAT, fileFormat);
         }
 
         s3Objects.stream().filter(object -> isValidFile(object.key(), fileFormat)).forEach(filesOnly::add);
+
+        return filesOnly;
     }
 
     /**
@@ -216,6 +213,35 @@ public class AwsS3InputStreamFactory implements IInputStreamFactory {
         return smallest;
     }
 
+    /**
+     * Prepares and builds the Amazon S3 client with the provided configuration
+     *
+     * @param configuration S3 client configuration
+     *
+     * @return Amazon S3 client
+     */
+    private static S3Client buildAwsS3Client(Map<String, String> configuration) {
+        S3ClientBuilder builder = S3Client.builder();
+
+        // Credentials
+        String accessKeyId = configuration.get(AwsS3Constants.ACCESS_KEY_ID_FIELD_NAME);
+        String secretAccessKey = configuration.get(AwsS3Constants.SECRET_ACCESS_KEY_FIELD_NAME);
+        AwsBasicCredentials credentials = AwsBasicCredentials.create(accessKeyId, secretAccessKey);
+        builder.credentialsProvider(StaticCredentialsProvider.create(credentials));
+
+        // Region
+        String region = configuration.get(AwsS3Constants.REGION_FIELD_NAME);
+        builder.region(Region.of(region));
+
+        // Use user's endpoint if provided
+        if (configuration.get(AwsS3Constants.SERVICE_END_POINT_FIELD_NAME) != null) {
+            String endPoint = configuration.get(AwsS3Constants.SERVICE_END_POINT_FIELD_NAME);
+            builder.endpointOverride(URI.create(endPoint));
+        }
+
+        return builder.build();
+    }
+
     /**
      * Returns the file extension for the provided file format.
      *