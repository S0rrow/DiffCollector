diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
index 4a09b08a4..4327d77ca 100755
--- a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
@@ -29,36 +29,46 @@ import org.apache.atlas.ha.HAConfiguration;
 import org.apache.atlas.listener.ActiveStateChangeHandler;
 import org.apache.atlas.listener.ChangedTypeDefs;
 import org.apache.atlas.listener.TypeDefChangeListener;
-import org.apache.atlas.model.TypeCategory;
-import org.apache.atlas.model.instance.AtlasEntity;
 import org.apache.atlas.model.typedef.AtlasBaseTypeDef;
-import org.apache.atlas.model.typedef.AtlasEntityDef;
 import org.apache.atlas.model.typedef.AtlasEnumDef;
-import org.apache.atlas.model.typedef.AtlasRelationshipDef;
 import org.apache.atlas.model.typedef.AtlasStructDef;
 import org.apache.atlas.model.typedef.AtlasStructDef.AtlasAttributeDef;
 import org.apache.atlas.repository.Constants;
 import org.apache.atlas.repository.IndexException;
 import org.apache.atlas.repository.RepositoryException;
-import org.apache.atlas.repository.graphdb.*;
+import org.apache.atlas.repository.graphdb.AtlasCardinality;
+import org.apache.atlas.repository.graphdb.AtlasEdgeDirection;
+import org.apache.atlas.repository.graphdb.AtlasGraph;
+import org.apache.atlas.repository.graphdb.AtlasGraphIndex;
+import org.apache.atlas.repository.graphdb.AtlasGraphManagement;
+import org.apache.atlas.repository.graphdb.AtlasPropertyKey;
 import org.apache.atlas.repository.store.graph.v2.AtlasGraphUtilsV2;
-import org.apache.atlas.type.*;
-import org.apache.atlas.type.AtlasStructType.AtlasAttribute;
+import org.apache.atlas.type.AtlasArrayType;
+import org.apache.atlas.type.AtlasClassificationType;
+import org.apache.atlas.type.AtlasEntityType;
+import org.apache.atlas.type.AtlasEnumType;
+import org.apache.atlas.type.AtlasMapType;
+import org.apache.atlas.type.AtlasRelationshipType;
+import org.apache.atlas.type.AtlasStructType;
 import org.apache.atlas.type.AtlasType;
 import org.apache.atlas.type.AtlasTypeRegistry;
 import org.apache.atlas.type.AtlasTypeUtil;
 import org.apache.commons.collections.CollectionUtils;
 import org.apache.commons.configuration.Configuration;
-import org.apache.solr.common.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.springframework.stereotype.Component;
-import org.springframework.core.annotation.Order;
 
 import javax.inject.Inject;
 import java.math.BigDecimal;
 import java.math.BigInteger;
-import java.util.*;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 
 import static org.apache.atlas.model.typedef.AtlasBaseTypeDef.*;
 import static org.apache.atlas.repository.Constants.*;
@@ -75,7 +85,6 @@ import static org.apache.atlas.type.AtlasTypeUtil.isMapType;
  * Adds index for properties of a given type when its added before any instances are added.
  */
 @Component
-@Order(1)
 public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler, TypeDefChangeListener {
 
     private static final Logger LOG = LoggerFactory.getLogger(GraphBackedSearchIndexer.class);
@@ -92,7 +101,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
     // Added for type lookup when indexing the new typedefs
     private final AtlasTypeRegistry typeRegistry;
-    private final List<IndexChangeListener> indexChangeListeners = new ArrayList<>();
 
     //allows injection of a dummy graph for testing
     private IAtlasGraphProvider provider;
@@ -100,20 +108,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
     private boolean     recomputeIndexedKeys = true;
     private Set<String> vertexIndexKeys      = new HashSet<>();
 
-    public static boolean isValidSearchWeight(int searchWeight) {
-        if (searchWeight != -1 ) {
-            if (searchWeight < 1 || searchWeight > 10) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public static boolean isStringAttribute(AtlasAttribute attribute) {
-        return AtlasBaseTypeDef.ATLAS_TYPE_STRING.equals(attribute.getTypeName());
-    }
-
-    public enum UniqueKind { NONE, GLOBAL_UNIQUE, PER_TYPE_UNIQUE }
+    private enum UniqueKind { NONE, GLOBAL_UNIQUE, PER_TYPE_UNIQUE }
 
     @Inject
     public GraphBackedSearchIndexer(AtlasTypeRegistry typeRegistry) throws AtlasException {
@@ -123,23 +118,13 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
     @VisibleForTesting
     GraphBackedSearchIndexer(IAtlasGraphProvider provider, Configuration configuration, AtlasTypeRegistry typeRegistry)
             throws IndexException, RepositoryException {
-        this.provider     = provider;
+        this.provider = provider;
         this.typeRegistry = typeRegistry;
-
-        //make sure solr index follows graph backed index listener
-        addIndexListener(new SolrIndexHelper(typeRegistry));
-
         if (!HAConfiguration.isHAEnabled(configuration)) {
             initialize(provider.get());
         }
-        notifyInitializationStart();
-    }
-
-    public void addIndexListener(IndexChangeListener listener) {
-        indexChangeListeners.add(listener);
     }
 
-
     /**
      * Initialize global indices for JanusGraph on server activation.
      *
@@ -170,15 +155,13 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         if (LOG.isDebugEnabled()) {
             LOG.debug("Processing changed typedefs {}", changedTypeDefs);
         }
-
         AtlasGraphManagement management = null;
-
         try {
             management = provider.get().getManagementSystem();
 
             // Update index for newly created types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getCreatedTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getCreatedTypeDefs()) {
+            if (CollectionUtils.isNotEmpty(changedTypeDefs.getCreateTypeDefs())) {
+                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getCreateTypeDefs()) {
                     updateIndexForTypeDef(management, typeDef);
                 }
             }
@@ -193,16 +176,10 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             // Invalidate the property key for deleted types
             if (CollectionUtils.isNotEmpty(changedTypeDefs.getDeletedTypeDefs())) {
                 for (AtlasBaseTypeDef typeDef : changedTypeDefs.getDeletedTypeDefs()) {
-                    deleteIndexForType(management, typeDef);
+                    cleanupIndices(management, typeDef);
                 }
             }
 
-            //resolve index fields names for the new entity attributes.
-            resolveIndexFieldNames(management, changedTypeDefs);
-
-            createEdgeLabels(management, changedTypeDefs.getCreatedTypeDefs());
-            createEdgeLabels(management, changedTypeDefs.getUpdatedTypeDefs());
-
             //Commit indexes
             commit(management);
         } catch (RepositoryException | IndexException e) {
@@ -210,37 +187,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             attemptRollback(changedTypeDefs, management);
         }
 
-        notifyChangeListeners(changedTypeDefs);
-    }
-
-    @Override
-    public void onLoadCompletion() throws AtlasBaseException {
-        if(LOG.isDebugEnabled()) {
-            LOG.debug("Type definition load completed. Informing the completion to IndexChangeListeners.");
-        }
-
-        Collection<AtlasBaseTypeDef> typeDefs = new ArrayList<>();
-
-        typeDefs.addAll(typeRegistry.getAllEntityDefs());
-        typeDefs.addAll(typeRegistry.getAllBusinessMetadataDefs());
-
-        ChangedTypeDefs      changedTypeDefs = new ChangedTypeDefs(null, new ArrayList<>(typeDefs), null);
-        AtlasGraphManagement management      = null;
-
-        try {
-            management = provider.get().getManagementSystem();
-
-            //resolve index fields names
-            resolveIndexFieldNames(management, changedTypeDefs);
-
-            //Commit indexes
-            commit(management);
-
-            notifyInitializationCompletion(changedTypeDefs);
-        } catch (RepositoryException | IndexException e) {
-            LOG.error("Failed to update indexes for changed typedefs", e);
-            attemptRollback(changedTypeDefs, management);
-        }
     }
 
     public Set<String> getVertexIndexKeys() {
@@ -318,35 +264,21 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             }
 
             // create vertex indexes
-            createCommonVertexIndex(management, GUID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, HISTORICAL_GUID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-
-            createCommonVertexIndex(management, TYPENAME_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, TYPESERVICETYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, VERTEX_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, VERTEX_ID_IN_IMPORT_KEY, UniqueKind.NONE, Long.class, SINGLE, true, false);
-
-            createCommonVertexIndex(management, ENTITY_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, SUPER_TYPES_PROPERTY_KEY, UniqueKind.NONE, String.class, SET, true, false);
-            createCommonVertexIndex(management, TIMESTAMP_PROPERTY_KEY, UniqueKind.NONE, Long.class, SINGLE, false, false);
-            createCommonVertexIndex(management, MODIFICATION_TIMESTAMP_PROPERTY_KEY, UniqueKind.NONE, Long.class, SINGLE, false, false);
-            createCommonVertexIndex(management, STATE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
-            createCommonVertexIndex(management, CREATED_BY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false, true);
-            createCommonVertexIndex(management, CLASSIFICATION_TEXT_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
-            createCommonVertexIndex(management, MODIFIED_BY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false, true);
-            createCommonVertexIndex(management, CLASSIFICATION_NAMES_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PROPAGATED_CLASSIFICATION_NAMES_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, TRAIT_NAMES_PROPERTY_KEY, UniqueKind.NONE, String.class, SET, true, true);
-            createCommonVertexIndex(management, PROPAGATED_TRAIT_NAMES_PROPERTY_KEY, UniqueKind.NONE, String.class, LIST, true, true);
-            createCommonVertexIndex(management, IS_INCOMPLETE_PROPERTY_KEY, UniqueKind.NONE, Integer.class, SINGLE, true, true);
-            createCommonVertexIndex(management, CUSTOM_ATTRIBUTES_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, LABELS_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-
-            createCommonVertexIndex(management, PATCH_ID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_DESCRIPTION_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_ACTION_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
-            createCommonVertexIndex(management, PATCH_STATE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
+            createVertexIndex(management, GUID_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
+            createVertexIndex(management, TYPENAME_PROPERTY_KEY, UniqueKind.GLOBAL_UNIQUE, String.class, SINGLE, true, false);
+            createVertexIndex(management, TYPESERVICETYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
+            createVertexIndex(management, VERTEX_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
+            createVertexIndex(management, VERTEX_ID_IN_IMPORT_KEY, UniqueKind.NONE, Long.class, SINGLE, true, false);
+
+            createVertexIndex(management, ENTITY_TYPE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, true, false);
+            createVertexIndex(management, SUPER_TYPES_PROPERTY_KEY, UniqueKind.NONE, String.class, SET, true, false);
+            createVertexIndex(management, TIMESTAMP_PROPERTY_KEY, UniqueKind.NONE, Long.class, SINGLE, false, false);
+            createVertexIndex(management, MODIFICATION_TIMESTAMP_PROPERTY_KEY, UniqueKind.NONE, Long.class, SINGLE, false, false);
+            createVertexIndex(management, STATE_PROPERTY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
+            createVertexIndex(management, CREATED_BY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
+            createVertexIndex(management, MODIFIED_BY_KEY, UniqueKind.NONE, String.class, SINGLE, false, false);
+            createVertexIndex(management, TRAIT_NAMES_PROPERTY_KEY, UniqueKind.NONE, String.class, SET, true, true);
+            createVertexIndex(management, PROPAGATED_TRAIT_NAMES_PROPERTY_KEY, UniqueKind.NONE, String.class, LIST, true, true);
 
             // create vertex-centric index
             createVertexCentricIndex(management, CLASSIFICATION_LABEL, AtlasEdgeDirection.BOTH, CLASSIFICATION_EDGE_NAME_PROPERTY_KEY, String.class, SINGLE);
@@ -360,129 +292,15 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             // create fulltext indexes
             createFullTextIndex(management, ENTITY_TEXT_PROPERTY_KEY, String.class, SINGLE);
 
-            createPropertyKey(management, IS_PROXY_KEY, Boolean.class, SINGLE);
-            createPropertyKey(management, PROVENANCE_TYPE_KEY, Integer.class, SINGLE);
-            createPropertyKey(management, HOME_ID_KEY, String.class, SINGLE);
-
-            createEdgeLabel(management, Constants.TERM_ASSIGNMENT_LABEL);
-            createEdgeLabel(management, Constants.CLASSIFICATION_LABEL);
-
             commit(management);
 
             LOG.info("Index creation for global keys complete.");
         } catch (Throwable t) {
-            LOG.error("GraphBackedSearchIndexer.initialize() failed", t);
-
             rollback(management);
             throw new RepositoryException(t);
         }
     }
 
-    private void resolveIndexFieldNames(AtlasGraphManagement managementSystem, ChangedTypeDefs changedTypeDefs) {
-        List<? extends AtlasBaseTypeDef> createdTypeDefs = changedTypeDefs.getCreatedTypeDefs();
-
-        if(createdTypeDefs != null) {
-            resolveIndexFieldNames(managementSystem, createdTypeDefs);
-        }
-
-        List<? extends AtlasBaseTypeDef> updatedTypeDefs = changedTypeDefs.getUpdatedTypeDefs();
-
-        if(updatedTypeDefs != null) {
-            resolveIndexFieldNames(managementSystem, updatedTypeDefs);
-        }
-    }
-
-    private void resolveIndexFieldNames(AtlasGraphManagement managementSystem, List<? extends AtlasBaseTypeDef> typeDefs) {
-        for(AtlasBaseTypeDef baseTypeDef: typeDefs) {
-            if(TypeCategory.ENTITY.equals(baseTypeDef.getCategory())) {
-                AtlasEntityType entityType = typeRegistry.getEntityTypeByName(baseTypeDef.getName());
-
-                resolveIndexFieldNames(managementSystem, entityType);
-            } else if(TypeCategory.BUSINESS_METADATA.equals(baseTypeDef.getCategory())) {
-                AtlasBusinessMetadataType businessMetadataType = typeRegistry.getBusinessMetadataTypeByName(baseTypeDef.getName());
-
-                resolveIndexFieldNames(managementSystem, businessMetadataType);
-            } else {
-                LOG.debug("Ignoring type definition {}", baseTypeDef.getName());
-            }
-        }
-    }
-
-    private void resolveIndexFieldNames(AtlasGraphManagement managementSystem, AtlasStructType structType) {
-        for(AtlasAttribute attribute: structType.getAllAttributes().values()) {
-            resolveIndexFieldName(managementSystem, attribute);
-        }
-    }
-
-    private void resolveIndexFieldName(AtlasGraphManagement managementSystem, AtlasAttribute attribute) {
-        try {
-            if (attribute.getIndexFieldName() == null && TypeCategory.PRIMITIVE.equals(attribute.getAttributeType().getTypeCategory())) {
-                AtlasStructType definedInType = attribute.getDefinedInType();
-                AtlasAttribute  baseInstance  = definedInType != null ? definedInType.getAttribute(attribute.getName()) : null;
-
-                if (baseInstance != null && baseInstance.getIndexFieldName() != null) {
-                    attribute.setIndexFieldName(baseInstance.getIndexFieldName());
-                } else if (isIndexApplicable(getPrimitiveClass(attribute.getTypeName()), toAtlasCardinality(attribute.getAttributeDef().getCardinality()))) {
-                    AtlasPropertyKey propertyKey = managementSystem.getPropertyKey(attribute.getVertexPropertyName());
-                    boolean isStringField = AtlasAttributeDef.IndexType.STRING.equals(attribute.getIndexType());
-                    if (propertyKey != null) {
-                        String indexFieldName = managementSystem.getIndexFieldName(Constants.VERTEX_INDEX, propertyKey, isStringField);
-
-                        attribute.setIndexFieldName(indexFieldName);
-
-                        if (baseInstance != null) {
-                            baseInstance.setIndexFieldName(indexFieldName);
-                        }
-
-                        typeRegistry.addIndexFieldName(attribute.getVertexPropertyName(), indexFieldName);
-
-                        LOG.info("Property {} is mapped to index field name {}", attribute.getQualifiedName(), attribute.getIndexFieldName());
-                    } else {
-                        LOG.warn("resolveIndexFieldName(attribute={}): propertyKey is null for vertextPropertyName={}", attribute.getQualifiedName(), attribute.getVertexPropertyName());
-                    }
-                }
-            }
-        } catch (Exception excp) {
-            LOG.warn("resolveIndexFieldName(attribute={}) failed.", attribute.getQualifiedName(), excp);
-        }
-    }
-
-    private void createCommonVertexIndex(AtlasGraphManagement management,
-                                         String propertyName,
-                                         UniqueKind uniqueKind,
-                                         Class propertyClass,
-                                         AtlasCardinality cardinality,
-                                         boolean createCompositeIndex,
-                                         boolean createCompositeIndexWithTypeAndSuperTypes) {
-        createCommonVertexIndex(management, propertyName, uniqueKind, propertyClass, cardinality, createCompositeIndex, createCompositeIndexWithTypeAndSuperTypes, false);
-    }
-
-    private void createCommonVertexIndex(AtlasGraphManagement management,
-                                         String propertyName,
-                                         UniqueKind uniqueKind,
-                                         Class propertyClass,
-                                         AtlasCardinality cardinality,
-                                         boolean createCompositeIndex,
-                                         boolean createCompositeIndexWithTypeAndSuperTypes,
-                                         boolean isStringField) {
-        if(isStringField && String.class.equals(propertyClass)) {
-
-            propertyName = AtlasAttribute.VERTEX_PROPERTY_PREFIX_STRING_INDEX_TYPE +propertyName;
-            LOG.debug("Creating the common attribute '{}' as string field.", propertyName);
-        }
-
-        final String indexFieldName = createVertexIndex(management,
-                                                        propertyName,
-                                                        uniqueKind,
-                                                        propertyClass,
-                                                        cardinality,
-                                                        createCompositeIndex,
-                                                        createCompositeIndexWithTypeAndSuperTypes, isStringField);
-        if(indexFieldName != null) {
-            typeRegistry.addIndexFieldName(propertyName, indexFieldName);
-        }
-    }
-
     private void addIndexForType(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
         if (typeDef instanceof AtlasEnumDef) {
             // Only handle complex types like Struct, Classification and Entity
@@ -493,7 +311,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             List<AtlasAttributeDef> attributeDefs = structDef.getAttributeDefs();
             if (CollectionUtils.isNotEmpty(attributeDefs)) {
                 for (AtlasAttributeDef attributeDef : attributeDefs) {
-                    createIndexForAttribute(management, structDef, attributeDef);
+                    createIndexForAttribute(management, typeDef.getName(), attributeDef);
                 }
             }
         } else if (!AtlasTypeUtil.isBuiltInType(typeDef.getName())){
@@ -501,30 +319,8 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    private void deleteIndexForType(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
-        Preconditions.checkNotNull(typeDef, "Cannot process null typedef");
-
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Deleting indexes for type {}", typeDef.getName());
-        }
-
-        if (typeDef instanceof AtlasStructDef) {
-            AtlasStructDef          structDef     = (AtlasStructDef) typeDef;
-            List<AtlasAttributeDef> attributeDefs = structDef.getAttributeDefs();
-
-            if (CollectionUtils.isNotEmpty(attributeDefs)) {
-                for (AtlasAttributeDef attributeDef : attributeDefs) {
-                    deleteIndexForAttribute(management, typeDef.getName(), attributeDef);
-                }
-            }
-        }
-
-        LOG.info("Completed deleting indexes for type {}", typeDef.getName());
-    }
-
-    private void createIndexForAttribute(AtlasGraphManagement management, AtlasStructDef structDef, AtlasAttributeDef attributeDef) {
-        String           qualifiedName  = AtlasAttribute.getQualifiedAttributeName(structDef, attributeDef.getName());
-        final String     propertyName   = AtlasAttribute.generateVertexPropertyName(structDef, attributeDef, qualifiedName);
+    private void createIndexForAttribute(AtlasGraphManagement management, String typeName, AtlasAttributeDef attributeDef) {
+        final String     propertyName   = AtlasGraphUtilsV2.encodePropertyKey(typeName + "." + attributeDef.getName());
         AtlasCardinality cardinality    = toAtlasCardinality(attributeDef.getCardinality());
         boolean          isUnique       = attributeDef.getIsUnique();
         boolean          isIndexable    = attributeDef.getIsIndexable();
@@ -532,11 +328,11 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         boolean          isBuiltInType  = AtlasTypeUtil.isBuiltInType(attribTypeName);
         boolean          isArrayType    = isArrayType(attribTypeName);
         boolean          isMapType      = isMapType(attribTypeName);
-        final String     uniqPropName   = isUnique ? AtlasGraphUtilsV2.encodePropertyKey(structDef.getName() + "." + UNIQUE_ATTRIBUTE_SHADE_PROPERTY_PREFIX + attributeDef.getName()) : null;
-        final AtlasAttributeDef.IndexType indexType      = attributeDef.getIndexType();
+        final String     uniqPropName   = isUnique ? AtlasGraphUtilsV2.encodePropertyKey(typeName + "." + UNIQUE_ATTRIBUTE_SHADE_PROPERTY_PREFIX + attributeDef.getName()) : null;
+
 
         try {
-            AtlasType atlasType     = typeRegistry.getType(structDef.getName());
+            AtlasType atlasType     = typeRegistry.getType(typeName);
             AtlasType attributeType = typeRegistry.getType(attribTypeName);
 
             if (isClassificationType(attributeType)) {
@@ -572,61 +368,31 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                 if (isRelationshipType(atlasType)) {
                     createEdgeIndex(management, propertyName, getPrimitiveClass(attribTypeName), cardinality, false);
                 } else {
-                    Class primitiveClassType = getPrimitiveClass(attribTypeName);
-                    boolean isStringField = false;
-                    if(primitiveClassType == String.class) {
-                        isStringField = AtlasAttributeDef.IndexType.STRING.equals(indexType);
-
-                    }
-                    createVertexIndex(management, propertyName, UniqueKind.NONE, getPrimitiveClass(attribTypeName), cardinality, isIndexable, false, isStringField);
+                    createVertexIndex(management, propertyName, UniqueKind.NONE, getPrimitiveClass(attribTypeName), cardinality, isIndexable, false);
 
                     if (uniqPropName != null) {
-                        createVertexIndex(management, uniqPropName, UniqueKind.PER_TYPE_UNIQUE, getPrimitiveClass(attribTypeName), cardinality, isIndexable, true, isStringField);
+                        createVertexIndex(management, uniqPropName, UniqueKind.PER_TYPE_UNIQUE, getPrimitiveClass(attribTypeName), cardinality, isIndexable, true);
                     }
                 }
             } else if (isEnumType(attributeType)) {
                 if (isRelationshipType(atlasType)) {
                     createEdgeIndex(management, propertyName, String.class, cardinality, false);
                 } else {
-                    createVertexIndex(management, propertyName, UniqueKind.NONE, String.class, cardinality, isIndexable, false, false);
+                    createVertexIndex(management, propertyName, UniqueKind.NONE, String.class, cardinality, isIndexable, false);
 
                     if (uniqPropName != null) {
-                        createVertexIndex(management, uniqPropName, UniqueKind.PER_TYPE_UNIQUE, String.class, cardinality, isIndexable, true, false);
+                        createVertexIndex(management, uniqPropName, UniqueKind.PER_TYPE_UNIQUE, String.class, cardinality, isIndexable, true);
                     }
                 }
             } else if (isStructType(attributeType)) {
-                AtlasStructDef attribureStructDef = typeRegistry.getStructDefByName(attribTypeName);
-                updateIndexForTypeDef(management, attribureStructDef);
+                AtlasStructDef structDef = typeRegistry.getStructDefByName(attribTypeName);
+                updateIndexForTypeDef(management, structDef);
             }
         } catch (AtlasBaseException e) {
             LOG.error("No type exists for {}", attribTypeName, e);
         }
     }
 
-    private void deleteIndexForAttribute(AtlasGraphManagement management, String typeName, AtlasAttributeDef attributeDef) {
-        final String propertyName = AtlasGraphUtilsV2.encodePropertyKey(typeName + "." + attributeDef.getName());
-
-        try {
-            if (management.containsPropertyKey(propertyName)) {
-                LOG.info("Deleting propertyKey {}, for attribute {}.{}", propertyName, typeName, attributeDef.getName());
-
-                management.deletePropertyKey(propertyName);
-            }
-        } catch (Exception excp) {
-            LOG.warn("Failed to delete propertyKey {}, for attribute {}.{}", propertyName, typeName, attributeDef.getName());
-        }
-    }
-
-    /**
-     * gets the encoded property name for the attribute passed in.
-     * @param baseTypeDef the type system of the attribute
-     * @param attributeDef the attribute definition
-     * @return the encoded property name for the attribute passed in.
-     */
-    public static String getEncodedPropertyName(AtlasStructDef baseTypeDef, AtlasAttributeDef attributeDef) {
-        return AtlasAttribute.getQualifiedAttributeName(baseTypeDef, attributeDef.getName());
-    }
-
     private void createLabelIfNeeded(final AtlasGraphManagement management, final String propertyName, final String attribTypeName) {
         // If any of the referenced typename is of type Entity or Struct then the edge label needs to be created
         for (String typeName : AtlasTypeUtil.getReferencedTypeNames(attribTypeName)) {
@@ -657,7 +423,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         return type instanceof AtlasRelationshipType;
     }
 
-    public Class getPrimitiveClass(String attribTypeName) {
+    private Class getPrimitiveClass(String attribTypeName) {
         String attributeTypeName = attribTypeName.toLowerCase();
 
         switch (attributeTypeName) {
@@ -687,7 +453,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         throw new IllegalArgumentException(String.format("Unknown primitive typename %s", attribTypeName));
     }
 
-    public AtlasCardinality toAtlasCardinality(AtlasAttributeDef.Cardinality cardinality) {
+    private AtlasCardinality toAtlasCardinality(AtlasAttributeDef.Cardinality cardinality) {
         switch (cardinality) {
             case SINGLE:
                 return SINGLE;
@@ -707,14 +473,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
         String label = Constants.INTERNAL_PROPERTY_KEY_PREFIX + propertyName;
 
-        createEdgeLabelUsingLabelName(management, label);
-    }
-
-    private void createEdgeLabelUsingLabelName(final AtlasGraphManagement management, final String label) {
-        if (StringUtils.isEmpty(label)) {
-            return;
-        }
-
         org.apache.atlas.repository.graphdb.AtlasEdgeLabel edgeLabel = management.getEdgeLabel(label);
 
         if (edgeLabel == null) {
@@ -734,10 +492,8 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         return propertyKey;
     }
 
-    public String createVertexIndex(AtlasGraphManagement management, String propertyName, UniqueKind uniqueKind, Class propertyClass,
-                                  AtlasCardinality cardinality, boolean createCompositeIndex, boolean createCompositeIndexWithTypeAndSuperTypes, boolean isStringField) {
-        String indexFieldName = null;
-
+    private void createVertexIndex(AtlasGraphManagement management, String propertyName, UniqueKind uniqueKind, Class propertyClass,
+                                   AtlasCardinality cardinality, boolean createCompositeIndex, boolean createCompositeIndexWithTypeAndSuperTypes) {
         if (propertyName != null) {
             AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
 
@@ -749,15 +505,12 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                         LOG.debug("Creating backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
                     }
 
-                    indexFieldName = management.addMixedIndex(VERTEX_INDEX, propertyKey, isStringField);
+                    management.addMixedIndex(VERTEX_INDEX, propertyKey);
+
                     LOG.info("Created backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
                 }
             }
 
-            if(indexFieldName == null && isIndexApplicable(propertyClass, cardinality)) {
-                indexFieldName = management.getIndexFieldName(VERTEX_INDEX, propertyKey, isStringField);
-            }
-
             if (propertyKey != null) {
                 if (createCompositeIndex || uniqueKind == UniqueKind.GLOBAL_UNIQUE || uniqueKind == UniqueKind.PER_TYPE_UNIQUE) {
                     createVertexCompositeIndex(management, propertyClass, propertyKey, uniqueKind == UniqueKind.GLOBAL_UNIQUE);
@@ -771,8 +524,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                 LOG.warn("Index not created for {}: propertyKey is null", propertyName);
             }
         }
-
-        return indexFieldName;
     }
 
     private void createVertexCentricIndex(AtlasGraphManagement management, String edgeLabel, AtlasEdgeDirection edgeDirection,
@@ -785,7 +536,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
         if (LOG.isDebugEnabled()) {
             LOG.debug("Creating vertex-centric index for edge label: {} direction: {} for property: {} of type: {} ",
-                    edgeLabel, edgeDirection.name(), propertyName, propertyClass.getName());
+                        edgeLabel, edgeDirection.name(), propertyName, propertyClass.getName());
         }
 
         final String indexName = edgeLabel + propertyKey.getName();
@@ -837,7 +588,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                         LOG.debug("Creating backing index for edge property {} of type {} ", propertyName, propertyClass.getName());
                     }
 
-                    management.addMixedIndex(EDGE_INDEX, propertyKey, false);
+                    management.addMixedIndex(EDGE_INDEX, propertyKey);
 
                     LOG.info("Created backing index for edge property {} of type {} ", propertyName, propertyClass.getName());
                 }
@@ -865,7 +616,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                     LOG.debug("Creating backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
                 }
 
-                management.addMixedIndex(FULLTEXT_INDEX, propertyKey, false);
+                management.addMixedIndex(FULLTEXT_INDEX, propertyKey);
 
                 LOG.info("Created backing index for vertex property {} of type {} ", propertyName, propertyClass.getName());
             }
@@ -945,7 +696,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         return !(INDEX_EXCLUSION_CLASSES.contains(propertyClass) || cardinality.isMany());
     }
     
-    public void commit(AtlasGraphManagement management) throws IndexException {
+    private void commit(AtlasGraphManagement management) throws IndexException {
         try {
             management.commit();
 
@@ -956,7 +707,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    public void rollback(AtlasGraphManagement management) throws IndexException {
+    private void rollback(AtlasGraphManagement management) throws IndexException {
         try {
             management.rollback();
 
@@ -967,105 +718,80 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    private void attemptRollback(ChangedTypeDefs changedTypeDefs, AtlasGraphManagement management)
-            throws AtlasBaseException {
-        if (null != management) {
-            try {
-                rollback(management);
-            } catch (IndexException e) {
-                LOG.error("Index rollback has failed", e);
-                throw new AtlasBaseException(AtlasErrorCode.INDEX_ROLLBACK_FAILED, e,
-                        changedTypeDefs.toString());
-            }
-        }
-    }
-
-    private void updateIndexForTypeDef(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
-        Preconditions.checkNotNull(typeDef, "Cannot index on null typedefs");
+    private void cleanupIndices(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
+        Preconditions.checkNotNull(typeDef, "Cannot process null typedef");
         if (LOG.isDebugEnabled()) {
-            LOG.debug("Creating indexes for type name={}, definition={}", typeDef.getName(), typeDef.getClass());
+            LOG.debug("Cleaning up index for {}", typeDef);
         }
-        addIndexForType(management, typeDef);
-        LOG.info("Index creation for type {} complete", typeDef.getName());
-    }
 
-    private void notifyChangeListeners(ChangedTypeDefs changedTypeDefs) {
-        for (IndexChangeListener indexChangeListener : indexChangeListeners) {
-            try {
-                indexChangeListener.onChange(changedTypeDefs);
-            } catch (Throwable t) {
-                LOG.error("Error encountered in notifying the index change listener {}.", indexChangeListener.getClass().getName(), t);
-                //we need to throw exception if any of the listeners throw execption.
-                throw new RuntimeException("Error encountered in notifying the index change listener " + indexChangeListener.getClass().getName(), t);
-            }
+        if (typeDef instanceof AtlasEnumDef) {
+            // Only handle complex types like Struct, Classification and Entity
+            return;
         }
-    }
 
-    private void notifyInitializationStart() {
-        for (IndexChangeListener indexChangeListener : indexChangeListeners) {
-            try {
-                indexChangeListener.onInitStart();
-            } catch (Throwable t) {
-                LOG.error("Error encountered in notifying the index change listener {}.", indexChangeListener.getClass().getName(), t);
-                //we need to throw exception if any of the listeners throw execption.
-                throw new RuntimeException("Error encountered in notifying the index change listener " + indexChangeListener.getClass().getName(), t);
+        if (typeDef instanceof AtlasStructDef) {
+            AtlasStructDef structDef = (AtlasStructDef) typeDef;
+            List<AtlasAttributeDef> attributeDefs = structDef.getAttributeDefs();
+            if (CollectionUtils.isNotEmpty(attributeDefs)) {
+                for (AtlasAttributeDef attributeDef : attributeDefs) {
+                    cleanupIndexForAttribute(management, typeDef.getName(), attributeDef);
+                }
             }
+        } else if (!AtlasTypeUtil.isBuiltInType(typeDef.getName())){
+            throw new IllegalArgumentException("bad data type" + typeDef.getName());
         }
     }
 
-    private void notifyInitializationCompletion(ChangedTypeDefs changedTypeDefs) {
-        for (IndexChangeListener indexChangeListener : indexChangeListeners) {
-            try {
-                indexChangeListener.onInitCompletion(changedTypeDefs);
-            } catch (Throwable t) {
-                LOG.error("Error encountered in notifying the index change listener {}.", indexChangeListener.getClass().getName(), t);
-                //we need to throw exception if any of the listeners throw execption.
-                throw new RuntimeException("Error encountered in notifying the index change listener " + indexChangeListener.getClass().getName(), t);
+    private void cleanupIndexForAttribute(AtlasGraphManagement management, String typeName, AtlasAttributeDef attributeDef) {
+        final String propertyName = AtlasGraphUtilsV2.encodePropertyKey(typeName + "." + attributeDef.getName());
+        String  attribTypeName    = attributeDef.getTypeName();
+        boolean isBuiltInType     = AtlasTypeUtil.isBuiltInType(attribTypeName);
+        boolean isArrayType       = isArrayType(attribTypeName);
+        boolean isMapType         = isMapType(attribTypeName);
+
+        try {
+            AtlasType atlasType = typeRegistry.getType(attribTypeName);
+
+            if (isClassificationType(atlasType) || isEntityType(atlasType)) {
+                LOG.warn("Ignoring non-indexable attribute {}", attribTypeName);
+            } else if (isBuiltInType || isEnumType(atlasType) || isArrayType || isMapType) {
+                cleanupIndex(management, propertyName);
+            } else if (isStructType(atlasType)) {
+                AtlasStructDef structDef = typeRegistry.getStructDefByName(attribTypeName);
+                cleanupIndices(management, structDef);
             }
+        } catch (AtlasBaseException e) {
+            LOG.error("No type exists for {}", attribTypeName, e);
         }
     }
 
-
-    private void createEdgeLabels(AtlasGraphManagement management, List<? extends AtlasBaseTypeDef> typeDefs) {
-        if (CollectionUtils.isEmpty(typeDefs)) {
-            return;
+    private void cleanupIndex(AtlasGraphManagement management, String propertyKey) {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Invalidating property key = {}", propertyKey);
         }
 
-        for (AtlasBaseTypeDef typeDef : typeDefs) {
-            if (typeDef instanceof AtlasEntityDef) {
-                AtlasEntityDef entityDef = (AtlasEntityDef) typeDef;
-                createEdgeLabelsForStruct(management, entityDef);
-            } else if (typeDef instanceof AtlasRelationshipDef) {
-                createEdgeLabels(management, (AtlasRelationshipDef) typeDef);
-            }
-        }
+        management.deletePropertyKey(propertyKey);
     }
 
-    private void createEdgeLabelsForStruct(AtlasGraphManagement management, AtlasEntityDef entityDef) {
-        try {
-            AtlasType type = typeRegistry.getType(entityDef.getName());
-            if (!(type instanceof AtlasEntityType)) {
-                return;
-            }
-
-            AtlasEntityType entityType = (AtlasEntityType) type;
-            for (AtlasAttributeDef attributeDef : entityDef.getAttributeDefs()) {
-                AtlasAttribute attribute = entityType.getAttribute(attributeDef.getName());
-                if (attribute.getAttributeType().getTypeCategory() == TypeCategory.STRUCT) {
-                    String relationshipLabel = attribute.getRelationshipEdgeLabel();
-                    createEdgeLabelUsingLabelName(management, relationshipLabel);
-                }
+    private void attemptRollback(ChangedTypeDefs changedTypeDefs, AtlasGraphManagement management)
+            throws AtlasBaseException {
+        if (null != management) {
+            try {
+                rollback(management);
+            } catch (IndexException e) {
+                LOG.error("Index rollback has failed", e);
+                throw new AtlasBaseException(AtlasErrorCode.INDEX_ROLLBACK_FAILED, e,
+                        changedTypeDefs.toString());
             }
-        } catch (AtlasBaseException e) {
-            LOG.error("Error fetching type: {}", entityDef.getName(), e);
         }
     }
 
-    private void createEdgeLabels(AtlasGraphManagement management, AtlasRelationshipDef relationshipDef) {
-        String relationshipTypeName = relationshipDef.getName();
-        AtlasRelationshipType relationshipType = typeRegistry.getRelationshipTypeByName(relationshipTypeName);
-        String relationshipLabel = relationshipType.getRelationshipLabel();
-
-        createEdgeLabelUsingLabelName(management, relationshipLabel);
+    private void updateIndexForTypeDef(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
+        Preconditions.checkNotNull(typeDef, "Cannot index on null typedefs");
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Creating indexes for type name={}, definition={}", typeDef.getName(), typeDef.getClass());
+        }
+        addIndexForType(management, typeDef);
+        LOG.info("Index creation for type {} complete", typeDef.getName());
     }
 }