diff --git a/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java b/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java
index bc511ea1dc..c623f3b6ab 100644
--- a/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java
+++ b/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java
@@ -17,37 +17,30 @@
 
 package org.apache.activemq.artemis.core.protocol.mqtt;
 
+import java.util.Set;
 import java.util.UUID;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
-import io.netty.util.CharsetUtil;
 import org.apache.activemq.artemis.api.core.client.ActiveMQClient;
 import org.apache.activemq.artemis.core.server.ActiveMQServer;
+import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
 import org.apache.activemq.artemis.core.server.impl.ServerSessionImpl;
+import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.artemis.utils.UUIDGenerator;
 
 /**
- * MQTTConnectionManager is responsible for handle Connect and Disconnect packets and any resulting behaviour of these
+ * MQTTConnectionMananager is responsible for handle Connect and Disconnect packets and any resulting behaviour of these
  * events.
  */
 public class MQTTConnectionManager {
 
    private MQTTSession session;
 
-   private MQTTLogger log = MQTTLogger.LOGGER;
-
-   private boolean isWill = false;
-
-   private ByteBuf willMessage;
-
-   private String willTopic;
-
-   private int willQoSLevel;
+   //TODO Read in a list of existing client IDs from stored Sessions.
+   public static Set<String> CONNECTED_CLIENTS = new ConcurrentHashSet<>();
 
-   private boolean willRetain;
+   private MQTTLogger log = MQTTLogger.LOGGER;
 
    public MQTTConnectionManager(MQTTSession session) {
       this.session = session;
@@ -60,9 +53,9 @@ public class MQTTConnectionManager {
     */
    synchronized void connect(String cId,
                              String username,
-                             byte[] passwordInBytes,
+                             String password,
                              boolean will,
-                             byte[] willMessage,
+                             String willMessage,
                              String willTopic,
                              boolean willRetain,
                              int willQosLevel,
@@ -70,33 +63,20 @@ public class MQTTConnectionManager {
       String clientId = validateClientId(cId, cleanSession);
       if (clientId == null) {
          session.getProtocolHandler().sendConnack(MqttConnectReturnCode.CONNECTION_REFUSED_IDENTIFIER_REJECTED);
-         session.getProtocolHandler().disconnect(true);
+         session.getProtocolHandler().disconnect();
          return;
       }
 
-      String password = passwordInBytes == null ? null : new String(passwordInBytes, CharsetUtil.UTF_8);
-      session.getConnection().setClientID(clientId);
+      session.setSessionState(getSessionState(clientId));
       ServerSessionImpl serverSession = createServerSession(username, password);
       serverSession.start();
-      session.setServerSession(serverSession);
 
-      session.setSessionState(getSessionState(clientId));
-
-      if (cleanSession) {
-         /* [MQTT-3.1.2-6] If CleanSession is set to 1, the Client and Server MUST discard any previous Session and
-          * start a new one. This Session lasts as long as the Network Connection. State data associated with this Session
-          * MUST NOT be reused in any subsequent Session */
-         session.clean();
-         session.setClean(true);
-      }
+      session.setServerSession(serverSession);
+      session.setIsClean(cleanSession);
 
       if (will) {
-         isWill = true;
-         this.willMessage = ByteBufAllocator.DEFAULT.buffer(willMessage.length);
-         this.willMessage.writeBytes(willMessage);
-         this.willQoSLevel = willQosLevel;
-         this.willRetain = willRetain;
-         this.willTopic = willTopic;
+         ServerMessage w = MQTTUtil.createServerMessageFromString(session, willMessage, willTopic, willQosLevel, willRetain);
+         session.getSessionState().setWillMessage(w);
       }
 
       session.getConnection().setConnected(true);
@@ -133,43 +113,57 @@ public class MQTTConnectionManager {
       return (ServerSessionImpl) serverSession;
    }
 
-   synchronized void disconnect(boolean failure) {
-      if (session == null || session.getStopped()) {
+   void disconnect() {
+      if (session == null) {
          return;
       }
-
       try {
-         if (isWill && failure) {
-            session.getMqttPublishManager().sendInternal(0, willTopic, willQoSLevel, willMessage, willRetain, true);
+         if (session.getSessionState() != null) {
+            String clientId = session.getSessionState().getClientId();
+            if (clientId != null)
+               CONNECTED_CLIENTS.remove(clientId);
+
+            if (session.getState().isWill()) {
+               session.getConnectionManager().sendWill();
+            }
          }
          session.stop();
+         session.getConnection().disconnect(false);
          session.getConnection().destroy();
       } catch (Exception e) {
+         /* FIXME Failure during disconnect would leave the session state in an unrecoverable state.  We should handle
+         errors more gracefully.
+          */
          log.error("Error disconnecting client: " + e.getMessage());
-      } finally {
-         if (session.getSessionState() != null) {
-            session.getSessionState().setAttached(false);
-            String clientId = session.getSessionState().getClientId();
-            /**
-             *  ensure that the connection for the client ID matches *this* connection otherwise we could remove the
-             *  entry for the client who "stole" this client ID via [MQTT-3.1.4-2]
-             */
-            if (clientId != null && session.getProtocolManager().isClientConnected(clientId, session.getConnection())) {
-               session.getProtocolManager().removeConnectedClient(clientId);
-            }
-         }
       }
    }
 
-   private MQTTSessionState getSessionState(String clientId) {
-      /* [MQTT-3.1.2-4] Attach an existing session if one exists otherwise create a new one. */
-      MQTTSessionState state = MQTTSession.SESSIONS.get(clientId);
-      if (state == null) {
-         state = new MQTTSessionState(clientId);
-         MQTTSession.SESSIONS.put(clientId, state);
-      }
+   private void sendWill() throws Exception {
+      session.getServerSession().send(session.getSessionState().getWillMessage(), true);
+      session.getSessionState().deleteWillMessage();
+   }
 
-      return state;
+   private MQTTSessionState getSessionState(String clientId) throws InterruptedException {
+      synchronized (MQTTSession.SESSIONS) {
+         /* [MQTT-3.1.2-6] If CleanSession is set to 1, the Client and Server MUST discard any previous Session and
+          * start a new one  This Session lasts as long as the Network Connection. State data associated with this Session
+          * MUST NOT be reused in any subsequent Session */
+
+         /* [MQTT-3.1.2-4] Attach an existing session if one exists (if cleanSession flag is false) otherwise create
+         a new one. */
+         MQTTSessionState state = MQTTSession.SESSIONS.get(clientId);
+         if (state != null) {
+            // TODO Add a count down latch for handling wait during attached session state.
+            while (state.getAttached()) {
+               Thread.sleep(1000);
+            }
+            return state;
+         } else {
+            state = new MQTTSessionState(clientId);
+            MQTTSession.SESSIONS.put(clientId, state);
+            return state;
+         }
+      }
    }
 
    private String validateClientId(String clientId, boolean cleanSession) {
@@ -181,13 +175,12 @@ public class MQTTConnectionManager {
             // [MQTT-3.1.3-8] Return ID rejected and disconnect if clean session = false and client id is null
             return null;
          }
-      } else {
-         MQTTConnection connection = session.getProtocolManager().addConnectedClient(clientId, session.getConnection());
+      } else if (!CONNECTED_CLIENTS.add(clientId)) {
+         // ^^^ If the client ID is not unique (i.e. it has already registered) then do not accept it.
 
-         if (connection != null) {
-            // [MQTT-3.1.4-2] If the client ID represents a client already connected to the server then the server MUST disconnect the existing client
-            connection.disconnect(false);
-         }
+
+         // [MQTT-3.1.3-9] Return ID Rejected if server rejects the client ID
+         return null;
       }
       return clientId;
    }