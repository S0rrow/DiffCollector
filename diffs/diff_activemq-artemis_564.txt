diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java
index 58102d4438..74f9906b21 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java
@@ -25,7 +25,6 @@ import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
@@ -70,7 +69,6 @@ import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
 import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
 import org.apache.activemq.artemis.utils.ExecutorFactory;
 import org.apache.activemq.artemis.utils.ReusableLatch;
-import org.jboss.logging.Logger;
 
 /**
  * Manages replication tasks on the live server (that is the live server side of a "remote backup"
@@ -82,9 +80,6 @@ import org.jboss.logging.Logger;
  */
 public final class ReplicationManager implements ActiveMQComponent, ReadyListener {
 
-
-   private static final Logger logger = Logger.getLogger(ReplicationManager.class);
-
    public enum ADD_OPERATION_TYPE {
       UPDATE {
          @Override
@@ -114,10 +109,9 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
 
    private volatile boolean enabled;
 
-   private final AtomicBoolean writable = new AtomicBoolean(true);
-
    private final Object replicationLock = new Object();
 
+   private final ReusableLatch latch = new ReusableLatch();
    private final Queue<OperationContext> pendingTokens = new ConcurrentLinkedQueue<>();
 
    private final ExecutorFactory executorFactory;
@@ -265,24 +259,18 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
    }
 
    @Override
-   public void stop() throws Exception {
-      synchronized (this) {
-         if (!started) {
-            logger.trace("Stopping being ignored as it hasn't been started");
-            return;
-         }
-      }
-
-      // This is to avoid the write holding a lock while we are trying to close it
-      if (replicatingChannel != null) {
-         replicatingChannel.close();
-         replicatingChannel.getConnection().getTransportConnection().fireReady(true);
+   public synchronized void stop() throws Exception {
+      if (!started) {
+         return;
       }
+      replicatingChannel.getConnection().getTransportConnection().fireReady(true);
+      latch.setCount(0);
 
       synchronized (replicationLock) {
          enabled = false;
-         writable.set(true);
-         replicationLock.notifyAll();
+         if (replicatingChannel != null) {
+            replicatingChannel.close();
+         }
          clearReplicationTokens();
       }
 
@@ -290,6 +278,7 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
       if (toStop != null) {
          toStop.removeFailureListener(failureListener);
       }
+
       remotingConnection = null;
       started = false;
    }
@@ -301,12 +290,9 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
     * backup crashing).
     */
    public void clearReplicationTokens() {
-      logger.trace("clearReplicationTokens initiating");
       synchronized (replicationLock) {
-         logger.trace("clearReplicationTokens entered the lock");
          while (!pendingTokens.isEmpty()) {
             OperationContext ctx = pendingTokens.poll();
-            logger.trace("Calling ctx.replicationDone()");
             try {
                ctx.replicationDone();
             }
@@ -315,7 +301,6 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
             }
          }
       }
-      logger.trace("clearReplicationTokens finished");
    }
 
    /**
@@ -353,8 +338,14 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
       synchronized (replicationLock) {
          if (enabled) {
             pendingTokens.add(repliToken);
-            if (!flowControl()) {
-               return repliToken;
+            if (!replicatingChannel.getConnection().isWritable(this)) {
+               latch.countUp();
+               try {
+                  latch.await();
+               }
+               catch (InterruptedException e) {
+                  throw new ActiveMQInterruptedException(e);
+               }
             }
             replicatingChannel.send(packet);
          }
@@ -373,49 +364,9 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
       return repliToken;
    }
 
-   /** This was written as a refactoring of sendReplicatePacket.
-    *  In case you refactor this in any way, this method must hold a lock on replication lock. .*/
-   private boolean flowControl() {
-      // synchronized (replicationLock) { -- I'm not adding this because the caller already has it
-      // future maintainers of this code please be aware that the intention here is hold the lock on replication lock
-      if (!replicatingChannel.getConnection().isWritable(this)) {
-         try {
-            logger.trace("flowControl waiting on writable");
-            writable.set(false);
-            //don't wait for ever as this may hang tests etc, we've probably been closed anyway
-            long now = System.currentTimeMillis();
-            long deadline = now + 5000;
-            while (!writable.get() && now < deadline)  {
-               replicationLock.wait(deadline - now);
-               now = System.currentTimeMillis();
-            }
-            logger.trace("flow control done");
-
-            if (!writable.get()) {
-               ActiveMQServerLogger.LOGGER.slowReplicationResponse();
-               logger.tracef("There was no response from replication backup after %s seconds, server being stopped now", System.currentTimeMillis() - now);
-               try {
-                  stop();
-               }
-               catch (Exception e) {
-                  logger.warn(e.getMessage(), e);
-               }
-               return false;
-            }
-         }
-         catch (InterruptedException e) {
-            throw new ActiveMQInterruptedException(e);
-         }
-      }
-      return true;
-   }
-
    @Override
    public void readyForWriting() {
-      synchronized (replicationLock) {
-         writable.set(true);
-         replicationLock.notifyAll();
-      }
+      latch.countDown();
    }
 
    /**
@@ -553,33 +504,42 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
          file.open();
       }
       try {
-         try (final FileInputStream fis = new FileInputStream(file.getJavaFile());
-              final FileChannel channel = fis.getChannel()) {
-            // We can afford having a single buffer here for this entire loop
-            // because sendReplicatePacket will encode the packet as a NettyBuffer
-            // through ActiveMQBuffer class leaving this buffer free to be reused on the next copy
-            final ByteBuffer buffer = ByteBuffer.allocate(1 << 17); // 1 << 17 == 131072 == 128 * 1024
-            while (true) {
-               buffer.clear();
-               final int bytesRead = channel.read(buffer);
-               int toSend = bytesRead;
-               if (bytesRead > 0) {
-                  if (bytesRead >= maxBytesToSend) {
-                     toSend = (int) maxBytesToSend;
-                     maxBytesToSend = 0;
-                  }
-                  else {
-                     maxBytesToSend = maxBytesToSend - bytesRead;
+         final FileInputStream fis = new FileInputStream(file.getJavaFile());
+         try {
+            final FileChannel channel = fis.getChannel();
+            try {
+               // We can afford having a single buffer here for this entire loop
+               // because sendReplicatePacket will encode the packet as a NettyBuffer
+               // through ActiveMQBuffer class leaving this buffer free to be reused on the next copy
+               final ByteBuffer buffer = ByteBuffer.allocate(1 << 17); // 1 << 17 == 131072 == 128 * 1024
+               while (true) {
+                  buffer.clear();
+                  final int bytesRead = channel.read(buffer);
+                  int toSend = bytesRead;
+                  if (bytesRead > 0) {
+                     if (bytesRead >= maxBytesToSend) {
+                        toSend = (int) maxBytesToSend;
+                        maxBytesToSend = 0;
+                     }
+                     else {
+                        maxBytesToSend = maxBytesToSend - bytesRead;
+                     }
+                     buffer.limit(toSend);
                   }
-                  buffer.limit(toSend);
-               }
-               buffer.rewind();
+                  buffer.rewind();
 
-               // sending -1 or 0 bytes will close the file at the backup
-               sendReplicatePacket(new ReplicationSyncFileMessage(content, pageStore, id, toSend, buffer));
-               if (bytesRead == -1 || bytesRead == 0 || maxBytesToSend == 0)
-                  break;
+                  // sending -1 or 0 bytes will close the file at the backup
+                  sendReplicatePacket(new ReplicationSyncFileMessage(content, pageStore, id, toSend, buffer));
+                  if (bytesRead == -1 || bytesRead == 0 || maxBytesToSend == 0)
+                     break;
+               }
             }
+            finally {
+               channel.close();
+            }
+         }
+         finally {
+            fis.close();
          }
       }
       finally {
@@ -613,25 +573,17 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
     */
    public void sendSynchronizationDone(String nodeID, long initialReplicationSyncTimeout) {
       if (enabled) {
-
-         if (logger.isTraceEnabled()) {
-            logger.trace("sendSynchronizationDone ::" + nodeID + ", " + initialReplicationSyncTimeout);
-         }
-
          synchronizationIsFinishedAcknowledgement.countUp();
          sendReplicatePacket(new ReplicationStartSyncMessage(nodeID));
          try {
             if (!synchronizationIsFinishedAcknowledgement.await(initialReplicationSyncTimeout)) {
-               logger.trace("sendSynchronizationDone wasn't finished in time");
                throw ActiveMQMessageBundle.BUNDLE.replicationSynchronizationTimeout(initialReplicationSyncTimeout);
             }
          }
          catch (InterruptedException e) {
-            logger.debug(e);
+            ActiveMQServerLogger.LOGGER.debug(e);
          }
          inSync = false;
-
-         logger.trace("sendSynchronizationDone finished");
       }
    }
 
@@ -660,9 +612,9 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
     * @return
     */
    public OperationContext sendLiveIsStopping(final LiveStopping finalMessage) {
-      logger.debug("LIVE IS STOPPING?!? message=" + finalMessage + " enabled=" + enabled);
+      ActiveMQServerLogger.LOGGER.debug("LIVE IS STOPPING?!? message=" + finalMessage + " enabled=" + enabled);
       if (enabled) {
-         logger.debug("LIVE IS STOPPING?!? message=" + finalMessage + " " + enabled);
+         ActiveMQServerLogger.LOGGER.debug("LIVE IS STOPPING?!? message=" + finalMessage + " " + enabled);
          return sendReplicatePacket(new ReplicationLiveIsStoppingMessage(finalMessage));
       }
       return null;