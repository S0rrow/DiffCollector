diff --git a/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/feed/dataflow/FeedRuntimeInputHandler.java b/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/feed/dataflow/FeedRuntimeInputHandler.java
index 329451dc1b..3920a03cec 100644
--- a/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/feed/dataflow/FeedRuntimeInputHandler.java
+++ b/asterixdb/asterix-external-data/src/main/java/org/apache/asterix/external/feed/dataflow/FeedRuntimeInputHandler.java
@@ -19,16 +19,15 @@
 package org.apache.asterix.external.feed.dataflow;
 
 import java.nio.ByteBuffer;
-import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.LinkedBlockingDeque;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import org.apache.asterix.active.ActiveRuntimeId;
-import org.apache.asterix.common.memory.ConcurrentFramePool;
-import org.apache.asterix.common.memory.FrameAction;
+import org.apache.asterix.external.feed.api.IFeedRuntime.Mode;
+import org.apache.asterix.external.feed.management.ConcurrentFramePool;
 import org.apache.asterix.external.feed.management.FeedConnectionId;
 import org.apache.asterix.external.feed.policy.FeedPolicyAccessor;
-import org.apache.asterix.external.util.FeedUtils.Mode;
+import org.apache.asterix.external.feed.runtime.FeedRuntimeId;
 import org.apache.hyracks.api.comm.IFrameWriter;
 import org.apache.hyracks.api.context.IHyracksTaskContext;
 import org.apache.hyracks.api.exceptions.HyracksDataException;
@@ -36,7 +35,7 @@ import org.apache.hyracks.dataflow.common.comm.io.FrameTupleAccessor;
 import org.apache.hyracks.dataflow.std.base.AbstractUnaryInputUnaryOutputOperatorNodePushable;
 
 /**
- * TODO: Add Failure cases unit tests for this class
+ * TODO: Add unit test cases for this class
  * Provides for error-handling and input-side buffering for a feed runtime.
  * .............______.............
  * ............|......|............
@@ -49,9 +48,8 @@ import org.apache.hyracks.dataflow.std.base.AbstractUnaryInputUnaryOutputOperato
 public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperatorNodePushable {
 
     private static final Logger LOGGER = Logger.getLogger(FeedRuntimeInputHandler.class.getName());
+    private static final ByteBuffer POISON_PILL = ByteBuffer.allocate(0);
     private static final double MAX_SPILL_USED_BEFORE_RESUME = 0.8;
-    private static final boolean DEBUG = false;
-    private final Object mutex = new Object();
     private final FeedExceptionHandler exceptionHandler;
     private final FrameSpiller spiller;
     private final FeedPolicyAccessor fpa;
@@ -59,40 +57,38 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
     private final int initialFrameSize;
     private final FrameTransporter consumer;
     private final Thread consumerThread;
-    private final LinkedBlockingQueue<ByteBuffer> inbox;
-    private final ConcurrentFramePool framePool;
+    private final LinkedBlockingDeque<ByteBuffer> inbox;
+    private final ConcurrentFramePool memoryManager;
     private Mode mode = Mode.PROCESS;
-    private int total = 0;
     private int numDiscarded = 0;
     private int numSpilled = 0;
     private int numProcessedInMemory = 0;
     private int numStalled = 0;
 
-    public FeedRuntimeInputHandler(IHyracksTaskContext ctx, FeedConnectionId connectionId, ActiveRuntimeId runtimeId,
-            IFrameWriter writer, FeedPolicyAccessor fpa, FrameTupleAccessor fta, ConcurrentFramePool framePool)
+    public FeedRuntimeInputHandler(IHyracksTaskContext ctx, FeedConnectionId connectionId, FeedRuntimeId runtimeId,
+            IFrameWriter writer, FeedPolicyAccessor fpa, FrameTupleAccessor fta, ConcurrentFramePool feedMemoryManager)
             throws HyracksDataException {
         this.writer = writer;
-        this.spiller = fpa.spillToDiskOnCongestion()
-                ? new FrameSpiller(ctx,
+        this.spiller =
+                new FrameSpiller(ctx,
                         connectionId.getFeedId() + "_" + connectionId.getDatasetName() + "_"
-                                + runtimeId.getRuntimeName() + "_" + runtimeId.getPartition(),
-                        fpa.getMaxSpillOnDisk())
-                : null;
+                                + runtimeId.getFeedRuntimeType() + "_" + runtimeId.getPartition(),
+                        fpa.getMaxSpillOnDisk());
         this.exceptionHandler = new FeedExceptionHandler(ctx, fta);
         this.fpa = fpa;
-        this.framePool = framePool;
-        this.inbox = new LinkedBlockingQueue<>();
+        this.memoryManager = feedMemoryManager;
+        this.inbox = new LinkedBlockingDeque<>();
         this.consumer = new FrameTransporter();
-        this.consumerThread = new Thread(consumer, "FeedRuntimeInputHandler-FrameTransporter");
+        this.consumerThread = new Thread();
+        this.consumerThread.start();
         this.initialFrameSize = ctx.getInitialFrameSize();
-        this.frameAction = new FrameAction();
+        this.frameAction = new FrameAction(inbox);
     }
 
     @Override
     public void open() throws HyracksDataException {
         synchronized (writer) {
             writer.open();
-            consumerThread.start();
         }
     }
 
@@ -105,48 +101,32 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
 
     @Override
     public void close() throws HyracksDataException {
+        inbox.add(POISON_PILL);
+        notify();
         try {
-            // Here we only put the poison frame into the inbox.
-            // If we use nextframe, chances are this frame will also be
-            // flushed into the spilled file. This causes problem when trying to
-            // read the frame and the size info is lost.
-            inbox.put(ByteBuffer.allocate(0));
-            synchronized (mutex) {
-                if (DEBUG) {
-                    LOGGER.info("Producer is waking up consumer");
-                }
-                mutex.notify();
-            }
             consumerThread.join();
         } catch (InterruptedException e) {
             LOGGER.log(Level.WARNING, e.getMessage(), e);
         }
         try {
-            framePool.release(inbox);
+            memoryManager.release(inbox);
         } catch (Throwable th) {
             LOGGER.log(Level.WARNING, th.getMessage(), th);
         }
         try {
-            if (spiller != null) {
-                spiller.close();
-            }
+            spiller.close();
         } catch (Throwable th) {
             LOGGER.log(Level.WARNING, th.getMessage(), th);
-        } finally {
-            writer.close();
         }
+        writer.close();
     }
 
     @Override
     public void nextFrame(ByteBuffer frame) throws HyracksDataException {
         try {
-            total++;
             if (consumer.cause() != null) {
                 throw consumer.cause();
             }
-            if (DEBUG) {
-                LOGGER.info("nextFrame() called. inputHandler is in mode: " + mode.toString());
-            }
             switch (mode) {
                 case PROCESS:
                     process(frame);
@@ -168,42 +148,25 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
         }
     }
 
-    // For unit testing purposes
-    public int framesOnDisk() {
-        return spiller.remaining();
-    }
-
     private ByteBuffer getFreeBuffer(int frameSize) throws HyracksDataException {
         int numFrames = frameSize / initialFrameSize;
         if (numFrames == 1) {
-            return framePool.get();
+            return memoryManager.get();
         } else {
-            return framePool.get(frameSize);
+            return memoryManager.get(frameSize);
         }
     }
 
     private void discard(ByteBuffer frame) throws HyracksDataException {
-        if (DEBUG) {
-            LOGGER.info("starting discard(frame)");
-        }
         if (fpa.spillToDiskOnCongestion()) {
-            if (DEBUG) {
-                LOGGER.info("Spilling to disk is enabled. Will try that");
-            }
             if (spiller.spill(frame)) {
                 numSpilled++;
                 mode = Mode.SPILL;
                 return;
             }
         } else {
-            if (DEBUG) {
-                LOGGER.info("Spilling to disk is disabled. Will try to get a buffer");
-            }
             ByteBuffer next = getFreeBuffer(frame.capacity());
             if (next != null) {
-                if (DEBUG) {
-                    LOGGER.info("Was able to get a buffer");
-                }
                 numProcessedInMemory++;
                 next.put(frame);
                 inbox.offer(next);
@@ -211,168 +174,102 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
                 return;
             }
         }
-        if ((numDiscarded + 1.0) / total > fpa.getMaxFractionDiscard()) {
-            if (DEBUG) {
-                LOGGER.info("in discard(frame). Discard allowance has been consumed. --> Stalling");
-            }
-            stall(frame);
-        } else {
-            if (DEBUG) {
-                LOGGER.info("in discard(frame). So far, I have discarded " + numDiscarded);
-            }
-            numDiscarded++;
-        }
+        numDiscarded++;
     }
 
-    private void exitProcessState(ByteBuffer frame) throws HyracksDataException {
+    private synchronized void exitProcessState(ByteBuffer frame) throws HyracksDataException {
         if (fpa.spillToDiskOnCongestion()) {
             mode = Mode.SPILL;
             spiller.open();
             spill(frame);
         } else {
-            if (DEBUG) {
-                LOGGER.info("Spilling is disabled --> discardOrStall(frame)");
-            }
             discardOrStall(frame);
         }
     }
 
     private void discardOrStall(ByteBuffer frame) throws HyracksDataException {
         if (fpa.discardOnCongestion()) {
+            numDiscarded++;
             mode = Mode.DISCARD;
             discard(frame);
         } else {
-            if (DEBUG) {
-                LOGGER.info("Discard is disabled --> stall(frame)");
-            }
             stall(frame);
         }
     }
 
     private void stall(ByteBuffer frame) throws HyracksDataException {
         try {
-            if (DEBUG) {
-                LOGGER.info("in stall(frame). So far, I have stalled " + numStalled);
-            }
             numStalled++;
             // If spilling is enabled, we wait on the spiller
             if (fpa.spillToDiskOnCongestion()) {
-                if (DEBUG) {
-                    LOGGER.info("in stall(frame). Spilling is enabled so we will attempt to spill");
+                synchronized (spiller) {
+                    while (spiller.usedBudget() > MAX_SPILL_USED_BEFORE_RESUME) {
+                        spiller.wait();
+                    }
                 }
-                waitforSpillSpace();
                 spiller.spill(frame);
-                numSpilled++;
-                synchronized (mutex) {
-                    if (DEBUG) {
-                        LOGGER.info("Producer is waking up consumer");
-                    }
-                    mutex.notify();
+                synchronized (this) {
+                    notify();
                 }
                 return;
             }
-            if (DEBUG) {
-                LOGGER.info("in stall(frame). Spilling is disabled. We will subscribe to frame pool");
-            }
             // Spilling is disabled, we subscribe to feedMemoryManager
             frameAction.setFrame(frame);
-            framePool.subscribe(frameAction);
-            ByteBuffer temp = frameAction.retrieve();
-            inbox.put(temp);
-            numProcessedInMemory++;
-            if (DEBUG) {
-                LOGGER.info("stall(frame) has been completed. Notifying the consumer that a frame is ready");
-            }
-            synchronized (mutex) {
-                if (DEBUG) {
-                    LOGGER.info("Producer is waking up consumer");
+            synchronized (frameAction) {
+                if (memoryManager.subscribe(frameAction)) {
+                    frameAction.wait();
                 }
-                mutex.notify();
+            }
+            synchronized (this) {
+                notify();
             }
         } catch (InterruptedException e) {
             throw new HyracksDataException(e);
         }
     }
 
-    private void waitforSpillSpace() throws InterruptedException {
-        synchronized (spiller) {
-            while (spiller.usedBudget() > MAX_SPILL_USED_BEFORE_RESUME) {
-                if (DEBUG) {
-                    LOGGER.info("in stall(frame). Spilling has been consumed. We will wait for it to be less than "
-                            + MAX_SPILL_USED_BEFORE_RESUME + " consumed. Current consumption = "
-                            + spiller.usedBudget());
-                }
-                spiller.wait();
-            }
-        }
-    }
-
     private void process(ByteBuffer frame) throws HyracksDataException {
-        // Get a page from frame pool
-        ByteBuffer next = (frame.capacity() <= framePool.getMaxFrameSize()) ? getFreeBuffer(frame.capacity()) : null;
+        // Get a page from
+        ByteBuffer next = getFreeBuffer(frame.capacity());
         if (next != null) {
-            // Got a page from memory pool
             numProcessedInMemory++;
             next.put(frame);
-            try {
-                inbox.put(next);
-                notifyMemoryConsumer();
-            } catch (InterruptedException e) {
-                throw new HyracksDataException(e);
+            inbox.offer(next);
+            if (inbox.size() == 1) {
+                synchronized (this) {
+                    notify();
+                }
             }
         } else {
-            if (DEBUG) {
-                LOGGER.info("Couldn't allocate memory --> exitProcessState(frame)");
-            }
-            // Out of memory. we switch to next mode as per policy
+            // out of memory. we switch to next mode as per policy -- synchronized method
             exitProcessState(frame);
         }
     }
 
-    private void notifyMemoryConsumer() {
-        if (inbox.size() == 1) {
-            synchronized (mutex) {
-                if (DEBUG) {
-                    LOGGER.info("Producer is waking up consumer");
-                }
-                mutex.notify();
-            }
-        }
-    }
-
     private void spill(ByteBuffer frame) throws HyracksDataException {
         if (spiller.switchToMemory()) {
-            synchronized (mutex) {
+            synchronized (this) {
                 // Check if there is memory
-                ByteBuffer next = null;
-                if (frame.capacity() <= framePool.getMaxFrameSize()) {
-                    next = getFreeBuffer(frame.capacity());
-                }
+                ByteBuffer next = getFreeBuffer(frame.capacity());
                 if (next != null) {
                     spiller.close();
                     numProcessedInMemory++;
                     next.put(frame);
                     inbox.offer(next);
-                    notifyMemoryConsumer();
                     mode = Mode.PROCESS;
                 } else {
-                    // spill. This will always succeed since spilled = 0 (TODO must verify that budget can't be 0)
+                    // spill. This will always succeed since spilled = 0 (must verify that budget can't be 0)
                     spiller.spill(frame);
                     numSpilled++;
-                    if (DEBUG) {
-                        LOGGER.info("Producer is waking up consumer");
-                    }
-                    mutex.notify();
+                    notify();
                 }
             }
         } else {
             // try to spill. If failed switch to either discard or stall
             if (spiller.spill(frame)) {
-                notifyDiskConsumer();
                 numSpilled++;
             } else {
                 if (fpa.discardOnCongestion()) {
-                    mode = Mode.DISCARD;
                     discard(frame);
                 } else {
                     stall(frame);
@@ -381,20 +278,19 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
         }
     }
 
-    private void notifyDiskConsumer() {
-        if (spiller.remaining() == 1) {
-            synchronized (mutex) {
-                if (DEBUG) {
-                    LOGGER.info("Producer is waking up consumer");
-                }
-                mutex.notify();
-            }
-        }
+    public Mode getMode() {
+        return mode;
+    }
+
+    public synchronized void setMode(Mode mode) {
+        this.mode = mode;
     }
 
     @Override
     public void flush() throws HyracksDataException {
-        // no op
+        synchronized (writer) {
+            writer.flush();
+        }
     }
 
     public int getNumDiscarded() {
@@ -415,7 +311,6 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
 
     private class FrameTransporter implements Runnable {
         private volatile Throwable cause;
-        private int consumed = 0;
 
         public Throwable cause() {
             return cause;
@@ -425,7 +320,6 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
             while (frame != null) {
                 try {
                     writer.nextFrame(frame);
-                    consumed++;
                     frame = null;
                 } catch (HyracksDataException e) {
                     // It is fine to catch throwable here since this thread is always expected to terminate gracefully
@@ -442,72 +336,52 @@ public class FeedRuntimeInputHandler extends AbstractUnaryInputUnaryOutputOperat
             return null;
         }
 
-        private boolean clearLocalFrames() throws HyracksDataException {
-            ByteBuffer frame = spiller.next();
-            while (frame != null) {
-                if (consume(frame) != null) {
-                    return false;
-                }
-                frame = spiller.next();
-            }
-            return true;
-        }
-
         @Override
         public void run() {
             try {
-                ByteBuffer frame;
-                boolean running = true;
-                while (running) {
-                    frame = inbox.poll();
-
-                    if (frame == null && spiller != null) {
-                        running = clearLocalFrames();
-                        continue;
-                    }
-
-                    if (frame == null) {
-                        synchronized (mutex) {
-                            LOGGER.info("Consumer is going to sleep");
-                            mutex.wait();
-                            LOGGER.info("Consumer is waking up");
-                        }
-                        continue;
-                    }
-
-                    // process
-                    if (frame.capacity() == 0) {
-                        running = false;
-                        if (spiller != null ) {
-                            clearLocalFrames();
-                        }
-                    } else {
+                ByteBuffer frame = inbox.poll();
+                while (frame != POISON_PILL) {
+                    if (frame != null) {
                         try {
                             if (consume(frame) != null) {
                                 return;
                             }
                         } finally {
-                            framePool.release(frame);
+                            // Done with frame.
+                            memoryManager.release(frame);
+                        }
+                    }
+                    frame = inbox.poll();
+                    if (frame == null) {
+                        // Memory queue is empty. Check spill
+                        frame = spiller.next();
+                        while (frame != null) {
+                            if (consume(frame) != null) {
+                                // We don't release the frame since this is a spill frame that we didn't get from memory
+                                // manager
+                                return;
+                            }
+                            frame = spiller.next();
+                        }
+                        writer.flush();
+                        // At this point. We consumed all memory and spilled
+                        // We can't assume the next will be in memory. what if there is 0 memory?
+                        synchronized (FeedRuntimeInputHandler.this) {
+                            frame = inbox.poll();
+                            if (frame == null) {
+                                // Nothing in memory
+                                if (spiller.switchToMemory()) {
+                                    // Nothing in disk
+                                    FeedRuntimeInputHandler.this.wait();
+                                }
+                            }
                         }
                     }
-                    writer.flush();
                 }
             } catch (Throwable th) {
                 this.cause = th;
             }
+            // cleanup will always be done through the close() call
         }
-
-        @Override
-        public String toString() {
-            return "consumed: " + consumed;
-        }
-    }
-
-    public int getTotal() {
-        return total;
-    }
-
-    public LinkedBlockingQueue<ByteBuffer> getInternalBuffer() {
-        return inbox;
     }
 }