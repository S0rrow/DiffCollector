diff --git a/asterix-algebra/src/main/java/edu/uci/ics/asterix/optimizer/rules/am/OptimizableOperatorSubTree.java b/asterix-algebra/src/main/java/edu/uci/ics/asterix/optimizer/rules/am/OptimizableOperatorSubTree.java
index c872c2abf7..77dff9f08d 100644
--- a/asterix-algebra/src/main/java/edu/uci/ics/asterix/optimizer/rules/am/OptimizableOperatorSubTree.java
+++ b/asterix-algebra/src/main/java/edu/uci/ics/asterix/optimizer/rules/am/OptimizableOperatorSubTree.java
@@ -19,6 +19,7 @@ import java.util.List;
 
 import org.apache.commons.lang3.mutable.Mutable;
 
+import edu.uci.ics.asterix.common.config.DatasetConfig.DatasetType;
 import edu.uci.ics.asterix.metadata.declared.AqlMetadataProvider;
 import edu.uci.ics.asterix.metadata.entities.Dataset;
 import edu.uci.ics.asterix.metadata.utils.DatasetUtils;
@@ -36,10 +37,7 @@ import edu.uci.ics.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;
 import edu.uci.ics.hyracks.algebricks.core.algebra.base.LogicalVariable;
 import edu.uci.ics.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;
 import edu.uci.ics.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;
-import edu.uci.ics.hyracks.algebricks.core.algebra.operators.logical.AbstractScanOperator;
-import edu.uci.ics.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestOperator;
 import edu.uci.ics.hyracks.algebricks.core.algebra.operators.logical.DataSourceScanOperator;
-import edu.uci.ics.hyracks.algebricks.core.algebra.operators.logical.ExternalDataLookupOperator;
 import edu.uci.ics.hyracks.algebricks.core.algebra.operators.logical.UnnestMapOperator;
 
 /**
@@ -50,9 +48,7 @@ public class OptimizableOperatorSubTree {
 
     public static enum DataSourceType {
         DATASOURCE_SCAN,
-        EXTERNAL_SCAN,
         PRIMARY_INDEX_LOOKUP,
-        COLLECTION_SCAN,
         NO_DATASOURCE
     }
 
@@ -72,28 +68,24 @@ public class OptimizableOperatorSubTree {
         root = subTreeOpRef.getValue();
         // Examine the op's children to match the expected patterns.
         AbstractLogicalOperator subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue();
+        // Skip select operator.
+        if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) {
+            subTreeOpRef = subTreeOp.getInputs().get(0);
+            subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue();
+        }
+        // Check primary-index pattern.
+        if (subTreeOp.getOperatorTag() != LogicalOperatorTag.ASSIGN && subTreeOp.getOperatorTag() != LogicalOperatorTag.UNNEST) {
+            // Pattern may still match if we are looking for primary index matches as well.
+            return initializeDataSource(subTreeOpRef);
+        }
+        // Match (assign | unnest)+.
         do {
-            // Skip select operator.
-            if (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT) {
-                subTreeOpRef = subTreeOp.getInputs().get(0);
-                subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue();
-            }
-            // Check primary-index pattern.
-            if (subTreeOp.getOperatorTag() != LogicalOperatorTag.ASSIGN
-                    && subTreeOp.getOperatorTag() != LogicalOperatorTag.UNNEST) {
-                // Pattern may still match if we are looking for primary index matches as well.
-                return initializeDataSource(subTreeOpRef);
-            }
-            // Match (assign | unnest)+.
-            while (subTreeOp.getOperatorTag() == LogicalOperatorTag.ASSIGN
-                    || subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST) {
-                assignsAndUnnestsRefs.add(subTreeOpRef);
-                assignsAndUnnests.add(subTreeOp);
+            assignsAndUnnestsRefs.add(subTreeOpRef);
+            assignsAndUnnests.add(subTreeOp);
 
-                subTreeOpRef = subTreeOp.getInputs().get(0);
-                subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue();
-            };
-        } while (subTreeOp.getOperatorTag() == LogicalOperatorTag.SELECT);
+            subTreeOpRef = subTreeOp.getInputs().get(0);
+            subTreeOp = (AbstractLogicalOperator) subTreeOpRef.getValue();
+        } while (subTreeOp.getOperatorTag() == LogicalOperatorTag.ASSIGN || subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST);
 
         // Match data source (datasource scan or primary index search).
         return initializeDataSource(subTreeOpRef);
@@ -105,14 +97,6 @@ public class OptimizableOperatorSubTree {
             dataSourceType = DataSourceType.DATASOURCE_SCAN;
             dataSourceRef = subTreeOpRef;
             return true;
-        } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.EXTERNAL_LOOKUP) {
-            dataSourceType = DataSourceType.EXTERNAL_SCAN;
-            dataSourceRef = subTreeOpRef;
-            return true;
-        } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.EMPTYTUPLESOURCE) {
-            dataSourceType = DataSourceType.COLLECTION_SCAN;
-            dataSourceRef = subTreeOpRef;
-            return true;
         } else if (subTreeOp.getOperatorTag() == LogicalOperatorTag.UNNEST_MAP) {
             UnnestMapOperator unnestMapOp = (UnnestMapOperator) subTreeOp;
             ILogicalExpression unnestExpr = unnestMapOp.getExpressionRef().getValue();
@@ -121,7 +105,7 @@ public class OptimizableOperatorSubTree {
                 if (f.getFunctionIdentifier().equals(AsterixBuiltinFunctions.INDEX_SEARCH)) {
                     AccessMethodJobGenParams jobGenParams = new AccessMethodJobGenParams();
                     jobGenParams.readFromFuncArgs(f.getArguments());
-                    if (jobGenParams.isPrimaryIndex()) {
+                    if(jobGenParams.isPrimaryIndex()) {
                         dataSourceType = DataSourceType.PRIMARY_INDEX_LOOKUP;
                         dataSourceRef = subTreeOpRef;
                         return true;
@@ -129,7 +113,6 @@ public class OptimizableOperatorSubTree {
                 }
             }
         }
-
         return false;
     }
 
@@ -148,7 +131,7 @@ public class OptimizableOperatorSubTree {
                 datasetName = datasetInfo.second;
                 break;
             case PRIMARY_INDEX_LOOKUP:
-                AbstractUnnestOperator unnestMapOp = (AbstractUnnestOperator) dataSourceRef.getValue();
+                UnnestMapOperator unnestMapOp = (UnnestMapOperator) dataSourceRef.getValue();
                 ILogicalExpression unnestExpr = unnestMapOp.getExpressionRef().getValue();
                 AbstractFunctionCallExpression f = (AbstractFunctionCallExpression) unnestExpr;
                 AccessMethodJobGenParams jobGenParams = new AccessMethodJobGenParams();
@@ -156,14 +139,6 @@ public class OptimizableOperatorSubTree {
                 datasetName = jobGenParams.getDatasetName();
                 dataverseName = jobGenParams.getDataverseName();
                 break;
-            case EXTERNAL_SCAN:
-                ExternalDataLookupOperator externalScan = (ExternalDataLookupOperator) dataSourceRef.getValue();
-                datasetInfo = AnalysisUtil.getDatasetInfo(externalScan);
-                dataverseName = datasetInfo.first;
-                datasetName = datasetInfo.second;
-                break;
-            case COLLECTION_SCAN:
-                return true;
             case NO_DATASOURCE:
             default:
                 return false;
@@ -176,6 +151,9 @@ public class OptimizableOperatorSubTree {
         if (dataset == null) {
             throw new AlgebricksException("No metadata for dataset " + datasetName);
         }
+        if (dataset.getDatasetType() != DatasetType.INTERNAL) {
+            return false;
+        }
         // Get the record type for that dataset.
         IAType itemType = metadataProvider.findType(dataverseName, dataset.getItemTypeName());
         if (itemType.getTypeTag() != ATypeTag.RECORD) {
@@ -204,7 +182,8 @@ public class OptimizableOperatorSubTree {
         recordType = null;
     }
 
-    public void getPrimaryKeyVars(List<LogicalVariable> target) throws AlgebricksException {
+    public void getPrimaryKeyVars(List<LogicalVariable> target, AqlMetadataProvider metadataProvider)
+            throws AlgebricksException {
         switch (dataSourceType) {
             case DATASOURCE_SCAN:
                 DataSourceScanOperator dataSourceScan = (DataSourceScanOperator) dataSourceRef.getValue();
@@ -228,12 +207,11 @@ public class OptimizableOperatorSubTree {
     public List<LogicalVariable> getDataSourceVariables() throws AlgebricksException {
         switch (dataSourceType) {
             case DATASOURCE_SCAN:
-            case EXTERNAL_SCAN:
+                DataSourceScanOperator dataSourceScan = (DataSourceScanOperator) dataSourceRef.getValue();
+                return dataSourceScan.getVariables();
             case PRIMARY_INDEX_LOOKUP:
-                AbstractScanOperator scanOp = (AbstractScanOperator) dataSourceRef.getValue();
-                return scanOp.getVariables();
-            case COLLECTION_SCAN:
-                return new ArrayList<LogicalVariable>();
+                UnnestMapOperator unnestMapOp = (UnnestMapOperator) dataSourceRef.getValue();
+                return unnestMapOp.getVariables();
             case NO_DATASOURCE:
             default:
                 throw new AlgebricksException("The subtree does not have any data source.");