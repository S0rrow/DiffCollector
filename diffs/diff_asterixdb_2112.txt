diff --git a/asterix-common/src/main/java/edu/uci/ics/asterix/common/context/DatasetLifecycleManager.java b/asterix-common/src/main/java/edu/uci/ics/asterix/common/context/DatasetLifecycleManager.java
index b7064d325f..17ad3315d5 100644
--- a/asterix-common/src/main/java/edu/uci/ics/asterix/common/context/DatasetLifecycleManager.java
+++ b/asterix-common/src/main/java/edu/uci/ics/asterix/common/context/DatasetLifecycleManager.java
@@ -26,20 +26,14 @@ import java.util.Set;
 
 import edu.uci.ics.asterix.common.api.ILocalResourceMetadata;
 import edu.uci.ics.asterix.common.config.AsterixStorageProperties;
-import edu.uci.ics.asterix.common.exceptions.ACIDException;
-import edu.uci.ics.asterix.common.ioopcallbacks.AbstractLSMIOOperationCallback;
-import edu.uci.ics.asterix.common.transactions.ILogManager;
-import edu.uci.ics.asterix.common.transactions.LogRecord;
+import edu.uci.ics.asterix.common.ioopcallbacks.LSMBTreeIOOperationCallbackFactory;
 import edu.uci.ics.hyracks.api.exceptions.HyracksDataException;
 import edu.uci.ics.hyracks.api.lifecycle.ILifeCycleComponent;
 import edu.uci.ics.hyracks.storage.am.common.api.IIndex;
 import edu.uci.ics.hyracks.storage.am.common.api.IIndexLifecycleManager;
-import edu.uci.ics.hyracks.storage.am.common.impls.NoOpOperationCallback;
 import edu.uci.ics.hyracks.storage.am.lsm.common.api.ILSMIndex;
-import edu.uci.ics.hyracks.storage.am.lsm.common.api.ILSMIndexAccessor;
 import edu.uci.ics.hyracks.storage.am.lsm.common.api.ILSMOperationTracker;
 import edu.uci.ics.hyracks.storage.am.lsm.common.api.IVirtualBufferCache;
-import edu.uci.ics.hyracks.storage.am.lsm.common.impls.AbstractLSMIndex;
 import edu.uci.ics.hyracks.storage.am.lsm.common.impls.MultitenantVirtualBufferCache;
 import edu.uci.ics.hyracks.storage.am.lsm.common.impls.VirtualBufferCache;
 import edu.uci.ics.hyracks.storage.common.buffercache.HeapBufferAllocator;
@@ -52,24 +46,19 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
     private final Map<Integer, ILSMOperationTracker> datasetOpTrackers;
     private final Map<Integer, DatasetInfo> datasetInfos;
     private final ILocalResourceRepository resourceRepository;
-    private final int firstAvilableUserDatasetID;
     private final long capacity;
     private long used;
-    private final ILogManager logManager;
-    private final LogRecord logRecord;
+    private final static int NUM_MUTABLE_BUFFERS = 2;
 
     public DatasetLifecycleManager(AsterixStorageProperties storageProperties,
-            ILocalResourceRepository resourceRepository, int firstAvilableUserDatasetID, ILogManager logManager) {
-        this.logManager = logManager;
+            ILocalResourceRepository resourceRepository) {
         this.storageProperties = storageProperties;
         this.resourceRepository = resourceRepository;
-        this.firstAvilableUserDatasetID = firstAvilableUserDatasetID;
         datasetVirtualBufferCaches = new HashMap<Integer, List<IVirtualBufferCache>>();
         datasetOpTrackers = new HashMap<Integer, ILSMOperationTracker>();
         datasetInfos = new HashMap<Integer, DatasetInfo>();
         capacity = storageProperties.getMemoryComponentGlobalBudget();
         used = 0;
-        logRecord = new LogRecord();
     }
 
     @Override
@@ -90,12 +79,7 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
         int did = getDIDfromRID(resourceID);
         DatasetInfo dsInfo = datasetInfos.get(did);
         if (dsInfo == null) {
-            dsInfo = new DatasetInfo(did, !index.hasMemoryComponents());
-            PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) datasetOpTrackers
-                    .get(dsInfo.datasetID);
-            if (opTracker != null) {
-                opTracker.setDatasetInfo(dsInfo);
-            }
+            dsInfo = new DatasetInfo(did);
         } else if (dsInfo.indexes.containsKey(resourceID)) {
             throw new HyracksDataException("Index with resource ID " + resourceID + " already exists.");
         }
@@ -112,55 +96,67 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
     }
 
     @Override
-    public synchronized void unregister(long resourceID) throws HyracksDataException {
-        int did = getDIDfromRID(resourceID);
-        DatasetInfo dsInfo = datasetInfos.get(did);
-        IndexInfo iInfo = dsInfo.indexes.get(resourceID);
-
-        if (dsInfo == null || iInfo == null) {
-            throw new HyracksDataException("Index with resource ID " + resourceID + " does not exist.");
-        }
-
-        PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) datasetOpTrackers.get(dsInfo.datasetID);
-        if (iInfo.referenceCount != 0 || (opTracker != null && opTracker.getNumActiveOperations() != 0)) {
-            throw new HyracksDataException("Cannot remove index while it is open.");
-        }
+    public void unregister(long resourceID) throws HyracksDataException {
+        int did;
+        PrimaryIndexOperationTracker opTracker;
+        DatasetInfo dsInfo;
+        IndexInfo iInfo;
+        synchronized (this) {
+            did = getDIDfromRID(resourceID);
+            dsInfo = datasetInfos.get(did);
+            iInfo = dsInfo.indexes.get(resourceID);
+
+            if (dsInfo == null || iInfo == null) {
+                throw new HyracksDataException("Index with resource ID " + resourceID + " does not exist.");
+            }
 
-        // TODO: use fine-grained counters, one for each index instead of a single counter per dataset.
+            opTracker = (PrimaryIndexOperationTracker) datasetOpTrackers.get(dsInfo.datasetID);
+            if (iInfo.referenceCount != 0 || (opTracker != null && opTracker.getNumActiveOperations() != 0)) {
+                throw new HyracksDataException("Cannot remove index while it is open.");
+            }
 
-        // First wait for any ongoing IO operations
-        synchronized (dsInfo) {
             while (dsInfo.numActiveIOOps > 0) {
                 try {
-                    //notification will come from DatasetInfo class (undeclareActiveIOOperation)
-                    dsInfo.wait();
+                    wait();
                 } catch (InterruptedException e) {
                     throw new HyracksDataException(e);
                 }
             }
         }
-
-        // Flush and wait for it to finish, it is separated from the above wait so they don't deadlock each other.
-        // TODO: Find a better way to do this.
-        flushAndWaitForIO(dsInfo, iInfo);
-
         if (iInfo.isOpen) {
-            iInfo.index.deactivate(false);
+            iInfo.index.deactivate(true);
         }
 
-        dsInfo.indexes.remove(resourceID);
-        if (dsInfo.referenceCount == 0 && dsInfo.isOpen && dsInfo.indexes.isEmpty() && !dsInfo.isExternal) {
-            List<IVirtualBufferCache> vbcs = getVirtualBufferCaches(did);
-            assert vbcs != null;
-            for (IVirtualBufferCache vbc : vbcs) {
-                used -= (vbc.getNumPages() * vbc.getPageSize());
+        synchronized (this) {
+            dsInfo.indexes.remove(resourceID);
+            if (dsInfo.referenceCount == 0 && dsInfo.isOpen && dsInfo.indexes.isEmpty()) {
+                List<IVirtualBufferCache> vbcs = getVirtualBufferCaches(did);
+                assert vbcs != null;
+                for (IVirtualBufferCache vbc : vbcs) {
+                    used -= (vbc.getNumPages() * vbc.getPageSize());
+                }
+                datasetInfos.remove(did);
             }
-            datasetInfos.remove(did);
-            datasetVirtualBufferCaches.remove(did);
-            datasetOpTrackers.remove(did);
         }
     }
 
+    public synchronized void declareActiveIOOperation(int datasetID) throws HyracksDataException {
+        DatasetInfo dsInfo = datasetInfos.get(datasetID);
+        if (dsInfo == null) {
+            throw new HyracksDataException("Failed to find a dataset with ID " + datasetID);
+        }
+        dsInfo.incrementActiveIOOps();
+    }
+
+    public synchronized void undeclareActiveIOOperation(int datasetID) throws HyracksDataException {
+        DatasetInfo dsInfo = datasetInfos.get(datasetID);
+        if (dsInfo == null) {
+            throw new HyracksDataException("Failed to find a dataset with ID " + datasetID);
+        }
+        dsInfo.decrementActiveIOOps();
+        notifyAll();
+    }
+
     @Override
     public synchronized void open(long resourceID) throws HyracksDataException {
         int did = getDIDfromRID(resourceID);
@@ -176,8 +172,7 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
                     + " since it does not exist.");
         }
 
-        // This is not needed for external datasets' indexes since they never use the virtual buffer cache.
-        if (!dsInfo.isOpen && !dsInfo.isExternal) {
+        if (!dsInfo.isOpen) {
             List<IVirtualBufferCache> vbcs = getVirtualBufferCaches(did);
             assert vbcs != null;
             long additionalSize = 0;
@@ -213,38 +208,30 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
                     .get(dsInfo.datasetID);
             if (opTracker != null && opTracker.getNumActiveOperations() == 0 && dsInfo.referenceCount == 0
                     && dsInfo.isOpen) {
-                closeDataset(dsInfo);
-                return true;
-            }
-        }
-        return false;
-    }
-
-    private void flushAndWaitForIO(DatasetInfo dsInfo, IndexInfo iInfo) throws HyracksDataException {
-        if (iInfo.isOpen) {
-            ILSMIndexAccessor accessor = iInfo.index.createAccessor(NoOpOperationCallback.INSTANCE,
-                    NoOpOperationCallback.INSTANCE);
-            accessor.scheduleFlush(iInfo.index.getIOOperationCallback());
-        }
+                while (dsInfo.numActiveIOOps > 0) {
+                    try {
+                        wait();
+                    } catch (InterruptedException e) {
+                        throw new HyracksDataException(e);
+                    }
+                }
+                for (IndexInfo iInfo : dsInfo.indexes.values()) {
+                    if (iInfo.isOpen) {
+                        iInfo.index.deactivate(true);
+                        iInfo.isOpen = false;
+                    }
+                    assert iInfo.referenceCount == 0;
+                }
 
-        // Wait for the above flush op.
-        synchronized (dsInfo) {
-            while (dsInfo.numActiveIOOps > 0) {
-                try {
-                    //notification will come from DatasetInfo class (undeclareActiveIOOperation)
-                    dsInfo.wait();
-                } catch (InterruptedException e) {
-                    throw new HyracksDataException(e);
+                List<IVirtualBufferCache> vbcs = getVirtualBufferCaches(dsInfo.datasetID);
+                for (IVirtualBufferCache vbc : vbcs) {
+                    used -= vbc.getNumPages() * vbc.getPageSize();
                 }
+                dsInfo.isOpen = false;
+                return true;
             }
         }
-    }
-
-    public DatasetInfo getDatasetInfo(int datasetID) {
-
-        synchronized (datasetInfos) {
-            return datasetInfos.get(datasetID);
-        }
+        return false;
     }
 
     @Override
@@ -280,12 +267,10 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
             List<IVirtualBufferCache> vbcs = datasetVirtualBufferCaches.get(datasetID);
             if (vbcs == null) {
                 vbcs = new ArrayList<IVirtualBufferCache>();
-                int numPages = datasetID < firstAvilableUserDatasetID ? storageProperties
-                        .getMetadataMemoryComponentNumPages() : storageProperties.getMemoryComponentNumPages();
-                for (int i = 0; i < storageProperties.getMemoryComponentsNum(); i++) {
+                for (int i = 0; i < NUM_MUTABLE_BUFFERS; i++) {
                     MultitenantVirtualBufferCache vbc = new MultitenantVirtualBufferCache(new VirtualBufferCache(
-                            new HeapBufferAllocator(), storageProperties.getMemoryComponentPageSize(), numPages
-                                    / storageProperties.getMemoryComponentsNum()));
+                            new HeapBufferAllocator(), storageProperties.getMemoryComponentPageSize(),
+                            storageProperties.getMemoryComponentNumPages() / NUM_MUTABLE_BUFFERS));
                     vbcs.add(vbc);
                 }
                 datasetVirtualBufferCaches.put(datasetID, vbcs);
@@ -298,14 +283,30 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
         synchronized (datasetOpTrackers) {
             ILSMOperationTracker opTracker = datasetOpTrackers.get(datasetID);
             if (opTracker == null) {
-                opTracker = new PrimaryIndexOperationTracker(this, datasetID, logManager, getDatasetInfo(datasetID));
+                opTracker = new PrimaryIndexOperationTracker(this, datasetID,
+                        LSMBTreeIOOperationCallbackFactory.INSTANCE);
                 datasetOpTrackers.put(datasetID, opTracker);
             }
+
             return opTracker;
         }
     }
 
-    private abstract class Info {
+    public synchronized Set<ILSMIndex> getDatasetIndexes(int datasetID) throws HyracksDataException {
+        DatasetInfo dsInfo = datasetInfos.get(datasetID);
+        if (dsInfo == null) {
+            throw new HyracksDataException("No dataset found with datasetID " + datasetID);
+        }
+        Set<ILSMIndex> datasetIndexes = new HashSet<ILSMIndex>();
+        for (IndexInfo iInfo : dsInfo.indexes.values()) {
+            if (iInfo.isOpen) {
+                datasetIndexes.add(iInfo.index);
+            }
+        }
+        return datasetIndexes;
+    }
+
+    private static abstract class Info {
         protected int referenceCount;
         protected boolean isOpen;
 
@@ -323,59 +324,42 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
         }
     }
 
-    private class IndexInfo extends Info {
-        private final ILSMIndex index;
+    private static class IndexInfo extends Info {
+        private ILSMIndex index;
 
         public IndexInfo(ILSMIndex index) {
             this.index = index;
         }
     }
 
-    public class DatasetInfo extends Info implements Comparable<DatasetInfo> {
+    private static class DatasetInfo extends Info implements Comparable<DatasetInfo> {
         private final Map<Long, IndexInfo> indexes;
         private final int datasetID;
         private long lastAccess;
         private int numActiveIOOps;
-        private final boolean isExternal;
 
-        public DatasetInfo(int datasetID, boolean isExternal) {
+        public DatasetInfo(int datasetID) {
             this.indexes = new HashMap<Long, IndexInfo>();
             this.lastAccess = -1;
             this.datasetID = datasetID;
-            this.isExternal = isExternal;
         }
 
-        @Override
         public void touch() {
             super.touch();
             lastAccess = System.currentTimeMillis();
         }
 
-        @Override
         public void untouch() {
             super.untouch();
             lastAccess = System.currentTimeMillis();
         }
 
-        public synchronized void declareActiveIOOperation() {
+        public void incrementActiveIOOps() {
             numActiveIOOps++;
         }
 
-        public synchronized void undeclareActiveIOOperation() {
+        public void decrementActiveIOOps() {
             numActiveIOOps--;
-            //notify threads waiting on this dataset info
-            notifyAll();
-        }
-
-        public synchronized Set<ILSMIndex> getDatasetIndexes() throws HyracksDataException {
-            Set<ILSMIndex> datasetIndexes = new HashSet<ILSMIndex>();
-            for (IndexInfo iInfo : indexes.values()) {
-                if (iInfo.isOpen) {
-                    datasetIndexes.add(iInfo.index);
-                }
-            }
-
-            return datasetIndexes;
         }
 
         @Override
@@ -412,7 +396,6 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
 
         }
 
-        @Override
         public String toString() {
             return "DatasetID: " + datasetID + ", isOpen: " + isOpen + ", refCount: " + referenceCount
                     + ", lastAccess: " + lastAccess + "}";
@@ -420,174 +403,42 @@ public class DatasetLifecycleManager implements IIndexLifecycleManager, ILifeCyc
     }
 
     @Override
-    public synchronized void start() {
-        used = 0;
-    }
-
-    public synchronized void flushAllDatasets() throws HyracksDataException {
-        for (DatasetInfo dsInfo : datasetInfos.values()) {
-            flushDatasetOpenIndexes(dsInfo, false);
-        }
-    }
-
-    public synchronized void flushDataset(int datasetId, boolean asyncFlush) throws HyracksDataException {
-        DatasetInfo datasetInfo = datasetInfos.get(datasetId);
-        if (datasetInfo != null) {
-            flushDatasetOpenIndexes(datasetInfo, asyncFlush);
-        }
-    }
-
-    public synchronized void scheduleAsyncFlushForLaggingDatasets(long targetLSN) throws HyracksDataException {
-        //schedule flush for datasets with min LSN (Log Serial Number) < targetLSN
-        for (DatasetInfo dsInfo : datasetInfos.values()) {
-            PrimaryIndexOperationTracker opTracker = (PrimaryIndexOperationTracker) getOperationTracker(dsInfo.datasetID);
-            synchronized (opTracker) {
-                for (IndexInfo iInfo : dsInfo.indexes.values()) {
-                    AbstractLSMIOOperationCallback ioCallback = (AbstractLSMIOOperationCallback) iInfo.index
-                            .getIOOperationCallback();
-                    if (!(((AbstractLSMIndex) iInfo.index).isCurrentMutableComponentEmpty()
-                            || ioCallback.hasPendingFlush() || opTracker.isFlushLogCreated() || opTracker.isFlushOnExit())) {
-                        long firstLSN = ioCallback.getFirstLSN();
-                        if (firstLSN < targetLSN) {
-                            opTracker.setFlushOnExit(true);
-                            if (opTracker.getNumActiveOperations() == 0) {
-                                // No Modify operations currently, we need to trigger the flush and we can do so safely
-                                opTracker.flushIfRequested();
-                            }
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    /*
-     * This method can only be called asynchronously safely if we're sure no modify operation will take place until the flush is scheduled
-     */
-    private void flushDatasetOpenIndexes(DatasetInfo dsInfo, boolean asyncFlush) throws HyracksDataException {
-        if (!dsInfo.isExternal) {
-            synchronized (logRecord) {
-                logRecord.formFlushLogRecord(dsInfo.datasetID, null);
-                try {
-                    logManager.log(logRecord);
-                } catch (ACIDException e) {
-                    throw new HyracksDataException("could not write flush log while closing dataset", e);
-                }
-
-                try {
-                    //notification will come from LogPage class (notifyFlushTerminator)
-                    logRecord.wait();
-                } catch (InterruptedException e) {
-                    throw new HyracksDataException(e);
-                }
-            }
-            for (IndexInfo iInfo : dsInfo.indexes.values()) {
-                //update resource lsn
-                AbstractLSMIOOperationCallback ioOpCallback = (AbstractLSMIOOperationCallback) iInfo.index
-                        .getIOOperationCallback();
-                ioOpCallback.updateLastLSN(logRecord.getLSN());
-            }
-        }
-
-        if (asyncFlush) {
-
-            for (IndexInfo iInfo : dsInfo.indexes.values()) {
-                ILSMIndexAccessor accessor = iInfo.index.createAccessor(NoOpOperationCallback.INSTANCE,
-                        NoOpOperationCallback.INSTANCE);
-                accessor.scheduleFlush(iInfo.index.getIOOperationCallback());
-            }
-        } else {
-
-            for (IndexInfo iInfo : dsInfo.indexes.values()) {
-                // TODO: This is not efficient since we flush the indexes sequentially. 
-                // Think of a way to allow submitting the flush requests concurrently. We don't do them concurrently because this
-                // may lead to a deadlock scenario between the DatasetLifeCycleManager and the PrimaryIndexOperationTracker.
-
-                flushAndWaitForIO(dsInfo, iInfo);
-            }
-        }
-    }
-
-    private void closeDataset(DatasetInfo dsInfo) throws HyracksDataException {
-        // First wait for any ongoing IO operations
-        synchronized (dsInfo) {
-            while (dsInfo.numActiveIOOps > 0) {
-                try {
-                    dsInfo.wait();
-                } catch (InterruptedException e) {
-                    throw new HyracksDataException(e);
-                }
-            }
-
-        }
-        try {
-            flushDatasetOpenIndexes(dsInfo, false);
-        } catch (Exception e) {
-            throw new HyracksDataException(e);
-        }
-
-        for (IndexInfo iInfo : dsInfo.indexes.values()) {
-            if (iInfo.isOpen) {
-                iInfo.index.deactivate(false);
-                iInfo.isOpen = false;
-            }
-            assert iInfo.referenceCount == 0;
-        }
-        dsInfo.isOpen = false;
-
-        List<IVirtualBufferCache> vbcs = getVirtualBufferCaches(dsInfo.datasetID);
-        for (IVirtualBufferCache vbc : vbcs) {
-            used -= vbc.getNumPages() * vbc.getPageSize();
-        }
+    public void start() {
     }
 
     @Override
-    public synchronized void stop(boolean dumpState, OutputStream outputStream) throws IOException {
+    public void stop(boolean dumpState, OutputStream outputStream) throws IOException {
         if (dumpState) {
             dumpState(outputStream);
         }
 
-        for (DatasetInfo dsInfo : datasetInfos.values()) {
-            closeDataset(dsInfo);
+        List<IIndex> openIndexes = getOpenIndexes();
+        for (IIndex index : openIndexes) {
+            index.deactivate();
         }
-
         datasetVirtualBufferCaches.clear();
         datasetOpTrackers.clear();
         datasetInfos.clear();
     }
 
-    @Override
-    public void dumpState(OutputStream outputStream) throws IOException {
+    private void dumpState(OutputStream outputStream) throws IOException {
         StringBuilder sb = new StringBuilder();
 
         sb.append(String.format("Memory budget = %d\n", capacity));
         sb.append(String.format("Memory used = %d\n", used));
-        sb.append("\n");
-
-        String dsHeaderFormat = "%-10s %-6s %-16s %-12s\n";
-        String dsFormat = "%-10d %-6b %-16d %-12d\n";
-        String idxHeaderFormat = "%-10s %-11s %-6s %-16s %-6s\n";
-        String idxFormat = "%-10d %-11d %-6b %-16d %-6s\n";
 
-        sb.append("[Datasets]\n");
-        sb.append(String.format(dsHeaderFormat, "DatasetID", "Open", "Reference Count", "Last Access"));
+        String headerFormat = "%-20s %-10s %-20s %-20s\n";
+        String dsFormat = "%-20d %-10b %-20d %-20s %-20s\n";
+        String idxFormat = "\t%-20d %-10b %-20d %-20s\n";
+        sb.append(String.format(headerFormat, "DatasetID", "Open", "Reference Count", "Last Access"));
         for (DatasetInfo dsInfo : datasetInfos.values()) {
             sb.append(String
                     .format(dsFormat, dsInfo.datasetID, dsInfo.isOpen, dsInfo.referenceCount, dsInfo.lastAccess));
-        }
-        sb.append("\n");
-
-        sb.append("[Indexes]\n");
-        sb.append(String.format(idxHeaderFormat, "DatasetID", "ResourceID", "Open", "Reference Count", "Index"));
-        for (DatasetInfo dsInfo : datasetInfos.values()) {
             for (Map.Entry<Long, IndexInfo> entry : dsInfo.indexes.entrySet()) {
                 IndexInfo iInfo = entry.getValue();
-                sb.append(String.format(idxFormat, dsInfo.datasetID, entry.getKey(), iInfo.isOpen,
-                        iInfo.referenceCount, iInfo.index));
+                sb.append(String.format(idxFormat, entry.getKey(), iInfo.isOpen, iInfo.referenceCount, iInfo.index));
             }
         }
-
         outputStream.write(sb.toString().getBytes());
     }
-}
+}
\ No newline at end of file