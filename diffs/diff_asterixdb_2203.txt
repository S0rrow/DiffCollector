diff --git a/hyracks-fullstack/hyracks/hyracks-control/hyracks-control-common/src/main/java/org/apache/hyracks/control/common/controllers/NCConfig.java b/hyracks-fullstack/hyracks/hyracks-control/hyracks-control-common/src/main/java/org/apache/hyracks/control/common/controllers/NCConfig.java
index 7906b52304..4240e3a3a0 100644
--- a/hyracks-fullstack/hyracks/hyracks-control/hyracks-control-common/src/main/java/org/apache/hyracks/control/common/controllers/NCConfig.java
+++ b/hyracks-fullstack/hyracks/hyracks-control/hyracks-control-common/src/main/java/org/apache/hyracks/control/common/controllers/NCConfig.java
@@ -18,485 +18,264 @@
  */
 package org.apache.hyracks.control.common.controllers;
 
-import static org.apache.hyracks.control.common.config.OptionTypes.BOOLEAN;
-import static org.apache.hyracks.control.common.config.OptionTypes.INTEGER;
-import static org.apache.hyracks.control.common.config.OptionTypes.INTEGER_BYTE_UNIT;
-import static org.apache.hyracks.control.common.config.OptionTypes.LONG;
-import static org.apache.hyracks.control.common.config.OptionTypes.STRING;
-import static org.apache.hyracks.control.common.config.OptionTypes.STRING_ARRAY;
-
+import org.apache.hyracks.api.application.IApplicationConfig;
+import org.apache.hyracks.control.common.application.IniApplicationConfig;
+import org.ini4j.Ini;
+import org.kohsuke.args4j.Argument;
+import org.kohsuke.args4j.Option;
+import org.kohsuke.args4j.spi.StopOptionHandler;
+
+import java.io.IOException;
+import java.io.Serializable;
 import java.net.InetAddress;
-import java.util.ArrayList;
 import java.util.List;
-import java.util.function.Supplier;
-
-import org.apache.hyracks.api.config.IApplicationConfig;
-import org.apache.hyracks.api.config.IOption;
-import org.apache.hyracks.api.config.IOptionType;
-import org.apache.hyracks.api.config.Section;
-import org.apache.hyracks.control.common.config.ConfigManager;
-import org.apache.hyracks.util.file.FileUtil;
-
-public class NCConfig extends ControllerConfig {
-    private static final long serialVersionUID = 3L;
-
-    public static String defaultDir = System.getProperty("java.io.tmpdir");
-    public static String defaultAppClass = null;
-
-    public enum Option implements IOption {
-        ADDRESS(STRING, InetAddress.getLoopbackAddress().getHostAddress()),
-        PUBLIC_ADDRESS(STRING, ADDRESS),
-        CLUSTER_LISTEN_ADDRESS(STRING, ADDRESS),
-        CLUSTER_LISTEN_PORT(INTEGER, 0),
-        NCSERVICE_ADDRESS(STRING, PUBLIC_ADDRESS),
-        NCSERVICE_PORT(INTEGER, 9090),
-        CLUSTER_ADDRESS(STRING, (String)null),
-        CLUSTER_PORT(INTEGER, 1099),
-        CLUSTER_PUBLIC_ADDRESS(STRING, PUBLIC_ADDRESS),
-        CLUSTER_PUBLIC_PORT(INTEGER, CLUSTER_LISTEN_PORT),
-        NODE_ID(STRING, (String)null),
-        DATA_LISTEN_ADDRESS(STRING, ADDRESS),
-        DATA_LISTEN_PORT(INTEGER, 0),
-        DATA_PUBLIC_ADDRESS(STRING, PUBLIC_ADDRESS),
-        DATA_PUBLIC_PORT(INTEGER, DATA_LISTEN_PORT),
-        RESULT_LISTEN_ADDRESS(STRING, ADDRESS),
-        RESULT_LISTEN_PORT(INTEGER, 0),
-        RESULT_PUBLIC_ADDRESS(STRING, PUBLIC_ADDRESS),
-        RESULT_PUBLIC_PORT(INTEGER, RESULT_LISTEN_PORT),
-        MESSAGING_LISTEN_ADDRESS(STRING, ADDRESS),
-        MESSAGING_LISTEN_PORT(INTEGER, 0),
-        MESSAGING_PUBLIC_ADDRESS(STRING, PUBLIC_ADDRESS),
-        MESSAGING_PUBLIC_PORT(INTEGER, MESSAGING_LISTEN_PORT),
-        CLUSTER_CONNECT_RETRIES(INTEGER, 5),
-        @SuppressWarnings("RedundantCast") // not redundant- false positive from IDEA
-        IODEVICES(STRING_ARRAY, (Supplier<String []>)() -> new String [] { FileUtil.joinPath(defaultDir, "iodevice") }),
-        NET_THREAD_COUNT(INTEGER, 1),
-        NET_BUFFER_COUNT(INTEGER, 1),
-        RESULT_TTL(LONG, 86400000L),
-        RESULT_SWEEP_THRESHOLD(LONG, 60000L),
-        RESULT_MANAGER_MEMORY(INTEGER_BYTE_UNIT, -1),
-        @SuppressWarnings("RedundantCast") // not redundant- false positive from IDEA
-        APP_CLASS(STRING, (Supplier<String>)() -> defaultAppClass),
-        NCSERVICE_PID(INTEGER, -1),
-        COMMAND(STRING, "hyracksnc"),
-        JVM_ARGS(STRING, (String)null),
-        VIRTUAL_NC(BOOLEAN, false);
-
-        private final IOptionType parser;
-        private final Object defaultValue;
-
-        <T> Option(IOptionType<T> parser, Option defaultOption) {
-            this.parser = parser;
-            this.defaultValue = defaultOption;
-        }
+import java.util.Map;
 
-        <T> Option(IOptionType<T> parser, T defaultValue) {
-            this.parser = parser;
-            this.defaultValue = defaultValue;
-        }
+public class NCConfig implements Serializable {
+    private static final long serialVersionUID = 2L;
 
-        <T> Option(IOptionType<T> parser, Supplier<T> defaultValue) {
-            this.parser = parser;
-            this.defaultValue = defaultValue;
-        }
+    @Option(name = "-cc-host", usage = "Cluster Controller host name (required unless specified in config file)", required = false)
+    public String ccHost = null;
 
-        @Override
-        public Section section() {
-            switch (this) {
-                case NODE_ID:
-                    return Section.LOCALNC;
-                default:
-                    return Section.NC;
-            }
-        }
+    @Option(name = "-cc-port", usage = "Cluster Controller port (default: 1099)", required = false)
+    public int ccPort = 1099;
 
-        @Override
-        public String description() {
-            switch (this) {
-                case ADDRESS:
-                    return "Default IP Address to bind listeners on this NC.  All services will bind on this address " +
-                            "unless a service-specific listen address is supplied.";
-                case CLUSTER_LISTEN_ADDRESS:
-                    return "IP Address to bind cluster listener on this NC";
-                case PUBLIC_ADDRESS:
-                    return "Default public address that other processes should use to contact this NC.  All services " +
-                            "will advertise this address unless a service-specific public address is supplied.";
-                case NCSERVICE_ADDRESS:
-                    return "Address the CC should use to contact the NCService associated with this NC";
-                case NCSERVICE_PORT:
-                    return "Port the CC should use to contact the NCService associated with this NC";
-                case CLUSTER_ADDRESS:
-                    return "Cluster Controller address (required unless specified in config file)";
-                case CLUSTER_PORT:
-                    return "Cluster Controller port";
-                case CLUSTER_LISTEN_PORT:
-                    return "IP port to bind cluster listener";
-                case CLUSTER_PUBLIC_ADDRESS:
-                    return "Public IP Address to announce cluster listener";
-                case CLUSTER_PUBLIC_PORT:
-                    return "Public IP port to announce cluster listener";
-                case NODE_ID:
-                    return "Logical name of node controller unique within the cluster (required unless specified in " +
-                            "config file)";
-                case DATA_LISTEN_ADDRESS:
-                    return "IP Address to bind data listener";
-                case DATA_LISTEN_PORT:
-                    return "IP port to bind data listener";
-                case DATA_PUBLIC_ADDRESS:
-                    return "Public IP Address to announce data listener";
-                case DATA_PUBLIC_PORT:
-                    return "Public IP port to announce data listener";
-                case RESULT_LISTEN_ADDRESS:
-                    return "IP Address to bind dataset result distribution listener";
-                case RESULT_LISTEN_PORT:
-                    return "IP port to bind dataset result distribution listener";
-                case RESULT_PUBLIC_ADDRESS:
-                    return "Public IP Address to announce dataset result distribution listener";
-                case RESULT_PUBLIC_PORT:
-                    return "Public IP port to announce dataset result distribution listener";
-                case MESSAGING_LISTEN_ADDRESS:
-                    return "IP Address to bind messaging listener";
-                case MESSAGING_LISTEN_PORT:
-                    return "IP port to bind messaging listener";
-                case MESSAGING_PUBLIC_ADDRESS:
-                    return "Public IP Address to announce messaging listener";
-                case MESSAGING_PUBLIC_PORT:
-                    return "Public IP port to announce messaging listener";
-                case CLUSTER_CONNECT_RETRIES:
-                    return "Number of attempts to contact CC before giving up";
-                case IODEVICES:
-                    return "Comma separated list of IO Device mount points";
-                case NET_THREAD_COUNT:
-                    return "Number of threads to use for Network I/O";
-                case NET_BUFFER_COUNT:
-                    return "Number of network buffers per input/output channel";
-                case RESULT_TTL:
-                    return "Limits the amount of time results for asynchronous jobs should be retained by the system " +
-                            "in milliseconds";
-                case RESULT_SWEEP_THRESHOLD:
-                    return "The duration within which an instance of the result cleanup should be invoked in " +
-                            "milliseconds";
-                case RESULT_MANAGER_MEMORY:
-                    return "Memory usable for result caching at this Node Controller in bytes";
-                case APP_CLASS:
-                    return "Application NC Main Class";
-                case NCSERVICE_PID:
-                    return "PID of the NCService which launched this NCDriver";
-                case COMMAND:
-                    return "Command NCService should invoke to start the NCDriver";
-                case JVM_ARGS:
-                    return "JVM args to pass to the NCDriver";
-                case VIRTUAL_NC:
-                    return "A flag indicating if this NC is running on virtual cluster";
-                default:
-                    throw new IllegalStateException("NYI: " + this);
-            }
-        }
+    @Option(name = "-address", usage = "IP Address for NC (default: localhost)", required = false)
+    public String ipAddress = InetAddress.getLoopbackAddress().getHostAddress();
 
+    @Option(name = "-cluster-net-ip-address", usage = "IP Address to bind cluster listener (default: same as -address)", required = false)
+    public String clusterNetIPAddress;
 
-        @Override
-        public IOptionType type() {
-            return parser;
-        }
+    @Option(name = "-cluster-net-port", usage = "IP port to bind cluster listener (default: random port)", required = false)
+    public int clusterNetPort = 0;
 
-        @Override
-        public Object defaultValue() {
-            return defaultValue;
-        }
+    @Option(name = "-cluster-net-public-ip-address", usage = "Public IP Address to announce cluster listener (default: same as -cluster-net-ip-address)", required = false)
+    public String clusterNetPublicIPAddress;
 
-        @Override
-        public boolean hidden() {
-            return this == VIRTUAL_NC;
-        }
-    }
+    @Option(name = "-cluster-net-public-port", usage = "Public IP port to announce cluster listener (default: same as -cluster-net-port; must set -cluser-net-public-ip-address also)", required = false)
+    public int clusterNetPublicPort = 0;
 
-    private List<String> appArgs = new ArrayList<>();
+    @Option(name = "-node-id", usage = "Logical name of node controller unique within the cluster (required unless specified in config file)", required = false)
+    public String nodeId = null;
 
-    private final IApplicationConfig appConfig;
-    private final String nodeId;
+    @Option(name = "-data-ip-address", usage = "IP Address to bind data listener (default: same as -address)", required = false)
+    public String dataIPAddress;
 
-    public NCConfig(String nodeId) {
-        this(nodeId, new ConfigManager(null));
-    }
+    @Option(name = "-data-port", usage = "IP port to bind data listener (default: random port)", required = false)
+    public int dataPort = 0;
 
-    public NCConfig(String nodeId, ConfigManager configManager) {
-        super(configManager);
-        this.appConfig = configManager.getNodeEffectiveConfig(nodeId);
-        configManager.register(Option.class);
-        setNodeId(nodeId);
-        this.nodeId = nodeId;
-        configManager.registerArgsListener(appArgs::addAll);
-    }
+    @Option(name = "-data-public-ip-address", usage = "Public IP Address to announce data listener (default: same as -data-ip-address)", required = false)
+    public String dataPublicIPAddress;
 
-    public List<String> getAppArgs() {
-        return appArgs;
-    }
+    @Option(name = "-data-public-port", usage = "Public IP port to announce data listener (default: same as -data-port; must set -data-public-ip-address also)", required = false)
+    public int dataPublicPort = 0;
 
-    public String[] getAppArgsArray() {
-        return appArgs.toArray(new String[appArgs.size()]);
-    }
+    @Option(name = "-result-ip-address", usage = "IP Address to bind dataset result distribution listener (default: same as -address)", required = false)
+    public String resultIPAddress;
 
-    public ConfigManager getConfigManager() {
-        return configManager;
-    }
+    @Option(name = "-result-port", usage = "IP port to bind dataset result distribution listener (default: random port)", required = false)
+    public int resultPort = 0;
 
-    public IApplicationConfig getAppConfig() {
-        return appConfig;
-    }
+    @Option(name = "-result-public-ip-address", usage = "Public IP Address to announce dataset result distribution listener (default: same as -result-ip-address)", required = false)
+    public String resultPublicIPAddress;
 
-    public String getPublicAddress() {
-        return appConfig.getString(Option.PUBLIC_ADDRESS);
-    }
+    @Option(name = "-result-public-port", usage = "Public IP port to announce dataset result distribution listener (default: same as -result-port; must set -result-public-ip-address also)", required = false)
+    public int resultPublicPort = 0;
 
-    public void setPublicAddress(String publicAddress) {
-        configManager.set(nodeId, Option.PUBLIC_ADDRESS, publicAddress);
-    }
+    @Option(name = "-retries", usage ="Number of attempts to contact CC before giving up (default = 5)")
+    public int retries = 5;
 
-    public String getNCServiceAddress() {
-        return appConfig.getString(Option.NCSERVICE_ADDRESS);
-    }
+    @Option(name = "-iodevices", usage = "Comma separated list of IO Device mount points (default: One device in default temp folder)", required = false)
+    public String ioDevices = System.getProperty("java.io.tmpdir");
 
-    public void setNCServiceAddress(String ncserviceAddress) {
-        configManager.set(nodeId, Option.NCSERVICE_ADDRESS, ncserviceAddress);
-    }
+    @Option(name = "-net-thread-count", usage = "Number of threads to use for Network I/O (default: 1)")
+    public int nNetThreads = 1;
 
-    public int getNCServicePort() {
-        return appConfig.getInt(Option.NCSERVICE_PORT);
-    }
+    @Option(name = "-net-buffer-count", usage = "Number of network buffers per input/output channel (default:1)", required = false)
+    public int nNetBuffers = 1;
 
-    public void setNCServicePort(int ncservicePort) {
-        configManager.set(nodeId, Option.NCSERVICE_PORT, ncservicePort);
-    }
+    @Option(name = "-max-memory", usage = "Maximum memory usable at this Node Controller in bytes (default: -1 auto)")
+    public int maxMemory = -1;
 
-    public String getClusterAddress() {
-        return appConfig.getString(Option.CLUSTER_ADDRESS);
-    }
+    @Option(name = "-result-time-to-live", usage = "Limits the amount of time results for asynchronous jobs should be retained by the system in milliseconds. (default: 24 hours)")
+    public long resultTTL = 86400000;
 
-    public void setClusterAddress(String clusterAddress) {
-        configManager.set(nodeId, Option.CLUSTER_ADDRESS, clusterAddress);
-    }
+    @Option(name = "-result-sweep-threshold", usage = "The duration within which an instance of the result cleanup should be invoked in milliseconds. (default: 1 minute)")
+    public long resultSweepThreshold = 60000;
 
-    public int getClusterPort() {
-        return appConfig.getInt(Option.CLUSTER_PORT);
-    }
+    @Option(name = "-result-manager-memory", usage = "Memory usable for result caching at this Node Controller in bytes (default: -1 auto)")
+    public int resultManagerMemory = -1;
 
-    public void setClusterPort(int clusterPort) {
-        configManager.set(nodeId, Option.CLUSTER_PORT, clusterPort);
-    }
+    @Option(name = "-app-nc-main-class", usage = "Application NC Main Class")
+    public String appNCMainClass;
 
-    public String getClusterListenAddress() {
-        return appConfig.getString(Option.CLUSTER_LISTEN_ADDRESS);
-    }
+    @Option(name = "-config-file", usage = "Specify path to local configuration file (default: no local config)", required = false)
+    public String configFile = null;
 
-    public void setClusterListenAddress(String clusterListenAddress) {
-        configManager.set(nodeId, Option.CLUSTER_LISTEN_ADDRESS, clusterListenAddress);
-    }
+    @Argument
+    @Option(name = "--", handler = StopOptionHandler.class)
+    public List<String> appArgs;
 
-    public int getClusterListenPort() {
-        return appConfig.getInt(Option.CLUSTER_LISTEN_PORT);
-    }
+    private transient Ini ini = null;
 
-    public void setClusterListenPort(int clusterListenPort) {
-        configManager.set(nodeId, Option.CLUSTER_LISTEN_PORT, clusterListenPort);
-    }
-
-    public String getClusterPublicAddress() {
-        return appConfig.getString(Option.CLUSTER_PUBLIC_ADDRESS);
-    }
-
-    public void setClusterPublicAddress(String clusterPublicAddress) {
-        configManager.set(nodeId, Option.CLUSTER_PUBLIC_ADDRESS, clusterPublicAddress);
-    }
-
-    public int getClusterPublicPort() {
-        return appConfig.getInt(Option.CLUSTER_PUBLIC_PORT);
-    }
-
-    public void setClusterPublicPort(int clusterPublicPort) {
-        configManager.set(nodeId, Option.CLUSTER_PUBLIC_PORT, clusterPublicPort);
-    }
-
-    public String getNodeId() {
-        return appConfig.getString(Option.NODE_ID);
-    }
+    private void loadINIFile() throws IOException {
+        ini = IniUtils.loadINIFile(configFile);
+        // QQQ This should default to cc/address if cluster.address not set, but
+        // that logic really should be handled by the ini file sent from the CC
+        ccHost = IniUtils.getString(ini, "cc", "cluster.address", ccHost);
+        ccPort = IniUtils.getInt(ini, "cc", "cluster.port", ccPort);
+        nodeId = IniUtils.getString(ini, "localnc", "id", nodeId);
 
-    public void setNodeId(String nodeId) {
-        configManager.set(nodeId, Option.NODE_ID, nodeId);
-    }
+        // Network ports
 
-    public String getDataListenAddress() {
-        return appConfig.getString(Option.DATA_LISTEN_ADDRESS);
-    }
+        ipAddress = IniUtils.getString(ini, "localnc", "address", ipAddress);
 
-    public void setDataListenAddress(String dataListenAddress) {
-        configManager.set(nodeId, Option.DATA_LISTEN_ADDRESS, dataListenAddress);
-    }
+        clusterNetIPAddress = IniUtils.getString(ini, "localnc", "cluster.address", clusterNetIPAddress);
+        clusterNetPort = IniUtils.getInt(ini, "localnc", "cluster.port", clusterNetPort);
+        dataIPAddress = IniUtils.getString(ini, "localnc", "data.address", dataIPAddress);
+        dataPort = IniUtils.getInt(ini, "localnc", "data.port", dataPort);
+        resultIPAddress = IniUtils.getString(ini, "localnc", "result.address", resultIPAddress);
+        resultPort = IniUtils.getInt(ini, "localnc", "result.port", resultPort);
 
-    public int getDataListenPort() {
-        return appConfig.getInt(Option.DATA_LISTEN_PORT);
-    }
+        clusterNetPublicIPAddress = IniUtils.getString(ini, "localnc", "public.cluster.address", clusterNetPublicIPAddress);
+        clusterNetPublicPort = IniUtils.getInt(ini, "localnc", "public.cluster.port", clusterNetPublicPort);
+        dataPublicIPAddress = IniUtils.getString(ini, "localnc", "public.data.address", dataPublicIPAddress);
+        dataPublicPort = IniUtils.getInt(ini, "localnc", "public.data.port", dataPublicPort);
+        resultPublicIPAddress = IniUtils.getString(ini, "localnc", "public.result.address", resultPublicIPAddress);
+        resultPublicPort = IniUtils.getInt(ini, "localnc", "public.result.port", resultPublicPort);
 
-    public void setDataListenPort(int dataListenPort) {
-        configManager.set(nodeId, Option.DATA_LISTEN_PORT, dataListenPort);
-    }
+        retries = IniUtils.getInt(ini, "localnc", "retries", retries);
 
-    public String getDataPublicAddress() {
-        return appConfig.getString(Option.DATA_PUBLIC_ADDRESS);
-    }
-
-    public void setDataPublicAddress(String dataPublicAddress) {
-        configManager.set(nodeId, Option.DATA_PUBLIC_ADDRESS, dataPublicAddress);
-    }
-
-    public int getDataPublicPort() {
-        return appConfig.getInt(Option.DATA_PUBLIC_PORT);
-    }
-
-    public void setDataPublicPort(int dataPublicPort) {
-        configManager.set(nodeId, Option.DATA_PUBLIC_PORT, dataPublicPort);
-    }
-
-    public String getResultListenAddress() {
-        return appConfig.getString(Option.RESULT_LISTEN_ADDRESS);
-    }
-
-    public void setResultListenAddress(String resultListenAddress) {
-        configManager.set(nodeId, Option.RESULT_LISTEN_ADDRESS, resultListenAddress);
-    }
-
-    public int getResultListenPort() {
-        return appConfig.getInt(Option.RESULT_LISTEN_PORT);
-    }
-
-    public void setResultListenPort(int resultListenPort) {
-        configManager.set(nodeId, Option.RESULT_LISTEN_PORT, resultListenPort);
-    }
+        // Directories
+        ioDevices = IniUtils.getString(ini, "localnc", "iodevices", ioDevices);
 
-    public String getResultPublicAddress() {
-        return appConfig.getString(Option.RESULT_PUBLIC_ADDRESS);
+        // Hyracks client entrypoint
+        appNCMainClass = IniUtils.getString(ini, "localnc", "app.class", appNCMainClass);
     }
 
-    public void setResultPublicAddress(String resultPublicAddress) {
-        configManager.set(nodeId, Option.RESULT_PUBLIC_ADDRESS, resultPublicAddress);
-    }
-
-    public int getResultPublicPort() {
-        return appConfig.getInt(Option.RESULT_PUBLIC_PORT);
-    }
-
-    public void setResultPublicPort(int resultPublicPort) {
-        configManager.set(nodeId, Option.RESULT_PUBLIC_PORT, resultPublicPort);
-    }
-
-    public String getMessagingListenAddress() {
-        return appConfig.getString(Option.MESSAGING_LISTEN_ADDRESS);
-    }
-
-    public void setMessagingListenAddress(String messagingListenAddress) {
-        configManager.set(nodeId, Option.MESSAGING_LISTEN_ADDRESS, messagingListenAddress);
-    }
-
-    public int getMessagingListenPort() {
-        return appConfig.getInt(Option.MESSAGING_LISTEN_PORT);
-    }
-
-    public void setMessagingListenPort(int messagingListenPort) {
-        configManager.set(nodeId, Option.MESSAGING_LISTEN_PORT, messagingListenPort);
-    }
-
-    public String getMessagingPublicAddress() {
-        return appConfig.getString(Option.MESSAGING_PUBLIC_ADDRESS);
-    }
-
-    public void setMessagingPublicAddress(String messagingPublicAddress) {
-        configManager.set(nodeId, Option.MESSAGING_PUBLIC_ADDRESS, messagingPublicAddress);
-    }
-
-    public int getMessagingPublicPort() {
-        return appConfig.getInt(Option.MESSAGING_PUBLIC_PORT);
-    }
-
-    public void setMessagingPublicPort(int messagingPublicPort) {
-        configManager.set(nodeId, Option.MESSAGING_PUBLIC_PORT, messagingPublicPort);
-    }
-
-    public int getClusterConnectRetries() {
-        return appConfig.getInt(Option.CLUSTER_CONNECT_RETRIES);
-    }
-
-    public void setClusterConnectRetries(int clusterConnectRetries) {
-        configManager.set(nodeId, Option.CLUSTER_CONNECT_RETRIES, clusterConnectRetries);
-    }
-
-    public String[] getIODevices() {
-        return appConfig.getStringArray(Option.IODEVICES);
-    }
-
-    public void setIODevices(String[] iodevices) {
-        configManager.set(nodeId, Option.IODEVICES, iodevices);
-    }
-
-    public int getNetThreadCount() {
-        return appConfig.getInt(Option.NET_THREAD_COUNT);
-    }
-
-    public void setNetThreadCount(int netThreadCount) {
-        configManager.set(nodeId, Option.NET_THREAD_COUNT, netThreadCount);
-    }
-
-    public int getNetBufferCount() {
-        return appConfig.getInt(Option.NET_BUFFER_COUNT);
-    }
-
-    public void setNetBufferCount(int netBufferCount) {
-        configManager.set(nodeId, Option.NET_BUFFER_COUNT, netBufferCount);
-    }
-
-    public long getResultTTL() {
-        return appConfig.getLong(Option.RESULT_TTL);
-    }
-
-    public void setResultTTL(long resultTTL) {
-        configManager.set(nodeId, Option.RESULT_TTL, resultTTL);
-    }
-
-    public long getResultSweepThreshold() {
-        return appConfig.getLong(Option.RESULT_SWEEP_THRESHOLD);
-    }
-
-    public void setResultSweepThreshold(long resultSweepThreshold) {
-        configManager.set(nodeId, Option.RESULT_SWEEP_THRESHOLD, resultSweepThreshold);
-    }
-
-    public int getResultManagerMemory() {
-        return appConfig.getInt(Option.RESULT_MANAGER_MEMORY);
-    }
-
-    public void setResultManagerMemory(int resultManagerMemory) {
-        configManager.set(nodeId, Option.RESULT_MANAGER_MEMORY, resultManagerMemory);
-    }
-
-    public String getAppClass() {
-        return appConfig.getString(Option.APP_CLASS);
-    }
-
-    public void setAppClass(String appClass) {
-        configManager.set(nodeId, Option.APP_CLASS, appClass);
-    }
-
-    public int getNCServicePid() {
-        return appConfig.getInt(Option.NCSERVICE_PID);
-    }
+    /*
+     * Once all @Option fields have been loaded from command-line or otherwise
+     * specified programmatically, call this method to:
+     * 1. Load options from a config file (as specified by -config-file)
+     * 2. Set default values for certain derived values, such as setting
+     *    clusterNetIpAddress to ipAddress
+     */
+    public void loadConfigAndApplyDefaults() throws IOException {
+        if (configFile != null) {
+            loadINIFile();
+        }
 
-    public void setNCServicePid(int ncservicePid) {
-        configManager.set(nodeId, Option.NCSERVICE_PID, ncservicePid);
+        // "address" is the default for all IP addresses
+        if (clusterNetIPAddress == null) clusterNetIPAddress = ipAddress;
+        if (dataIPAddress == null) dataIPAddress = ipAddress;
+        if (resultIPAddress == null) resultIPAddress = ipAddress;
+
+        // All "public" options default to their "non-public" versions
+        if (clusterNetPublicIPAddress == null) clusterNetPublicIPAddress = clusterNetIPAddress;
+        if (clusterNetPublicPort == 0) clusterNetPublicPort = clusterNetPort;
+        if (dataPublicIPAddress == null) dataPublicIPAddress = dataIPAddress;
+        if (dataPublicPort == 0) dataPublicPort = dataPort;
+        if (resultPublicIPAddress == null) resultPublicIPAddress = resultIPAddress;
+        if (resultPublicPort == 0) resultPublicPort = resultPort;
+    }
+
+    /**
+     * @return An IApplicationConfig representing this NCConfig.
+     * Note: Currently this only includes the values from the configuration
+     * file, not anything specified on the command-line. QQQ
+     */
+    public IApplicationConfig getAppConfig() {
+        return new IniApplicationConfig(ini);
+    }
+
+    public void toCommandLine(List<String> cList) {
+        cList.add("-cc-host");
+        cList.add(ccHost);
+        cList.add("-cc-port");
+        cList.add(String.valueOf(ccPort));
+        cList.add("-cluster-net-ip-address");
+        cList.add(clusterNetIPAddress);
+        cList.add("-cluster-net-port");
+        cList.add(String.valueOf(clusterNetPort));
+        cList.add("-cluster-net-public-ip-address");
+        cList.add(clusterNetPublicIPAddress);
+        cList.add("-cluster-net-public-port");
+        cList.add(String.valueOf(clusterNetPublicPort));
+        cList.add("-node-id");
+        cList.add(nodeId);
+        cList.add("-data-ip-address");
+        cList.add(dataIPAddress);
+        cList.add("-data-port");
+        cList.add(String.valueOf(dataPort));
+        cList.add("-data-public-ip-address");
+        cList.add(dataPublicIPAddress);
+        cList.add("-data-public-port");
+        cList.add(String.valueOf(dataPublicPort));
+        cList.add("-result-ip-address");
+        cList.add(resultIPAddress);
+        cList.add("-result-port");
+        cList.add(String.valueOf(resultPort));
+        cList.add("-result-public-ip-address");
+        cList.add(resultPublicIPAddress);
+        cList.add("-result-public-port");
+        cList.add(String.valueOf(resultPublicPort));
+        cList.add("-retries");
+        cList.add(String.valueOf(retries));
+        cList.add("-iodevices");
+        cList.add(ioDevices);
+        cList.add("-net-thread-count");
+        cList.add(String.valueOf(nNetThreads));
+        cList.add("-net-buffer-count");
+        cList.add(String.valueOf(nNetBuffers));
+        cList.add("-max-memory");
+        cList.add(String.valueOf(maxMemory));
+        cList.add("-result-time-to-live");
+        cList.add(String.valueOf(resultTTL));
+        cList.add("-result-sweep-threshold");
+        cList.add(String.valueOf(resultSweepThreshold));
+        cList.add("-result-manager-memory");
+        cList.add(String.valueOf(resultManagerMemory));
+
+        if (appNCMainClass != null) {
+            cList.add("-app-nc-main-class");
+            cList.add(appNCMainClass);
+        }
+        if (appArgs != null && !appArgs.isEmpty()) {
+            cList.add("--");
+            for (String appArg : appArgs) {
+                cList.add(appArg);
+            }
+        }
     }
 
-    public boolean getVirtualNC() {
-        return appConfig.getBoolean(Option.VIRTUAL_NC);
-    }
+    public void toMap(Map<String, String> configuration) {
+        configuration.put("cc-host", ccHost);
+        configuration.put("cc-port", (String.valueOf(ccPort)));
+        configuration.put("cluster-net-ip-address", clusterNetIPAddress);
+        configuration.put("cluster-net-port", String.valueOf(clusterNetPort));
+        configuration.put("cluster-net-public-ip-address", clusterNetPublicIPAddress);
+        configuration.put("cluster-net-public-port", String.valueOf(clusterNetPublicPort));
+        configuration.put("node-id", nodeId);
+        configuration.put("data-ip-address", dataIPAddress);
+        configuration.put("data-port", String.valueOf(dataPort));
+        configuration.put("data-public-ip-address", dataPublicIPAddress);
+        configuration.put("data-public-port", String.valueOf(dataPublicPort));
+        configuration.put("result-ip-address", resultIPAddress);
+        configuration.put("result-port", String.valueOf(resultPort));
+        configuration.put("result-public-ip-address", resultPublicIPAddress);
+        configuration.put("result-public-port", String.valueOf(resultPublicPort));
+        configuration.put("retries", String.valueOf(retries));
+        configuration.put("iodevices", ioDevices);
+        configuration.put("net-thread-count", String.valueOf(nNetThreads));
+        configuration.put("net-buffer-count", String.valueOf(nNetBuffers));
+        configuration.put("max-memory", String.valueOf(maxMemory));
+        configuration.put("result-time-to-live", String.valueOf(resultTTL));
+        configuration.put("result-sweep-threshold", String.valueOf(resultSweepThreshold));
+        configuration.put("result-manager-memory", String.valueOf(resultManagerMemory));
+
+        if (appNCMainClass != null) {
+            configuration.put("app-nc-main-class", appNCMainClass);
+        }
 
-    public void setVirtualNC(boolean virtualNC) {
-        configManager.set(nodeId, Option.VIRTUAL_NC, virtualNC);
     }
 }