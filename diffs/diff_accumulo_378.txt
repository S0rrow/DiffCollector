diff --git a/server/tracer/src/main/java/org/apache/accumulo/tracer/TraceServer.java b/server/tracer/src/main/java/org/apache/accumulo/tracer/TraceServer.java
index 2fe9a27f11..d200e7bcce 100644
--- a/server/tracer/src/main/java/org/apache/accumulo/tracer/TraceServer.java
+++ b/server/tracer/src/main/java/org/apache/accumulo/tracer/TraceServer.java
@@ -16,33 +16,25 @@
  */
 package org.apache.accumulo.tracer;
 
-import static com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly;
 import static java.nio.charset.StandardCharsets.UTF_8;
 
 import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.net.ServerSocket;
 import java.nio.channels.ServerSocketChannel;
-import java.util.Arrays;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
 
-import org.apache.accumulo.core.Constants;
-import org.apache.accumulo.core.client.AccumuloException;
-import org.apache.accumulo.core.client.AccumuloSecurityException;
 import org.apache.accumulo.core.client.BatchWriter;
 import org.apache.accumulo.core.client.BatchWriterConfig;
 import org.apache.accumulo.core.client.Connector;
 import org.apache.accumulo.core.client.Instance;
 import org.apache.accumulo.core.client.IteratorSetting;
 import org.apache.accumulo.core.client.MutationsRejectedException;
-import org.apache.accumulo.core.client.TableExistsException;
-import org.apache.accumulo.core.client.TableNotFoundException;
 import org.apache.accumulo.core.client.security.tokens.AuthenticationToken;
 import org.apache.accumulo.core.client.security.tokens.AuthenticationToken.Properties;
-import org.apache.accumulo.core.client.security.tokens.KerberosToken;
 import org.apache.accumulo.core.client.security.tokens.PasswordToken;
 import org.apache.accumulo.core.conf.AccumuloConfiguration;
 import org.apache.accumulo.core.conf.Property;
@@ -66,6 +58,7 @@ import org.apache.accumulo.tracer.thrift.RemoteSpan;
 import org.apache.accumulo.tracer.thrift.SpanReceiver.Iface;
 import org.apache.accumulo.tracer.thrift.SpanReceiver.Processor;
 import org.apache.hadoop.io.Text;
+import org.apache.hadoop.security.UserGroupInformation;
 import org.apache.htrace.Span;
 import org.apache.thrift.TByteArrayOutputStream;
 import org.apache.thrift.TException;
@@ -83,6 +76,8 @@ import org.apache.zookeeper.Watcher.Event.KeeperState;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static com.google.common.util.concurrent.Uninterruptibles.sleepUninterruptibly;
+
 public class TraceServer implements Watcher {
 
   final private static Logger log = LoggerFactory.getLogger(TraceServer.class);
@@ -90,7 +85,7 @@ public class TraceServer implements Watcher {
   final private TServer server;
   final private AtomicReference<BatchWriter> writer;
   final private Connector connector;
-  final String tableName;
+  final String table;
   final private static int BATCH_WRITER_MAX_LATENCY = 5;
   final private static long SCHEDULE_PERIOD = 1000;
   final private static long SCHEDULE_DELAY = 1000;
@@ -183,52 +178,8 @@ public class TraceServer implements Watcher {
 
   public TraceServer(ServerConfigurationFactory serverConfiguration, String hostname) throws Exception {
     this.serverConfiguration = serverConfiguration;
-    log.info("Version " + Constants.VERSION);
-    log.info("Instance " + serverConfiguration.getInstance().getInstanceID());
     AccumuloConfiguration conf = serverConfiguration.getConfiguration();
-    tableName = conf.get(Property.TRACE_TABLE);
-    connector = ensureTraceTableExists(conf);
-
-    int ports[] = conf.getPort(Property.TRACE_PORT);
-    ServerSocket sock = null;
-    for (int port : ports) {
-      ServerSocket s = ServerSocketChannel.open().socket();
-      s.setReuseAddress(true);
-      try {
-        s.bind(new InetSocketAddress(hostname, port));
-        sock = s;
-        break;
-      } catch (Exception e) {
-        log.warn("Unable to start trace server on port {}", port);
-      }
-    }
-    if (null == sock) {
-      throw new RuntimeException("Unable to start trace server on configured ports: " + Arrays.toString(ports));
-    }
-    final TServerTransport transport = new TServerSocket(sock);
-    TThreadPoolServer.Args options = new TThreadPoolServer.Args(transport);
-    options.processor(new Processor<Iface>(new Receiver()));
-    server = new TThreadPoolServer(options);
-    registerInZooKeeper(sock.getInetAddress().getHostAddress() + ":" + sock.getLocalPort(), conf.get(Property.TRACE_ZK_PATH));
-    writer = new AtomicReference<>(this.connector.createBatchWriter(tableName,
-        new BatchWriterConfig().setMaxLatency(BATCH_WRITER_MAX_LATENCY, TimeUnit.SECONDS)));
-  }
-
-  /**
-   * Exceptions thrown out of here should be things that cause service failure (e.g. misconfigurations that aren't likely to change on retry).
-   *
-   * @return a working Connection that can be reused
-   * @throws ClassNotFoundException
-   *           if TRACE_TOKEN_TYPE is set to a class that we can't load.
-   * @throws InstantiationException
-   *           if we fail to create an instance of TRACE_TOKEN_TYPE.
-   * @throws IllegalAccessException
-   *           if the class pointed to by TRACE_TOKEN_TYPE is private.
-   * @throws AccumuloSecurityException
-   *           if the trace user has the wrong permissions
-   */
-  private Connector ensureTraceTableExists(final AccumuloConfiguration conf) throws AccumuloSecurityException, ClassNotFoundException, InstantiationException,
-      IllegalAccessException {
+    table = conf.get(Property.TRACE_TABLE);
     Connector connector = null;
     while (true) {
       try {
@@ -260,20 +211,34 @@ public class TraceServer implements Watcher {
         }
 
         connector = serverConfiguration.getInstance().getConnector(principal, at);
-        if (!connector.tableOperations().exists(tableName)) {
-          connector.tableOperations().create(tableName);
+        if (!connector.tableOperations().exists(table)) {
+          connector.tableOperations().create(table);
           IteratorSetting setting = new IteratorSetting(10, "ageoff", AgeOffFilter.class.getName());
           AgeOffFilter.setTTL(setting, 7 * 24 * 60 * 60 * 1000l);
-          connector.tableOperations().attachIterator(tableName, setting);
+          connector.tableOperations().attachIterator(table, setting);
         }
-        connector.tableOperations().setProperty(tableName, Property.TABLE_FORMATTER_CLASS.getKey(), TraceFormatter.class.getName());
+        connector.tableOperations().setProperty(table, Property.TABLE_FORMATTER_CLASS.getKey(), TraceFormatter.class.getName());
         break;
-      } catch (AccumuloException | TableExistsException | TableNotFoundException | IOException | RuntimeException ex) {
+      } catch (RuntimeException ex) {
         log.info("Waiting to checking/create the trace table.", ex);
         sleepUninterruptibly(1, TimeUnit.SECONDS);
       }
     }
-    return connector;
+    this.connector = connector;
+    // make sure we refer to the final variable from now on.
+    connector = null;
+
+    int port = conf.getPort(Property.TRACE_PORT);
+    final ServerSocket sock = ServerSocketChannel.open().socket();
+    sock.setReuseAddress(true);
+    sock.bind(new InetSocketAddress(hostname, port));
+    final TServerTransport transport = new TServerSocket(sock);
+    TThreadPoolServer.Args options = new TThreadPoolServer.Args(transport);
+    options.processor(new Processor<Iface>(new Receiver()));
+    server = new TThreadPoolServer(options);
+    registerInZooKeeper(sock.getInetAddress().getHostAddress() + ":" + sock.getLocalPort(), conf.get(Property.TRACE_ZK_PATH));
+    writer = new AtomicReference<BatchWriter>(this.connector.createBatchWriter(table,
+        new BatchWriterConfig().setMaxLatency(BATCH_WRITER_MAX_LATENCY, TimeUnit.SECONDS)));
   }
 
   public void run() throws Exception {
@@ -293,7 +258,7 @@ public class TraceServer implements Watcher {
         writer.flush();
       } else {
         // We don't have a writer. If the table exists, try to make a new writer.
-        if (connector.tableOperations().exists(tableName)) {
+        if (connector.tableOperations().exists(table)) {
           resetWriter();
         }
       }
@@ -312,7 +277,7 @@ public class TraceServer implements Watcher {
   private void resetWriter() {
     BatchWriter writer = null;
     try {
-      writer = connector.createBatchWriter(tableName, new BatchWriterConfig().setMaxLatency(BATCH_WRITER_MAX_LATENCY, TimeUnit.SECONDS));
+      writer = connector.createBatchWriter(table, new BatchWriterConfig().setMaxLatency(BATCH_WRITER_MAX_LATENCY, TimeUnit.SECONDS));
     } catch (Exception ex) {
       log.warn("Unable to create a batch writer, will retry. Set log level to DEBUG to see stacktrace. cause: " + ex);
       log.debug("batch writer creation failed with exception.", ex);
@@ -339,48 +304,38 @@ public class TraceServer implements Watcher {
   }
 
   private static void loginTracer(AccumuloConfiguration acuConf) {
-    try {
-      Class<? extends AuthenticationToken> traceTokenType = AccumuloVFSClassLoader.getClassLoader().loadClass(acuConf.get(Property.TRACE_TOKEN_TYPE))
-          .asSubclass(AuthenticationToken.class);
-
-      if (!(KerberosToken.class.isAssignableFrom(traceTokenType))) {
-        // We're not using Kerberos to talk to Accumulo, but we might still need it for talking to HDFS/ZK for
-        // instance information.
-        log.info("Handling login under the assumption that Accumulo users are not using Kerberos.");
-        SecurityUtil.serverLogin(acuConf);
-      } else {
-        // We're using Kerberos to talk to Accumulo, so check for trace user specific auth details.
-        // We presume this same user will have the needed access for the service to interact with HDFS/ZK for
-        // instance information.
-        log.info("Handling login under the assumption that Accumulo users are using Kerberos.");
-        Map<String,String> loginMap = acuConf.getAllPropertiesWithPrefix(Property.TRACE_TOKEN_PROPERTY_PREFIX);
-        String keyTab = loginMap.get(Property.TRACE_TOKEN_PROPERTY_PREFIX.getKey() + "keytab");
-        if (keyTab == null || keyTab.length() == 0) {
-          keyTab = acuConf.getPath(Property.GENERAL_KERBEROS_KEYTAB);
-        }
-        if (keyTab == null || keyTab.length() == 0)
-          return;
+    Map<String,String> loginMap = acuConf.getAllPropertiesWithPrefix(Property.TRACE_TOKEN_PROPERTY_PREFIX);
+    String keyTab = loginMap.get(Property.TRACE_TOKEN_PROPERTY_PREFIX.getKey() + "keytab");
+    if (keyTab == null || keyTab.length() == 0) {
+      keyTab = acuConf.getPath(Property.GENERAL_KERBEROS_KEYTAB);
+    }
+    if (keyTab == null || keyTab.length() == 0)
+      return;
 
-        String principalConfig = acuConf.get(Property.TRACE_USER);
-        if (principalConfig == null || principalConfig.length() == 0)
-          return;
+    String principalConfig = acuConf.get(Property.TRACE_USER);
+    if (principalConfig == null || principalConfig.length() == 0)
+      return;
 
-        log.info("Attempting to login as {} with {}", principalConfig, keyTab);
-        SecurityUtil.serverLogin(acuConf, keyTab, principalConfig);
+    log.info("Attempting to login as {} with {}", principalConfig, keyTab);
+    if (SecurityUtil.login(principalConfig, keyTab)) {
+      try {
+        // This spawns a thread to periodically renew the logged in (trace) user
+        UserGroupInformation.getLoginUser();
+        return;
+      } catch (IOException io) {
+        log.error("Error starting up renewal thread. This shouldn't be happening.", io);
       }
-    } catch (IOException | ClassNotFoundException exception) {
-      final String msg = String.format("Failed to retrieve trace user token information based on property %1s.", Property.TRACE_TOKEN_TYPE);
-      log.error(msg, exception);
-      throw new RuntimeException(msg, exception);
     }
+
+    throw new RuntimeException("Failed to perform Kerberos login for " + principalConfig + " using  " + keyTab);
   }
 
   public static void main(String[] args) throws Exception {
-    final String app = "tracer";
-    Accumulo.setupLogging(app);
     loginTracer(SiteConfiguration.getInstance());
     ServerOpts opts = new ServerOpts();
+    final String app = "tracer";
     opts.parseArgs(app, args);
+    Accumulo.setupLogging(app);
     Instance instance = HdfsZooInstance.getInstance();
     ServerConfigurationFactory conf = new ServerConfigurationFactory(instance);
     VolumeManager fs = VolumeManagerImpl.get();