diff --git a/repository/src/main/java/org/apache/atlas/services/DefaultMetadataService.java b/repository/src/main/java/org/apache/atlas/services/DefaultMetadataService.java
index db61de935..03717820a 100755
--- a/repository/src/main/java/org/apache/atlas/services/DefaultMetadataService.java
+++ b/repository/src/main/java/org/apache/atlas/services/DefaultMetadataService.java
@@ -21,17 +21,16 @@ package org.apache.atlas.services;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.inject.Provider;
-import org.apache.atlas.AtlasClient;
 import org.apache.atlas.AtlasException;
+import org.apache.atlas.AtlasClient;
 import org.apache.atlas.ParamChecker;
 import org.apache.atlas.TypeNotFoundException;
 import org.apache.atlas.classification.InterfaceAudience;
+import org.apache.atlas.discovery.SearchIndexer;
 import org.apache.atlas.listener.EntityChangeListener;
-import org.apache.atlas.listener.TypesChangeListener;
 import org.apache.atlas.repository.IndexCreationException;
 import org.apache.atlas.repository.MetadataRepository;
 import org.apache.atlas.repository.typestore.ITypeStore;
-import org.apache.atlas.typesystem.IStruct;
 import org.apache.atlas.typesystem.ITypedReferenceableInstance;
 import org.apache.atlas.typesystem.ITypedStruct;
 import org.apache.atlas.typesystem.Referenceable;
@@ -40,7 +39,6 @@ import org.apache.atlas.typesystem.TypesDef;
 import org.apache.atlas.typesystem.json.InstanceSerialization;
 import org.apache.atlas.typesystem.json.TypesSerialization;
 import org.apache.atlas.typesystem.types.AttributeDefinition;
-import org.apache.atlas.typesystem.types.AttributeInfo;
 import org.apache.atlas.typesystem.types.ClassType;
 import org.apache.atlas.typesystem.types.DataTypes;
 import org.apache.atlas.typesystem.types.EnumTypeDefinition;
@@ -50,20 +48,16 @@ import org.apache.atlas.typesystem.types.Multiplicity;
 import org.apache.atlas.typesystem.types.StructTypeDefinition;
 import org.apache.atlas.typesystem.types.TraitType;
 import org.apache.atlas.typesystem.types.TypeSystem;
-import org.apache.atlas.typesystem.types.ValueConversionException;
+import org.apache.atlas.typesystem.types.TypeUtils;
 import org.apache.atlas.typesystem.types.utils.TypesUtil;
-import org.codehaus.jettison.json.JSONArray;
 import org.codehaus.jettison.json.JSONException;
 import org.codehaus.jettison.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import scala.actors.threadpool.Arrays;
 
 import javax.inject.Inject;
 import javax.inject.Singleton;
-import java.util.Collection;
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -76,24 +70,26 @@ import java.util.Set;
 @Singleton
 public class DefaultMetadataService implements MetadataService {
 
-    private static final Logger LOG = LoggerFactory.getLogger(DefaultMetadataService.class);
+    private static final Logger LOG =
+            LoggerFactory.getLogger(DefaultMetadataService.class);
 
-    private final Collection<EntityChangeListener> entityChangeListeners = new LinkedHashSet<>();
+    private final Set<EntityChangeListener> entityChangeListeners
+            = new LinkedHashSet<>();
 
     private final TypeSystem typeSystem;
     private final MetadataRepository repository;
     private final ITypeStore typeStore;
-    private final Collection<Provider<TypesChangeListener>> typeChangeListeners;
+    private final Set<Provider<SearchIndexer>> typeChangeListeners;
 
     @Inject
-    DefaultMetadataService(final MetadataRepository repository, final ITypeStore typeStore,
-        final Collection<Provider<TypesChangeListener>> typeChangeListeners) throws AtlasException {
-
+    DefaultMetadataService(final MetadataRepository repository,
+                           final Provider<SearchIndexer> searchIndexProvider, final ITypeStore typeStore) throws
+    AtlasException {
         this.typeStore = typeStore;
         this.typeSystem = TypeSystem.getInstance();
         this.repository = repository;
 
-        this.typeChangeListeners = typeChangeListeners;
+        this.typeChangeListeners = new LinkedHashSet<Provider<SearchIndexer>>() {{ add(searchIndexProvider); }};
         restoreTypeSystem();
     }
 
@@ -113,45 +109,39 @@ public class DefaultMetadataService implements MetadataService {
     }
 
     private static final AttributeDefinition NAME_ATTRIBUTE =
-            TypesUtil.createUniqueRequiredAttrDef("name", DataTypes.STRING_TYPE);
+            TypesUtil.createRequiredAttrDef("name", DataTypes.STRING_TYPE);
     private static final AttributeDefinition DESCRIPTION_ATTRIBUTE =
             TypesUtil.createOptionalAttrDef("description", DataTypes.STRING_TYPE);
 
     @InterfaceAudience.Private
     private void createSuperTypes() throws AtlasException {
-        HierarchicalTypeDefinition<ClassType> infraType = TypesUtil
-                .createClassTypeDef(AtlasClient.INFRASTRUCTURE_SUPER_TYPE, ImmutableList.<String>of(), NAME_ATTRIBUTE,
-                        DESCRIPTION_ATTRIBUTE);
-        createType(infraType);
+        if (typeSystem.isRegistered(AtlasClient.DATA_SET_SUPER_TYPE)) {
+            return; // this is already registered
+        }
+
+        HierarchicalTypeDefinition<ClassType> infraType =
+                TypesUtil.createClassTypeDef(AtlasClient.INFRASTRUCTURE_SUPER_TYPE,
+                        ImmutableList.<String>of(), NAME_ATTRIBUTE, DESCRIPTION_ATTRIBUTE);
 
         HierarchicalTypeDefinition<ClassType> datasetType = TypesUtil
-                .createClassTypeDef(AtlasClient.DATA_SET_SUPER_TYPE, ImmutableList.<String>of(), NAME_ATTRIBUTE,
-                        DESCRIPTION_ATTRIBUTE);
-        createType(datasetType);
+                .createClassTypeDef(AtlasClient.DATA_SET_SUPER_TYPE,
+                        ImmutableList.<String>of(),
+                        NAME_ATTRIBUTE, DESCRIPTION_ATTRIBUTE);
 
         HierarchicalTypeDefinition<ClassType> processType = TypesUtil
-                .createClassTypeDef(AtlasClient.PROCESS_SUPER_TYPE, ImmutableList.<String>of(), NAME_ATTRIBUTE,
-                        DESCRIPTION_ATTRIBUTE,
-                        new AttributeDefinition("inputs", DataTypes.arrayTypeName(AtlasClient.DATA_SET_SUPER_TYPE),
+                .createClassTypeDef(AtlasClient.PROCESS_SUPER_TYPE, ImmutableList.<String>of(),
+                        NAME_ATTRIBUTE, DESCRIPTION_ATTRIBUTE, new AttributeDefinition("inputs",
+                                DataTypes.arrayTypeName(AtlasClient.DATA_SET_SUPER_TYPE),
                                 Multiplicity.OPTIONAL, false, null),
-                        new AttributeDefinition("outputs", DataTypes.arrayTypeName(AtlasClient.DATA_SET_SUPER_TYPE),
+                        new AttributeDefinition("outputs",
+                                DataTypes.arrayTypeName(AtlasClient.DATA_SET_SUPER_TYPE),
                                 Multiplicity.OPTIONAL, false, null));
-        createType(processType);
 
-        HierarchicalTypeDefinition<ClassType> referenceableType = TypesUtil
-                .createClassTypeDef(AtlasClient.REFERENCEABLE_SUPER_TYPE, ImmutableList.<String>of(),
-                        TypesUtil.createUniqueRequiredAttrDef(AtlasClient.REFERENCEABLE_ATTRIBUTE_NAME,
-                                DataTypes.STRING_TYPE));
-        createType(referenceableType);
-    }
-
-    private void createType(HierarchicalTypeDefinition<ClassType> type) throws AtlasException {
-        if (!typeSystem.isRegistered(type.typeName)) {
-            TypesDef typesDef = TypesUtil.getTypesDef(ImmutableList.<EnumTypeDefinition>of(), ImmutableList.<StructTypeDefinition>of(),
-                            ImmutableList.<HierarchicalTypeDefinition<TraitType>>of(),
-                            ImmutableList.of(type));
-            createType(TypesSerialization.toJson(typesDef));
-        }
+        TypesDef typesDef = TypeUtils
+                .getTypesDef(ImmutableList.<EnumTypeDefinition>of(), ImmutableList.<StructTypeDefinition>of(),
+                        ImmutableList.<HierarchicalTypeDefinition<TraitType>>of(),
+                        ImmutableList.of(infraType, datasetType, processType));
+        createType(TypesSerialization.toJson(typesDef));
     }
 
     /**
@@ -164,44 +154,26 @@ public class DefaultMetadataService implements MetadataService {
     @Override
     public JSONObject createType(String typeDefinition) throws AtlasException {
         ParamChecker.notEmpty(typeDefinition, "type definition cannot be empty");
-        TypesDef typesDef = validateTypeDefinition(typeDefinition);
 
+        TypesDef typesDef;
         try {
-            final Map<String, IDataType> typesAdded = typeSystem.defineTypes(typesDef);
-
-            try {
-                /* Create indexes first so that if index creation fails then we rollback
-                   the typesystem and also do not persist the graph
-                 */
-                onTypesAdded(typesAdded);
-                typeStore.store(typeSystem, ImmutableList.copyOf(typesAdded.keySet()));
-            } catch (Throwable t) {
-                typeSystem.removeTypes(typesAdded.keySet());
-                throw new AtlasException("Unable to persist types ", t);
+            typesDef = TypesSerialization.fromJson(typeDefinition);
+            if (typesDef.isEmpty()) {
+                throw new AtlasException("Invalid type definition");
             }
-
-            return new JSONObject() {{
-                put(AtlasClient.TYPES, typesAdded.keySet());
-            }};
-        } catch (JSONException e) {
-            LOG.error("Unable to create response for types={}", typeDefinition, e);
-            throw new AtlasException("Unable to create response ", e);
+        } catch (Exception e) {
+            LOG.error("Unable to deserialize json={}", typeDefinition, e);
+            throw new IllegalArgumentException("Unable to deserialize json ", e);
         }
-    }
-
-    @Override
-    public JSONObject updateType(String typeDefinition) throws AtlasException {
-        ParamChecker.notEmpty(typeDefinition, "type definition cannot be empty");
-        TypesDef typesDef = validateTypeDefinition(typeDefinition);
 
         try {
-            final Map<String, IDataType> typesAdded = typeSystem.updateTypes(typesDef);
+            final Map<String, IDataType> typesAdded = typeSystem.defineTypes(typesDef);
 
             try {
                 /* Create indexes first so that if index creation fails then we rollback
                    the typesystem and also do not persist the graph
                  */
-                onTypesUpdated(typesAdded);
+                onTypesAddedToRepo(typesAdded);
                 typeStore.store(typeSystem, ImmutableList.copyOf(typesAdded.keySet()));
             } catch (Throwable t) {
                 typeSystem.removeTypes(typesAdded.keySet());
@@ -217,19 +189,6 @@ public class DefaultMetadataService implements MetadataService {
         }
     }
 
-    private TypesDef validateTypeDefinition(String typeDefinition) {
-        try {
-            TypesDef typesDef = TypesSerialization.fromJson(typeDefinition);
-            if (typesDef.isEmpty()) {
-                throw new IllegalArgumentException("Invalid type definition");
-            }
-            return typesDef;
-        } catch (Exception e) {
-            LOG.error("Unable to deserialize json={}", typeDefinition, e);
-            throw new IllegalArgumentException("Unable to deserialize json " + typeDefinition, e);
-        }
-    }
-
     /**
      * Return the definition for the given type.
      *
@@ -265,50 +224,38 @@ public class DefaultMetadataService implements MetadataService {
     /**
      * Creates an entity, instance of the type.
      *
-     * @param entityInstanceDefinition json array of entity definitions
-     * @return guids - json array of guids
+     * @param entityInstanceDefinition definition
+     * @return guid
      */
     @Override
-    public String createEntities(String entityInstanceDefinition) throws AtlasException {
+    public String createEntity(String entityInstanceDefinition) throws AtlasException {
         ParamChecker.notEmpty(entityInstanceDefinition, "Entity instance definition cannot be empty");
 
-        ITypedReferenceableInstance[] typedInstances = deserializeClassInstances(entityInstanceDefinition);
-
-        final String[] guids = repository.createEntities(typedInstances);
-
-        Set<ITypedReferenceableInstance> entitites = new HashSet<>();
+        ITypedReferenceableInstance entityTypedInstance =
+                deserializeClassInstance(entityInstanceDefinition);
 
-        for (String guid : guids) {
-            entitites.add(repository.getEntityDefinition(guid));
-        }
-
-        onEntitiesAddedToRepo(entitites);
+        final String guid = repository.createEntity(entityTypedInstance);
 
-        return new JSONArray(Arrays.asList(guids)).toString();
+        onEntityAddedToRepo(entityTypedInstance);
+        return guid;
     }
 
-    private ITypedReferenceableInstance[] deserializeClassInstances(String entityInstanceDefinition)
-    throws AtlasException {
+    private ITypedReferenceableInstance deserializeClassInstance(
+            String entityInstanceDefinition) throws AtlasException {
+
+        final Referenceable entityInstance;
         try {
-            JSONArray referableInstances = new JSONArray(entityInstanceDefinition);
-            ITypedReferenceableInstance[] instances = new ITypedReferenceableInstance[referableInstances.length()];
-            for (int index = 0; index < referableInstances.length(); index++) {
-                Referenceable entityInstance =
-                        InstanceSerialization.fromJsonReferenceable(referableInstances.getString(index), true);
-                final String entityTypeName = entityInstance.getTypeName();
-                ParamChecker.notEmpty(entityTypeName, "Entity type cannot be null");
-
-                ClassType entityType = typeSystem.getDataType(ClassType.class, entityTypeName);
-                ITypedReferenceableInstance typedInstrance = entityType.convert(entityInstance, Multiplicity.REQUIRED);
-                instances[index] = typedInstrance;
-            }
-            return instances;
-        } catch(ValueConversionException e) {
-            throw e;
+            entityInstance = InstanceSerialization.fromJsonReferenceable(
+                    entityInstanceDefinition, true);
         } catch (Exception e) {  // exception from deserializer
             LOG.error("Unable to deserialize json={}", entityInstanceDefinition, e);
             throw new IllegalArgumentException("Unable to deserialize json");
         }
+        final String entityTypeName = entityInstance.getTypeName();
+        ParamChecker.notEmpty(entityTypeName, "Entity type cannot be null");
+
+        ClassType entityType = typeSystem.getDataType(ClassType.class, entityTypeName);
+        return entityType.convert(entityInstance, Multiplicity.REQUIRED);
     }
 
     /**
@@ -325,29 +272,6 @@ public class DefaultMetadataService implements MetadataService {
         return InstanceSerialization.toJson(instance, true);
     }
 
-    @Override
-    public String getEntityDefinition(String entityType, String attribute, String value) throws AtlasException {
-        validateTypeExists(entityType);
-        validateUniqueAttribute(entityType, attribute);
-
-        final ITypedReferenceableInstance instance = repository.getEntityDefinition(entityType, attribute, value);
-        return InstanceSerialization.toJson(instance, true);
-    }
-
-    /**
-     * Validate that attribute is unique attribute
-     * @param entityType     the entity type
-     * @param attributeName  the name of the attribute
-     */
-    private void validateUniqueAttribute(String entityType, String attributeName) throws AtlasException {
-        ClassType type = typeSystem.getDataType(ClassType.class, entityType);
-        AttributeInfo attribute = type.fieldMapping().fields.get(attributeName);
-        if (!attribute.isUnique) {
-            throw new IllegalArgumentException(
-                    String.format("%s.%s is not a unique attribute", entityType, attributeName));
-        }
-    }
-
     /**
      * Return the list of entity names for the given type in the repository.
      *
@@ -368,16 +292,14 @@ public class DefaultMetadataService implements MetadataService {
         ParamChecker.notEmpty(value, "property value cannot be null");
 
         repository.updateEntity(guid, property, value);
-
-        onEntityUpdated(repository.getEntityDefinition(guid));
     }
 
     private void validateTypeExists(String entityType) throws AtlasException {
         ParamChecker.notEmpty(entityType, "entity type cannot be null");
 
-        IDataType type = typeSystem.getDataType(IDataType.class, entityType);
-        if (type.getTypeCategory() != DataTypes.TypeCategory.CLASS) {
-            throw new IllegalArgumentException("type " + entityType + " not a CLASS type");
+        // verify if the type exists
+        if (!typeSystem.isRegistered(entityType)) {
+            throw new TypeNotFoundException("type is not defined for : " + entityType);
         }
     }
 
@@ -402,7 +324,8 @@ public class DefaultMetadataService implements MetadataService {
      * @throws AtlasException
      */
     @Override
-    public void addTrait(String guid, String traitInstanceDefinition) throws AtlasException {
+    public void addTrait(String guid,
+                         String traitInstanceDefinition) throws AtlasException {
         ParamChecker.notEmpty(guid, "entity GUID cannot be null");
         ParamChecker.notEmpty(traitInstanceDefinition, "Trait instance cannot be null");
 
@@ -410,33 +333,34 @@ public class DefaultMetadataService implements MetadataService {
         final String traitName = traitInstance.getTypeName();
 
         // ensure trait type is already registered with the TS
-        if (!typeSystem.isRegistered(traitName)) {
+        if ( !typeSystem.isRegistered(traitName) ) {
             String msg = String.format("trait=%s should be defined in type system before it can be added", traitName);
             LOG.error(msg);
             throw new TypeNotFoundException(msg);
         }
 
         // ensure trait is not already defined
-        Preconditions
-            .checkArgument(!getTraitNames(guid).contains(traitName), "trait=%s is already defined for entity=%s",
-                traitName, guid);
+        Preconditions.checkArgument(!getTraitNames(guid).contains(traitName),
+                "trait=%s is already defined for entity=%s", traitName, guid);
 
         repository.addTrait(guid, traitInstance);
 
-        onTraitAddedToEntity(repository.getEntityDefinition(guid), traitInstance);
+        onTraitAddedToEntity(guid, traitName);
     }
 
     private ITypedStruct deserializeTraitInstance(String traitInstanceDefinition)
-    throws AtlasException {
+            throws AtlasException {
 
         try {
-            Struct traitInstance = InstanceSerialization.fromJsonStruct(traitInstanceDefinition, true);
+            Struct traitInstance = InstanceSerialization.fromJsonStruct(
+                    traitInstanceDefinition, true);
             final String entityTypeName = traitInstance.getTypeName();
             ParamChecker.notEmpty(entityTypeName, "entity type cannot be null");
 
             TraitType traitType = typeSystem.getDataType(TraitType.class, entityTypeName);
-            return traitType.convert(traitInstance, Multiplicity.REQUIRED);
-        } catch (TypeNotFoundException e) {
+            return traitType.convert(
+                    traitInstance, Multiplicity.REQUIRED);
+        } catch ( TypeNotFoundException e ) {
             throw e;
         } catch (Exception e) {
             throw new AtlasException("Error deserializing trait instance", e);
@@ -451,12 +375,13 @@ public class DefaultMetadataService implements MetadataService {
      * @throws AtlasException
      */
     @Override
-    public void deleteTrait(String guid, String traitNameToBeDeleted) throws AtlasException {
+    public void deleteTrait(String guid,
+                            String traitNameToBeDeleted) throws AtlasException {
         ParamChecker.notEmpty(guid, "entity GUID cannot be null");
         ParamChecker.notEmpty(traitNameToBeDeleted, "Trait name cannot be null");
 
         // ensure trait type is already registered with the TS
-        if (!typeSystem.isRegistered(traitNameToBeDeleted)) {
+        if ( !typeSystem.isRegistered(traitNameToBeDeleted)) {
             final String msg = String.format("trait=%s should be defined in type system before it can be deleted",
                     traitNameToBeDeleted);
             LOG.error(msg);
@@ -465,66 +390,49 @@ public class DefaultMetadataService implements MetadataService {
 
         repository.deleteTrait(guid, traitNameToBeDeleted);
 
-        onTraitDeletedFromEntity(repository.getEntityDefinition(guid), traitNameToBeDeleted);
+        onTraitDeletedFromEntity(guid, traitNameToBeDeleted);
     }
 
-    private void onTypesAdded(Map<String, IDataType> typesAdded) throws AtlasException {
-        Map<TypesChangeListener, Throwable> caughtExceptions = new HashMap<>();
-        for (Provider<TypesChangeListener> indexerProvider : typeChangeListeners) {
-            final TypesChangeListener listener = indexerProvider.get();
+    private void onTypesAddedToRepo(Map<String, IDataType> typesAdded) throws AtlasException {
+        Map<SearchIndexer, Throwable> caughtExceptions = new HashMap<>();
+        for(Provider<SearchIndexer> indexerProvider : typeChangeListeners) {
+            final SearchIndexer indexer = indexerProvider.get();
             try {
-                listener.onAdd(typesAdded.values());
+                for (Map.Entry<String, IDataType> entry : typesAdded.entrySet()) {
+                    indexer.onAdd(entry.getKey(), entry.getValue());
+                }
+                indexer.commit();
             } catch (IndexCreationException ice) {
                 LOG.error("Index creation for listener {} failed ", indexerProvider, ice);
-                caughtExceptions.put(listener, ice);
+                indexer.rollback();
+                caughtExceptions.put(indexer, ice);
             }
         }
 
         if (caughtExceptions.size() > 0) {
-            throw new IndexCreationException("Index creation failed for types " + typesAdded.keySet() + ". Aborting");
+           throw new IndexCreationException("Index creation failed for types " + typesAdded.keySet() + ". Aborting");
         }
     }
 
-    private void onEntitiesAddedToRepo(Collection<ITypedReferenceableInstance> entities) throws AtlasException {
+    private void onEntityAddedToRepo(ITypedReferenceableInstance typedInstance)
+            throws AtlasException {
 
         for (EntityChangeListener listener : entityChangeListeners) {
-            listener.onEntitiesAdded(entities);
+            listener.onEntityAdded(typedInstance);
         }
     }
 
-    private void onTypesUpdated(Map<String, IDataType> typesUpdated) throws AtlasException {
-        Map<TypesChangeListener, Throwable> caughtExceptions = new HashMap<>();
-        for (Provider<TypesChangeListener> indexerProvider : typeChangeListeners) {
-            final TypesChangeListener listener = indexerProvider.get();
-            try {
-                listener.onChange(typesUpdated.values());
-            } catch (IndexCreationException ice) {
-                LOG.error("Index creation for listener {} failed ", indexerProvider, ice);
-                caughtExceptions.put(listener, ice);
-            }
-        }
-
-        if (caughtExceptions.size() > 0) {
-            throw new IndexCreationException("Index creation failed for types " + typesUpdated.keySet() + ". Aborting");
-        }
-    }
-
-    private void onEntityUpdated(ITypedReferenceableInstance entity)
-        throws AtlasException {
+    private void onTraitAddedToEntity(String typeName,
+                                      String traitName) throws AtlasException {
         for (EntityChangeListener listener : entityChangeListeners) {
-            listener.onEntityUpdated(entity);
+            listener.onTraitAdded(typeName, traitName);
         }
     }
 
-    private void onTraitAddedToEntity(ITypedReferenceableInstance entity, IStruct trait) throws AtlasException {
+    private void onTraitDeletedFromEntity(String typeName,
+                                          String traitName) throws AtlasException {
         for (EntityChangeListener listener : entityChangeListeners) {
-            listener.onTraitAdded(entity, trait);
-        }
-    }
-
-    private void onTraitDeletedFromEntity(ITypedReferenceableInstance entity, String traitName) throws AtlasException {
-        for (EntityChangeListener listener : entityChangeListeners) {
-            listener.onTraitDeleted(entity, traitName);
+            listener.onTraitDeleted(typeName, traitName);
         }
     }
 
@@ -535,4 +443,5 @@ public class DefaultMetadataService implements MetadataService {
     public void unregisterListener(EntityChangeListener listener) {
         entityChangeListeners.remove(listener);
     }
-}
+
+}
\ No newline at end of file