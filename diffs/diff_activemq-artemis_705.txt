diff --git a/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/buffer/TimedBuffer.java b/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/buffer/TimedBuffer.java
index b74ada40d9..2713255b7f 100644
--- a/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/buffer/TimedBuffer.java
+++ b/artemis-journal/src/main/java/org/apache/activemq/artemis/core/io/buffer/TimedBuffer.java
@@ -48,7 +48,7 @@ public final class TimedBuffer {
    // prevent that
    private final Semaphore spinLimiter = new Semaphore(1);
 
-   private CheckTimer timerRunnable;
+   private CheckTimer timerRunnable = null;
 
    private final int bufferSize;
 
@@ -369,10 +369,11 @@ public final class TimedBuffer {
 
       int checks = 0;
       int failedChecks = 0;
+      long timeBefore = 0;
 
       @Override
       public void run() {
-         long lastFlushTime = System.nanoTime();
+         long lastFlushTime = 0;
 
          while (!closed) {
             // We flush on the timer if there are pending syncs there and we've waited at least one
@@ -383,22 +384,17 @@ public final class TimedBuffer {
             if (pendingSync) {
                if (useSleep) {
                   // if using sleep, we will always flush
-                  lastFlushTime = System.nanoTime();
                   flush();
-
-               } else if (bufferObserver != null && System.nanoTime() > lastFlushTime + timeout) {
                   lastFlushTime = System.nanoTime();
+               } else if (bufferObserver != null && System.nanoTime() > lastFlushTime + timeout) {
                   // if not using flush we will spin and do the time checks manually
                   flush();
+                  lastFlushTime = System.nanoTime();
                }
 
             }
-            //it could wait until the timeout is expired
-            final long timeFromTheLastFlush = System.nanoTime() - lastFlushTime;
-            final long timeToSleep = timeFromTheLastFlush - timeout;
-            if (timeToSleep > 0) {
-               sleepIfPossible(timeToSleep);
-            }
+
+            sleepIfPossible();
 
             try {
                spinLimiter.acquire();
@@ -417,28 +413,28 @@ public final class TimedBuffer {
        * we will on that case verify up to MAX_CHECKS if nano sleep is behaving well.
        * if more than 50% of the checks have failed we will cancel the sleep and just use regular spin
        */
-      private void sleepIfPossible(long nanosToSleep) {
+      private void sleepIfPossible() {
          if (useSleep) {
-            try {
-               final long startSleep = System.nanoTime();
-               sleep(nanosToSleep);
-               final long elapsedSleep = System.nanoTime() - startSleep;
-               if (checks < MAX_CHECKS_ON_SLEEP) {
-                  // I'm letting the real time to be up to 50% than the requested sleep.
-                  if (elapsedSleep > nanosToSleep * 1.5) {
-                     failedChecks++;
-                  }
+            if (checks < MAX_CHECKS_ON_SLEEP) {
+               timeBefore = System.nanoTime();
+            }
 
-                  if (++checks >= MAX_CHECKS_ON_SLEEP) {
-                     if (failedChecks > MAX_CHECKS_ON_SLEEP * 0.5) {
-                        ActiveMQJournalLogger.LOGGER.debug("LockSupport.parkNanos with nano seconds is not working as expected, Your kernel possibly doesn't support real time. the Journal TimedBuffer will spin for timeouts");
-                        useSleep = false;
-                     }
+            LockSupport.parkNanos(timeout);
+
+            if (checks < MAX_CHECKS_ON_SLEEP) {
+               long realTimeSleep = System.nanoTime() - timeBefore;
+
+               // I'm letting the real time to be up to 50% than the requested sleep.
+               if (realTimeSleep > timeout * 1.5) {
+                  failedChecks++;
+               }
+
+               if (++checks >= MAX_CHECKS_ON_SLEEP) {
+                  if (failedChecks > MAX_CHECKS_ON_SLEEP * 0.5) {
+                     ActiveMQJournalLogger.LOGGER.debug("Thread.sleep with nano seconds is not working as expected, Your kernel possibly doesn't support real time. the Journal TimedBuffer will spin for timeouts");
+                     useSleep = false;
                   }
                }
-            } catch (Exception e) {
-               useSleep = false;
-               ActiveMQJournalLogger.LOGGER.warn(e.getMessage() + ", disabling sleep on TimedBuffer, using spin now", e);
             }
          }
       }
@@ -448,16 +444,6 @@ public final class TimedBuffer {
       }
    }
 
-   /**
-    * Sub classes (tests basically) can use this to override how the sleep is being done
-    *
-    * @param sleepNanos
-    * @throws InterruptedException
-    */
-   protected void sleep(long sleepNanos) {
-      LockSupport.parkNanos(sleepNanos);
-   }
-
    /**
     * Sub classes (tests basically) can use this to override disabling spinning
     */