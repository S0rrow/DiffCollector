diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
index 83193292d2..98b6bb7022 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
@@ -16,10 +16,9 @@
  */
 package org.apache.activemq.artemis.core.server.impl;
 
-import javax.json.JsonArrayBuilder;
-import javax.json.JsonObjectBuilder;
 import javax.transaction.xa.XAException;
 import javax.transaction.xa.Xid;
+
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -32,8 +31,6 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.activemq.artemis.api.core.ActiveMQException;
-import org.apache.activemq.artemis.api.core.ActiveMQIOErrorException;
-import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
 import org.apache.activemq.artemis.api.core.ActiveMQNonExistentQueueException;
 import org.apache.activemq.artemis.api.core.Message;
 import org.apache.activemq.artemis.api.core.Pair;
@@ -46,26 +43,24 @@ import org.apache.activemq.artemis.core.client.impl.ClientMessageImpl;
 import org.apache.activemq.artemis.core.exception.ActiveMQXAException;
 import org.apache.activemq.artemis.core.filter.Filter;
 import org.apache.activemq.artemis.core.filter.impl.FilterImpl;
-import org.apache.activemq.artemis.core.io.IOCallback;
+import org.apache.activemq.artemis.core.journal.IOAsyncTask;
 import org.apache.activemq.artemis.core.message.impl.MessageInternal;
-import org.apache.activemq.artemis.core.paging.PagingManager;
 import org.apache.activemq.artemis.core.paging.PagingStore;
 import org.apache.activemq.artemis.core.persistence.OperationContext;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.postoffice.Binding;
 import org.apache.activemq.artemis.core.postoffice.BindingType;
+import org.apache.activemq.artemis.core.postoffice.Bindings;
 import org.apache.activemq.artemis.core.postoffice.PostOffice;
 import org.apache.activemq.artemis.core.postoffice.QueueBinding;
-import org.apache.activemq.artemis.core.postoffice.RoutingStatus;
 import org.apache.activemq.artemis.core.remoting.CloseListener;
 import org.apache.activemq.artemis.core.remoting.FailureListener;
 import org.apache.activemq.artemis.core.security.CheckType;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
 import org.apache.activemq.artemis.core.security.SecurityStore;
-import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
-import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.BindingQueryResult;
+import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
+import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.LargeServerMessage;
 import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.Queue;
@@ -75,44 +70,39 @@ import org.apache.activemq.artemis.core.server.RoutingContext;
 import org.apache.activemq.artemis.core.server.ServerConsumer;
 import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
-import org.apache.activemq.artemis.core.server.TempQueueObserver;
 import org.apache.activemq.artemis.core.server.management.ManagementService;
 import org.apache.activemq.artemis.core.server.management.Notification;
 import org.apache.activemq.artemis.core.transaction.ResourceManager;
 import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.core.transaction.Transaction.State;
+import org.apache.activemq.artemis.core.transaction.TransactionFactory;
 import org.apache.activemq.artemis.core.transaction.TransactionOperationAbstract;
 import org.apache.activemq.artemis.core.transaction.TransactionPropertyIndexes;
 import org.apache.activemq.artemis.core.transaction.impl.TransactionImpl;
 import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
 import org.apache.activemq.artemis.spi.core.protocol.SessionCallback;
-import org.apache.activemq.artemis.utils.JsonLoader;
 import org.apache.activemq.artemis.utils.TypedProperties;
 import org.apache.activemq.artemis.utils.UUID;
-import org.jboss.logging.Logger;
-
-import static org.apache.activemq.artemis.api.core.JsonUtil.nullSafe;
+import org.apache.activemq.artemis.utils.json.JSONArray;
+import org.apache.activemq.artemis.utils.json.JSONObject;
 
 /**
  * Server side Session implementation
  */
-public class ServerSessionImpl implements ServerSession, FailureListener {
+public class ServerSessionImpl implements ServerSession, FailureListener
+{
    // Constants -----------------------------------------------------------------------------
 
-   private static final Logger logger = Logger.getLogger(ServerSessionImpl.class);
+   private static final boolean isTrace = ActiveMQServerLogger.LOGGER.isTraceEnabled();
 
    // Static -------------------------------------------------------------------------------
 
    // Attributes ----------------------------------------------------------------------------
 
-   private boolean securityEnabled = true;
-
    protected final String username;
 
    protected final String password;
 
-   protected final String validatedUser;
-
    private final int minLargeMessageSize;
 
    protected boolean autoCommitSends;
@@ -125,14 +115,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    protected final RemotingConnection remotingConnection;
 
-   protected final Map<Long, ServerConsumer> consumers = new ConcurrentHashMap<>();
+   protected final Map<Long, ServerConsumer> consumers = new ConcurrentHashMap<Long, ServerConsumer>();
 
    protected Transaction tx;
 
    protected boolean xa;
 
-   protected final PagingManager pagingManager;
-
    protected final StorageManager storageManager;
 
    private final ResourceManager resourceManager;
@@ -145,7 +133,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    protected volatile boolean started = false;
 
-   protected final Map<SimpleString, TempQueueCleanerUpper> tempQueueCleannerUppers = new HashMap<>();
+   protected final Map<SimpleString, TempQueueCleanerUpper> tempQueueCleannerUppers = new HashMap<SimpleString, TempQueueCleanerUpper>();
 
    protected final String name;
 
@@ -171,7 +159,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    private QueueCreator queueCreator;
 
    // Session's usage should be by definition single threaded, hence it's not needed to use a concurrentHashMap here
-   protected final Map<SimpleString, Pair<UUID, AtomicLong>> targetAddressInfos = new HashMap<>();
+   protected final Map<SimpleString, Pair<UUID, AtomicLong>> targetAddressInfos = new HashMap<SimpleString, Pair<UUID, AtomicLong>>();
 
    private final long creationTime = System.currentTimeMillis();
 
@@ -183,10 +171,66 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    // concurrently.
    private volatile boolean closed = false;
 
+   private final TransactionFactory transactionFactory;
+
+   //create an 'empty' session. Only used by AMQServerSession
+   //in order to check username and password
+   protected ServerSessionImpl(String username, String password)
+   {
+      this.username = username;
+      this.password = password;
+
+      this.transactionFactory = null;
+      this.strictUpdateDeliveryCount = false;
+      this.storageManager = null;
+      this.server = null;
+      this.securityStore = null;
+      this.resourceManager = null;
+      this.remotingConnection = null;
+      this.preAcknowledge = false;
+      this.postOffice = null;
+      this.name = null;
+      this.minLargeMessageSize = 0;
+      this.managementService = null;
+      this.managementAddress = null;
+      this.context = null;
+      this.callback = null;
+      this.queueCreator = null;
+   }
+
+   public ServerSessionImpl(final String name,
+                            final String username,
+                            final String password,
+                            final int minLargeMessageSize,
+                            final boolean autoCommitSends,
+                            final boolean autoCommitAcks,
+                            final boolean preAcknowledge,
+                            final boolean strictUpdateDeliveryCount,
+                            final boolean xa,
+                            final RemotingConnection remotingConnection,
+                            final StorageManager storageManager,
+                            final PostOffice postOffice,
+                            final ResourceManager resourceManager,
+                            final SecurityStore securityStore,
+                            final ManagementService managementService,
+                            final ActiveMQServer server,
+                            final SimpleString managementAddress,
+                            final SimpleString defaultAddress,
+                            final SessionCallback callback,
+                            final OperationContext context,
+                            final QueueCreator queueCreator) throws Exception
+   {
+      this(name, username, password, minLargeMessageSize,
+         autoCommitSends, autoCommitAcks, preAcknowledge,
+         strictUpdateDeliveryCount, xa, remotingConnection,
+         storageManager, postOffice, resourceManager, securityStore,
+         managementService, server, managementAddress, defaultAddress,
+         callback, context, null, queueCreator);
+   }
+
    public ServerSessionImpl(final String name,
                             final String username,
                             final String password,
-                            final String validatedUser,
                             final int minLargeMessageSize,
                             final boolean autoCommitSends,
                             final boolean autoCommitAcks,
@@ -204,14 +248,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                             final SimpleString defaultAddress,
                             final SessionCallback callback,
                             final OperationContext context,
-                            final QueueCreator queueCreator,
-                            final PagingManager pagingManager) throws Exception {
+                            TransactionFactory transactionFactory,
+                            final QueueCreator queueCreator) throws Exception
+   {
       this.username = username;
 
       this.password = password;
 
-      this.validatedUser = validatedUser;
-
       this.minLargeMessageSize = minLargeMessageSize;
 
       this.autoCommitSends = autoCommitSends;
@@ -230,8 +273,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       this.securityStore = securityStore;
 
-      this.pagingManager = pagingManager;
-
       timeoutSeconds = resourceManager.getTimeoutSeconds();
       this.xa = xa;
 
@@ -254,98 +295,83 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       this.queueCreator = queueCreator;
 
-      if (!xa) {
+      if (transactionFactory == null)
+      {
+         this.transactionFactory = new DefaultTransactionFactory();
+      }
+      else
+      {
+         this.transactionFactory = transactionFactory;
+      }
+
+      if (!xa)
+      {
          tx = newTransaction();
       }
    }
 
    // ServerSession implementation ----------------------------------------------------------------------------
 
-   @Override
-   public void enableSecurity() {
-      this.securityEnabled = true;
-   }
-
-   @Override
-   public void disableSecurity() {
-      this.securityEnabled = false;
-   }
-
-   @Override
-   public boolean isClosed() {
-      return closed;
-   }
-
    /**
     * @return the sessionContext
     */
-   @Override
-   public OperationContext getSessionContext() {
+   public OperationContext getSessionContext()
+   {
       return context;
    }
 
-   @Override
-   public String getUsername() {
+   public String getUsername()
+   {
       return username;
    }
 
-   @Override
-   public String getPassword() {
+   public String getPassword()
+   {
       return password;
    }
 
-   @Override
-   public int getMinLargeMessageSize() {
+   public int getMinLargeMessageSize()
+   {
       return minLargeMessageSize;
    }
 
-   @Override
-   public String getName() {
+   public String getName()
+   {
       return name;
    }
 
-   @Override
-   public Object getConnectionID() {
+   public Object getConnectionID()
+   {
       return remotingConnection.getID();
    }
 
-   @Override
-   public Set<ServerConsumer> getServerConsumers() {
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+   public Set<ServerConsumer> getServerConsumers()
+   {
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
       return Collections.unmodifiableSet(consumersClone);
    }
 
-   @Override
-   public void markTXFailed(Throwable e) {
-      Transaction currentTX = this.tx;
-      if (currentTX != null) {
-         if (e instanceof ActiveMQException) {
-            currentTX.markAsRollbackOnly((ActiveMQException) e);
-         } else {
-            ActiveMQException exception = new ActiveMQException(e.getMessage());
-            exception.initCause(e);
-            currentTX.markAsRollbackOnly(exception);
-         }
-      }
-   }
-
-   @Override
-   public boolean removeConsumer(final long consumerID) throws Exception {
+   public boolean removeConsumer(final long consumerID) throws Exception
+   {
       return consumers.remove(consumerID) != null;
    }
 
-   protected void doClose(final boolean failed) throws Exception {
-      synchronized (this) {
-         this.setStarted(false);
-         if (closed)
-            return;
+   protected void doClose(final boolean failed) throws Exception
+   {
+      synchronized (this)
+      {
+         if (closed) return;
 
-         if (tx != null && tx.getXid() == null) {
+         if (tx != null && tx.getXid() == null)
+         {
             // We only rollback local txs on close, not XA tx branches
 
-            try {
+            try
+            {
                rollback(failed, false);
-            } catch (Exception e) {
+            }
+            catch (Exception e)
+            {
                ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
             }
          }
@@ -353,16 +379,23 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       //putting closing of consumers outside the sync block
       //https://issues.jboss.org/browse/HORNETQ-1141
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
 
-      for (ServerConsumer consumer : consumersClone) {
-         try {
+      for (ServerConsumer consumer : consumersClone)
+      {
+         try
+         {
             consumer.close(failed);
-         } catch (Throwable e) {
+         }
+         catch (Throwable e)
+         {
             ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
-            try {
+            try
+            {
                consumer.removeItself();
-            } catch (Throwable e2) {
+            }
+            catch (Throwable e2)
+            {
                ActiveMQServerLogger.LOGGER.warn(e2.getMessage(), e2);
             }
          }
@@ -370,79 +403,81 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       consumers.clear();
 
-      if (currentLargeMessage != null) {
-         try {
+      if (currentLargeMessage != null)
+      {
+         try
+         {
             currentLargeMessage.deleteFile();
-         } catch (Throwable error) {
+         }
+         catch (Throwable error)
+         {
             ActiveMQServerLogger.LOGGER.errorDeletingLargeMessageFile(error);
          }
       }
 
-      synchronized (this) {
+
+      synchronized (this)
+      {
          server.removeSession(name);
 
          remotingConnection.removeFailureListener(this);
 
-         if (callback != null) {
-            callback.closed();
-         }
+         callback.closed();
 
          closed = true;
       }
    }
 
-   @Override
-   public QueueCreator getQueueCreator() {
-      return queueCreator;
-   }
 
-   protected void securityCheck(SimpleString address, CheckType checkType, SecurityAuth auth) throws Exception {
-      if (securityEnabled) {
-         securityStore.check(address, checkType, auth);
-      }
+
+   public QueueCreator getQueueCreator()
+   {
+      return queueCreator;
    }
 
-   @Override
    public ServerConsumer createConsumer(final long consumerID,
                                         final SimpleString queueName,
                                         final SimpleString filterString,
-                                        final boolean browseOnly) throws Exception {
+                                        final boolean browseOnly) throws Exception
+   {
       return this.createConsumer(consumerID, queueName, filterString, browseOnly, true, null);
    }
 
-   @Override
    public ServerConsumer createConsumer(final long consumerID,
                                         final SimpleString queueName,
                                         final SimpleString filterString,
                                         final boolean browseOnly,
                                         final boolean supportLargeMessage,
-                                        final Integer credits) throws Exception {
+                                        final Integer credits) throws Exception
+   {
       Binding binding = postOffice.getBinding(queueName);
 
-      if (binding == null || binding.getType() != BindingType.LOCAL_QUEUE) {
+      if (binding == null || binding.getType() != BindingType.LOCAL_QUEUE)
+      {
          throw ActiveMQMessageBundle.BUNDLE.noSuchQueue(queueName);
       }
 
-      if (browseOnly) {
-         try {
-            securityCheck(binding.getAddress(), CheckType.BROWSE, this);
-         } catch (Exception e) {
-            securityCheck(binding.getAddress().concat(".").concat(queueName), CheckType.BROWSE, this);
-         }
-      } else {
-         try {
-            securityCheck(binding.getAddress(), CheckType.CONSUME, this);
-         } catch (Exception e) {
-            securityCheck(binding.getAddress().concat(".").concat(queueName), CheckType.CONSUME, this);
-         }
-      }
+      securityStore.check(binding.getAddress(), CheckType.CONSUME, this);
 
       Filter filter = FilterImpl.createFilter(filterString);
 
-      ServerConsumer consumer = new ServerConsumerImpl(consumerID, this, (QueueBinding) binding, filter, started, browseOnly, storageManager, callback, preAcknowledge, strictUpdateDeliveryCount, managementService, supportLargeMessage, credits, server);
+      ServerConsumer consumer = newConsumer(consumerID,
+                                                       this,
+                                                       (QueueBinding) binding,
+                                                       filter,
+                                                       started,
+                                                       browseOnly,
+                                                       storageManager,
+                                                       callback,
+                                                       preAcknowledge,
+                                                       strictUpdateDeliveryCount,
+                                                       managementService,
+                                                       supportLargeMessage,
+                                                       credits);
       consumers.put(consumer.getID(), consumer);
 
-      if (!browseOnly) {
+      if (!browseOnly)
+      {
          TypedProperties props = new TypedProperties();
 
          props.putSimpleStringProperty(ManagementHelper.HDR_ADDRESS, binding.getAddress());
@@ -464,17 +499,19 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
          props.putSimpleStringProperty(ManagementHelper.HDR_SESSION_NAME, SimpleString.toSimpleString(name));
 
-         if (filterString != null) {
+         if (filterString != null)
+         {
             props.putSimpleStringProperty(ManagementHelper.HDR_FILTERSTRING, filterString);
          }
 
          Notification notification = new Notification(null, CoreNotificationType.CONSUMER_CREATED, props);
 
-         if (logger.isDebugEnabled()) {
-            logger.debug("Session with user=" + username +
-                            ", connection=" + this.remotingConnection +
-                            " created a consumer on queue " + queueName +
-                            ", filter = " + filterString);
+         if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+         {
+            ActiveMQServerLogger.LOGGER.debug("Session with user=" + username +
+                                                ", connection=" + this.remotingConnection +
+                                                " created a consumer on queue " + queueName +
+                                                ", filter = " + filterString);
          }
 
          managementService.sendNotification(notification);
@@ -483,54 +520,61 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       return consumer;
    }
 
-   /**
-    * Some protocols may chose to hold their transactions outside of the ServerSession.
-    * This can be used to replace the transaction.
-    * Notice that we set autoCommitACK and autoCommitSends to true if tx == null
-    */
-   @Override
-   public void resetTX(Transaction transaction) {
-      this.tx = transaction;
-      this.autoCommitAcks = transaction == null;
-      this.autoCommitSends = transaction == null;
+   protected ServerConsumer newConsumer(long consumerID,
+         ServerSessionImpl serverSessionImpl, QueueBinding binding,
+         Filter filter, boolean started2, boolean browseOnly,
+         StorageManager storageManager2, SessionCallback callback2,
+         boolean preAcknowledge2, boolean strictUpdateDeliveryCount2,
+         ManagementService managementService2, boolean supportLargeMessage,
+         Integer credits) throws Exception
+   {
+      return new ServerConsumerImpl(consumerID,
+            this,
+            (QueueBinding) binding,
+            filter,
+            started,
+            browseOnly,
+            storageManager,
+            callback,
+            preAcknowledge,
+            strictUpdateDeliveryCount,
+            managementService,
+            supportLargeMessage,
+            credits);
    }
 
-   @Override
    public Queue createQueue(final SimpleString address,
-                            final SimpleString name,
-                            final SimpleString filterString,
-                            final boolean temporary,
-                            final boolean durable) throws Exception {
-      return createQueue(address, name, filterString, temporary, durable, null, null);
-   }
-
-   @Override
-   public Queue createQueue(final SimpleString address,
-                            final SimpleString name,
-                            final SimpleString filterString,
-                            final boolean temporary,
-                            final boolean durable,
-                            final Integer maxConsumers,
-                            final Boolean deleteOnNoConsumers) throws Exception {
-      if (durable) {
+                           final SimpleString name,
+                           final SimpleString filterString,
+                           final boolean temporary,
+                           final boolean durable) throws Exception
+   {
+      if (durable)
+      {
          // make sure the user has privileges to create this queue
-         securityCheck(address, CheckType.CREATE_DURABLE_QUEUE, this);
-      } else {
-         securityCheck(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
+         securityStore.check(address, CheckType.CREATE_DURABLE_QUEUE, this);
+      }
+      else
+      {
+         securityStore.check(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
       }
 
-      server.checkQueueCreationLimit(getUsername());
+      ((ActiveMQServerImpl)server).checkQueueCreationLimit(getUsername());
 
       Queue queue;
 
-      // any non-temporary JMS destination created via this method should be marked as auto-created
-      if (!temporary && ((address.toString().startsWith(ResourceNames.JMS_QUEUE) && address.equals(name)) || address.toString().startsWith(ResourceNames.JMS_TOPIC))) {
-         queue = server.createQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary, true, maxConsumers, deleteOnNoConsumers);
-      } else {
-         queue = server.createQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary, maxConsumers, deleteOnNoConsumers);
+      // any non-temporary JMS queue created via this method should be marked as auto-created
+      if (!temporary && address.toString().startsWith(ResourceNames.JMS_QUEUE) && address.equals(name))
+      {
+         queue = server.createQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary, true);
+      }
+      else
+      {
+         queue = server.createQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary);
       }
 
-      if (temporary) {
+      if (temporary)
+      {
          // Temporary queue in core simply means the queue will be deleted if
          // the remoting connection
          // dies. It does not mean it will get deleted automatically when the
@@ -538,9 +582,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          // It is up to the user to delete the queue when finished with it
 
          TempQueueCleanerUpper cleaner = new TempQueueCleanerUpper(server, name);
-         if (remotingConnection instanceof TempQueueObserver) {
-            cleaner.setObserver((TempQueueObserver) remotingConnection);
-         }
 
          remotingConnection.addCloseListener(cleaner);
          remotingConnection.addFailureListener(cleaner);
@@ -548,10 +589,11 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          tempQueueCleannerUppers.put(name, cleaner);
       }
 
-      if (logger.isDebugEnabled()) {
-         logger.debug("Queue " + name + " created on address " + address +
-                         " with filter=" + filterString + " temporary = " +
-                         temporary + " durable=" + durable + " on session user=" + this.username + ", connection=" + this.remotingConnection);
+      if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+      {
+         ActiveMQServerLogger.LOGGER.debug("Queue " + name + " created on address " + address +
+                                             " with filter=" + filterString + " temporary = " +
+                                             temporary + " durable=" + durable + " on session user=" + this.username + ", connection=" + this.remotingConnection);
       }
 
       return queue;
@@ -562,83 +604,87 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    public void createSharedQueue(final SimpleString address,
                                  final SimpleString name,
                                  boolean durable,
-                                 final SimpleString filterString) throws Exception {
-      securityCheck(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
+                                 final SimpleString filterString) throws Exception
+   {
+      securityStore.check(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
 
-      server.checkQueueCreationLimit(getUsername());
+      ((ActiveMQServerImpl)server).checkQueueCreationLimit(getUsername());
 
       server.createSharedQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable);
    }
 
-   @Override
-   public RemotingConnection getRemotingConnection() {
+   public RemotingConnection getRemotingConnection()
+   {
       return remotingConnection;
    }
 
-   public static class TempQueueCleanerUpper implements CloseListener, FailureListener {
-
+   public static class TempQueueCleanerUpper implements CloseListener, FailureListener
+   {
       private final SimpleString bindingName;
 
       private final ActiveMQServer server;
 
-      private TempQueueObserver observer;
-
-      public TempQueueCleanerUpper(final ActiveMQServer server, final SimpleString bindingName) {
+      public TempQueueCleanerUpper(final ActiveMQServer server, final SimpleString bindingName)
+      {
          this.server = server;
 
          this.bindingName = bindingName;
       }
 
-      public void setObserver(TempQueueObserver observer) {
-         this.observer = observer;
-      }
-
-      private void run() {
-         try {
-            if (logger.isDebugEnabled()) {
-               logger.debug("deleting temporary queue " + bindingName);
+      private void run()
+      {
+         try
+         {
+            if (ActiveMQServerLogger.LOGGER.isDebugEnabled())
+            {
+               ActiveMQServerLogger.LOGGER.debug("deleting temporary queue " + bindingName);
             }
-            try {
+            try
+            {
                server.destroyQueue(bindingName, null, false);
-               if (observer != null) {
-                  observer.tempQueueDeleted(bindingName);
-               }
-            } catch (ActiveMQException e) {
+            }
+            catch (ActiveMQException e)
+            {
                // that's fine.. it can happen due to queue already been deleted
-               logger.debug(e.getMessage(), e);
+               ActiveMQServerLogger.LOGGER.debug(e.getMessage(), e);
             }
-         } catch (Exception e) {
+         }
+         catch (Exception e)
+         {
             ActiveMQServerLogger.LOGGER.errorRemovingTempQueue(e, bindingName);
          }
       }
 
-      @Override
-      public void connectionFailed(ActiveMQException exception, boolean failedOver) {
+      public void connectionFailed(ActiveMQException exception, boolean failedOver)
+      {
          run();
       }
 
       @Override
-      public void connectionFailed(final ActiveMQException me, boolean failedOver, String scaleDownTargetNodeID) {
+      public void connectionFailed(final ActiveMQException me, boolean failedOver, String scaleDownTargetNodeID)
+      {
          connectionFailed(me, failedOver);
       }
 
-      @Override
-      public void connectionClosed() {
+      public void connectionClosed()
+      {
          run();
       }
 
       @Override
-      public String toString() {
+      public String toString()
+      {
          return "Temporary Cleaner for queue " + bindingName;
       }
 
    }
 
-   @Override
-   public void deleteQueue(final SimpleString queueToDelete) throws Exception {
+   public void deleteQueue(final SimpleString queueToDelete) throws Exception
+   {
       Binding binding = postOffice.getBinding(queueToDelete);
 
-      if (binding == null || binding.getType() != BindingType.LOCAL_QUEUE) {
+      if (binding == null || binding.getType() != BindingType.LOCAL_QUEUE)
+      {
          throw new ActiveMQNonExistentQueueException();
       }
 
@@ -646,133 +692,196 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       TempQueueCleanerUpper cleaner = this.tempQueueCleannerUppers.remove(queueToDelete);
 
-      if (cleaner != null) {
+      if (cleaner != null)
+      {
          remotingConnection.removeCloseListener(cleaner);
 
          remotingConnection.removeFailureListener(cleaner);
       }
    }
 
-   @Override
-   public QueueQueryResult executeQueueQuery(final SimpleString name) throws Exception {
-      return server.queueQuery(name);
+   public QueueQueryResult executeQueueQuery(final SimpleString name) throws Exception
+   {
+      boolean autoCreateJmsQueues = name.toString().startsWith(ResourceNames.JMS_QUEUE) && server.getAddressSettingsRepository().getMatch(name.toString()).isAutoCreateJmsQueues();
+
+      if (name == null)
+      {
+         throw ActiveMQMessageBundle.BUNDLE.queueNameIsNull();
+      }
+
+      QueueQueryResult response;
+
+      Binding binding = postOffice.getBinding(name);
+
+      if (binding != null && binding.getType() == BindingType.LOCAL_QUEUE)
+      {
+         Queue queue = (Queue) binding.getBindable();
+
+         Filter filter = queue.getFilter();
+
+         SimpleString filterString = filter == null ? null : filter.getFilterString();
+
+         response = new QueueQueryResult(name,
+                                         binding.getAddress(),
+                                         queue.isDurable(),
+                                         queue.isTemporary(),
+                                         filterString,
+                                         queue.getConsumerCount(),
+                                         queue.getMessageCount(),
+                                         autoCreateJmsQueues);
+      }
+      // make an exception for the management address (see HORNETQ-29)
+      else if (name.equals(managementAddress))
+      {
+         response = new QueueQueryResult(name, managementAddress, true, false, null, -1, -1, autoCreateJmsQueues);
+      }
+      else if (autoCreateJmsQueues)
+      {
+         response = new QueueQueryResult(name, name, true, false, null, 0, 0, true, false);
+      }
+      else
+      {
+         response = new QueueQueryResult(null, null, false, false, null, 0, 0, false, false);
+      }
+
+      return response;
    }
 
-   @Override
-   public BindingQueryResult executeBindingQuery(final SimpleString address) throws Exception {
-      return server.bindingQuery(address);
+   public BindingQueryResult executeBindingQuery(final SimpleString address) throws Exception
+   {
+      boolean autoCreateJmsQueues = address.toString().startsWith(ResourceNames.JMS_QUEUE) && server.getAddressSettingsRepository().getMatch(address.toString()).isAutoCreateJmsQueues();
+
+      if (address == null)
+      {
+         throw ActiveMQMessageBundle.BUNDLE.addressIsNull();
+      }
+
+      List<SimpleString> names = new ArrayList<SimpleString>();
+
+      // make an exception for the management address (see HORNETQ-29)
+      if (address.equals(managementAddress))
+      {
+         return new BindingQueryResult(true, names, autoCreateJmsQueues);
+      }
+
+      Bindings bindings = postOffice.getMatchingBindings(address);
+
+      for (Binding binding : bindings.getBindings())
+      {
+         if (binding.getType() == BindingType.LOCAL_QUEUE || binding.getType() == BindingType.REMOTE_QUEUE)
+         {
+            names.add(binding.getUniqueName());
+         }
+      }
+
+      return new BindingQueryResult(!names.isEmpty(), names, autoCreateJmsQueues);
    }
 
-   @Override
-   public void forceConsumerDelivery(final long consumerID, final long sequence) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
+   public void forceConsumerDelivery(final long consumerID, final long sequence) throws Exception
+   {
+      ServerConsumer consumer = consumers.get(consumerID);
 
       // this would be possible if the server consumer was closed by pings/pongs.. etc
-      if (consumer != null) {
+      if (consumer != null)
+      {
          consumer.forceDelivery(sequence);
       }
    }
 
-   @Override
-   public void acknowledge(final long consumerID, final long messageID) throws Exception {
-      ServerConsumer consumer = findConsumer(consumerID);
+   public void acknowledge(final long consumerID, final long messageID) throws Exception
+   {
+      ServerConsumer consumer = consumers.get(consumerID);
 
-      if (tx != null && tx.getState() == State.ROLLEDBACK) {
+      if (consumer == null)
+      {
+         throw ActiveMQMessageBundle.BUNDLE.consumerDoesntExist(consumerID);
+      }
+
+      if (tx != null && tx.getState() == State.ROLLEDBACK)
+      {
          // JBPAPP-8845 - if we let stuff to be acked on a rolled back TX, we will just
          // have these messages to be stuck on the limbo until the server is restarted
          // The tx has already timed out, so we need to ack and rollback immediately
          Transaction newTX = newTransaction();
-         try {
-            consumer.acknowledge(newTX, messageID);
-         } catch (Exception e) {
-            // just ignored
-            // will log it just in case
-            logger.debug("Ignored exception while acking messageID " + messageID +
-                            " on a rolledback TX", e);
-         }
+         consumer.acknowledge(newTX, messageID);
          newTX.rollback();
-      } else {
-         consumer.acknowledge(autoCommitAcks ? null : tx, messageID);
       }
-   }
-
-   @Override
-   public ServerConsumer locateConsumer(long consumerID) {
-      return consumers.get(consumerID);
-   }
-
-   private ServerConsumer findConsumer(long consumerID) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
-
-      if (consumer == null) {
-         Transaction currentTX = tx;
-         ActiveMQIllegalStateException exception = ActiveMQMessageBundle.BUNDLE.consumerDoesntExist(consumerID);
-
-         if (currentTX != null) {
-            currentTX.markAsRollbackOnly(exception);
-         }
-
-         throw exception;
+      else
+      {
+         consumer.acknowledge(autoCommitAcks ? null : tx, messageID);
       }
-      return consumer;
    }
 
-   @Override
-   public void individualAcknowledge(final long consumerID, final long messageID) throws Exception {
-      ServerConsumer consumer = findConsumer(consumerID);
+   public void individualAcknowledge(final long consumerID, final long messageID) throws Exception
+   {
+      ServerConsumer consumer = consumers.get(consumerID);
 
-      if (tx != null && tx.getState() == State.ROLLEDBACK) {
+      if (tx != null && tx.getState() == State.ROLLEDBACK)
+      {
          // JBPAPP-8845 - if we let stuff to be acked on a rolled back TX, we will just
          // have these messages to be stuck on the limbo until the server is restarted
          // The tx has already timed out, so we need to ack and rollback immediately
          Transaction newTX = newTransaction();
          consumer.individualAcknowledge(tx, messageID);
          newTX.rollback();
-      } else {
+      }
+      else
+      {
          consumer.individualAcknowledge(autoCommitAcks ? null : tx, messageID);
       }
 
    }
 
-   @Override
-   public void individualCancel(final long consumerID, final long messageID, boolean failed) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
+   public void individualCancel(final long consumerID, final long messageID, boolean failed) throws Exception
+   {
+      ServerConsumer consumer = consumers.get(consumerID);
 
-      if (consumer != null) {
+      if (consumer != null)
+      {
          consumer.individualCancel(messageID, failed);
       }
 
    }
 
-   @Override
-   public void expire(final long consumerID, final long messageID) throws Exception {
-      MessageReference ref = locateConsumer(consumerID).removeReferenceByID(messageID);
 
-      if (ref != null) {
+   public void expire(final long consumerID, final long messageID) throws Exception
+   {
+      MessageReference ref = consumers.get(consumerID).removeReferenceByID(messageID);
+
+      if (ref != null)
+      {
          ref.getQueue().expire(ref);
       }
    }
 
-   @Override
-   public synchronized void commit() throws Exception {
-      if (logger.isTraceEnabled()) {
-         logger.trace("Calling commit");
+   public synchronized void commit() throws Exception
+   {
+      if (isTrace)
+      {
+         ActiveMQServerLogger.LOGGER.trace("Calling commit");
       }
-      try {
-         if (tx != null) {
+      try
+      {
+         if (tx != null)
+         {
             tx.commit();
          }
-      } finally {
-         if (xa) {
+      }
+      finally
+      {
+         if (xa)
+         {
             tx = null;
-         } else {
+         }
+         else
+         {
             tx = newTransaction();
          }
       }
    }
 
-   @Override
-   public void rollback(final boolean considerLastMessageAsDelivered) throws Exception {
+   public void rollback(final boolean considerLastMessageAsDelivered) throws Exception
+   {
       rollback(false, considerLastMessageAsDelivered);
    }
 
@@ -781,9 +890,10 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
     * @param considerLastMessageAsDelivered
     * @throws Exception
     */
-   private synchronized void rollback(final boolean clientFailed,
-                                      final boolean considerLastMessageAsDelivered) throws Exception {
-      if (tx == null) {
+   private synchronized void rollback(final boolean clientFailed, final boolean considerLastMessageAsDelivered) throws Exception
+   {
+      if (tx == null)
+      {
          // Might be null if XA
 
          tx = newTransaction();
@@ -791,9 +901,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       doRollback(clientFailed, considerLastMessageAsDelivered, tx);
 
-      if (xa) {
+      if (xa)
+      {
          tx = null;
-      } else {
+      }
+      else
+      {
          tx = newTransaction();
       }
    }
@@ -801,154 +914,206 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    /**
     * @return
     */
-   @Override
-   public Transaction newTransaction() {
-      return new TransactionImpl(null, storageManager, timeoutSeconds);
+   protected Transaction newTransaction()
+   {
+      return transactionFactory.newTransaction(null, storageManager, timeoutSeconds);
    }
 
    /**
     * @param xid
     * @return
     */
-   private Transaction newTransaction(final Xid xid) {
-      return new TransactionImpl(xid, storageManager, timeoutSeconds);
+   private Transaction newTransaction(final Xid xid)
+   {
+      return transactionFactory.newTransaction(xid, storageManager, timeoutSeconds);
    }
 
-   @Override
-   public synchronized void xaCommit(final Xid xid, final boolean onePhase) throws Exception {
+   public synchronized void xaCommit(final Xid xid, final boolean onePhase) throws Exception
+   {
 
-      if (tx != null && tx.getXid().equals(xid)) {
+      if (tx != null && tx.getXid().equals(xid))
+      {
          final String msg = "Cannot commit, session is currently doing work in transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else
+      {
          Transaction theTx = resourceManager.removeTransaction(xid);
 
-         if (logger.isTraceEnabled()) {
-            logger.trace("XAcommit into " + theTx + ", xid=" + xid);
+
+         if (isTrace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("XAcommit into " + theTx + ", xid=" + xid);
          }
 
-         if (theTx == null) {
+         if (theTx == null)
+         {
             // checked heuristic committed transactions
-            if (resourceManager.getHeuristicCommittedTransactions().contains(xid)) {
-               throw new ActiveMQXAException(XAException.XA_HEURCOM, "transaction has been heuristically committed: " + xid);
-            } else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid)) {
-               // checked heuristic rolled back transactions
-               throw new ActiveMQXAException(XAException.XA_HEURRB, "transaction has been heuristically rolled back: " + xid);
-            } else {
-               if (logger.isTraceEnabled()) {
-                  logger.trace("XAcommit into " + theTx + ", xid=" + xid + " cannot find it");
+            if (resourceManager.getHeuristicCommittedTransactions().contains(xid))
+            {
+               throw new ActiveMQXAException(XAException.XA_HEURCOM,
+                                            "transaction has been heuristically committed: " + xid);
+            }
+            // checked heuristic rolled back transactions
+            else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid))
+            {
+               throw new ActiveMQXAException(XAException.XA_HEURRB,
+                                            "transaction has been heuristically rolled back: " + xid);
+            }
+            else
+            {
+               if (isTrace)
+               {
+                  ActiveMQServerLogger.LOGGER.trace("XAcommit into " + theTx + ", xid=" + xid + " cannot find it");
                }
 
                throw new ActiveMQXAException(XAException.XAER_NOTA, "Cannot find xid in resource manager: " + xid);
             }
-         } else {
-            if (theTx.getState() == Transaction.State.SUSPENDED) {
+         }
+         else
+         {
+            if (theTx.getState() == Transaction.State.SUSPENDED)
+            {
                // Put it back
                resourceManager.putTransaction(xid, theTx);
 
                throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot commit transaction, it is suspended " + xid);
-            } else {
+            }
+            else
+            {
                theTx.commit(onePhase);
             }
          }
       }
    }
 
-   @Override
-   public synchronized void xaEnd(final Xid xid) throws Exception {
-      if (tx != null && tx.getXid().equals(xid)) {
-         if (tx.getState() == Transaction.State.SUSPENDED) {
+   public synchronized void xaEnd(final Xid xid) throws Exception
+   {
+      if (tx != null && tx.getXid().equals(xid))
+      {
+         if (tx.getState() == Transaction.State.SUSPENDED)
+         {
             final String msg = "Cannot end, transaction is suspended";
 
             throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-         } else if (tx.getState() == Transaction.State.ROLLEDBACK) {
+         }
+         else if (tx.getState() == Transaction.State.ROLLEDBACK)
+         {
             final String msg = "Cannot end, transaction is rolled back";
 
-            final boolean timeout = tx.hasTimedOut();
             tx = null;
 
-            if (timeout) {
-               throw new ActiveMQXAException(XAException.XA_RBTIMEOUT, msg);
-            } else {
-               throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-            }
-         } else {
+            throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
+         }
+         else
+         {
             tx = null;
          }
-      } else {
+      }
+      else
+      {
          // It's also legal for the TM to call end for a Xid in the suspended
          // state
          // See JTA 1.1 spec 3.4.4 - state diagram
          // Although in practice TMs rarely do this.
          Transaction theTx = resourceManager.getTransaction(xid);
 
-         if (theTx == null) {
+         if (theTx == null)
+         {
             final String msg = "Cannot find suspended transaction to end " + xid;
 
             throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-         } else {
-            if (theTx.getState() != Transaction.State.SUSPENDED) {
+         }
+         else
+         {
+            if (theTx.getState() != Transaction.State.SUSPENDED)
+            {
                final String msg = "Transaction is not suspended " + xid;
 
                throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-            } else {
+            }
+            else
+            {
                theTx.resume();
             }
          }
       }
    }
 
-   @Override
-   public synchronized void xaForget(final Xid xid) throws Exception {
+   public synchronized void xaForget(final Xid xid) throws Exception
+   {
       long id = resourceManager.removeHeuristicCompletion(xid);
 
-      if (id != -1) {
-         try {
+      if (id != -1)
+      {
+         try
+         {
             storageManager.deleteHeuristicCompletion(id);
-         } catch (Exception e) {
-            ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
+         }
+         catch (Exception e)
+         {
+            e.printStackTrace();
+
             throw new ActiveMQXAException(XAException.XAER_RMFAIL);
          }
-      } else {
+      }
+      else
+      {
          throw new ActiveMQXAException(XAException.XAER_NOTA);
       }
    }
 
-   @Override
-   public synchronized void xaJoin(final Xid xid) throws Exception {
+   public synchronized void xaJoin(final Xid xid) throws Exception
+   {
       Transaction theTx = resourceManager.getTransaction(xid);
 
-      if (theTx == null) {
+      if (theTx == null)
+      {
          final String msg = "Cannot find xid in resource manager: " + xid;
 
          throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-      } else {
-         if (theTx.getState() == Transaction.State.SUSPENDED) {
+      }
+      else
+      {
+         if (theTx.getState() == Transaction.State.SUSPENDED)
+         {
             throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot join tx, it is suspended " + xid);
-         } else {
+         }
+         else
+         {
             tx = theTx;
          }
       }
    }
 
-   @Override
-   public synchronized void xaResume(final Xid xid) throws Exception {
-      if (tx != null) {
+   public synchronized void xaResume(final Xid xid) throws Exception
+   {
+      if (tx != null)
+      {
          final String msg = "Cannot resume, session is currently doing work in a transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else
+      {
          Transaction theTx = resourceManager.getTransaction(xid);
 
-         if (theTx == null) {
+         if (theTx == null)
+         {
             final String msg = "Cannot find xid in resource manager: " + xid;
 
             throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-         } else {
-            if (theTx.getState() != Transaction.State.SUSPENDED) {
-               throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot resume transaction, it is not suspended " + xid);
-            } else {
+         }
+         else
+         {
+            if (theTx.getState() != Transaction.State.SUSPENDED)
+            {
+               throw new ActiveMQXAException(XAException.XAER_PROTO,
+                                            "Cannot resume transaction, it is not suspended " + xid);
+            }
+            else
+            {
                tx = theTx;
 
                tx.resume();
@@ -957,130 +1122,177 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
-   public synchronized void xaRollback(final Xid xid) throws Exception {
-      if (tx != null && tx.getXid().equals(xid)) {
+   public synchronized void xaRollback(final Xid xid) throws Exception
+   {
+      if (tx != null && tx.getXid().equals(xid))
+      {
          final String msg = "Cannot roll back, session is currently doing work in a transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else
+      {
          Transaction theTx = resourceManager.removeTransaction(xid);
-         if (logger.isTraceEnabled()) {
-            logger.trace("xarollback into " + theTx);
+         if (isTrace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("xarollback into " + theTx);
          }
 
-         if (theTx == null) {
+         if (theTx == null)
+         {
             // checked heuristic committed transactions
-            if (resourceManager.getHeuristicCommittedTransactions().contains(xid)) {
-               throw new ActiveMQXAException(XAException.XA_HEURCOM, "transaction has ben heuristically committed: " + xid);
-            } else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid)) {
-               // checked heuristic rolled back transactions
-               throw new ActiveMQXAException(XAException.XA_HEURRB, "transaction has ben heuristically rolled back: " + xid);
-            } else {
-               if (logger.isTraceEnabled()) {
-                  logger.trace("xarollback into " + theTx + ", xid=" + xid + " forcing a rollback regular");
+            if (resourceManager.getHeuristicCommittedTransactions().contains(xid))
+            {
+               throw new ActiveMQXAException(XAException.XA_HEURCOM,
+                                            "transaction has ben heuristically committed: " + xid);
+            }
+            // checked heuristic rolled back transactions
+            else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid))
+            {
+               throw new ActiveMQXAException(XAException.XA_HEURRB,
+                                            "transaction has ben heuristically rolled back: " + xid);
+            }
+            else
+            {
+               if (isTrace)
+               {
+                  ActiveMQServerLogger.LOGGER.trace("xarollback into " + theTx + ", xid=" + xid + " forcing a rollback regular");
                }
 
-               try {
+               try
+               {
                   // jbpapp-8845
                   // This could have happened because the TX timed out,
                   // at this point we would be better on rolling back this session as a way to prevent consumers from holding their messages
                   this.rollback(false);
-               } catch (Exception e) {
+               }
+               catch (Exception e)
+               {
                   ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
                }
 
                throw new ActiveMQXAException(XAException.XAER_NOTA, "Cannot find xid in resource manager: " + xid);
             }
-         } else {
-            if (theTx.getState() == Transaction.State.SUSPENDED) {
-               if (logger.isTraceEnabled()) {
-                  logger.trace("xarollback into " + theTx + " sending tx back as it was suspended");
+         }
+         else
+         {
+            if (theTx.getState() == Transaction.State.SUSPENDED)
+            {
+               if (isTrace)
+               {
+                  ActiveMQServerLogger.LOGGER.trace("xarollback into " + theTx + " sending tx back as it was suspended");
                }
 
+
                // Put it back
                resourceManager.putTransaction(xid, tx);
 
-               throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot rollback transaction, it is suspended " + xid);
-            } else {
+               throw new ActiveMQXAException(XAException.XAER_PROTO,
+                                            "Cannot rollback transaction, it is suspended " + xid);
+            }
+            else
+            {
                doRollback(false, false, theTx);
             }
          }
       }
    }
 
-   @Override
-   public synchronized void xaStart(final Xid xid) throws Exception {
-      if (tx != null) {
+   public synchronized void xaStart(final Xid xid) throws Exception
+   {
+      if (tx != null)
+      {
          ActiveMQServerLogger.LOGGER.xidReplacedOnXStart(tx.getXid().toString(), xid.toString());
 
-         try {
-            if (tx.getState() != Transaction.State.PREPARED) {
+         try
+         {
+            if (tx.getState() != Transaction.State.PREPARED)
+            {
                // we don't want to rollback anything prepared here
-               if (tx.getXid() != null) {
+               if (tx.getXid() != null)
+               {
                   resourceManager.removeTransaction(tx.getXid());
                }
                tx.rollback();
             }
-         } catch (Exception e) {
-            logger.debug("An exception happened while we tried to debug the previous tx, we can ignore this exception", e);
+         }
+         catch (Exception e)
+         {
+            ActiveMQServerLogger.LOGGER.debug("An exception happened while we tried to debug the previous tx, we can ignore this exception", e);
          }
       }
 
       tx = newTransaction(xid);
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("xastart into tx= " + tx);
+      if (isTrace)
+      {
+         ActiveMQServerLogger.LOGGER.trace("xastart into tx= " + tx);
       }
 
       boolean added = resourceManager.putTransaction(xid, tx);
 
-      if (!added) {
+      if (!added)
+      {
          final String msg = "Cannot start, there is already a xid " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_DUPID, msg);
       }
    }
 
-   @Override
-   public synchronized void xaFailed(final Xid xid) throws Exception {
-      Transaction theTX = resourceManager.getTransaction(xid);
+   public synchronized void xaFailed(final Xid xid) throws Exception
+   {
+      if (tx != null)
+      {
+         final String msg = "Cannot start, session is already doing work in a transaction " + tx.getXid();
 
-      if (theTX == null) {
-         theTX = newTransaction(xid);
-         resourceManager.putTransaction(xid, theTX);
+         throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
       }
+      else
+      {
 
-      if (theTX.isEffective()) {
-         logger.debug("Client failed with Xid " + xid + " but the server already had it " + theTX.getState());
-         tx = null;
-      } else {
-         theTX.markAsRollbackOnly(new ActiveMQException("Can't commit as a Failover happened during the operation"));
-         tx = theTX;
-      }
+         tx = newTransaction(xid);
+         tx.markAsRollbackOnly(new ActiveMQException("Can't commit as a Failover happened during the operation"));
+
+         if (isTrace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("xastart into tx= " + tx);
+         }
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("xastart into tx= " + tx);
+         boolean added = resourceManager.putTransaction(xid, tx);
+
+         if (!added)
+         {
+            final String msg = "Cannot start, there is already a xid " + tx.getXid();
+
+            throw new ActiveMQXAException(XAException.XAER_DUPID, msg);
+         }
       }
    }
 
-   @Override
-   public synchronized void xaSuspend() throws Exception {
+   public synchronized void xaSuspend() throws Exception
+   {
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("xasuspend on " + this.tx);
+      if (isTrace)
+      {
+         ActiveMQServerLogger.LOGGER.trace("xasuspend on " + this.tx);
       }
 
-      if (tx == null) {
+      if (tx == null)
+      {
          final String msg = "Cannot suspend, session is not doing work in a transaction ";
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
-         if (tx.getState() == Transaction.State.SUSPENDED) {
+      }
+      else
+      {
+         if (tx.getState() == Transaction.State.SUSPENDED)
+         {
             final String msg = "Cannot suspend, transaction is already suspended " + tx.getXid();
 
             throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-         } else {
+         }
+         else
+         {
             tx.suspend();
 
             tx = null;
@@ -1088,111 +1300,142 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
    }
 
-   @Override
-   public synchronized void xaPrepare(final Xid xid) throws Exception {
-      if (tx != null && tx.getXid().equals(xid)) {
+   public synchronized void xaPrepare(final Xid xid) throws Exception
+   {
+      if (tx != null && tx.getXid().equals(xid))
+      {
          final String msg = "Cannot commit, session is currently doing work in a transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else
+      {
          Transaction theTx = resourceManager.getTransaction(xid);
 
-         if (logger.isTraceEnabled()) {
-            logger.trace("xaprepare into " + ", xid=" + xid + ", tx= " + tx);
+         if (isTrace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("xaprepare into " + ", xid=" + xid + ", tx= " + tx);
          }
 
-         if (theTx == null) {
+         if (theTx == null)
+         {
             final String msg = "Cannot find xid in resource manager: " + xid;
 
             throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-         } else {
-            if (theTx.getState() == Transaction.State.SUSPENDED) {
-               throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot prepare transaction, it is suspended " + xid);
-            } else if (theTx.getState() == Transaction.State.PREPARED) {
+         }
+         else
+         {
+            if (theTx.getState() == Transaction.State.SUSPENDED)
+            {
+               throw new ActiveMQXAException(XAException.XAER_PROTO,
+                                            "Cannot prepare transaction, it is suspended " + xid);
+            }
+            else if (theTx.getState() == Transaction.State.PREPARED)
+            {
                ActiveMQServerLogger.LOGGER.info("ignoring prepare on xid as already called :" + xid);
-            } else {
+            }
+            else
+            {
                theTx.prepare();
             }
          }
       }
    }
 
-   @Override
-   public List<Xid> xaGetInDoubtXids() {
-      return resourceManager.getInDoubtTransactions();
+   public List<Xid> xaGetInDoubtXids()
+   {
+      List<Xid> xids = new ArrayList<Xid>();
+
+      xids.addAll(resourceManager.getPreparedTransactions());
+      xids.addAll(resourceManager.getHeuristicCommittedTransactions());
+      xids.addAll(resourceManager.getHeuristicRolledbackTransactions());
+
+      return xids;
    }
 
-   @Override
-   public int xaGetTimeout() {
+   public int xaGetTimeout()
+   {
       return resourceManager.getTimeoutSeconds();
    }
 
-   @Override
-   public void xaSetTimeout(final int timeout) {
+   public void xaSetTimeout(final int timeout)
+   {
       timeoutSeconds = timeout;
-      if (tx != null) {
+      if (tx != null)
+      {
          tx.setTimeout(timeout);
       }
    }
 
-   @Override
-   public void start() {
+   public void start()
+   {
       setStarted(true);
    }
 
-   @Override
-   public void stop() {
+   public void stop()
+   {
       setStarted(false);
    }
 
-   @Override
-   public void waitContextCompletion() {
-      try {
-         if (!context.waitCompletion(10000)) {
+   public void waitContextCompletion()
+   {
+      try
+      {
+         if (!context.waitCompletion(10000))
+         {
             ActiveMQServerLogger.LOGGER.errorCompletingContext(new Exception("warning"));
          }
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
       }
    }
 
-   @Override
-   public void close(final boolean failed) {
-      if (closed)
-         return;
-      context.executeOnCompletion(new IOCallback() {
-         @Override
-         public void onError(int errorCode, String errorMessage) {
+   public void close(final boolean failed)
+   {
+      if (closed) return;
+      context.executeOnCompletion(new IOAsyncTask()
+      {
+         public void onError(int errorCode, String errorMessage)
+         {
          }
 
-         @Override
-         public void done() {
-            try {
+         public void done()
+         {
+            try
+            {
                doClose(failed);
-            } catch (Exception e) {
+            }
+            catch (Exception e)
+            {
                ActiveMQServerLogger.LOGGER.errorClosingSession(e);
             }
          }
       });
    }
 
-   @Override
-   public void closeConsumer(final long consumerID) throws Exception {
-      final ServerConsumer consumer = locateConsumer(consumerID);
+   public void closeConsumer(final long consumerID) throws Exception
+   {
+      final ServerConsumer consumer = consumers.get(consumerID);
 
-      if (consumer != null) {
+      if (consumer != null)
+      {
          consumer.close(false);
-      } else {
+      }
+      else
+      {
          ActiveMQServerLogger.LOGGER.cannotFindConsumer(consumerID);
       }
    }
 
-   @Override
-   public void receiveConsumerCredits(final long consumerID, final int credits) throws Exception {
-      ServerConsumer consumer = locateConsumer(consumerID);
+   public void receiveConsumerCredits(final long consumerID, final int credits) throws Exception
+   {
+      ServerConsumer consumer = consumers.get(consumerID);
 
-      if (consumer == null) {
-         logger.debug("There is no consumer with id " + consumerID);
+      if (consumer == null)
+      {
+         ActiveMQServerLogger.LOGGER.debug("There is no consumer with id " + consumerID);
 
          return;
       }
@@ -1201,109 +1444,99 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    }
 
    @Override
-   public Transaction getCurrentTransaction() {
+   public Transaction getCurrentTransaction()
+   {
+      if (tx == null)
+      {
+         tx = newTransaction();
+      }
       return tx;
    }
 
-   @Override
-   public void sendLarge(final MessageInternal message) throws Exception {
+   public void sendLarge(final MessageInternal message) throws Exception
+   {
       // need to create the LargeMessage before continue
       long id = storageManager.generateID();
 
       LargeServerMessage largeMsg = storageManager.createLargeMessage(id, message);
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("sendLarge::" + largeMsg);
+      if (ActiveMQServerLogger.LOGGER.isTraceEnabled())
+      {
+         ActiveMQServerLogger.LOGGER.trace("sendLarge::" + largeMsg);
       }
 
-      if (currentLargeMessage != null) {
+      if (currentLargeMessage != null)
+      {
          ActiveMQServerLogger.LOGGER.replacingIncompleteLargeMessage(currentLargeMessage.getMessageID());
       }
 
       currentLargeMessage = largeMsg;
    }
 
-   @Override
-   public RoutingStatus send(final ServerMessage message, final boolean direct) throws Exception {
-      return send(message, direct, false);
-   }
-
-   @Override
-   public RoutingStatus send(final ServerMessage message,
-                             final boolean direct,
-                             boolean noAutoCreateQueue) throws Exception {
-      return send(getCurrentTransaction(), message, direct, noAutoCreateQueue);
-   }
-
-   @Override
-   public RoutingStatus send(Transaction tx,
-                             final ServerMessage message,
-                             final boolean direct,
-                             boolean noAutoCreateQueue) throws Exception {
-
-      // If the protocol doesn't support flow control, we have no choice other than fail the communication
-      if (!this.getRemotingConnection().isSupportsFlowControl() && pagingManager.isDiskFull()) {
-         ActiveMQIOErrorException exception = ActiveMQMessageBundle.BUNDLE.diskBeyondLimit();
-         this.getRemotingConnection().fail(exception);
-         throw exception;
-      }
-
-      RoutingStatus result = RoutingStatus.OK;
+   public void send(final ServerMessage message, final boolean direct) throws Exception
+   {
       //large message may come from StompSession directly, in which
       //case the id header already generated.
-      if (!message.isLargeMessage()) {
+      if (!message.isLargeMessage())
+      {
          long id = storageManager.generateID();
 
          message.setMessageID(id);
          message.encodeMessageIDToBuffer();
       }
 
-      if (server.getConfiguration().isPopulateValidatedUser() && validatedUser != null) {
-         message.putStringProperty(Message.HDR_VALIDATED_USER, SimpleString.toSimpleString(validatedUser));
-      }
-
       SimpleString address = message.getAddress();
 
-      if (defaultAddress == null && address != null) {
+      if (defaultAddress == null && address != null)
+      {
          defaultAddress = address;
       }
 
-      if (address == null) {
-         if (message.isDurable()) {
+      if (address == null)
+      {
+         if (message.isDurable())
+         {
             // We need to force a re-encode when the message gets persisted or when it gets reloaded
             // it will have no address
             message.setAddress(defaultAddress);
-         } else {
+         }
+         else
+         {
             // We don't want to force a re-encode when the message gets sent to the consumer
             message.setAddressTransient(defaultAddress);
          }
       }
 
-      if (logger.isTraceEnabled()) {
-         logger.trace("send(message=" + message + ", direct=" + direct + ") being called");
+      if (isTrace)
+      {
+         ActiveMQServerLogger.LOGGER.trace("send(message=" + message + ", direct=" + direct + ") being called");
       }
 
-      if (message.getAddress() == null) {
+      if (message.getAddress() == null)
+      {
          // This could happen with some tests that are ignoring messages
          throw ActiveMQMessageBundle.BUNDLE.noAddress();
       }
 
-      if (message.getAddress().equals(managementAddress)) {
+      if (message.getAddress().equals(managementAddress))
+      {
          // It's a management message
 
-         handleManagementMessage(tx, message, direct);
-      } else {
-         result = doSend(tx, message, direct, noAutoCreateQueue);
+         handleManagementMessage(message, direct);
+      }
+      else
+      {
+         doSend(message, direct);
       }
-      return result;
    }
 
-   @Override
    public void sendContinuations(final int packetSize,
                                  final long messageBodySize,
                                  final byte[] body,
-                                 final boolean continues) throws Exception {
-      if (currentLargeMessage == null) {
+                                 final boolean continues) throws Exception
+   {
+      if (currentLargeMessage == null)
+      {
          throw ActiveMQMessageBundle.BUNDLE.largeMessageNotInitialised();
       }
 
@@ -1312,140 +1545,162 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       currentLargeMessage.addBytes(body);
 
-      if (!continues) {
+      if (!continues)
+      {
          currentLargeMessage.releaseResources();
 
-         if (messageBodySize >= 0) {
+         if (messageBodySize >= 0)
+         {
             currentLargeMessage.putLongProperty(Message.HDR_LARGE_BODY_SIZE, messageBodySize);
          }
 
-         doSend(tx, currentLargeMessage, false, false);
+         doSend(currentLargeMessage, false);
 
          currentLargeMessage = null;
       }
    }
 
-   @Override
-   public void requestProducerCredits(final SimpleString address, final int credits) throws Exception {
+   public void requestProducerCredits(final SimpleString address, final int credits) throws Exception
+   {
       PagingStore store = server.getPagingManager().getPageStore(address);
 
-      if (!store.checkMemory(new Runnable() {
-         @Override
-         public void run() {
+      if (!store.checkMemory(new Runnable()
+      {
+         public void run()
+         {
             callback.sendProducerCreditsMessage(credits, address);
          }
-      })) {
+      }))
+      {
          callback.sendProducerCreditsFailMessage(credits, address);
       }
    }
 
-   @Override
-   public void setTransferring(final boolean transferring) {
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+   public void setTransferring(final boolean transferring)
+   {
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
 
-      for (ServerConsumer consumer : consumersClone) {
+      for (ServerConsumer consumer : consumersClone)
+      {
          consumer.setTransferring(transferring);
       }
    }
 
-   @Override
-   public void addMetaData(String key, String data) {
-      if (metaData == null) {
-         metaData = new HashMap<>();
+   public void addMetaData(String key, String data)
+   {
+      if (metaData == null)
+      {
+         metaData = new HashMap<String, String>();
       }
       metaData.put(key, data);
    }
 
-   @Override
-   public boolean addUniqueMetaData(String key, String data) {
+
+   public boolean addUniqueMetaData(String key, String data)
+   {
       ServerSession sessionWithMetaData = server.lookupSession(key, data);
-      if (sessionWithMetaData != null && sessionWithMetaData != this) {
+      if (sessionWithMetaData != null && sessionWithMetaData != this)
+      {
          // There is a duplication of this property
          return false;
-      } else {
+      }
+      else
+      {
          addMetaData(key, data);
          return true;
       }
    }
 
-   @Override
-   public String getMetaData(String key) {
+   public String getMetaData(String key)
+   {
       String data = null;
-      if (metaData != null) {
+      if (metaData != null)
+      {
          data = metaData.get(key);
       }
 
-      if (key.equals(ClientSession.JMS_SESSION_CLIENT_ID_PROPERTY)) {
+      if (key.equals(ClientSession.JMS_SESSION_CLIENT_ID_PROPERTY))
+      {
          // we know it's a JMS Session, we now install JMS Hooks of any kind
          installJMSHooks();
       }
       return data;
    }
 
-   @Override
-   public String[] getTargetAddresses() {
+   public String[] getTargetAddresses()
+   {
       Map<SimpleString, Pair<UUID, AtomicLong>> copy = cloneTargetAddresses();
       Iterator<SimpleString> iter = copy.keySet().iterator();
       int num = copy.keySet().size();
       String[] addresses = new String[num];
       int i = 0;
-      while (iter.hasNext()) {
+      while (iter.hasNext())
+      {
          addresses[i] = iter.next().toString();
          i++;
       }
       return addresses;
    }
 
-   @Override
-   public String getLastSentMessageID(String address) {
+   public String getLastSentMessageID(String address)
+   {
       Pair<UUID, AtomicLong> value = targetAddressInfos.get(SimpleString.toSimpleString(address));
-      if (value != null) {
+      if (value != null)
+      {
          return value.getA().toString();
-      } else {
+      }
+      else
+      {
          return null;
       }
    }
 
-   @Override
-   public long getCreationTime() {
+   public long getCreationTime()
+   {
       return this.creationTime;
    }
 
-   public StorageManager getStorageManager() {
+   public StorageManager getStorageManager()
+   {
       return this.storageManager;
    }
 
    @Override
-   public void describeProducersInfo(JsonArrayBuilder array) throws Exception {
+   public void describeProducersInfo(JSONArray array) throws Exception
+   {
       Map<SimpleString, Pair<UUID, AtomicLong>> targetCopy = cloneTargetAddresses();
 
-      for (Map.Entry<SimpleString, Pair<UUID, AtomicLong>> entry : targetCopy.entrySet()) {
-         String uuid = null;
-         if (entry.getValue().getA() != null) {
-            uuid = entry.getValue().getA().toString();
-         }
-         JsonObjectBuilder producerInfo = JsonLoader.createObjectBuilder().add("connectionID", this.getConnectionID().toString()).add("sessionID", this.getName()).add("destination", entry.getKey().toString()).add("lastUUIDSent", nullSafe(uuid)).add("msgSent", entry.getValue().getB().longValue());
-         array.add(producerInfo);
+      for (Map.Entry<SimpleString, Pair<UUID, AtomicLong>> entry : targetCopy.entrySet())
+      {
+         JSONObject producerInfo = new JSONObject();
+         producerInfo.put("connectionID", this.getConnectionID().toString());
+         producerInfo.put("sessionID", this.getName());
+         producerInfo.put("destination", entry.getKey().toString());
+         producerInfo.put("lastUUIDSent", entry.getValue().getA());
+         producerInfo.put("msgSent", entry.getValue().getB().longValue());
+         array.put(producerInfo);
       }
    }
 
    @Override
-   public String getValidatedUser() {
-      return validatedUser;
-   }
-
-   @Override
-   public String toString() {
+   public String toString()
+   {
       StringBuffer buffer = new StringBuffer();
-      if (this.metaData != null) {
-         for (Map.Entry<String, String> value : metaData.entrySet()) {
-            if (buffer.length() != 0) {
+      if (this.metaData != null)
+      {
+         for (Map.Entry<String, String> value : metaData.entrySet())
+         {
+            if (buffer.length() != 0)
+            {
                buffer.append(",");
             }
             Object tmpValue = value.getValue();
-            if (tmpValue == null || tmpValue.toString().isEmpty()) {
+            if (tmpValue == null || tmpValue.toString().isEmpty())
+            {
                buffer.append(value.getKey() + "=*N/A*");
-            } else {
+            }
+            else
+            {
                buffer.append(value.getKey() + "=" + tmpValue);
             }
          }
@@ -1460,52 +1715,68 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    // --------------------------------------------------------------------
 
    @Override
-   public void connectionFailed(final ActiveMQException me, boolean failedOver) {
-      try {
+   public void connectionFailed(final ActiveMQException me, boolean failedOver)
+   {
+      try
+      {
          ActiveMQServerLogger.LOGGER.clientConnectionFailed(name);
 
          close(true);
 
          ActiveMQServerLogger.LOGGER.clientConnectionFailedClearingSession(name);
-      } catch (Throwable t) {
+      }
+      catch (Throwable t)
+      {
          ActiveMQServerLogger.LOGGER.errorClosingConnection(this);
       }
    }
 
    @Override
-   public void connectionFailed(final ActiveMQException me, boolean failedOver, String scaleDownTargetNodeID) {
+   public void connectionFailed(final ActiveMQException me, boolean failedOver, String scaleDownTargetNodeID)
+   {
       connectionFailed(me, failedOver);
    }
 
-   public void clearLargeMessage() {
+   public void clearLargeMessage()
+   {
       currentLargeMessage = null;
    }
 
-   private void installJMSHooks() {
-      this.queueCreator = server.getJMSDestinationCreator();
+
+
+   private void installJMSHooks()
+   {
+      this.queueCreator = server.getJMSQueueCreator();
    }
 
-   private Map<SimpleString, Pair<UUID, AtomicLong>> cloneTargetAddresses() {
-      return new HashMap<>(targetAddressInfos);
+
+   private Map<SimpleString, Pair<UUID, AtomicLong>> cloneTargetAddresses()
+   {
+      return new HashMap<SimpleString, Pair<UUID, AtomicLong>>(targetAddressInfos);
    }
 
-   private void setStarted(final boolean s) {
-      Set<ServerConsumer> consumersClone = new HashSet<>(consumers.values());
+   private void setStarted(final boolean s)
+   {
+      Set<ServerConsumer> consumersClone = new HashSet<ServerConsumer>(consumers.values());
 
-      for (ServerConsumer consumer : consumersClone) {
+      for (ServerConsumer consumer : consumersClone)
+      {
          consumer.setStarted(s);
       }
 
       started = s;
    }
 
-   private RoutingStatus handleManagementMessage(final Transaction tx,
-                                                 final ServerMessage message,
-                                                 final boolean direct) throws Exception {
-      try {
-         securityCheck(message.getAddress(), CheckType.MANAGE, this);
-      } catch (ActiveMQException e) {
-         if (!autoCommitSends) {
+   private void handleManagementMessage(final ServerMessage message, final boolean direct) throws Exception
+   {
+      try
+      {
+         securityStore.check(message.getAddress(), CheckType.MANAGE, this);
+      }
+      catch (ActiveMQException e)
+      {
+         if (!autoCommitSends)
+         {
             tx.markAsRollbackOnly(e);
          }
          throw e;
@@ -1515,24 +1786,24 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       SimpleString replyTo = message.getSimpleStringProperty(ClientMessageImpl.REPLYTO_HEADER_NAME);
 
-      if (replyTo != null) {
+      if (replyTo != null)
+      {
          reply.setAddress(replyTo);
 
-         doSend(tx, reply, direct, false);
+         doSend(reply, direct);
       }
-
-      return RoutingStatus.OK;
    }
 
-   private void doRollback(final boolean clientFailed,
-                           final boolean lastMessageAsDelived,
-                           final Transaction theTx) throws Exception {
+   private void doRollback(final boolean clientFailed, final boolean lastMessageAsDelived, final Transaction theTx) throws Exception
+   {
       boolean wasStarted = started;
 
-      List<MessageReference> toCancel = new ArrayList<>();
+      List<MessageReference> toCancel = new ArrayList<MessageReference>();
 
-      for (ServerConsumer consumer : consumers.values()) {
-         if (wasStarted) {
+      for (ServerConsumer consumer : consumers.values())
+      {
+         if (wasStarted)
+         {
             consumer.setStarted(false);
          }
 
@@ -1543,28 +1814,32 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       //after the last tx was rolled back so we should handle them separately. if not they
       //will end up added to the tx but never ever handled even tho they were removed from the consumers delivering refs.
       //we add them to a new tx and roll them back as the calling client will assume that this has happened.
-      if (theTx.getState() == State.ROLLEDBACK) {
+      if (theTx.getState() == State.ROLLEDBACK)
+      {
          Transaction newTX = newTransaction();
          cancelAndRollback(clientFailed, newTX, wasStarted, toCancel);
-      } else {
-         cancelAndRollback(clientFailed, theTx, wasStarted, toCancel);
+         throw new IllegalStateException("Transaction has already been rolled back");
       }
+      cancelAndRollback(clientFailed, theTx, wasStarted, toCancel);
    }
 
-   private void cancelAndRollback(boolean clientFailed,
-                                  Transaction theTx,
-                                  boolean wasStarted,
-                                  List<MessageReference> toCancel) throws Exception {
-      for (MessageReference ref : toCancel) {
+   private void cancelAndRollback(boolean clientFailed, Transaction theTx, boolean wasStarted, List<MessageReference> toCancel) throws Exception
+   {
+      for (MessageReference ref : toCancel)
+      {
          ref.getQueue().cancel(theTx, ref);
       }
       //if we failed don't restart as an attempt to deliver messages may be made before we actually close the consumer
-      if (wasStarted && !clientFailed) {
-         theTx.addOperation(new TransactionOperationAbstract() {
+      if (wasStarted && !clientFailed)
+      {
+         theTx.addOperation(new TransactionOperationAbstract()
+         {
 
             @Override
-            public void afterRollback(Transaction tx) {
-               for (ServerConsumer consumer : consumers.values()) {
+            public void afterRollback(Transaction tx)
+            {
+               for (ServerConsumer consumer : consumers.values())
+               {
                   consumer.setStarted(true);
                }
             }
@@ -1575,59 +1850,81 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       theTx.rollback();
    }
 
-   public RoutingStatus doSend(final Transaction tx,
-                               final ServerMessage msg,
-                               final boolean direct,
-                               final boolean noAutoCreateQueue) throws Exception {
-      RoutingStatus result = RoutingStatus.OK;
+   protected void doSend(final ServerMessage msg, final boolean direct) throws Exception
+   {
       // check the user has write access to this address.
-      try {
-         securityCheck(msg.getAddress(), CheckType.SEND, this);
-      } catch (ActiveMQException e) {
-         if (!autoCommitSends && tx != null) {
+      try
+      {
+         securityStore.check(msg.getAddress(), CheckType.SEND, this);
+      }
+      catch (ActiveMQException e)
+      {
+         if (!autoCommitSends && tx != null)
+         {
             tx.markAsRollbackOnly(e);
          }
          throw e;
       }
 
-      if (tx == null || autoCommitSends) {
-      } else {
+      if (tx == null || autoCommitSends)
+      {
+      }
+      else
+      {
          routingContext.setTransaction(tx);
       }
 
-      try {
-         if (noAutoCreateQueue) {
-            result = postOffice.route(msg, null, routingContext, direct);
-         } else {
-            result = postOffice.route(msg, queueCreator, routingContext, direct);
-         }
+      try
+      {
+         postOffice.route(msg, queueCreator, routingContext, direct);
 
          Pair<UUID, AtomicLong> value = targetAddressInfos.get(msg.getAddress());
 
-         if (value == null) {
-            targetAddressInfos.put(msg.getAddress(), new Pair<>(msg.getUserID(), new AtomicLong(1)));
-         } else {
+         if (value == null)
+         {
+            targetAddressInfos.put(msg.getAddress(), new Pair<UUID, AtomicLong>(msg.getUserID(), new AtomicLong(1)));
+         }
+         else
+         {
             value.setA(msg.getUserID());
             value.getB().incrementAndGet();
          }
-      } finally {
+      }
+      finally
+      {
          routingContext.clear();
       }
-      return result;
    }
 
+
    @Override
-   public List<MessageReference> getInTXMessagesForConsumer(long consumerId) {
-      if (this.tx != null) {
+   public List<MessageReference> getInTXMessagesForConsumer(long consumerId)
+   {
+      if (this.tx != null)
+      {
          RefsOperation oper = (RefsOperation) tx.getProperty(TransactionPropertyIndexes.REFS_OPERATION);
 
-         if (oper == null) {
+         if (oper == null)
+         {
             return Collections.emptyList();
-         } else {
+         }
+         else
+         {
             return oper.getListOnConsumer(consumerId);
          }
-      } else {
+      }
+      else
+      {
          return Collections.emptyList();
       }
    }
+
+   private static class DefaultTransactionFactory implements TransactionFactory
+   {
+      @Override
+      public Transaction newTransaction(Xid xid, StorageManager storageManager, int timeoutSeconds)
+      {
+         return new TransactionImpl(xid, storageManager, timeoutSeconds);
+      }
+   }
 }