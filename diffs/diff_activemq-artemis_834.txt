diff --git a/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java b/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java
index 497448e547..f6fe2676de 100644
--- a/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java
+++ b/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnection.java
@@ -16,15 +16,10 @@
  */
 package org.apache.activemq.artemis.core.remoting.impl.netty;
 
-import java.io.IOException;
-import java.io.RandomAccessFile;
 import java.net.SocketAddress;
-import java.nio.channels.FileChannel;
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Map;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.locks.LockSupport;
+import java.util.Set;
+import java.util.concurrent.Semaphore;
 
 import io.netty.buffer.ByteBuf;
 import io.netty.channel.Channel;
@@ -33,51 +28,53 @@ import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoop;
 import io.netty.handler.ssl.SslHandler;
-import io.netty.handler.stream.ChunkedFile;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
+import org.apache.activemq.artemis.api.core.ActiveMQBuffers;
 import org.apache.activemq.artemis.api.core.ActiveMQInterruptedException;
 import org.apache.activemq.artemis.api.core.TransportConfiguration;
 import org.apache.activemq.artemis.core.buffers.impl.ChannelBufferWrapper;
 import org.apache.activemq.artemis.core.client.ActiveMQClientLogger;
 import org.apache.activemq.artemis.core.security.ActiveMQPrincipal;
 import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
-import org.apache.activemq.artemis.spi.core.remoting.BaseConnectionLifeCycleListener;
 import org.apache.activemq.artemis.spi.core.remoting.Connection;
+import org.apache.activemq.artemis.spi.core.remoting.ConnectionLifeCycleListener;
 import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
-import org.apache.activemq.artemis.utils.Env;
-import org.apache.activemq.artemis.utils.IPV6Util;
-import org.jboss.logging.Logger;
+import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 
 public class NettyConnection implements Connection {
 
-   private static final Logger logger = Logger.getLogger(NettyConnection.class);
+   // Constants -----------------------------------------------------
+   private static final int BATCHING_BUFFER_SIZE = 8192;
 
-   private static final int DEFAULT_BATCH_BYTES = Integer.getInteger("io.netty.batch.bytes", 8192);
-   private static final int DEFAULT_WAIT_MILLIS = 10_000;
+   // Attributes ----------------------------------------------------
 
    protected final Channel channel;
-   private final BaseConnectionLifeCycleListener<?> listener;
+
+   private boolean closed;
+
+   private final ConnectionLifeCycleListener listener;
+
+   private final boolean batchingEnabled;
+
    private final boolean directDeliver;
+
+   private volatile ActiveMQBuffer batchBuffer;
+
    private final Map<String, Object> configuration;
-   /**
-    * if {@link #isWritable(ReadyListener)} returns false, we add a callback
-    * here for when the connection (or Netty Channel) becomes available again.
-    */
-   private final List<ReadyListener> readyListeners = new ArrayList<>();
-   private final ThreadLocal<ArrayList<ReadyListener>> localListenersPool = new ThreadLocal<>();
 
-   private final boolean batchingEnabled;
-   private final int writeBufferHighWaterMark;
-   private final int batchLimit;
+   private final Semaphore writeLock = new Semaphore(1);
+
+   private final Set<ReadyListener> readyListeners = new ConcurrentHashSet<ReadyListener>();
 
-   private boolean closed;
    private RemotingConnection protocolConnection;
 
-   private boolean ready = true;
+   // Static --------------------------------------------------------
+
+   // Constructors --------------------------------------------------
 
    public NettyConnection(final Map<String, Object> configuration,
                           final Channel channel,
-                          final BaseConnectionLifeCycleListener<?> listener,
+                          final ConnectionLifeCycleListener listener,
                           boolean batchingEnabled,
                           boolean directDeliver) {
       this.configuration = configuration;
@@ -86,128 +83,25 @@ public class NettyConnection implements Connection {
 
       this.listener = listener;
 
-      this.directDeliver = directDeliver;
-
       this.batchingEnabled = batchingEnabled;
 
-      this.writeBufferHighWaterMark = this.channel.config().getWriteBufferHighWaterMark();
-
-      this.batchLimit = batchingEnabled ? Math.min(this.writeBufferHighWaterMark, DEFAULT_BATCH_BYTES) : 0;
-   }
-
-   private static void waitFor(ChannelPromise promise, long millis) {
-      try {
-         final boolean completed = promise.await(millis);
-         if (!completed) {
-            ActiveMQClientLogger.LOGGER.timeoutFlushingPacket();
-         }
-      } catch (InterruptedException e) {
-         throw new ActiveMQInterruptedException(e);
-      }
-   }
-
-   /**
-    * Returns an estimation of the current size of the write buffer in the channel.
-    * To obtain a more precise value is necessary to use the unsafe API of the channel to
-    * call the {@link io.netty.channel.ChannelOutboundBuffer#totalPendingWriteBytes()}.
-    * Anyway, both these values are subject to concurrent modifications.
-    */
-   private static int batchBufferSize(Channel channel, int writeBufferHighWaterMark) {
-      //Channel::bytesBeforeUnwritable is performing a volatile load
-      //this is the reason why writeBufferHighWaterMark is passed as an argument
-      final int bytesBeforeUnwritable = (int) channel.bytesBeforeUnwritable();
-      assert bytesBeforeUnwritable >= 0;
-      final int writtenBytes = writeBufferHighWaterMark - bytesBeforeUnwritable;
-      assert writtenBytes >= 0;
-      return writtenBytes;
+      this.directDeliver = directDeliver;
    }
 
-   public final int pendingWritesOnChannel() {
-      return batchBufferSize(this.channel, this.writeBufferHighWaterMark);
-   }
+   // Public --------------------------------------------------------
 
-   public final Channel getNettyChannel() {
+   public Channel getNettyChannel() {
       return channel;
    }
+   // Connection implementation ----------------------------
 
-   @Override
-   public final void setAutoRead(boolean autoRead) {
-      channel.config().setAutoRead(autoRead);
-   }
-
-   @Override
-   public final boolean isWritable(ReadyListener callback) {
-      synchronized (readyListeners) {
-         if (!ready) {
-            readyListeners.add(callback);
-         }
-
-         return ready;
-      }
-   }
-
-   @Override
-   public boolean isOpen() {
-      return channel.isOpen();
-   }
-
-   @Override
-   public final void fireReady(final boolean ready) {
-      ArrayList<ReadyListener> readyToCall = localListenersPool.get();
-      if (readyToCall != null) {
-         localListenersPool.set(null);
-      }
-      synchronized (readyListeners) {
-         this.ready = ready;
-
-         if (ready) {
-            final int size = this.readyListeners.size();
-            if (readyToCall != null) {
-               readyToCall.ensureCapacity(size);
-            }
-            try {
-               for (int i = 0; i < size; i++) {
-                  final ReadyListener readyListener = readyListeners.get(i);
-                  if (readyListener == null) {
-                     break;
-                  }
-                  if (readyToCall == null) {
-                     readyToCall = new ArrayList<>(size);
-                  }
-                  readyToCall.add(readyListener);
-               }
-            } finally {
-               readyListeners.clear();
-            }
-         }
-      }
-      if (readyToCall != null) {
-         try {
-            readyToCall.forEach(readyListener -> {
-               try {
-                  readyListener.readyForWriting();
-               } catch (Throwable logOnly) {
-                  ActiveMQClientLogger.LOGGER.failedToSetChannelReadyForWriting(logOnly);
-               }
-            });
-         } catch (Throwable t) {
-            ActiveMQClientLogger.LOGGER.failedToSetChannelReadyForWriting(t);
-         } finally {
-            readyToCall.clear();
-            if (localListenersPool.get() != null) {
-               localListenersPool.set(readyToCall);
-            }
-         }
-      }
-   }
-
-   @Override
-   public final void forceClose() {
+   public void forceClose() {
       if (channel != null) {
          try {
             channel.close();
-         } catch (Throwable e) {
-            ActiveMQClientLogger.LOGGER.failedForceClose(e);
+         }
+         catch (Throwable e) {
+            ActiveMQClientLogger.LOGGER.warn(e.getMessage(), e);
          }
       }
    }
@@ -217,33 +111,36 @@ public class NettyConnection implements Connection {
     *
     * @return
     */
-   public final Channel getChannel() {
+   public Channel getChannel() {
       return channel;
    }
 
-   @Override
-   public final RemotingConnection getProtocolConnection() {
+   public RemotingConnection getProtocolConnection() {
       return protocolConnection;
    }
 
-   @Override
-   public final void setProtocolConnection(RemotingConnection protocolConnection) {
+   public void setProtocolConnection(RemotingConnection protocolConnection) {
       this.protocolConnection = protocolConnection;
    }
 
-   @Override
-   public final void close() {
+   public void close() {
       if (closed) {
          return;
       }
+
+      final SslHandler sslHandler = (SslHandler) channel.pipeline().get("ssl");
       EventLoop eventLoop = channel.eventLoop();
       boolean inEventLoop = eventLoop.inEventLoop();
       //if we are in an event loop we need to close the channel after the writes have finished
       if (!inEventLoop) {
-         closeChannel(channel, false);
-      } else {
-         eventLoop.execute(() -> {
-            closeChannel(channel, true);
+         closeSSLAndChannel(sslHandler, channel);
+      }
+      else {
+         eventLoop.execute(new Runnable() {
+            @Override
+            public void run() {
+               closeSSLAndChannel(sslHandler, channel);
+            }
          });
       }
 
@@ -252,213 +149,148 @@ public class NettyConnection implements Connection {
       listener.connectionDestroyed(getID());
    }
 
-   @Override
    public ActiveMQBuffer createTransportBuffer(final int size) {
-      try {
-         return new ChannelBufferWrapper(channel.alloc().directBuffer(size), true);
-      } catch (OutOfMemoryError oom) {
-         final long totalPendingWriteBytes = batchBufferSize(this.channel, this.writeBufferHighWaterMark);
-         // I'm not using the ActiveMQLogger framework here, as I wanted the class name to be very specific here
-         logger.warn("Trying to allocate " + size + " bytes, System is throwing OutOfMemoryError on NettyConnection " + this + ", there are currently " + "pendingWrites: [NETTY] -> " + totalPendingWriteBytes + " causes: " + oom.getMessage(), oom);
-         throw oom;
-      }
+      return new ChannelBufferWrapper(PartialPooledByteBufAllocator.INSTANCE.directBuffer(size), true);
    }
 
-   @Override
-   public final Object getID() {
-      return channel.id();
+   public Object getID() {
+      // TODO: Think of it
+      return channel.hashCode();
    }
 
    // This is called periodically to flush the batch buffer
-   @Override
-   public final void checkFlushBatchBuffer() {
-      if (this.batchingEnabled) {
-         //perform the flush only if necessary
-         final int batchBufferSize = batchBufferSize(this.channel, this.writeBufferHighWaterMark);
-         if (batchBufferSize > 0) {
-            this.channel.flush();
+   public void checkFlushBatchBuffer() {
+      if (!batchingEnabled) {
+         return;
+      }
+
+      if (writeLock.tryAcquire()) {
+         try {
+            if (batchBuffer != null && batchBuffer.readable()) {
+               channel.writeAndFlush(batchBuffer.byteBuf());
+
+               batchBuffer = createTransportBuffer(BATCHING_BUFFER_SIZE);
+            }
+         }
+         finally {
+            writeLock.release();
          }
       }
    }
 
-   @Override
-   public final void write(final ActiveMQBuffer buffer) {
+   public void write(final ActiveMQBuffer buffer) {
       write(buffer, false, false);
    }
 
-   @Override
-   public final void write(ActiveMQBuffer buffer, final boolean flush, final boolean batched) {
+   public void write(ActiveMQBuffer buffer, final boolean flush, final boolean batched) {
       write(buffer, flush, batched, null);
    }
 
-   private void checkConnectionState() {
-      if (this.closed || !this.channel.isActive()) {
-         throw new IllegalStateException("Connection " + getID() + " closed or disconnected");
-      }
-   }
+   public void write(ActiveMQBuffer buffer,
+                     final boolean flush,
+                     final boolean batched,
+                     final ChannelFutureListener futureListener) {
 
-   @Override
-   public final boolean blockUntilWritable(final int requiredCapacity, final long timeout, final TimeUnit timeUnit) {
-      checkConnectionState();
-      final boolean isAllowedToBlock = isAllowedToBlock();
-      if (!isAllowedToBlock) {
-
-         if (Env.isTestEnv()) {
-            // this will only show when inside the testsuite.
-            // we may great the log for FAILURE
-            logger.warn("FAILURE! The code is using blockUntilWritable inside a Netty worker, which would block. " +
-                           "The code will probably need fixing!", new Exception("trace"));
-         }
+      try {
+         writeLock.acquire();
 
-         if (logger.isDebugEnabled()) {
-            logger.debug("Calling blockUntilWritable using a thread where it's not allowed");
-         }
-         return canWrite(requiredCapacity);
-      } else {
-         final long timeoutNanos = timeUnit.toNanos(timeout);
-         final long deadline = System.nanoTime() + timeoutNanos;
-         //choose wait time unit size
-         final long parkNanos;
-         //if is requested to wait more than a millisecond than we could use
-         if (timeoutNanos >= 1_000_000L) {
-            parkNanos = 100_000L;
-         } else {
-            //reduce it doesn't make sense, only a spin loop could be enough precise with the most OS
-            parkNanos = 1000L;
-         }
-         boolean canWrite;
-         while (!(canWrite = canWrite(requiredCapacity)) && (System.nanoTime() - deadline) < 0) {
-            //periodically check the connection state
-            checkConnectionState();
-            LockSupport.parkNanos(parkNanos);
-         }
-         return canWrite;
-      }
-   }
+         try {
+            if (batchBuffer == null && batchingEnabled && batched && !flush) {
+               // Lazily create batch buffer
 
-   private boolean isAllowedToBlock() {
-      final EventLoop eventLoop = channel.eventLoop();
-      final boolean inEventLoop = eventLoop.inEventLoop();
-      return !inEventLoop;
-   }
+               batchBuffer = ActiveMQBuffers.dynamicBuffer(BATCHING_BUFFER_SIZE);
+            }
 
-   private boolean canWrite(final int requiredCapacity) {
-      //evaluate if the write request could be taken:
-      //there is enough space in the write buffer?
-      final long totalPendingWrites = this.pendingWritesOnChannel();
-      final boolean canWrite;
-      if (requiredCapacity > this.writeBufferHighWaterMark) {
-         canWrite = totalPendingWrites == 0;
-      } else {
-         canWrite = (totalPendingWrites + requiredCapacity) <= this.writeBufferHighWaterMark;
-      }
-      return canWrite;
-   }
+            if (batchBuffer != null) {
+               batchBuffer.writeBytes(buffer, 0, buffer.writerIndex());
 
-   private Object getFileObject(RandomAccessFile raf, FileChannel fileChannel, long offset, int dataSize) {
-      if (channel.pipeline().get(SslHandler.class) == null) {
-         return new NonClosingDefaultFileRegion(fileChannel, offset, dataSize);
-      } else {
-         try {
-            return new ChunkedFile(raf, offset, dataSize, 8192);
-         } catch (IOException e) {
-            throw new RuntimeException(e);
-         }
-      }
-   }
+               if (batchBuffer.writerIndex() >= BATCHING_BUFFER_SIZE || !batched || flush) {
+                  // If the batch buffer is full or it's flush param or not batched then flush the buffer
 
-   @Override
-   public final void write(ActiveMQBuffer buffer,
-                           final boolean flush,
-                           final boolean batched,
-                           final ChannelFutureListener futureListener) {
-      final int readableBytes = buffer.readableBytes();
-      if (logger.isDebugEnabled()) {
-         final int remainingBytes = this.writeBufferHighWaterMark - readableBytes;
-         if (remainingBytes < 0) {
-            logger.debug("a write request is exceeding by " + (-remainingBytes) + " bytes the writeBufferHighWaterMark size [ " + this.writeBufferHighWaterMark + " ] : consider to set it at least of " + readableBytes + " bytes");
-         }
-      }
-      //no need to lock because the Netty's channel is thread-safe
-      //and the order of write is ensured by the order of the write calls
-      final Channel channel = this.channel;
-      final ChannelPromise promise;
-      if (flush || (futureListener != null)) {
-         promise = channel.newPromise();
-      } else {
-         promise = channel.voidPromise();
-      }
-      final ChannelFuture future;
-      final ByteBuf bytes = buffer.byteBuf();
-      assert readableBytes >= 0;
-      final int writeBatchSize = this.batchLimit;
-      final boolean batchingEnabled = this.batchingEnabled;
-      if (batchingEnabled && batched && !flush && readableBytes < writeBatchSize) {
-         future = writeBatch(bytes, readableBytes, promise);
-      } else {
-         future = channel.writeAndFlush(bytes, promise);
-      }
-      if (futureListener != null) {
-         future.addListener(futureListener);
-      }
-      if (flush) {
-         //NOTE: this code path seems used only on RemotingConnection::disconnect
-         flushAndWait(channel, promise);
-      }
-   }
+                  buffer = batchBuffer;
+               }
+               else {
+                  return;
+               }
 
-   @Override
-   public void write(RandomAccessFile raf,
-                     FileChannel fileChannel,
-                     long offset,
-                     int dataSize,
-                     final ChannelFutureListener futureListener) {
-      final int readableBytes = dataSize;
-      if (logger.isDebugEnabled()) {
-         final int remainingBytes = this.writeBufferHighWaterMark - readableBytes;
-         if (remainingBytes < 0) {
-            logger.debug("a write request is exceeding by " + (-remainingBytes) + " bytes the writeBufferHighWaterMark size [ " + this.writeBufferHighWaterMark + " ] : consider to set it at least of " + readableBytes + " bytes");
-         }
-      }
+               if (!batched || flush) {
+                  batchBuffer = null;
+               }
+               else {
+                  // Create a new buffer
 
-      //no need to lock because the Netty's channel is thread-safe
-      //and the order of write is ensured by the order of the write calls
-      final Channel channel = this.channel;
-      assert readableBytes >= 0;
-      ChannelFuture channelFuture = channel.writeAndFlush(getFileObject(raf, fileChannel, offset, dataSize));
-      if (futureListener != null) {
-         channelFuture.addListener(futureListener);
-      }
-   }
+                  batchBuffer = ActiveMQBuffers.dynamicBuffer(BATCHING_BUFFER_SIZE);
+               }
+            }
+
+            // depending on if we need to flush or not we can use a voidPromise or
+            // use a normal promise
+            final ByteBuf buf = buffer.byteBuf();
+            final ChannelPromise promise;
+            if (flush || futureListener != null) {
+               promise = channel.newPromise();
+            }
+            else {
+               promise = channel.voidPromise();
+            }
+
+            EventLoop eventLoop = channel.eventLoop();
+            boolean inEventLoop = eventLoop.inEventLoop();
+            if (!inEventLoop) {
+               if (futureListener != null) {
+                  channel.writeAndFlush(buf, promise).addListener(futureListener);
+               }
+               else {
+                  channel.writeAndFlush(buf, promise);
+               }
+            }
+            else {
+               // create a task which will be picked up by the eventloop and trigger the write.
+               // This is mainly needed as this method is triggered by different threads for the same channel.
+               // if we not do this we may produce out of order writes.
+               final Runnable task = new Runnable() {
+                  @Override
+                  public void run() {
+                     if (futureListener != null) {
+                        channel.writeAndFlush(buf, promise).addListener(futureListener);
+                     }
+                     else {
+                        channel.writeAndFlush(buf, promise);
+                     }
+                  }
+               };
+               // execute the task on the eventloop
+               eventLoop.execute(task);
+            }
+
+            // only try to wait if not in the eventloop otherwise we will produce a deadlock
+            if (flush && !inEventLoop) {
+               while (true) {
+                  try {
+                     boolean ok = promise.await(10000);
+
+                     if (!ok) {
+                        ActiveMQClientLogger.LOGGER.timeoutFlushingPacket();
+                     }
 
-   private static void flushAndWait(final Channel channel, final ChannelPromise promise) {
-      if (!channel.eventLoop().inEventLoop()) {
-         waitFor(promise, DEFAULT_WAIT_MILLIS);
-      } else {
-         if (logger.isDebugEnabled()) {
-            logger.debug("Calling write with flush from a thread where it's not allowed");
+                     break;
+                  }
+                  catch (InterruptedException e) {
+                     throw new ActiveMQInterruptedException(e);
+                  }
+               }
+            }
+         }
+         finally {
+            writeLock.release();
          }
       }
-   }
-
-   private ChannelFuture writeBatch(final ByteBuf bytes, final int readableBytes, final ChannelPromise promise) {
-      final int batchBufferSize = batchBufferSize(channel, this.writeBufferHighWaterMark);
-      final int nextBatchSize = batchBufferSize + readableBytes;
-      if (nextBatchSize > batchLimit) {
-         //request to flush before writing, to create the chance to make the channel writable again
-         channel.flush();
-         //let netty use its write batching ability
-         return channel.write(bytes, promise);
-      } else if (nextBatchSize == batchLimit) {
-         return channel.writeAndFlush(bytes, promise);
-      } else {
-         //let netty use its write batching ability
-         return channel.write(bytes, promise);
+      catch (InterruptedException e) {
+         throw new ActiveMQInterruptedException(e);
       }
    }
 
-   @Override
-   public final String getRemoteAddress() {
+   public String getRemoteAddress() {
       SocketAddress address = channel.remoteAddress();
       if (address == null) {
          return null;
@@ -466,91 +298,76 @@ public class NettyConnection implements Connection {
       return address.toString();
    }
 
-   @Override
-   public final String getLocalAddress() {
-      SocketAddress address = channel.localAddress();
-      if (address == null) {
-         return null;
-      }
-      return "tcp://" + IPV6Util.encloseHost(address.toString());
+   public boolean isDirectDeliver() {
+      return directDeliver;
    }
 
-   @Override
-   public final boolean isDirectDeliver() {
-      return directDeliver;
+   public void addReadyListener(final ReadyListener listener) {
+      readyListeners.add(listener);
+   }
+
+   public void removeReadyListener(final ReadyListener listener) {
+      readyListeners.remove(listener);
    }
 
    //never allow this
-   @Override
-   public final ActiveMQPrincipal getDefaultActiveMQPrincipal() {
+   public ActiveMQPrincipal getDefaultActiveMQPrincipal() {
       return null;
    }
 
+   void fireReady(final boolean ready) {
+      for (ReadyListener listener : readyListeners) {
+         listener.readyForWriting(ready);
+      }
+   }
+
    @Override
-   public final TransportConfiguration getConnectorConfig() {
+   public TransportConfiguration getConnectorConfig() {
       if (configuration != null) {
          return new TransportConfiguration(NettyConnectorFactory.class.getName(), this.configuration);
-      } else {
+      }
+      else {
          return null;
       }
    }
 
    @Override
-   public final boolean isUsingProtocolHandling() {
+   public boolean isUsingProtocolHandling() {
       return true;
    }
 
+   // Public --------------------------------------------------------
+
    @Override
-   public boolean isSameTarget(TransportConfiguration... configs) {
-      boolean result = false;
-      for (TransportConfiguration cfg : configs) {
-         if (cfg == null) {
-            continue;
-         }
-         if (NettyConnectorFactory.class.getName().equals(cfg.getFactoryClassName())) {
-            if (configuration.get(TransportConstants.PORT_PROP_NAME).equals(cfg.getParams().get(TransportConstants.PORT_PROP_NAME))) {
-               //port same, check host
-               Object hostParam = configuration.get(TransportConstants.HOST_PROP_NAME);
-               if (hostParam != null) {
-                  if (hostParam.equals(cfg.getParams().get(TransportConstants.HOST_PROP_NAME))) {
-                     result = true;
-                     break;
-                  } else {
-                     //check special 'localhost' case
-                     if (isLocalhost((String) configuration.get(TransportConstants.HOST_PROP_NAME)) && isLocalhost((String) cfg.getParams().get(TransportConstants.HOST_PROP_NAME))) {
-                        result = true;
-                        break;
-                     }
-                  }
-               } else if (cfg.getParams().get(TransportConstants.HOST_PROP_NAME) == null) {
-                  result = true;
-                  break;
-               }
-            }
-         }
-      }
-      return result;
+   public String toString() {
+      return super.toString() + "[local= " + channel.localAddress() + ", remote=" + channel.remoteAddress() + "]";
    }
 
-   //here we consider 'localhost' is equivalent to '127.0.0.1'
-   //other values of 127.0.0.x is not and the user makes sure
-   //not to mix use of 'localhost' and '127.0.0.x'
-   private boolean isLocalhost(String hostname) {
-      return "127.0.0.1".equals(hostname) || "localhost".equals(hostname);
-   }
+   // Package protected ---------------------------------------------
 
-   @Override
-   public final String toString() {
-      return super.toString() + "[ID=" + getID() + ", local= " + channel.localAddress() + ", remote=" + channel.remoteAddress() + "]";
-   }
+   // Protected -----------------------------------------------------
+
+   // Private -------------------------------------------------------
+
+   private void closeSSLAndChannel(SslHandler sslHandler, Channel channel) {
+      if (sslHandler != null) {
+         try {
+            ChannelFuture sslCloseFuture = sslHandler.close();
+
+            if (!sslCloseFuture.awaitUninterruptibly(10000)) {
+               ActiveMQClientLogger.LOGGER.timeoutClosingSSL();
+            }
+         }
+         catch (Throwable t) {
+            // ignore
+         }
+      }
 
-   private void closeChannel(final Channel channel, boolean inEventLoop) {
-      checkFlushBatchBuffer();
-      // closing the channel results in closing any sslHandler first; SslHandler#close() was deprecated by netty
       ChannelFuture closeFuture = channel.close();
-      if (!inEventLoop && !closeFuture.awaitUninterruptibly(DEFAULT_WAIT_MILLIS)) {
+      if (!closeFuture.awaitUninterruptibly(10000)) {
          ActiveMQClientLogger.LOGGER.timeoutClosingNettyChannel();
       }
    }
+   // Inner classes -------------------------------------------------
 
 }