diff --git a/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java b/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java
index 199fd0f6be..00f82044e7 100644
--- a/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java
+++ b/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java
@@ -15,6 +15,7 @@
 package edu.uci.ics.asterix.transaction.management.service.logging;
 
 import java.io.File;
+import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.RandomAccessFile;
@@ -27,12 +28,15 @@ import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
 import edu.uci.ics.asterix.transaction.management.exception.ACIDException;
 import edu.uci.ics.asterix.transaction.management.service.logging.IndexLogger.ReusableLogContentObject;
+import edu.uci.ics.asterix.transaction.management.service.logging.LogManager.PageOwnershipStatus;
+import edu.uci.ics.asterix.transaction.management.service.logging.LogManager.PageState;
 import edu.uci.ics.asterix.transaction.management.service.transaction.TransactionContext;
 import edu.uci.ics.asterix.transaction.management.service.transaction.TransactionManagementConstants;
 import edu.uci.ics.asterix.transaction.management.service.transaction.TransactionSubsystem;
@@ -45,9 +49,6 @@ public class LogManager implements ILogManager {
     private final TransactionSubsystem provider;
     private LogManagerProperties logManagerProperties;
     private LogPageFlushThread logPageFlusher;
-    private final int logPageSize;
-    private long statLogSize;
-    private long statLogCount;
 
     /*
      * the array of log pages. The number of log pages is configurable. Pages
@@ -62,7 +63,47 @@ public class LogManager implements ILogManager {
      */
     private int numLogPages;
 
-    private AtomicLong lastFlushedLSN = new AtomicLong(-1);
+    /*
+     * Initially all pages have an owner count of 1 that is the LogManager. When
+     * a transaction requests to write in a log page, the owner count is
+     * incremented. The log manager reserves space in the log page and puts in
+     * the log header but leaves the space for the content and the checksum
+     * (covering the whole log record). When the content has been put, the log
+     * manager computes the checksum and puts it after the content. At this
+     * point, the ownership count is decremented as the transaction is done with
+     * using the page. When a page is requested to be flushed, logPageFlusher
+     * set the count to 0(LOG_FLUSHER: meaning that the page is being flushed)
+     * only if the count is 1(LOG_WRITER: meaning that there is no other 
+     * transactions who own the page to write logs.) After flushing the page, 
+     * logPageFlusher set this count to 1. 
+     */
+    private AtomicInteger[] logPageOwnerCount;
+
+    static class PageOwnershipStatus {
+        public static final int LOG_WRITER = 1;
+        public static final int LOG_FLUSHER = 0;
+    }
+
+    /*
+     * LogPageStatus: A page is either ACTIVE or INACTIVE. The status for each
+     * page is maintained in logPageStatus. A page is ACTIVE when the LogManager 
+     * can allocate space in the page for writing a log record. Initially all 
+     * pages are ACTIVE. As transactions fill up space by writing log records, 
+     * a page may not have sufficient space left for serving a request by a 
+     * transaction. When this happens, the page is flushed to disk by calling
+     * logPageFlusher.requestFlush(). In the requestFlush(), after groupCommitWaitTime,
+     * the page status is set to INACTIVE. Then, there is no more writer on the
+     * page(meaning the corresponding logPageOwnerCount is 1), the page is flushed
+     * by the logPageFlusher and the status is reset to ACTIVE by the logPageFlusher.   
+     */
+    private AtomicInteger[] logPageStatus;
+
+    static class PageState {
+        public static final int INACTIVE = 0;
+        public static final int ACTIVE = 1;
+    }
+
+    private AtomicLong lastFlushedLsn = new AtomicLong(-1);
 
     /*
      * When the transaction eco-system comes to life, the log manager positions
@@ -70,7 +111,7 @@ public class LogManager implements ILogManager {
      * lsn value of the next log record to be written after a system (re)start.
      * The value is zero when the system is starting for the first time.
      */
-    private long startingLSN = 0;
+    private long startingLsn = 0;
 
     /*
      * lsn represents the monotonically increasing long value that can be broken
@@ -85,7 +126,11 @@ public class LogManager implements ILogManager {
     }
 
     public AtomicLong getLastFlushedLsn() {
-        return lastFlushedLSN;
+        return lastFlushedLsn;
+    }
+
+    public AtomicInteger getLogPageStatus(int pageIndex) {
+        return logPageStatus[pageIndex];
     }
 
     public AtomicLong getCurrentLsn() {
@@ -93,60 +138,69 @@ public class LogManager implements ILogManager {
     }
 
     public long incrementLastFlushedLsn(long delta) {
-        return lastFlushedLSN.addAndGet(delta);
+        return lastFlushedLsn.addAndGet(delta);
     }
 
     public LogManager(TransactionSubsystem provider) throws ACIDException {
         this.provider = provider;
-        initLogManagerProperties(this.provider.getId());
-        logPageSize = logManagerProperties.getLogPageSize();
+        initLogManagerProperties(null);
         initLogManager();
-        statLogSize = 0;
-        statLogCount = 0;
     }
 
-    public LogManager(TransactionSubsystem provider, String nodeId) throws ACIDException {
+    public LogManager(TransactionSubsystem provider, LogManagerProperties logConfiguration) throws ACIDException {
         this.provider = provider;
-        initLogManagerProperties(nodeId);
-        logPageSize = logManagerProperties.getLogPageSize();
+        initLogManagerProperties(logConfiguration);
         initLogManager();
-        statLogSize = 0;
-        statLogCount = 0;
     }
 
     /*
      * initialize the log manager properties either from the configuration file
      * on disk or with default values
      */
-    private void initLogManagerProperties(String nodeId) throws ACIDException {
-        LogManagerProperties logProperties = null;
-        InputStream is = null;
-        try {
-            is = this.getClass().getClassLoader()
-                    .getResourceAsStream(TransactionManagementConstants.LogManagerConstants.LOG_CONF_FILE);
-
-            Properties p = new Properties();
-
-            if (is != null) {
-                p.load(is);
-            }
-            logProperties = new LogManagerProperties(p, nodeId);
-
-        } catch (IOException ioe) {
-            if (is != null) {
-                try {
-                    is.close();
-                } catch (IOException e) {
-                    throw new ACIDException("unable to close input stream ", e);
+    private void initLogManagerProperties(LogManagerProperties logConfiguration) throws ACIDException {
+        if (logConfiguration == null) {
+            InputStream is = null;
+            try {
+                File file = new File(TransactionManagementConstants.LogManagerConstants.LOG_CONF_DIR
+                        + File.pathSeparator + TransactionManagementConstants.LogManagerConstants.LOG_CONF_FILE);
+                if (LOGGER.isLoggable(Level.INFO)) {
+                    LOGGER.info("Log Configuration file path is " + file.getAbsolutePath());
+                }
+                if (file.exists()) {
+                    is = new FileInputStream(TransactionManagementConstants.LogManagerConstants.LOG_CONF_DIR
+                            + File.pathSeparator + TransactionManagementConstants.LogManagerConstants.LOG_CONF_FILE);
+                    Properties configuredProperties = new Properties();
+                    configuredProperties.load(is);
+                    logConfiguration = new LogManagerProperties(configuredProperties);
+                } else {
+                    if (LOGGER.isLoggable(Level.INFO)) {
+                        LOGGER.info("Log configuration file not found, using defaults !");
+                    }
+                    Properties configuredProperties = new Properties();
+                    configuredProperties.setProperty(LogManagerProperties.LOG_DIR_KEY,
+                            TransactionManagementConstants.LogManagerConstants.DEFAULT_LOG_DIR + File.separator
+                                    + provider.getId());
+                    logConfiguration = new LogManagerProperties(configuredProperties);
+                }
+            } catch (IOException ioe) {
+                if (is != null) {
+                    try {
+                        is.close();
+                    } catch (IOException e) {
+                        throw new ACIDException("unable to close input stream ", e);
+                    }
                 }
             }
         }
-        logManagerProperties = logProperties;
+        logManagerProperties = logConfiguration;
     }
 
     private void initLogManager() throws ACIDException {
         logRecordHelper = new LogRecordHelper(this);
         numLogPages = logManagerProperties.getNumLogPages();
+        logPageOwnerCount = new AtomicInteger[numLogPages];
+        logPageStatus = new AtomicInteger[numLogPages];
+
         activeTxnCountMaps = new ArrayList<HashMap<TransactionContext, Integer>>(numLogPages);
         for (int i = 0; i < numLogPages; i++) {
             activeTxnCountMaps.add(new HashMap<TransactionContext, Integer>());
@@ -157,12 +211,25 @@ public class LogManager implements ILogManager {
         /*
          * place the log anchor at the end of the last log record written.
          */
-        initLSN();
+        PhysicalLogLocator nextPhysicalLsn = LogUtil.initializeLogAnchor(this);
+        startingLsn = nextPhysicalLsn.getLsn();
+        lastFlushedLsn.set(startingLsn - 1);
+        if (LOGGER.isLoggable(Level.INFO)) {
+            LOGGER.info(" Starting lsn is : " + startingLsn);
+        }
+        lsn.set(startingLsn);
+        /*
+         * initialize meta data for each log page.
+         */
+        for (int i = 0; i < numLogPages; i++) {
+            logPageOwnerCount[i] = new AtomicInteger(PageOwnershipStatus.LOG_WRITER);
+            logPageStatus[i] = new AtomicInteger(PageState.ACTIVE);
+        }
 
         /*
          * initialize the log pages.
          */
-        initializeLogPages(startingLSN);
+        initializeLogPages(nextPhysicalLsn);
 
         /*
          * Instantiate and begin the LogFlusher thread. The Log Flusher thread
@@ -176,7 +243,8 @@ public class LogManager implements ILogManager {
     }
 
     public int getLogPageIndex(long lsnValue) {
-        return (int) (((lsnValue - startingLSN) / logPageSize) % numLogPages);
+        return (int) ((lsnValue - startingLsn) / logManagerProperties.getLogPageSize()) % numLogPages;
+
     }
 
     /*
@@ -185,6 +253,7 @@ public class LogManager implements ILogManager {
      */
     public int getLogFileId(long lsnValue) {
         return (int) ((lsnValue) / logManagerProperties.getLogPartitionSize());
+
     }
 
     /*
@@ -192,7 +261,28 @@ public class LogManager implements ILogManager {
      * record is (to be) placed.
      */
     public int getLogPageOffset(long lsnValue) {
-        return (int) (lsnValue % logPageSize);
+        return (int) (lsnValue - startingLsn) % logManagerProperties.getLogPageSize();
+    }
+
+    /*
+     * a transaction thread under certain scenarios is required to wait until
+     * the page where it has to write a log record becomes available for writing
+     * a log record.
+     */
+    private void waitUntillPageIsAvailableForWritingLog(int pageIndex) throws ACIDException {
+        if (logPageStatus[pageIndex].get() == PageState.ACTIVE
+                && logPageOwnerCount[pageIndex].get() >= PageOwnershipStatus.LOG_WRITER) {
+            return;
+        }
+        try {
+            synchronized (logPages[pageIndex]) {
+                while (!(logPageStatus[pageIndex].get() == PageState.ACTIVE && logPageOwnerCount[pageIndex].get() >= PageOwnershipStatus.LOG_WRITER)) {
+                    logPages[pageIndex].wait();
+                }
+            }
+        } catch (InterruptedException e) {
+            throw new ACIDException(" thread interrupted while waiting for page " + pageIndex + " to be available ", e);
+        }
     }
 
     /*
@@ -206,44 +296,38 @@ public class LogManager implements ILogManager {
      * @param logType: the type of log record.
      */
     private long getLsn(int entrySize, byte logType) throws ACIDException {
+        long pageSize = logManagerProperties.getLogPageSize();
 
         while (true) {
             boolean forwardPage = false;
             long old = lsn.get();
 
-            // get the log page corresponding to the current lsn value
+            //get the log page corresponding to the current lsn value
             int pageIndex = getLogPageIndex(old);
             long retVal = old;
 
-            // the lsn value for the next request if the current request is
-            // served.
+            // the lsn value for the next request if the current request is served.
             long next = old + entrySize;
             int prevPage = -1;
 
-            // check if the log record will cross page boundaries, a case that
-            // is not allowed.
-            if ((next - 1) / logPageSize != old / logPageSize || (next % logPageSize == 0)) {
-
-                if ((old != 0 && old % logPageSize == 0)) {
-                    // On second thought, this shall never be the case as it
-                    // means that the lsn is
-                    // currently at the beginning of a page and we still need to
-                    // forward the page which
-                    // means that the entrySize exceeds a log page size. If this
-                    // is the case, an
-                    // exception is thrown before calling this API. would remove
-                    // this case.
+            // check if the log  record will cross page boundaries, a case that is not allowed.
+            if ((next - 1) / pageSize != old / pageSize || (next % pageSize == 0)) {
+
+                if ((old != 0 && old % pageSize == 0)) {
+                    // On second thought, this shall never be the case as it means that the lsn is
+                    // currently at the beginning of a page and we still need to forward the page which
+                    // means that the entrySize exceeds a log page size. If this is the case, an
+                    // exception is thrown before calling this API. would remove this case.
                     retVal = old;
 
                 } else {
                     // set the lsn to point to the beginning of the next page.
-                    retVal = ((old / logPageSize) + 1) * logPageSize;
+                    retVal = ((old / pageSize) + 1) * pageSize;
                 }
 
                 next = retVal;
 
-                // as the log record shall cross log page boundary, we must
-                // re-assign the lsn so
+                // as the log record shall cross log page boundary, we must re-assign the lsn so
                 // that the log record begins on a different location.
                 forwardPage = true;
 
@@ -251,18 +335,27 @@ public class LogManager implements ILogManager {
                 pageIndex = getNextPageInSequence(pageIndex);
             }
 
+            /*
+             * we do not want to keep allocating LSNs if the corresponding page
+             * is unavailable. Consider a scenario when the log flusher thread
+             * is incredibly slow in flushing pages. Transaction threads will
+             * acquire an lsn each for writing their next log record. When a
+             * page has been made available, mulltiple transaction threads that
+             * were waiting can continue to write their log record at the
+             * assigned LSNs. Two transaction threads may get LSNs that are on
+             * the same log page but actually differ by the size of the log
+             * buffer. This would be erroneous. Transaction threads are made to
+             * wait upfront for avoiding this situation.
+             */
+            waitUntillPageIsAvailableForWritingLog(pageIndex);
+
             if (!lsn.compareAndSet(old, next)) {
-                // Atomic call -> returns true only when the value represented
-                // by lsn is same as
+                // Atomic call -> returns true only when the value represented by lsn is same as
                 // "old". The value is updated to "next".
                 continue;
             }
 
             if (forwardPage) {
-
-                // forward the nextWriteOffset in the log page
-                logPages[pageIndex].setBufferNextWriteOffset(logPageSize);
-
                 addFlushRequest(prevPage, old, false);
 
                 // The transaction thread that discovers the need to forward a
@@ -270,18 +363,19 @@ public class LogManager implements ILogManager {
                 continue;
 
             } else {
-                logPages[pageIndex].acquireReadLatch();
+                // the transaction thread has been given a space in a log page,
+                // but is made to wait until the page is available.
+                // (Is this needed? when does this wait happen?)
+                waitUntillPageIsAvailableForWritingLog(pageIndex);
+
                 // increment the counter as the transaction thread now holds a
                 // space in the log page and hence is an owner.
-                logPages[pageIndex].incRefCnt();
-                logPages[pageIndex].releaseReadLatch();
-
-                // Before the count is incremented, if the flusher flushed the
-                // allocated page,
-                // then retry to get new LSN. Otherwise, the log with allocated
-                // lsn will be lost.
-                if (lastFlushedLSN.get() >= retVal) {
-                    logPages[pageIndex].decRefCnt();
+                logPageOwnerCount[pageIndex].incrementAndGet();
+
+                // Before the count is incremented, if the flusher flushed the allocated page, 
+                // then retry to get new LSN. Otherwise, the log with allocated lsn will be lost. 
+                if (lastFlushedLsn.get() >= retVal) {
+                    logPageOwnerCount[pageIndex].decrementAndGet();
                     continue;
                 }
             }
@@ -298,8 +392,7 @@ public class LogManager implements ILogManager {
         HashMap<TransactionContext, Integer> map = null;
         int activeTxnCount;
 
-        // logLocator is a re-usable object that is appropriately set in each
-        // invocation.
+        // logLocator is a re-usable object that is appropriately set in each invocation. 
         // If the reference is null, the log manager must throw an exception.
         if (logicalLogLocator == null) {
             throw new ACIDException(
@@ -311,18 +404,17 @@ public class LogManager implements ILogManager {
         int totalLogSize = logRecordHelper.getLogRecordSize(logType, logContentSize);
 
         // check for the total space requirement to be less than a log page.
-        if (totalLogSize > logPageSize) {
+        if (totalLogSize > logManagerProperties.getLogPageSize()) {
             throw new ACIDException(
                     " Maximum Log Content Size is "
-                            + (logPageSize - logRecordHelper.getLogHeaderSize(LogType.UPDATE) - logRecordHelper
+                            + (logManagerProperties.getLogPageSize() - logRecordHelper.getLogHeaderSize(LogType.UPDATE) - logRecordHelper
                                     .getLogChecksumSize()));
         }
 
         // all constraints checked and we are good to go and acquire a lsn.
         long previousLSN = -1;
 
-        // the will be set to the location (a long value) where the log record
-        // needs to be placed.
+        // the will be set to the location (a long value) where the log record needs to be placed.
         long currentLSN;
 
         // The logs written by a transaction need to be linked to each other for
@@ -348,8 +440,7 @@ public class LogManager implements ILogManager {
          * performed correctly that is ownership is released.
          */
 
-        // indicates if the transaction thread has release ownership of the
-        // page.
+        // indicates if the transaction thread has release ownership of the page.
         boolean decremented = false;
 
         int pageIndex = (int) getLogPageIndex(currentLSN);
@@ -369,9 +460,8 @@ public class LogManager implements ILogManager {
             // content in the correct region of the allocated space.
             logicalLogLocator.increaseMemoryOffset(logRecordHelper.getLogHeaderSize(logType));
 
-            // a COMMIT log record does not have any content and hence
-            // the logger (responsible for putting the log content) is not
-            // invoked.
+            // a COMMIT log record does not have any content and hence 
+            // the logger (responsible for putting the log content) is not invoked.
             if (logContentSize != 0) {
                 logger.preLog(txnCtx, reusableLogContentObject);
             }
@@ -397,21 +487,15 @@ public class LogManager implements ILogManager {
             logPages[pageIndex].writeLong(pageOffset + logRecordHelper.getLogHeaderSize(logType) + logContentSize,
                     checksum);
 
-            // forward the nextWriteOffset in the log page
-            int bufferNextWriteOffset = (int) ((currentLSN + totalLogSize) % logPageSize);
-            if (bufferNextWriteOffset == 0) {
-                bufferNextWriteOffset = logPageSize;
+            if (IS_DEBUG_MODE) {
+                System.out.println("--------------> LSN(" + currentLSN + ") is written");
             }
-            logPages[pageIndex].setBufferNextWriteOffset(bufferNextWriteOffset);
 
-            if (logType != LogType.ENTITY_COMMIT) {
-                // release the ownership as the log record has been placed in
-                // created space.
-                logPages[pageIndex].decRefCnt();
+            // release the ownership as the log record has been placed in created space.
+            logPageOwnerCount[pageIndex].decrementAndGet();
 
-                // indicating that the transaction thread has released ownership
-                decremented = true;
-            }
+            // indicating that the transaction thread has released ownership
+            decremented = true;
 
             if (logType == LogType.ENTITY_COMMIT) {
                 map = activeTxnCountMaps.get(pageIndex);
@@ -422,42 +506,18 @@ public class LogManager implements ILogManager {
                 } else {
                     map.put(txnCtx, 1);
                 }
-                //------------------------------------------------------------------------------
-                // [Notice]
-                // reference count should be decremented 
-                // after activeTxnCount is incremented, but before addFlushRequest() is called. 
-                //------------------------------------------------------------------------------
-                // release the ownership as the log record has been placed in
-                // created space.
-                logPages[pageIndex].decRefCnt();
-
-                // indicating that the transaction thread has released ownership
-                decremented = true;
-                
                 addFlushRequest(pageIndex, currentLSN, false);
             } else if (logType == LogType.COMMIT) {
-
                 addFlushRequest(pageIndex, currentLSN, true);
-                if (IS_DEBUG_MODE) {
-                    System.out.println("Running sum of log size: " + statLogSize + ", log count: " + statLogCount);
-                }
             }
 
-            if (IS_DEBUG_MODE) {
-                System.out.println("--------------> LSN(" + currentLSN + ") is written");
-            }
-
-            //collect statistics
-            statLogSize += totalLogSize;
-            statLogCount++;
-
         } catch (Exception e) {
             e.printStackTrace();
             throw new ACIDException(txnCtx, "Thread: " + Thread.currentThread().getName()
                     + " logger encountered exception", e);
         } finally {
             if (!decremented) {
-                logPages[pageIndex].decRefCnt();
+                logPageOwnerCount[pageIndex].decrementAndGet();
             }
         }
     }
@@ -466,17 +526,24 @@ public class LogManager implements ILogManager {
      * This method resets the log page and is called by the log flusher thread
      * after a page has been flushed to disk.
      */
-    public void resetLogPage(long lsn, long nextWritePosition, int pageIndex) throws IOException {
+    public void resetLogPage(long nextWritePosition, int pageIndex) throws IOException {
 
-        String filePath = LogUtil.getLogFilePath(logManagerProperties, getLogFileId(lsn));
+        String filePath = LogUtil.getLogFilePath(logManagerProperties, getLogFileId(nextWritePosition));
 
-        logPages[pageIndex].reset(filePath, LogUtil.getFileOffset(this, nextWritePosition), logPageSize);
+        logPages[pageIndex].reset(filePath, LogUtil.getFileOffset(this, nextWritePosition),
+                logManagerProperties.getLogPageSize());
+    }
+
+    @Override
+    public ILogCursor readLog(ILogFilter logFilter) throws ACIDException {
+        LogCursor cursor = new LogCursor(this, logFilter);
+        return cursor;
     }
 
     @Override
     public ILogCursor readLog(PhysicalLogLocator physicalLogLocator, ILogFilter logFilter) throws IOException,
             ACIDException {
-        LogCursor cursor = new LogCursor(this, physicalLogLocator, logFilter, logPageSize);
+        LogCursor cursor = new LogCursor(this, physicalLogLocator, logFilter);
         return cursor;
     }
 
@@ -486,17 +553,14 @@ public class LogManager implements ILogManager {
     private void readDiskLog(long lsnValue, LogicalLogLocator logicalLogLocator) throws ACIDException {
         String filePath = LogUtil.getLogFilePath(logManagerProperties, LogUtil.getFileId(this, lsnValue));
         long fileOffset = LogUtil.getFileOffset(this, lsnValue);
-
-        ByteBuffer buffer = ByteBuffer.allocate(logPageSize);
+        ByteBuffer buffer = ByteBuffer.allocate(logManagerProperties.getLogPageSize());
         RandomAccessFile raf = null;
-        FileChannel fileChannel = null;
         try {
             raf = new RandomAccessFile(filePath, "r");
-            fileChannel = raf.getChannel();
-            fileChannel.position(fileOffset);
+            raf.seek(fileOffset);
+            FileChannel fileChannel = raf.getChannel();
             fileChannel.read(buffer);
             buffer.position(0);
-
             byte logType = buffer.get(4);
             int logHeaderSize = logRecordHelper.getLogHeaderSize(logType);
             int logBodySize = buffer.getInt(logHeaderSize - 4);
@@ -514,19 +578,16 @@ public class LogManager implements ILogManager {
                 throw new ACIDException(" invalid log record at lsn " + lsnValue);
             }
         } catch (Exception fnfe) {
-            fnfe.printStackTrace();
             throw new ACIDException(" unable to retrieve log record with lsn " + lsnValue + " from the file system",
                     fnfe);
         } finally {
             try {
-                if (fileChannel != null) {
-                    fileChannel.close();
-                } else if (raf != null) {
+                if (raf != null) {
                     raf.close();
                 }
             } catch (IOException ioe) {
                 ioe.printStackTrace();
-                throw new ACIDException(" exception in closing a file: " + filePath, ioe);
+                throw new ACIDException(" exception in closing " + raf, ioe);
             }
         }
     }
@@ -534,30 +595,27 @@ public class LogManager implements ILogManager {
     @Override
     public void readLog(long lsnValue, LogicalLogLocator logicalLogLocator) throws ACIDException {
         byte[] logRecord = null;
-
-        if (lsnValue >= lsn.get()) {
+        //long lsnValue = physicalLogLocator.getLsn();
+        if (lsnValue > lsn.get()) {
             throw new ACIDException(" invalid lsn " + lsnValue);
         }
 
         /* check if the log record in the log buffer or has reached the disk. */
-        if (isMemoryRead(lsnValue)) {
+        if (lsnValue > getLastFlushedLsn().get()) {
             int pageIndex = getLogPageIndex(lsnValue);
             int pageOffset = getLogPageOffset(lsnValue);
 
-            // TODO
-            // minimize memory allocation overhead. current code allocates the
-            // log page size per reading a log record.
+            //TODO
+            //minimize memory allocation overhead. current code allocates the log page size per reading a log record.
 
-            byte[] pageContent = new byte[logPageSize];
+            byte[] pageContent = new byte[logManagerProperties.getLogPageSize()];
 
-            // take a lock on the log page so that the page is not flushed to
-            // disk interim
+            // take a lock on the log page so that the page is not flushed to disk interim
             synchronized (logPages[pageIndex]) {
 
-                // need to check again (this thread may have got de-scheduled
-                // and must refresh!)
+                // need to check again (this thread may have got de-scheduled and must refresh!)
+                if (lsnValue > getLastFlushedLsn().get()) {
 
-                if (isMemoryRead(lsnValue)) {
                     // get the log record length
                     logPages[pageIndex].getBytes(pageContent, 0, pageContent.length);
                     byte logType = pageContent[pageOffset + 4];
@@ -593,90 +651,39 @@ public class LogManager implements ILogManager {
         readDiskLog(lsnValue, logicalLogLocator);
     }
 
-    public boolean isMemoryRead(long currentLSN) {
-        long flushLSN = lastFlushedLSN.get();
-        if ((flushLSN + 1) % logPageSize == 0) {
-            return false;
-        }
-        long logPageBeginOffset = flushLSN - (flushLSN % logPageSize);
-        long logPageEndOffset = logPageBeginOffset + logPageSize;
-        if (currentLSN > flushLSN || (currentLSN >= logPageBeginOffset && currentLSN < logPageEndOffset)) {
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    public void renewLogFiles() throws ACIDException {
-        List<String> logFileNames = LogUtil.getLogFiles(logManagerProperties);
-        for (String name : logFileNames) {
-            File file = new File(LogUtil.getLogFilePath(logManagerProperties, Long.parseLong(name)));
-            if (!file.delete()) {
-                throw new ACIDException("Failed to delete a file: " + name);
-            }
-        }
-        closeLogPages();
-        initLSN();
-        openLogPages();
-        logPageFlusher.renew();
-    }
-
-    private void initLSN() throws ACIDException {
-        PhysicalLogLocator nextPhysicalLsn = LogUtil.initializeLogAnchor(this);
-        startingLSN = nextPhysicalLsn.getLsn();
-        lastFlushedLSN.set(startingLSN - 1);
-        if (LOGGER.isLoggable(Level.INFO)) {
-            LOGGER.info(" Starting lsn is : " + startingLSN);
-        }
-        lsn.set(startingLSN);
-    }
-
-    private void closeLogPages() throws ACIDException {
-        for (int i = 0; i < numLogPages; i++) {
-            try {
-                logPages[i].close();
-            } catch (IOException e) {
-                throw new ACIDException(e);
-            }
-        }
-    }
-
-    private void openLogPages() throws ACIDException {
-        try {
-            String filePath = LogUtil.getLogFilePath(logManagerProperties, LogUtil.getFileId(this, startingLSN));
-            for (int i = 0; i < numLogPages; i++) {
-                logPages[i].open(filePath, LogUtil.getFileOffset(this, startingLSN) + i * logPageSize, logPageSize);
-            }
-        } catch (Exception e) {
-            throw new ACIDException(Thread.currentThread().getName() + " unable to create log buffer", e);
-        }
-    }
-
     @Override
     public ILogRecordHelper getLogRecordHelper() {
         return logRecordHelper;
     }
 
+    /*
+     * This method shall be called by the Buffer manager when it needs to evict
+     * a page from the cache. TODO: Change the implementation from a looping
+     * logic to event based when log manager support is integrated with the
+     * Buffer Manager.
+     */
+    @Override
+    public synchronized void flushLog(LogicalLogLocator logicalLogLocator) throws ACIDException {
+        if (logicalLogLocator.getLsn() > lsn.get()) {
+            throw new ACIDException(" invalid lsn " + logicalLogLocator.getLsn());
+        }
+        while (lastFlushedLsn.get() < logicalLogLocator.getLsn());
+    }
+
     /*
      * Map each log page to cover a physical byte range over a log file. When a
      * page is flushed, the page contents are put to disk in the corresponding
      * byte range.
      */
-    private void initializeLogPages(long beginLsn) throws ACIDException {
+    private void initializeLogPages(PhysicalLogLocator physicalLogLocator) throws ACIDException {
         try {
-            String filePath = LogUtil.getLogFilePath(logManagerProperties, LogUtil.getFileId(this, beginLsn));
-            long nextDiskWriteOffset = LogUtil.getFileOffset(this, beginLsn);
-            long nextBufferWriteOffset = nextDiskWriteOffset % logPageSize;
-            long bufferBeginOffset = nextDiskWriteOffset - nextBufferWriteOffset;
-
+            String filePath = LogUtil.getLogFilePath(logManagerProperties,
+                    LogUtil.getFileId(this, physicalLogLocator.getLsn()));
             for (int i = 0; i < numLogPages; i++) {
-                logPages[i] = FileUtil.getFileBasedBuffer(filePath, bufferBeginOffset + i * logPageSize, logPageSize,
-                        logManagerProperties.getDiskSectorSize());
-                if (i == 0) {
-                    logPages[i].setBufferLastFlushOffset((int) nextBufferWriteOffset);
-                    logPages[i].setBufferNextWriteOffset((int) nextBufferWriteOffset);
-                    logPages[i].setDiskNextWriteOffset(nextDiskWriteOffset);
-                }
+                logPages[i] = FileUtil.getFileBasedBuffer(
+                        filePath,
+                        LogUtil.getFileOffset(this, physicalLogLocator.getLsn()) + i
+                                * logManagerProperties.getLogPageSize(), logManagerProperties.getLogPageSize());
             }
         } catch (Exception e) {
             e.printStackTrace();
@@ -704,6 +711,10 @@ public class LogManager implements ILogManager {
         return logPages[pageIndex];
     }
 
+    public AtomicInteger getLogPageOwnershipCount(int pageIndex) {
+        return logPageOwnerCount[pageIndex];
+    }
+
     public IFileBasedBuffer[] getLogPages() {
         return logPages;
     }
@@ -765,9 +776,8 @@ class LogPageFlushThread extends Thread {
      */
     private final LinkedBlockingQueue<Object>[] flushRequestQueue;
     private final Object[] flushRequests;
-    private int flushPageIndex;
+    private int lastFlushedPageIndex;
     private final long groupCommitWaitPeriod;
-    private boolean isRenewRequest;
 
     public LogPageFlushThread(LogManager logManager) {
         this.logManager = logManager;
@@ -779,35 +789,26 @@ class LogPageFlushThread extends Thread {
             flushRequestQueue[i] = new LinkedBlockingQueue<Object>(1);
             flushRequests[i] = new Object();
         }
-        this.flushPageIndex = 0;
+        this.lastFlushedPageIndex = -1;
         groupCommitWaitPeriod = logManager.getLogManagerProperties().getGroupCommitWaitPeriod();
-        isRenewRequest = false;
-    }
-
-    public void renew() {
-        isRenewRequest = true;
-        flushPageIndex = 0;
-        this.interrupt();
-        isRenewRequest = false;
     }
 
     public void requestFlush(int pageIndex, long lsn, boolean isSynchronous) {
         synchronized (logManager.getLogPage(pageIndex)) {
-            // return if flushedLSN >= lsn
+            //return if flushedLSN >= lsn
             if (logManager.getLastFlushedLsn().get() >= lsn) {
                 return;
             }
 
-            // put a new request to the queue only if the request on the page is
-            // not in the queue.
+            //put a new request to the queue only if the request on the page is not in the queue.
             flushRequestQueue[pageIndex].offer(flushRequests[pageIndex]);
 
-            // return if the request is asynchronous
+            //return if the request is asynchronous
             if (!isSynchronous) {
                 return;
             }
 
-            // wait until there is flush.
+            //wait until there is flush.
             boolean isNotified = false;
             while (!isNotified) {
                 try {
@@ -822,94 +823,83 @@ class LogPageFlushThread extends Thread {
 
     @Override
     public void run() {
-        int logPageSize = logManager.getLogManagerProperties().getLogPageSize();
-        int logBufferSize = logManager.getLogManagerProperties().getLogBufferSize();
-        int beforeFlushOffset = 0;
-        int afterFlushOffset = 0;
-        boolean resetFlushPageIndex = false;
-
         while (true) {
             try {
+                int pageToFlush = logManager.getNextPageInSequence(lastFlushedPageIndex);
+
                 // A wait call on the linkedBLockingQueue. The flusher thread is
                 // notified when an object is added to the queue. Please note
                 // that each page has an associated blocking queue.
-                try {
-                    flushRequestQueue[flushPageIndex].take();
-                } catch (InterruptedException ie) {
-                    while (isRenewRequest) {
-                        sleep(1);
+                flushRequestQueue[pageToFlush].take();
+
+                synchronized (logManager.getLogPage(pageToFlush)) {
+
+                    // lock the internal state of the log manager and create a
+                    // log file if necessary.
+                    int prevLogFileId = logManager.getLogFileId(logManager.getLastFlushedLsn().get());
+                    int nextLogFileId = logManager.getLogFileId(logManager.getLastFlushedLsn().get()
+                            + logManager.getLogManagerProperties().getLogPageSize());
+                    if (prevLogFileId != nextLogFileId) {
+                        String filePath = LogUtil.getLogFilePath(logManager.getLogManagerProperties(), nextLogFileId);
+                        FileUtil.createFileIfNotExists(filePath);
+                        logManager.getLogPage(pageToFlush).reset(
+                                LogUtil.getLogFilePath(logManager.getLogManagerProperties(), nextLogFileId), 0,
+                                logManager.getLogManagerProperties().getLogPageSize());
                     }
-                    continue;
-                }
 
-                //if the log page is already full, don't wait. 
-                if (logManager.getLogPage(flushPageIndex).getBufferNextWriteOffset() < logPageSize
-                        - logManager.getLogRecordHelper().getCommitLogSize()) {
-                    // #. sleep for the groupCommitWaitTime
+                    //#. sleep during the groupCommitWaitTime
                     sleep(groupCommitWaitPeriod);
-                }
 
-                synchronized (logManager.getLogPage(flushPageIndex)) {
-                    logManager.getLogPage(flushPageIndex).acquireWriteLatch();
-                    try {
+                    //#. set the logPageStatus to INACTIVE in order to prevent other txns from writing on this page.
+                    logManager.getLogPageStatus(pageToFlush).set(PageState.INACTIVE);
 
-                        // #. need to wait until the reference count reaches 0
-                        while (logManager.getLogPage(flushPageIndex).getRefCnt() != 0) {
-                            sleep(0);
-                        }
+                    //#. need to wait until the logPageOwnerCount reaches 1 (LOG_WRITER) 
+                    //   meaning every one has finished writing logs on this page.
+                    while (logManager.getLogPageOwnershipCount(pageToFlush).get() != PageOwnershipStatus.LOG_WRITER) {
+                        sleep(0);
+                    }
 
-                        beforeFlushOffset = logManager.getLogPage(flushPageIndex).getBufferLastFlushOffset();
+                    //#. set the logPageOwnerCount to 0 (LOG_FLUSHER)
+                    //   meaning it is flushing. 
+                    logManager.getLogPageOwnershipCount(pageToFlush).set(PageOwnershipStatus.LOG_FLUSHER);
 
-                        // put the content to disk (the thread still has a lock on the log page)
-                        logManager.getLogPage(flushPageIndex).flush();
+                    // put the content to disk (the thread still has a lock on the log page)
+                    logManager.getLogPage(pageToFlush).flush();
 
-                        afterFlushOffset = logManager.getLogPage(flushPageIndex).getBufferLastFlushOffset();
+                    // increment the last flushed lsn and lastFlushedPage
+                    logManager.incrementLastFlushedLsn(logManager.getLogManagerProperties().getLogPageSize());
+                    lastFlushedPageIndex = pageToFlush;
 
-                        // increment the last flushed lsn
-                        logManager.incrementLastFlushedLsn(afterFlushOffset - beforeFlushOffset);
+                    // decrement activeTxnCountOnIndexes
+                    logManager.decrementActiveTxnCountOnIndexes(pageToFlush);
 
-                        // increment currentLSN if currentLSN is less than flushLSN.
-                        if (logManager.getLastFlushedLsn().get() + 1 > logManager.getCurrentLsn().get()) {
-                            logManager.getCurrentLsn().set(logManager.getLastFlushedLsn().get() + 1);
-                        }
-                        
-                        // Map the log page to a new region in the log file if the flushOffset reached the logPageSize
-                        if (afterFlushOffset == logPageSize) {
-                            long diskNextWriteOffset = logManager.getLogPages()[flushPageIndex].getDiskNextWriteOffset()
-                                    + logBufferSize;
-                            logManager.resetLogPage(logManager.getLastFlushedLsn().get() + 1 + logBufferSize,
-                                    diskNextWriteOffset, flushPageIndex);
-                            resetFlushPageIndex = true;
-                        }
-                        
-                        // decrement activeTxnCountOnIndexes
-                        logManager.decrementActiveTxnCountOnIndexes(flushPageIndex);
+                    // reset the count to 1
+                    logManager.getLogPageOwnershipCount(pageToFlush).set(PageOwnershipStatus.LOG_WRITER);
 
-                    } finally {
-                        logManager.getLogPage(flushPageIndex).releaseWriteLatch();
-                    }
+                    // Map the log page to a new region in the log file.
+                    long nextWritePosition = logManager.getLogPages()[pageToFlush].getNextWritePosition()
+                            + logManager.getLogManagerProperties().getLogBufferSize();
 
-                    // #. checks the queue whether there is another flush
-                    // request on the same log buffer
-                    // If there is another request, then simply remove it.
-                    if (flushRequestQueue[flushPageIndex].peek() != null) {
-                        flushRequestQueue[flushPageIndex].take();
-                    }
+                    logManager.resetLogPage(nextWritePosition, pageToFlush);
 
-                    // notify all waiting (transaction) threads.
-                    logManager.getLogPage(flushPageIndex).notifyAll();
+                    // mark the page as ACTIVE
+                    logManager.getLogPageStatus(pageToFlush).set(LogManager.PageState.ACTIVE);
 
-                    if (resetFlushPageIndex) {
-                        flushPageIndex = logManager.getNextPageInSequence(flushPageIndex);
-                        resetFlushPageIndex = false;
+                    //#. checks the queue whether there is another flush request on the same log buffer
+                    //   If there is another request, then simply remove it.
+                    if (flushRequestQueue[pageToFlush].peek() != null) {
+                        flushRequestQueue[pageToFlush].take();
                     }
+
+                    // notify all waiting (transaction) threads.
+                    logManager.getLogPage(pageToFlush).notifyAll();
                 }
             } catch (IOException ioe) {
                 ioe.printStackTrace();
                 throw new Error(" exception in flushing log page", ioe);
             } catch (InterruptedException e) {
                 e.printStackTrace();
-                break;
+                break; 
             }
         }
     }