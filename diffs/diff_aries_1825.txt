diff --git a/blueprint/blueprint-core/src/main/java/org/apache/aries/blueprint/container/BeanRecipe.java b/blueprint/blueprint-core/src/main/java/org/apache/aries/blueprint/container/BeanRecipe.java
index 6c1168b67..b077f4c90 100644
--- a/blueprint/blueprint-core/src/main/java/org/apache/aries/blueprint/container/BeanRecipe.java
+++ b/blueprint/blueprint-core/src/main/java/org/apache/aries/blueprint/container/BeanRecipe.java
@@ -18,104 +18,36 @@
  */
 package org.apache.aries.blueprint.container;
 
-import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
-
 import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Semaphore;
-import java.util.concurrent.atomic.AtomicReference;
 
 import org.apache.aries.blueprint.BeanProcessor;
-import org.apache.aries.blueprint.ComponentDefinitionRegistry;
-import org.apache.aries.blueprint.Interceptor;
+import org.apache.aries.blueprint.ExtendedBlueprintContainer;
 import org.apache.aries.blueprint.di.AbstractRecipe;
 import org.apache.aries.blueprint.di.Recipe;
-import org.apache.aries.blueprint.proxy.Collaborator;
-import org.apache.aries.blueprint.proxy.ProxyUtils;
-import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
 import org.apache.aries.blueprint.utils.ReflectionUtils;
-import org.apache.aries.blueprint.utils.ReflectionUtils.PropertyDescriptor;
-import org.apache.aries.proxy.UnableToProxyException;
-import org.osgi.framework.Bundle;
-import org.osgi.framework.BundleContext;
-import org.osgi.framework.FrameworkUtil;
-import org.osgi.service.blueprint.container.ComponentDefinitionException;
+import static org.apache.aries.blueprint.utils.ReflectionUtils.getRealCause;
 import org.osgi.service.blueprint.container.ReifiedType;
-import org.osgi.service.blueprint.reflect.BeanMetadata;
+import org.osgi.service.blueprint.container.ComponentDefinitionException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
  * A <code>Recipe</code> to create POJOs.
  *
+ * @author <a href="mailto:dev@geronimo.apache.org">Apache Geronimo Project</a>
  * @version $Rev$, $Date$
  */
 public class BeanRecipe extends AbstractRecipe {
-	
-	static class UnwrapperedBeanHolder {
-		final Object unwrapperedBean;
-		final BeanRecipe recipe;
-		
-		public UnwrapperedBeanHolder(Object unwrapperedBean, BeanRecipe recipe) {
-			this.unwrapperedBean = unwrapperedBean;
-			this.recipe = recipe;
-		}
-	}
-
-    public class VoidableCallable implements Callable<Object>, Voidable {
-
-        private final AtomicReference<Object> ref = new AtomicReference<Object>();
-        
-        private final Semaphore sem = new Semaphore(1);
-        
-        private final ThreadLocal<Object> deadlockDetector = new ThreadLocal<Object>();
-        
-        public void voidReference() {
-            ref.set(null);
-        }
-
-        public Object call() throws ComponentDefinitionException {
-            Object o = ref.get();
-            
-            if (o == null) {
-                if(deadlockDetector.get() != null) {
-                    deadlockDetector.remove();
-                    throw new ComponentDefinitionException("Construction cycle detected for bean " + name);
-                }
-                
-                sem.acquireUninterruptibly();
-                try {
-                    o = ref.get();
-                    if (o == null) {
-                        deadlockDetector.set(this);
-                        try {
-                            o = internalCreate2();
-                            ref.set(o);
-                        } finally {
-                            deadlockDetector.remove();
-                        }
-                    }
-                } finally {
-                  sem.release();
-                }
-            }
-            
-            return o;
-        }
-
-    }
 
     private static final Logger LOGGER = LoggerFactory.getLogger(BeanRecipe.class);
 
@@ -132,15 +64,12 @@ public class BeanRecipe extends AbstractRecipe {
     private List<Object> arguments;
     private List<String> argTypes;
     private boolean reorderArguments;
-    private final boolean allowsFieldInjection;
-    private BeanMetadata interceptorLookupKey;
-    
 
-    public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type, boolean allowsFieldInjection) {
+
+    public BeanRecipe(String name, ExtendedBlueprintContainer blueprintContainer, Object type) {
         super(name);
         this.blueprintContainer = blueprintContainer;
         this.type = type;
-        this.allowsFieldInjection = allowsFieldInjection;
     }
 
     public Object getProperty(String name) {
@@ -199,10 +128,6 @@ public class BeanRecipe extends AbstractRecipe {
         this.explicitDependencies = explicitDependencies;
     }
 
-    public void setInterceptorLookupKey(BeanMetadata metadata) {
-    	interceptorLookupKey = metadata;
-    }
-    
     @Override
     public List<Recipe> getConstructorDependencies() {
         List<Recipe> recipes = new ArrayList<Recipe>();
@@ -274,18 +199,6 @@ public class BeanRecipe extends AbstractRecipe {
         if (factory != null) {
             // look for instance method on factory object
             Object factoryObj = factory.create();
-            
-            // If the factory is a service reference, we need to get hold of the actual proxy for the service
-            if (factoryObj instanceof ReferenceRecipe.ServiceProxyWrapper) {
-                try {
-                    factoryObj = ((ReferenceRecipe.ServiceProxyWrapper) factoryObj).convert(new ReifiedType(Object.class));
-                } catch (Exception e) {
-                    throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
-                }
-            } else if (factoryObj instanceof UnwrapperedBeanHolder) {
-            	factoryObj = wrap((UnwrapperedBeanHolder) factoryObj, Object.class);
-            }
-            
             // Map of matching methods
             Map<Method, List<Object>> matches = findMatchingMethods(factoryObj.getClass(), factoryMethod, true, args, argTypes);
             if (matches.size() == 1) {
@@ -293,7 +206,7 @@ public class BeanRecipe extends AbstractRecipe {
                     Map.Entry<Method, List<Object>> match = matches.entrySet().iterator().next();
                     instance = invoke(match.getKey(), factoryObj, match.getValue().toArray());
                 } catch (Throwable e) {
-                    throw new ComponentDefinitionException("Error when instantiating bean " + getName() + " of class " + getType(), getRealCause(e));
+                    throw new ComponentDefinitionException("Error when instanciating bean " + getName() + " of class " + getType(), getRealCause(e));
                 }
             } else if (matches.size() == 0) {
                 throw new ComponentDefinitionException("Unable to find a matching factory method " + factoryMethod + " on class " + factoryObj.getClass().getName() + " for arguments " + args + " when instanciating bean " + getName());
@@ -351,17 +264,8 @@ public class BeanRecipe extends AbstractRecipe {
                 it.remove();
             } else if (instance ^ !Modifier.isStatic(mth.getModifiers())) {
                 it.remove();
-            } else if (mth.isBridge()) {
-                it.remove();
             }
         }
-        
-        // on some JVMs (J9) hidden static methods are returned by Class.getMethods so we need to weed them out
-        // to reduce ambiguity
-        if (!instance) {
-        	methods = applyStaticHidingRules(methods);
-        }
-        
         // Find a direct match with assignment
         if (matches.size() != 1) {
             Map<Method, List<Object>> nmatches = new HashMap<Method, List<Object>>();
@@ -374,18 +278,12 @@ public class BeanRecipe extends AbstractRecipe {
                         found = false;
                         break;
                     }
-                    //If the arg is an Unwrappered bean then we need to do the assignment check against the
-                    //unwrappered bean itself.
-                    Object arg = args.get(i);
-                    Object argToTest = arg;
-                    if(arg instanceof UnwrapperedBeanHolder)
-                    	argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
-                    if (!AggregateConverter.isAssignable(argToTest, argType)) {
+                    if (!AggregateConverter.isAssignable(args.get(i), argType)) {
                         found = false;
                         break;
                     }
                     try {
-                        match.add(convert(arg, mth.getGenericParameterTypes()[i]));
+                        match.add(convert(args.get(i), mth.getGenericParameterTypes()[i]));
                     } catch (Throwable t) {
                         found = false;
                         break;
@@ -455,49 +353,8 @@ public class BeanRecipe extends AbstractRecipe {
                 matches = nmatches;
             }
         }
-        
         return matches;
     }
-    
-    private static List<Method> applyStaticHidingRules(Collection<Method> methods) {
-    	List<Method> result = new ArrayList<Method>(methods.size());
-    	for (Method m : methods) {
-    		boolean toBeAdded = true;
-
-    		Iterator<Method> it = result.iterator();
-    		inner: while (it.hasNext()) {
-    			Method other = it.next();
-    			if (hasIdenticalParameters(m, other)) {
-    				Class<?> mClass = m.getDeclaringClass();
-    				Class<?> otherClass = other.getDeclaringClass();
-    				
-    				if (mClass.isAssignableFrom(otherClass)) {
-    					toBeAdded = false;
-    					break inner;
-    				} else if (otherClass.isAssignableFrom(mClass)) {
-    					it.remove();
-    				}
-    			}
-    		}
-    		
-    		if (toBeAdded) result.add(m);
-    	}
-    	
-    	return result;
-    }
-    
-    private static boolean hasIdenticalParameters(Method one, Method two) {
-		Class<?>[] oneTypes = one.getParameterTypes();
-		Class<?>[] twoTypes = two.getParameterTypes();
-    	
-		if (oneTypes.length != twoTypes.length) return false;
-		
-		for (int i=0; i<oneTypes.length; i++) {
-			if (!oneTypes[i].equals(twoTypes[i])) return false;
-		}
-		
-		return true;
-    }
 
     private Map<Constructor, List<Object>> findMatchingConstructors(Class type, List<Object> args, List<ReifiedType> types) {
         Map<Constructor, List<Object>> matches = new HashMap<Constructor, List<Object>>();
@@ -521,18 +378,12 @@ public class BeanRecipe extends AbstractRecipe {
                         found = false;
                         break;
                     }
-                    //If the arg is an Unwrappered bean then we need to do the assignment check against the
-                    //unwrappered bean itself.
-                    Object arg = args.get(i);
-                    Object argToTest = arg;
-                    if(arg instanceof UnwrapperedBeanHolder)
-                    	argToTest = ((UnwrapperedBeanHolder)arg).unwrapperedBean;
-                    if (!AggregateConverter.isAssignable(argToTest, argType)) {
+                    if (!AggregateConverter.isAssignable(args.get(i), argType)) {
                         found = false;
                         break;
                     }
                     try {
-                        match.add(convert(arg, cns.getGenericParameterTypes()[i]));
+                        match.add(convert(args.get(i), cns.getGenericParameterTypes()[i]));
                     } catch (Throwable t) {
                         found = false;
                         break;
@@ -626,7 +477,7 @@ public class BeanRecipe extends AbstractRecipe {
      */
     public Method getDestroyMethod(Object instance) throws ComponentDefinitionException {
         Method method = null;        
-        if (instance != null && destroyMethod != null && destroyMethod.length() > 0) {
+        if (destroyMethod != null && destroyMethod.length() > 0) {
             method = ReflectionUtils.getLifecycleMethod(instance.getClass(), destroyMethod);
             if (method == null) {
                 throw new ComponentDefinitionException("Component '" + getName() + "' does not have destroy-method: " + destroyMethod);
@@ -635,167 +486,8 @@ public class BeanRecipe extends AbstractRecipe {
         return method;
     }
     
-    /**
-     * Small helper class, to construct a chain of BeanCreators.
-     * <br> 
-     * Each bean creator in the chain will return a bean that has been 
-     * processed by every BeanProcessor in the chain before it.
-     */
-    private static class BeanCreatorChain implements BeanProcessor.BeanCreator {
-        public enum ChainType{Before,After};
-        private final BeanProcessor.BeanCreator parentBeanCreator;
-        private final BeanProcessor parentBeanProcessor;
-        private final BeanMetadata beanData;
-        private final String beanName;        
-        private final ChainType when;
-        public BeanCreatorChain(BeanProcessor.BeanCreator parentBeanCreator, 
-                                BeanProcessor parentBeanProcessor,
-                                BeanMetadata beanData,
-                                String beanName,
-                                ChainType when){
-            this.parentBeanCreator = parentBeanCreator;
-            this.parentBeanProcessor = parentBeanProcessor;
-            this.beanData = beanData;
-            this.beanName = beanName;
-            this.when = when;
-        }
-
-        public Object getBean() {
-            Object previousBean = parentBeanCreator.getBean();
-            Object processed = null;
-            switch(when){
-                case Before :
-                  processed = parentBeanProcessor.beforeInit(previousBean, beanName, parentBeanCreator, beanData);
-                  break;
-                case After:
-                  processed = parentBeanProcessor.afterInit(previousBean, beanName, parentBeanCreator, beanData);
-                  break;
-            }
-            return processed;
-        }   
-    }
-    
-    private Object runBeanProcPreInit(Object obj){
-        String beanName = getName();
-        BeanMetadata beanData = (BeanMetadata) blueprintContainer
-          .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
-        List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
-        
-        //The start link of the chain, that provides the 
-        //original, unprocessed bean to the head of the chain.
-        BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
-            public Object getBean() {
-                Object obj = getInstance();
-                //getinit, getdestroy, addpartial object don't need calling again.
-                //however, property injection does.
-                setProperties(obj);
-                return obj;
-            }
-        };
-
-        BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
-        for(BeanProcessor processor : processors){
-            obj = processor.beforeInit(obj, getName(), currentCreator, beanData);
-            currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.Before);
-        }
-        return obj;
-    }
-    
-    private void runBeanProcInit(Method initMethod, Object obj){
-        // call init method
-        if (initMethod != null) {
-            try {
-                invoke(initMethod, obj, (Object[]) null);
-            } catch (Throwable t) {
-                throw new ComponentDefinitionException("Unable to intialize bean " + getName(), getRealCause(t));
-            }
-        }   
-    }
-    
-    private Object runBeanProcPostInit(Object obj){
-        String beanName = getName();
-        BeanMetadata beanData = (BeanMetadata) blueprintContainer
-          .getComponentDefinitionRegistry().getComponentDefinition(beanName);        
-        List<BeanProcessor> processors = blueprintContainer.getProcessors(BeanProcessor.class);
-        
-        //The start link of the chain, that provides the 
-        //original, unprocessed bean to the head of the chain.
-        BeanProcessor.BeanCreator initialBeanCreator = new BeanProcessor.BeanCreator() {            
-            public Object getBean() {                                
-                Object obj = getInstance();
-                //getinit, getdestroy, addpartial object don't need calling again.
-                //however, property injection does.
-                setProperties(obj);
-                //as this is the post init chain, new beans need to go thru 
-                //the pre-init chain, and then have init called, before 
-                //being passed along the post-init chain.
-                obj = runBeanProcPreInit(obj);
-                runBeanProcInit(getInitMethod(obj), obj);
-                return obj;
-            }
-        };
-
-        BeanProcessor.BeanCreator currentCreator = initialBeanCreator;
-        for(BeanProcessor processor : processors){
-            obj = processor.afterInit(obj, getName(), currentCreator, beanData);
-            currentCreator = new BeanCreatorChain(currentCreator, processor, beanData, beanName, BeanCreatorChain.ChainType.After);
-        }
-        return obj;
-    }    
-    
-    private Object addInterceptors(final Object original, Collection<Class<?>> requiredInterfaces)
-            throws ComponentDefinitionException {
-
-        Object intercepted = null;
-        if(requiredInterfaces.isEmpty())
-        	requiredInterfaces.add(original.getClass());
-        
-        ComponentDefinitionRegistry reg = blueprintContainer
-                .getComponentDefinitionRegistry();
-        List<Interceptor> interceptors = reg.getInterceptors(interceptorLookupKey);
-        if (interceptors != null && interceptors.size() > 0) {
-            try {
-                Bundle b = FrameworkUtil.getBundle(original.getClass());
-                if (b == null) {
-                    // we have a class from the framework parent, so use our bundle for proxying.
-                    b = blueprintContainer.getBundleContext().getBundle();
-                }
-                intercepted = blueprintContainer.getProxyManager().createInterceptingProxy(b,
-                requiredInterfaces, original, new Collaborator(interceptorLookupKey, interceptors));
-            } catch (org.apache.aries.proxy.UnableToProxyException e) {
-                Bundle b = blueprintContainer.getBundleContext().getBundle();
-                throw new ComponentDefinitionException("Unable to create proxy for bean " + name + " in bundle " + b.getSymbolicName() + " version " + b.getVersion(), e);
-            }
-        } else {
-            intercepted = original;
-        }
-        return intercepted;
-    }
-        
     @Override
     protected Object internalCreate() throws ComponentDefinitionException {
-        if (factory instanceof ReferenceRecipe) {
-            ReferenceRecipe rr = (ReferenceRecipe) factory;
-            if (rr.getProxyChildBeanClasses() != null) {
-                return createProxyBean(rr);
-            }
-        } 
-        return new UnwrapperedBeanHolder(internalCreate2(), this);
-    }
-    
-    private Object createProxyBean(ReferenceRecipe rr) {
-        try {
-            VoidableCallable vc = new VoidableCallable();
-            rr.addVoidableChild(vc);
-            return blueprintContainer.getProxyManager().createDelegatingProxy(
-                blueprintContainer.getBundleContext().getBundle(), rr.getProxyChildBeanClasses(),
-                vc, vc.call());
-        } catch (UnableToProxyException e) {
-            throw new ComponentDefinitionException(e);
-        }
-    }
-    
-    private Object internalCreate2() throws ComponentDefinitionException {
         
         instantiateExplicitDependencies();
 
@@ -814,66 +506,52 @@ public class BeanRecipe extends AbstractRecipe {
 
         // inject properties
         setProperties(obj);
+
+        for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
+            obj = processor.beforeInit(obj, getName());
+        }
         
-        obj = runBeanProcPreInit(obj);
-        
-        runBeanProcInit(initMethod, obj);
-        
-        obj = runBeanProcPostInit(obj);
-        
-        //Replaced by calling wrap on the UnwrapperedBeanHolder
-//        obj = addInterceptors(obj);
+        // call init method
+        if (initMethod != null) {
+            try {
+                invoke(initMethod, obj, null);
+            } catch (Throwable t) {
+                throw new ComponentDefinitionException("Unable to intialize bean " + getName(), getRealCause(t));
+            }
+        }
         
         return obj;
     }
     
-    static Object wrap(UnwrapperedBeanHolder holder, Collection<Class<?>> requiredViews) {
-        return holder.recipe.addInterceptors(holder.unwrapperedBean, requiredViews);
-    }
-    
-    static Object wrap(UnwrapperedBeanHolder holder, Class<?> requiredView) {
-        if(requiredView == Object.class) {
-          //We don't know what we need so we have to do everything
-            return holder.recipe.addInterceptors(holder.unwrapperedBean, new ArrayList<Class<?>>(1));
-        } else {
-        	return holder.recipe.addInterceptors(holder.unwrapperedBean, ProxyUtils.asList(requiredView));
-        }
-    }
-    
-    
-    @Override
-    public void destroy(Object obj) {
-        //This object should *always* be an UnwrapperedBeanHolder, so cast it and get the bean out.
-    	obj = ((UnwrapperedBeanHolder)obj).unwrapperedBean;
-    	
+    public void destroyInstance(Object obj) {
         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
             processor.beforeDestroy(obj, getName());
         }
         try {
             Method method = getDestroyMethod(obj);
             if (method != null) {
-                invoke(method, obj, (Object[]) null);
+                invoke(method, obj, null);
             }
-        } catch (ComponentDefinitionException e) {
-            // This exception occurs if the destroy method does not exist, so we just output the exception message.
-            LOGGER.error(e.getMessage());
-        } catch (InvocationTargetException ite) {
-          Throwable t = ite.getTargetException();
-          BundleContext ctx = blueprintContainer.getBundleContext();
-          Bundle b = ctx.getBundle();
-          String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
-          LOGGER.error("The blueprint bean " + getName() + " in bundle " + bundleIdentifier + " incorrectly threw an exception from its destroy method.", t);
         } catch (Exception e) {
-            BundleContext ctx = blueprintContainer.getBundleContext();
-            Bundle b = ctx.getBundle();
-            String bundleIdentifier = b.getSymbolicName() + '/' + b.getVersion();
-            LOGGER.error("An exception occurred while calling the destroy method of the blueprint bean " + getName() + " in bundle " + bundleIdentifier + ".", getRealCause(e));
+            LOGGER.info("Error invoking destroy method", getRealCause(e));
         }
         for (BeanProcessor processor : blueprintContainer.getProcessors(BeanProcessor.class)) {
             processor.afterDestroy(obj, getName());
         }
     }
 
+    @Override
+    public void destroy(Object instance) {
+        Method method = getDestroyMethod(instance);
+        if (method != null) {
+            try {
+                invoke(method, instance, null);
+            } catch (Throwable e) {
+                LOGGER.info("Error destroying bean " + getName(), getRealCause(e));
+            }
+        }
+    }
+
     public void setProperties(Object instance) throws ComponentDefinitionException {
         // clone the properties so they can be used again
         Map<String,Object> propertyValues = new LinkedHashMap<String,Object>(properties);
@@ -904,10 +582,10 @@ public class BeanRecipe extends AbstractRecipe {
     private void setProperty(Object instance, Class clazz, String propertyName, Object propertyValue) {
         String[] names = propertyName.split("\\.");
         for (int i = 0; i < names.length - 1; i++) {
-            PropertyDescriptor pd = getPropertyDescriptor(clazz, names[i]);
-            if (pd.allowsGet()) {
+            Method getter = getPropertyDescriptor(clazz, names[i]).getGetter();
+            if (getter != null) {
                 try {
-                    instance = pd.get(instance, blueprintContainer);
+                    instance = invoke(getter, instance, null);
                 } catch (Exception e) {
                     throw new ComponentDefinitionException("Error getting property: " + names[i] + " on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName(), getRealCause(e));
                 }
@@ -919,26 +597,37 @@ public class BeanRecipe extends AbstractRecipe {
                 throw new ComponentDefinitionException("No getter for " + names[i] + " property on bean " + getName() + " when setting property " + propertyName + " on class " + clazz.getName());
             }
         }
-        
-        // Instantiate value
-        if (propertyValue instanceof Recipe) {
-            propertyValue = ((Recipe) propertyValue).create();
-        }
-
-        final PropertyDescriptor pd = getPropertyDescriptor(clazz, names[names.length - 1]);
-        if (pd.allowsSet()) {
+        Method setter = getPropertyDescriptor(clazz, names[names.length - 1]).getSetter();
+        if (setter != null) {
+            // convert the value to type of setter/field
+            Type type = setter.getGenericParameterTypes()[0];
+            // Instanciate value
+            if (propertyValue instanceof Recipe) {
+                propertyValue = ((Recipe) propertyValue).create();
+            }
             try {
-                pd.set(instance, propertyValue, blueprintContainer);
+                propertyValue = convert(propertyValue, type);
             } catch (Exception e) {
-                throw new ComponentDefinitionException("Error setting property: " + pd, getRealCause(e));
+                    String valueType = propertyValue == null ? "null" : propertyValue.getClass().getName();
+                String memberType = type instanceof Class ? ((Class) type).getName() : type.toString();
+                throw new ComponentDefinitionException("Unable to convert property value" +
+                        " from " + valueType +
+                        " to " + memberType +
+                        " for injection " + setter, e);
+            }
+            try {
+                // set value
+                invoke(setter, instance, propertyValue);
+            } catch (Exception e) {
+                throw new ComponentDefinitionException("Error setting property: " + setter, getRealCause(e));
             }
         } else {
             throw new ComponentDefinitionException("No setter for " + names[names.length - 1] + " property");
         }
     }
 
-    private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String name) {
-        for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz, allowsFieldInjection)) {
+    private ReflectionUtils.PropertyDescriptor getPropertyDescriptor(Class clazz, String name) {
+        for (ReflectionUtils.PropertyDescriptor pd : ReflectionUtils.getPropertyDescriptors(clazz)) {
             if (pd.getName().equals(name)) {
                 return pd;
             }
@@ -958,8 +647,8 @@ public class BeanRecipe extends AbstractRecipe {
 
     private class ArgumentMatcher {
 
-        private final List<TypeEntry> entries;
-        private final boolean convert;
+        private List<TypeEntry> entries;
+        private boolean convert;
 
         public ArgumentMatcher(Type[] types, boolean convert) {
             entries = new ArrayList<TypeEntry>();
@@ -1011,26 +700,15 @@ public class BeanRecipe extends AbstractRecipe {
                     }
                 } else if (arg != null) {
                     if (convert) {
-                        
-                        if(canConvert(arg, entry.type)) {
-                            try {
-								val = convert(arg, entry.type);
-							} catch (Exception e) {
-								throw new ComponentDefinitionException(e);
-							}
-                        } else { 
+                        try {
+                            // TODO: call canConvert instead of convert()
+                            val = convert(arg, entry.type);
+                        } catch (Throwable t) {
                             continue;
                         }
                     } else {
-                    	UnwrapperedBeanHolder holder = null;
-                        if(arg instanceof UnwrapperedBeanHolder) {
-                        	holder = (UnwrapperedBeanHolder)arg;
-                        	arg = holder.unwrapperedBean;
-                        }
                         if (!AggregateConverter.isAssignable(arg, entry.type)) {
                             continue;
-                        } else if (holder != null) {
-                            val = wrap(holder, entry.type.getRawClass());
                         }
                     }
                 }