diff --git a/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java b/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java
index be42d2fefb..fb10717909 100644
--- a/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java
+++ b/artemis-protocols/artemis-mqtt-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/mqtt/MQTTConnectionManager.java
@@ -6,7 +6,7 @@
  * (the "License"); you may not use this file except in compliance with
  * the License. You may obtain a copy of the License at
  *
- * http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -17,12 +17,6 @@
 
 package org.apache.activemq.artemis.core.protocol.mqtt;
 
-import java.nio.charset.Charset;
-import java.util.Set;
-import java.util.UUID;
-
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufAllocator;
 import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
 import org.apache.activemq.artemis.api.core.client.ActiveMQClient;
 import org.apache.activemq.artemis.core.server.ActiveMQServer;
@@ -32,6 +26,9 @@ import org.apache.activemq.artemis.core.server.impl.ServerSessionImpl;
 import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.artemis.utils.UUIDGenerator;
 
+import java.util.Set;
+import java.util.UUID;
+
 /**
  * MQTTConnectionMananager is responsible for handle Connect and Disconnect packets and any resulting behaviour of these
  * events.
@@ -41,7 +38,7 @@ public class MQTTConnectionManager {
    private MQTTSession session;
 
    //TODO Read in a list of existing client IDs from stored Sessions.
-   public static Set<String> CONNECTED_CLIENTS = new ConcurrentHashSet<>();
+   public static Set<String> CONNECTED_CLIENTS = new ConcurrentHashSet<String>();
 
    private MQTTLogger log = MQTTLogger.LOGGER;
 
@@ -70,18 +67,15 @@ public class MQTTConnectionManager {
          return;
       }
 
-      session.setSessionState(getSessionState(clientId));
+      session.setSessionState(getSessionState(clientId, cleanSession));
+
       ServerSessionImpl serverSession = createServerSession(username, password);
       serverSession.start();
 
       session.setServerSession(serverSession);
-      session.setIsClean(cleanSession);
 
       if (will) {
-         byte[] payload = willMessage.getBytes(Charset.forName("UTF-8"));
-         ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(payload.length);
-         buf.writeBytes(payload);
-         ServerMessage w = MQTTUtil.createServerMessageFromByteBuf(session, willTopic, willRetain, willQosLevel, buf);
+         ServerMessage w = MQTTUtil.createServerMessageFromString(session, willMessage, willTopic, willQosLevel, willRetain);
          session.getSessionState().setWillMessage(w);
       }
 
@@ -102,67 +96,65 @@ public class MQTTConnectionManager {
       String id = UUIDGenerator.getInstance().generateStringUUID();
       ActiveMQServer server = session.getServer();
 
-      ServerSession serverSession = server.createSession(id,
-                                                         username,
-                                                         password,
-                                                         ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE,
-                                                         session.getConnection(),
-                                                         MQTTUtil.SESSION_AUTO_COMMIT_SENDS,
-                                                         MQTTUtil.SESSION_AUTO_COMMIT_ACKS,
-                                                         MQTTUtil.SESSION_PREACKNOWLEDGE,
-                                                         MQTTUtil.SESSION_XA,
-                                                         null,
-                                                         session.getSessionCallback(),
-                                                         MQTTUtil.SESSION_AUTO_CREATE_QUEUE,
-                                                         server.newOperationContext(),
-                                                         session.getProtocolManager().getPrefixes());
+      ServerSession serverSession = server.createSession(id, username, password, ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE, session.getConnection(), MQTTUtil.SESSION_AUTO_COMMIT_SENDS, MQTTUtil.SESSION_AUTO_COMMIT_ACKS, MQTTUtil.SESSION_PREACKNOWLEDGE, MQTTUtil.SESSION_XA, null, session.getSessionCallback(), null, // Session factory
+                                                         MQTTUtil.SESSION_AUTO_CREATE_QUEUE);
       return (ServerSessionImpl) serverSession;
    }
 
-   synchronized void disconnect() {
-      if (session == null) {
-         return;
-      }
-
+   void disconnect() {
       try {
-         session.stop();
-         session.getConnection().destroy();
-
-         if (session.getState().isWill()) {
-            session.getConnectionManager().sendWill();
-         }
-      } catch (Exception e) {
-         log.error("Error disconnecting client: " + e.getMessage());
-      } finally {
-         if (session.getSessionState() != null) {
-            session.getSessionState().setAttached(false);
+         if (session != null && session.getSessionState() != null) {
             String clientId = session.getSessionState().getClientId();
-            if (clientId != null) {
+            if (clientId != null)
                CONNECTED_CLIENTS.remove(clientId);
+
+            if (session.getState().isWill()) {
+               session.getConnectionManager().sendWill();
             }
          }
+         session.stop();
+         session.getConnection().disconnect(false);
+         session.getConnection().destroy();
+      }
+      catch (Exception e) {
+         /* FIXME Failure during disconnect would leave the session state in an unrecoverable state.  We should handle
+         errors more gracefully.
+          */
+         log.error("Error disconnecting client: " + e.getMessage());
       }
    }
 
    private void sendWill() throws Exception {
-      session.getServer().getPostOffice().route(session.getSessionState().getWillMessage(), true);
+      session.getServerSession().send(session.getSessionState().getWillMessage(), true);
       session.getSessionState().deleteWillMessage();
    }
 
-   private MQTTSessionState getSessionState(String clientId) throws InterruptedException {
-      /* [MQTT-3.1.2-6] If CleanSession is set to 1, the Client and Server MUST discard any previous Session and
-       * start a new one  This Session lasts as long as the Network Connection. State data associated with this Session
-       * MUST NOT be reused in any subsequent Session */
-
-      /* [MQTT-3.1.2-4] Attach an existing session if one exists (if cleanSession flag is false) otherwise create
-      a new one. */
-      MQTTSessionState state = MQTTSession.SESSIONS.get(clientId);
-      if (state != null) {
-         return state;
-      } else {
-         state = new MQTTSessionState(clientId);
-         MQTTSession.SESSIONS.put(clientId, state);
-         return state;
+   private MQTTSessionState getSessionState(String clientId, boolean cleanSession) throws InterruptedException {
+      synchronized (MQTTSession.SESSIONS) {
+         /* [MQTT-3.1.2-6] If CleanSession is set to 1, the Client and Server MUST discard any previous Session and
+          * start a new one  This Session lasts as long as the Network Connection. State data associated with this Session
+          * MUST NOT be reused in any subsequent Session */
+         if (cleanSession) {
+            MQTTSession.SESSIONS.remove(clientId);
+            return new MQTTSessionState(clientId);
+         }
+         else {
+            /* [MQTT-3.1.2-4] Attach an existing session if one exists (if cleanSession flag is false) otherwise create
+            a new one. */
+            MQTTSessionState state = MQTTSession.SESSIONS.get(clientId);
+            if (state != null) {
+               // TODO Add a count down latch for handling wait during attached session state.
+               while (state.getAttached()) {
+                  Thread.sleep(1000);
+               }
+               return state;
+            }
+            else {
+               state = new MQTTSessionState(clientId);
+               MQTTSession.SESSIONS.put(clientId, state);
+               return state;
+            }
+         }
       }
    }
 
@@ -171,14 +163,14 @@ public class MQTTConnectionManager {
          // [MQTT-3.1.3-7] [MQTT-3.1.3-6] If client does not specify a client ID and clean session is set to 1 create it.
          if (cleanSession) {
             clientId = UUID.randomUUID().toString();
-         } else {
+         }
+         else {
             // [MQTT-3.1.3-8] Return ID rejected and disconnect if clean session = false and client id is null
             return null;
          }
-      } else if (!CONNECTED_CLIENTS.add(clientId)) {
-         // ^^^ If the client ID is not unique (i.e. it has already registered) then do not accept it.
-
-
+      }
+      // If the client ID is not unique (i.e. it has already registered) then do not accept it.
+      else if (!CONNECTED_CLIENTS.add(clientId)) {
          // [MQTT-3.1.3-9] Return ID Rejected if server rejects the client ID
          return null;
       }