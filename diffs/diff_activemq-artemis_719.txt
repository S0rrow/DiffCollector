diff --git a/artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/ProcessorBase.java b/artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/ProcessorBase.java
index 1c77a522cc..44b291606d 100644
--- a/artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/ProcessorBase.java
+++ b/artemis-commons/src/main/java/org/apache/activemq/artemis/utils/actors/ProcessorBase.java
@@ -17,24 +17,15 @@
 
 package org.apache.activemq.artemis.utils.actors;
 
-import java.util.ArrayList;
-import java.util.List;
 import java.util.Queue;
 import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.concurrent.Executor;
-import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-import java.util.concurrent.locks.LockSupport;
 
-import org.jboss.logging.Logger;
+public abstract class ProcessorBase<T> {
 
-public abstract class ProcessorBase<T> extends HandlerBase {
-
-   private static final Logger logger = Logger.getLogger(ProcessorBase.class);
-
-   public static final int STATE_NOT_RUNNING = 0;
-   public static final int STATE_RUNNING = 1;
-   public static final int STATE_FORCED_SHUTDOWN = 2;
+   private static final int STATE_NOT_RUNNING = 0;
+   private static final int STATE_RUNNING = 1;
 
    protected final Queue<T> tasks = new ConcurrentLinkedQueue<>();
 
@@ -42,13 +33,12 @@ public abstract class ProcessorBase<T> extends HandlerBase {
 
    private final ExecutorTask task = new ExecutorTask();
 
+   private final Object startedGuard = new Object();
+   private volatile boolean started = true;
+
    // used by stateUpdater
    @SuppressWarnings("unused")
-   private volatile int state = STATE_NOT_RUNNING;
-
-   private volatile boolean requestedShutdown = false;
-
-   private volatile boolean started = true;
+   private volatile int state = 0;
 
    private static final AtomicIntegerFieldUpdater<ProcessorBase> stateUpdater = AtomicIntegerFieldUpdater.newUpdater(ProcessorBase.class, "state");
 
@@ -57,26 +47,26 @@ public abstract class ProcessorBase<T> extends HandlerBase {
       @Override
       public void run() {
          do {
-            //if there is no thread active and is not already dead then we run
+            //if there is no thread active then we run
             if (stateUpdater.compareAndSet(ProcessorBase.this, STATE_NOT_RUNNING, STATE_RUNNING)) {
-               enter();
-               try {
-                  T task = tasks.poll();
-                  //while the queue is not empty we process in order
-                  while (task != null && !requestedShutdown) {
-                     //just drain the tasks if has been requested a shutdown to help the shutdown process
-                     if (requestedShutdown) {
-                        tasks.add(task);
-                        break;
+               T task = tasks.poll();
+               //while the queue is not empty we process in order
+
+               // All we care on started, is that a current task is not running as we call shutdown.
+               // for that reason this first run doesn't need to be under any lock
+               while (task != null && started) {
+
+                  // Synchronized here is just to guarantee that a current task is finished before
+                  // the started update can be taken as false
+                  synchronized (startedGuard) {
+                     if (started) {
+                        doTask(task);
                      }
-                     doTask(task);
-                     task = tasks.poll();
                   }
-               } finally {
-                  leave();
-                  //set state back to not running.
-                  stateUpdater.compareAndSet(ProcessorBase.this, STATE_RUNNING, STATE_NOT_RUNNING);
+                  task = tasks.poll();
                }
+               //set state back to not running.
+               stateUpdater.set(ProcessorBase.this, STATE_NOT_RUNNING);
             } else {
                return;
             }
@@ -88,57 +78,13 @@ public abstract class ProcessorBase<T> extends HandlerBase {
       }
    }
 
-   /**
-    * It will shutdown and wait 30 seconds for timeout.
-    */
-   public void shutdown() {
-      shutdown(30, TimeUnit.SECONDS);
-   }
-
-   public void shutdown(long timeout, TimeUnit unit) {
-      started = false;
-
-      if (!inHandler()) {
-         // if it's in handler.. we just return
-         flush(timeout, unit);
-      }
-   }
-
-   /**
-    * It will wait the current execution (if there is one) to finish
-    * but will not complete any further executions
-    */
-   public List<T> shutdownNow() {
-      //alert anyone that has been requested (at least) an immediate shutdown
-      requestedShutdown = true;
-      started = false;
-
-      if (inHandler()) {
-         stateUpdater.set(this, STATE_FORCED_SHUTDOWN);
-      } else {
-         //it could take a very long time depending on the current executing task
-         do {
-            //alert the ExecutorTask (if is running) to just drain the current backlog of tasks
-            final int startState = stateUpdater.get(this);
-            if (startState == STATE_FORCED_SHUTDOWN) {
-               //another thread has completed a forced shutdown
-               break;
-            }
-            if (startState == STATE_RUNNING) {
-               //wait 100 ms to avoid burning CPU while waiting and
-               //give other threads a chance to make progress
-               LockSupport.parkNanos(100_000_000L);
-            }
-         }
-         while (!stateUpdater.compareAndSet(this, STATE_NOT_RUNNING, STATE_FORCED_SHUTDOWN));
-         //this could happen just one time: the forced shutdown state is the last one and
-         //can be set by just one caller.
-         //As noted on the execute method there is a small chance that some tasks would be enqueued
+   /** It will wait the current execution (if there is one) to finish
+    *  but will not complete any further executions */
+   public void shutdownNow() {
+      synchronized (startedGuard) {
+         started = false;
       }
-      ArrayList<T> returnList = new ArrayList<>(tasks);
       tasks.clear();
-
-      return returnList;
    }
 
    protected abstract void doTask(T task);
@@ -151,64 +97,21 @@ public abstract class ProcessorBase<T> extends HandlerBase {
       return stateUpdater.get(this) == STATE_NOT_RUNNING;
    }
 
-   /**
-    * WARNING: This will only flush when all the activity is suspended.
-    * don't expect success on this call if another thread keeps feeding the queue
-    * this is only valid on situations where you are not feeding the queue,
-    * like in shutdown and failover situations.
-    */
-   public final boolean flush(long timeout, TimeUnit unit) {
-      if (stateUpdater.get(this) == STATE_NOT_RUNNING) {
-         // quick test, most of the time it will be empty anyways
-         return true;
-      }
-
-      long timeLimit = System.currentTimeMillis() + unit.toMillis(timeout);
-      try {
-         while (stateUpdater.get(this) == STATE_RUNNING && timeLimit > System.currentTimeMillis()) {
-
-            if (tasks.isEmpty()) {
-               return true;
-            }
-
-            Thread.sleep(10);
-         }
-      } catch (InterruptedException e) {
-         // ignored
+   protected void task(T command) {
+      // There is no need to verify the lock here.
+      // you can only turn of running once
+      if (started) {
+         tasks.add(command);
+         startPoller();
       }
-
-      return stateUpdater.get(this) == STATE_NOT_RUNNING;
    }
 
-   protected void task(T command) {
-      if (!started) {
-         logger.debug("Ordered executor has been shutdown at", new Exception("debug"));
-      }
-      //The shutdown process could finish right after the above check: shutdownNow can drain the remaining tasks
-      tasks.add(command);
-      //cache locally the state to avoid multiple volatile loads
-      final int state = stateUpdater.get(this);
-      if (state == STATE_FORCED_SHUTDOWN) {
-         //help the GC by draining any task just submitted: it help to cover the case of a shutdownNow finished before tasks.add
-         tasks.clear();
-      } else if (state == STATE_NOT_RUNNING) {
-         //startPoller could be deleted but is maintained because is inherited
+   protected void startPoller() {
+      if (stateUpdater.get(this) == STATE_NOT_RUNNING) {
+         //note that this can result in multiple tasks being queued
+         //this is not an issue as the CAS will mean that the second (and subsequent) execution is ignored
          delegate.execute(task);
       }
    }
 
-   /**
-    * Returns the remaining items to be processed.
-    * <p>
-    * This method is safe to be called by different threads and its accuracy is subject to concurrent modifications.<br>
-    * It is meant to be used only for test purposes, because of its {@code O(n)} cost.
-    */
-   public final int remaining() {
-      return tasks.size();
-   }
-
-   public final int status() {
-      return stateUpdater.get(this);
-   }
-
 }