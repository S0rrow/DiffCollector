diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
index 9f1206cab..9b921f918 100755
--- a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
@@ -34,6 +34,7 @@ import org.apache.atlas.model.typedef.AtlasEnumDef;
 import org.apache.atlas.model.typedef.AtlasStructDef;
 import org.apache.atlas.model.typedef.AtlasStructDef.AtlasAttributeDef;
 import org.apache.atlas.repository.Constants;
+import org.apache.atlas.repository.IndexCreationException;
 import org.apache.atlas.repository.IndexException;
 import org.apache.atlas.repository.RepositoryException;
 import org.apache.atlas.repository.graphdb.AtlasCardinality;
@@ -48,20 +49,26 @@ import org.apache.atlas.type.AtlasStructType;
 import org.apache.atlas.type.AtlasType;
 import org.apache.atlas.type.AtlasTypeRegistry;
 import org.apache.atlas.type.AtlasTypeUtil;
+import org.apache.atlas.typesystem.types.AttributeInfo;
+import org.apache.atlas.typesystem.types.ClassType;
+import org.apache.atlas.typesystem.types.DataTypes;
+import org.apache.atlas.typesystem.types.IDataType;
+import org.apache.atlas.typesystem.types.Multiplicity;
+import org.apache.atlas.typesystem.types.StructType;
+import org.apache.atlas.typesystem.types.TraitType;
 import org.apache.commons.collections.CollectionUtils;
 import org.apache.commons.configuration.Configuration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
-import org.springframework.stereotype.Component;
 
 import javax.inject.Inject;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
-import java.util.Set;
+import java.util.Map;
 
 import static org.apache.atlas.model.typedef.AtlasBaseTypeDef.*;
 
@@ -69,8 +76,8 @@ import static org.apache.atlas.model.typedef.AtlasBaseTypeDef.*;
 /**
  * Adds index for properties of a given type when its added before any instances are added.
  */
-@Component
-public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler, TypeDefChangeListener {
+public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler,
+        TypeDefChangeListener {
 
     private static final Logger LOG = LoggerFactory.getLogger(GraphBackedSearchIndexer.class);
     
@@ -87,10 +94,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
     //allows injection of a dummy graph for testing
     private IAtlasGraphProvider provider;
-
-    private boolean     recomputeIndexedKeys = true;
-    private Set<String> vertexIndexKeys      = new HashSet<>();
-
+    
     @Inject
     public GraphBackedSearchIndexer(AtlasTypeRegistry typeRegistry) throws AtlasException {
         this(new AtlasGraphProvider(), ApplicationProperties.get(), typeRegistry);
@@ -106,110 +110,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    /**
-     * Initialize global indices for Titan graph on server activation.
-     *
-     * Since the indices are shared state, we need to do this only from an active instance.
-     */
-    @Override
-    public void instanceIsActive() throws AtlasException {
-        LOG.info("Reacting to active: initializing index");
-        try {
-            initialize();
-        } catch (RepositoryException | IndexException e) {
-            throw new AtlasException("Error in reacting to active on initialization", e);
-        }
-    }
-
-    @Override
-    public void instanceIsPassive() {
-        LOG.info("Reacting to passive state: No action right now.");
-    }
-
-    @Override
-    public int getHandlerOrder() {
-        return HandlerOrder.GRAPH_BACKED_SEARCH_INDEXER.getOrder();
-    }
-
-    @Override
-    public void onChange(ChangedTypeDefs changedTypeDefs) throws AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("Processing changed typedefs {}", changedTypeDefs);
-        }
-        AtlasGraphManagement management = null;
-        try {
-            management = provider.get().getManagementSystem();
-
-            // Update index for newly created types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getCreateTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getCreateTypeDefs()) {
-                    updateIndexForTypeDef(management, typeDef);
-                }
-            }
-
-            // Update index for updated types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getUpdatedTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getUpdatedTypeDefs()) {
-                    updateIndexForTypeDef(management, typeDef);
-                }
-            }
-
-            // Invalidate the property key for deleted types
-            if (CollectionUtils.isNotEmpty(changedTypeDefs.getDeletedTypeDefs())) {
-                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getDeletedTypeDefs()) {
-                    cleanupIndices(management, typeDef);
-                }
-            }
-
-            //Commit indexes
-            commit(management);
-        } catch (RepositoryException | IndexException e) {
-            LOG.error("Failed to update indexes for changed typedefs", e);
-            attemptRollback(changedTypeDefs, management);
-        }
-
-    }
-
-    public Set<String> getVertexIndexKeys() {
-        if (recomputeIndexedKeys) {
-            AtlasGraphManagement management = null;
-
-            try {
-                management = provider.get().getManagementSystem();
-
-                if (management != null) {
-                    AtlasGraphIndex vertexIndex = management.getGraphIndex(Constants.VERTEX_INDEX);
-
-                    if (vertexIndex != null) {
-                        recomputeIndexedKeys = false;
-
-                        Set<String> indexKeys = new HashSet<>();
-
-                        for (AtlasPropertyKey fieldKey : vertexIndex.getFieldKeys()) {
-                            indexKeys.add(fieldKey.getName());
-                        }
-
-                        vertexIndexKeys = indexKeys;
-                    }
-
-                    management.commit();
-                }
-            } catch (Exception excp) {
-                LOG.error("getVertexIndexKeys(): failed to get indexedKeys from graph", excp);
-
-                if (management != null) {
-                    try {
-                        management.rollback();
-                    } catch (Exception e) {
-                        LOG.error("getVertexIndexKeys(): rollback failed", e);
-                    }
-                }
-            }
-        }
-
-        return vertexIndexKeys;
-    }
-
     /**
      * Initializes the indices for the graph - create indices for Global AtlasVertex Keys
      */
@@ -225,20 +125,18 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         AtlasGraphManagement management = graph.getManagementSystem();
 
         try {
-            LOG.info("Creating indexes for graph.");
-
-            if (management.getGraphIndex(Constants.VERTEX_INDEX) == null) {
-                management.createVertexIndex(Constants.VERTEX_INDEX, Constants.BACKING_INDEX, Collections.<AtlasPropertyKey>emptyList());
-
-                LOG.info("Created index {}", Constants.VERTEX_INDEX);
+            if (management.containsPropertyKey(Constants.VERTEX_TYPE_PROPERTY_KEY)) {
+                LOG.info("Global indexes already exist for graph");
+                management.commit();
+                return;
             }
 
-            if (management.getGraphIndex(Constants.EDGE_INDEX) == null) {
-                management.createEdgeIndex(Constants.EDGE_INDEX, Constants.BACKING_INDEX);
-
-                LOG.info("Created index {}", Constants.EDGE_INDEX);
-            }
+            /* This is called only once, which is the first time Atlas types are made indexable .*/
+            LOG.info("Indexes do not exist, Creating indexes for graph.");
 
+            
+            management.createVertexIndex(Constants.VERTEX_INDEX, Constants.BACKING_INDEX, Collections.<AtlasPropertyKey>emptyList());              
+            management.createEdgeIndex(Constants.EDGE_INDEX, Constants.BACKING_INDEX);
 
             // create a composite index for guid as its unique
             createIndexes(management, Constants.GUID_PROPERTY_KEY, String.class, true,
@@ -283,7 +181,8 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
             //Indexes for graph backed type system store
             createTypeStoreIndexes(management);
-
+      
+            
             commit(management);
             LOG.info("Index creation for global keys complete.");
         } catch (Throwable t) {
@@ -291,16 +190,14 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             throw new RepositoryException(t);
         }
     }
+   
 
     private void createFullTextIndex(AtlasGraphManagement management) {
-        if (!management.containsPropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY)) {
-            AtlasPropertyKey fullText =
-                    management.makePropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY, String.class, AtlasCardinality.SINGLE);
+        AtlasPropertyKey fullText =
+                management.makePropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY, String.class, AtlasCardinality.SINGLE);
 
-            management.createFullTextIndex(Constants.FULLTEXT_INDEX, fullText, Constants.BACKING_INDEX);
+        management.createFullTextIndex(Constants.FULLTEXT_INDEX, fullText, Constants.BACKING_INDEX);
 
-            LOG.info("Created index {}", Constants.ENTITY_TEXT_PROPERTY_KEY);
-        }
     }
 
     private void createTypeStoreIndexes(AtlasGraphManagement management) {
@@ -313,6 +210,41 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                 true, true);
     }
 
+    /**
+     * This is upon adding a new type to Store.
+     *
+     * @param dataTypes data type
+     * @throws AtlasException
+     */
+    @Override
+    public void onAdd(Collection<? extends IDataType> dataTypes) throws AtlasException {
+        AtlasGraphManagement management = provider.get().getManagementSystem();
+               
+        for (IDataType dataType : dataTypes) {
+            if (LOG.isDebugEnabled()) {
+                LOG.debug("Creating indexes for type name={}, definition={}", dataType.getName(), dataType.getClass());
+            }
+
+            try {
+                addIndexForType(management, dataType);
+                LOG.info("Index creation for type {} complete", dataType.getName());
+            } catch (Throwable throwable) {
+                LOG.error("Error creating index for type {}", dataType, throwable);
+                //Rollback indexes if any failure
+                rollback(management);
+                throw new IndexCreationException("Error while creating index for type " + dataType, throwable);
+            }
+        }
+
+        //Commit indexes
+        commit(management);
+    }
+
+    @Override
+    public void onChange(Collection<? extends IDataType> dataTypes) throws AtlasException {
+        onAdd(dataTypes);
+    }
+
     private void addIndexForType(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
         if (typeDef instanceof AtlasEnumDef) {
             // Only handle complex types like Struct, Classification and Entity
@@ -346,12 +278,8 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         try {
             AtlasType atlasType = typeRegistry.getType(attribTypeName);
 
-            if (isMapType || isClassificationType(atlasType)) {
+            if (isMapType || isArrayType || isClassificationType(atlasType) || isEntityType(atlasType)) {
                 LOG.warn("Ignoring non-indexable attribute {}", attribTypeName);
-            } if (isArrayType) {
-                createLabelIfNeeded(management, propertyName, attribTypeName);
-            } if (isEntityType(atlasType)) {
-                createEdgeLabel(management, propertyName);
             } else if (isBuiltInType) {
                 createIndexes(management, propertyName, getPrimitiveClass(attribTypeName), isUnique, cardinality, false, isIndexable);
             } else if (isEnumType(atlasType)) {
@@ -365,16 +293,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    private void createLabelIfNeeded(final AtlasGraphManagement management, final String propertyName, final String attribTypeName) {
-        // If any of the referenced typename is of type Entity or Struct then the edge label needs to be created
-        for (String typeName : AtlasTypeUtil.getReferencedTypeNames(attribTypeName)) {
-            if (typeRegistry.getEntityDefByName(typeName) != null || typeRegistry.getStructDefByName(typeName) != null) {
-                // Create the edge label upfront to avoid running into concurrent call issue (ATLAS-2092)
-                createEdgeLabel(management, propertyName);
-            }
-        }
-    }
-
     private boolean isEntityType(AtlasType type) {
         return type instanceof AtlasEntityType;
     }
@@ -432,22 +350,126 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         throw new IllegalArgumentException(String.format("Bad cardinality %s", cardinality));
     }
 
-    private void createEdgeLabel(final AtlasGraphManagement management, final String propertyName) {
-        // Create the edge label upfront to avoid running into concurrent call issue (ATLAS-2092)
-        // ATLAS-2092 addresses this problem by creating the edge label upfront while type creation
-        // which resolves the race condition during the entity creation
-
-        String label = Constants.INTERNAL_PROPERTY_KEY_PREFIX + propertyName;
-
-        org.apache.atlas.repository.graphdb.AtlasEdgeLabel edgeLabel = management.getEdgeLabel(label);
-
-        if (edgeLabel == null) {
-            management.makeEdgeLabel(label);
-
-            LOG.info("Created edge label {} ", label);
+    private void addIndexForType(AtlasGraphManagement management, IDataType dataType) {
+        switch (dataType.getTypeCategory()) {
+        case PRIMITIVE:
+        case ENUM:
+        case ARRAY:
+        case MAP:
+            // do nothing since these are only attributes
+            // and not types like structs, traits or classes
+            break;
+
+        case STRUCT:
+            StructType structType = (StructType) dataType;
+            createIndexForFields(management, structType, structType.fieldMapping().fields);
+            break;
+
+        case TRAIT:
+            TraitType traitType = (TraitType) dataType;
+            createIndexForFields(management, traitType, traitType.fieldMapping().fields);
+            break;
+
+        case CLASS:
+            ClassType classType = (ClassType) dataType;
+            createIndexForFields(management, classType, classType.fieldMapping().fields);
+            break;
+
+        default:
+            throw new IllegalArgumentException("bad data type" + dataType);
+        }
+    }
+
+    private void createIndexForFields(AtlasGraphManagement management, IDataType dataType, Map<String, AttributeInfo> fields) {
+        for (AttributeInfo field : fields.values()) {
+            createIndexForAttribute(management, dataType.getName(), field);
+        }
+    }
+
+    private void createIndexForAttribute(AtlasGraphManagement management, String typeName, AttributeInfo field) {
+        final String propertyName = GraphHelper.encodePropertyKey(typeName + "." + field.name);
+        switch (field.dataType().getTypeCategory()) {
+        case PRIMITIVE:
+            AtlasCardinality cardinality = getCardinality(field.multiplicity);
+            createIndexes(management, propertyName, getPrimitiveClass(field.dataType()), field.isUnique,
+                    cardinality, false, field.isIndexable);
+            break;
+
+        case ENUM:
+            cardinality = getCardinality(field.multiplicity);
+            createIndexes(management, propertyName, String.class, field.isUnique, cardinality, false, field.isIndexable);
+            break;
+
+        case ARRAY:
+        case MAP:
+            // todo - how do we overcome this limitation?
+            // IGNORE: Can only index single-valued property keys on vertices in Mixed Index
+            break;
+
+        case STRUCT:
+            StructType structType = (StructType) field.dataType();
+            createIndexForFields(management, structType, structType.fieldMapping().fields);
+            break;
+
+        case TRAIT:
+            // do nothing since this is NOT contained in other types
+            break;
+
+        case CLASS:
+            // this is only A reference, index the attribute for edge
+            // Commenting this out since we do not need an index for edge here
+            //createEdgeMixedIndex(propertyName);
+            break;
+
+        default:
+            throw new IllegalArgumentException("bad data type" + field.dataType().getName());
+        }
+    }
+
+    private Class getPrimitiveClass(IDataType dataType) {
+        if (dataType == DataTypes.STRING_TYPE) {
+            return String.class;
+        } else if (dataType == DataTypes.SHORT_TYPE) {
+            return Short.class;
+        } else if (dataType == DataTypes.INT_TYPE) {
+            return Integer.class;
+        } else if (dataType == DataTypes.BIGINTEGER_TYPE) {
+            return BigInteger.class;
+        } else if (dataType == DataTypes.BOOLEAN_TYPE) {
+            return Boolean.class;
+        } else if (dataType == DataTypes.BYTE_TYPE) {
+            return Byte.class;
+        } else if (dataType == DataTypes.LONG_TYPE) {
+            return Long.class;
+        } else if (dataType == DataTypes.FLOAT_TYPE) {
+            return Float.class;
+        } else if (dataType == DataTypes.DOUBLE_TYPE) {
+            return Double.class;
+        } else if (dataType == DataTypes.BIGDECIMAL_TYPE) {
+            return BigDecimal.class;
+        } else if (dataType == DataTypes.DATE_TYPE) {
+            //Indexing with date converted to long as of now since Titan is yet to add support for Date type with mixed indexes
+            return Long.class;
+        }
+
+
+        throw new IllegalArgumentException("unknown data type " + dataType);
+    }
+  
+
+    private AtlasCardinality getCardinality(Multiplicity multiplicity) {
+        if (multiplicity == Multiplicity.OPTIONAL || multiplicity == Multiplicity.REQUIRED) {
+            return AtlasCardinality.SINGLE;
+        } else if (multiplicity == Multiplicity.COLLECTION) {
+            return AtlasCardinality.LIST;
+        } else if (multiplicity == Multiplicity.SET) {
+            return AtlasCardinality.SET;
         }
+
+        // todo - default to LIST as this is the most forgiving
+        return AtlasCardinality.LIST;
     }
-
+    
     private AtlasPropertyKey createIndexes(AtlasGraphManagement management, String propertyName, Class propertyClass,
             boolean isUnique, AtlasCardinality cardinality, boolean createCompositeForAttribute,
             boolean createCompositeWithTypeandSuperTypes) {
@@ -457,21 +479,17 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
 
             updateVertexIndex(management, propertyName, propertyClass, cardinality, propertyKey);
-        }
 
-        if (propertyKey != null) {
-            if (createCompositeForAttribute) {
-                createExactMatchIndex(management, propertyClass, propertyKey, isUnique);
-            } else if (createCompositeWithTypeandSuperTypes) {
-                // Index with typename since typename+property key queries need to
-                // speed up
-                createExactMatchIndexWithTypeName(management, propertyClass, propertyKey);
-                createExactMatchIndexWithSuperTypeName(management, propertyClass, propertyKey);
-            }
-        } else {
-            LOG.warn("Index not created for {}: propertyKey is null", propertyName);
         }
 
+        if (createCompositeForAttribute) {
+            createExactMatchIndex(management, propertyClass, propertyKey, isUnique);
+        } else if (createCompositeWithTypeandSuperTypes) {
+            // Index with typename since typename+property key queries need to
+            // speed up
+            createExactMatchIndexWithTypeName(management, propertyClass, propertyKey);
+            createExactMatchIndexWithSuperTypeName(management, propertyClass, propertyKey);
+        }
         return propertyKey;
     }
     
@@ -487,9 +505,9 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         AtlasGraphIndex existingIndex = management.getGraphIndex(propertyName);
         if (existingIndex == null) {
             management.createExactMatchIndex(propertyName, enforceUniqueness, Collections.singletonList(propertyKey));
-
-            LOG.info("Created composite index for property {} of type {}; isUnique={} ", propertyName, propertyClass.getName(), enforceUniqueness);
         }
+
+        LOG.info("Created composite index for property {} of type {}; isUnique={} ", propertyName, propertyClass.getName(), enforceUniqueness);
     }
     
 
@@ -523,6 +541,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         AtlasGraphIndex existingIndex = management.getGraphIndex(indexName);
 
         if (existingIndex == null) {
+            
             List<AtlasPropertyKey> keys = new ArrayList<>(2);
             keys.add(propertyKey);
             keys.add(typePropertyKey);
@@ -556,8 +575,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
     private void commit(AtlasGraphManagement management) throws IndexException {
         try {
             management.commit();
-
-            recomputeIndexedKeys = true;
         } catch (Exception e) {
             LOG.error("Index commit failed", e);
             throw new IndexException("Index commit failed ", e);
@@ -567,14 +584,71 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
     private void rollback(AtlasGraphManagement management) throws IndexException {
         try {
             management.rollback();
-
-            recomputeIndexedKeys = true;
         } catch (Exception e) {
             LOG.error("Index rollback failed ", e);
             throw new IndexException("Index rollback failed ", e);
         }
     }
 
+    /**
+     * Initialize global indices for Titan graph on server activation.
+     *
+     * Since the indices are shared state, we need to do this only from an active instance.
+     */
+    @Override
+    public void instanceIsActive() throws AtlasException {
+        LOG.info("Reacting to active: initializing index");
+        try {
+            initialize();
+        } catch (RepositoryException | IndexException e) {
+            throw new AtlasException("Error in reacting to active on initialization", e);
+        }
+    }
+
+    @Override
+    public void instanceIsPassive() {
+        LOG.info("Reacting to passive state: No action right now.");
+    }
+
+    @Override
+    public void onChange(ChangedTypeDefs changedTypeDefs) throws AtlasBaseException {
+        if (LOG.isDebugEnabled()) {
+            LOG.debug("Processing changed typedefs {}", changedTypeDefs);
+        }
+        AtlasGraphManagement management = null;
+        try {
+            management = provider.get().getManagementSystem();
+
+            // Update index for newly created types
+            if (CollectionUtils.isNotEmpty(changedTypeDefs.getCreateTypeDefs())) {
+                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getCreateTypeDefs()) {
+                    updateIndexForTypeDef(management, typeDef);
+                }
+            }
+
+            // Update index for updated types
+            if (CollectionUtils.isNotEmpty(changedTypeDefs.getUpdatedTypeDefs())) {
+                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getUpdatedTypeDefs()) {
+                    updateIndexForTypeDef(management, typeDef);
+                }
+            }
+
+            // Invalidate the property key for deleted types
+            if (CollectionUtils.isNotEmpty(changedTypeDefs.getDeletedTypeDefs())) {
+                for (AtlasBaseTypeDef typeDef : changedTypeDefs.getDeletedTypeDefs()) {
+                    cleanupIndices(management, typeDef);
+                }
+            }
+
+            //Commit indexes
+            commit(management);
+        } catch (RepositoryException | IndexException e) {
+            LOG.error("Failed to update indexes for changed typedefs", e);
+            attemptRollback(changedTypeDefs, management);
+        }
+
+    }
+
     private void cleanupIndices(AtlasGraphManagement management, AtlasBaseTypeDef typeDef) {
         Preconditions.checkNotNull(typeDef, "Cannot process null typedef");
         if (LOG.isDebugEnabled()) {
@@ -650,4 +724,14 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         addIndexForType(management, typeDef);
         LOG.info("Index creation for type {} complete", typeDef.getName());
     }
+
+    /* Commenting this out since we do not need an index for edge label here
+    private void createEdgeMixedIndex(String propertyName) {
+        EdgeLabel edgeLabel = management.getEdgeLabel(propertyName);
+        if (edgeLabel == null) {
+            edgeLabel = management.makeEdgeLabel(propertyName).make();
+            management.buildEdgeIndex(edgeLabel, propertyName, Direction.BOTH, Order.DEFAULT);
+            LOG.info("Created index for edge label {}", propertyName);
+        }
+    }*/
 }