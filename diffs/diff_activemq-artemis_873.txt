diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java
index b9385bc3e8..50d2ef4773 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java
@@ -16,30 +16,25 @@
  */
 package org.apache.activemq.artemis.protocol.amqp.proton;
 
-import java.nio.ByteBuffer;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import java.util.concurrent.atomic.AtomicBoolean;
-import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.activemq.artemis.api.core.ActiveMQExceptionType;
+import org.apache.activemq.artemis.api.core.ActiveMQQueueExistsException;
 import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
 import org.apache.activemq.artemis.api.core.Message;
 import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.message.LargeBodyReader;
 import org.apache.activemq.artemis.core.persistence.OperationContext;
 import org.apache.activemq.artemis.core.server.AddressQueryResult;
 import org.apache.activemq.artemis.core.server.Consumer;
 import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
-import org.apache.activemq.artemis.core.server.ServerConsumer;
-import org.apache.activemq.artemis.core.server.impl.ServerConsumerImpl;
 import org.apache.activemq.artemis.jms.client.ActiveMQDestination;
-import org.apache.activemq.artemis.protocol.amqp.broker.AMQPLargeMessage;
 import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessage;
 import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;
 import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;
@@ -51,36 +46,38 @@ import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPNotFound
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPResourceLimitExceededException;
 import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolMessageBundle;
 import org.apache.activemq.artemis.protocol.amqp.proton.transaction.ProtonTransactionImpl;
-import org.apache.activemq.artemis.protocol.amqp.util.NettyReadable;
 import org.apache.activemq.artemis.reader.MessageUtil;
 import org.apache.activemq.artemis.selector.filter.FilterException;
 import org.apache.activemq.artemis.selector.impl.SelectorParser;
-import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
+import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.artemis.utils.CompositeAddress;
 import org.apache.qpid.proton.amqp.DescribedType;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Modified;
 import org.apache.qpid.proton.amqp.messaging.Outcome;
+import org.apache.qpid.proton.amqp.messaging.Rejected;
+import org.apache.qpid.proton.amqp.messaging.Released;
 import org.apache.qpid.proton.amqp.messaging.Source;
 import org.apache.qpid.proton.amqp.messaging.TerminusDurability;
 import org.apache.qpid.proton.amqp.messaging.TerminusExpiryPolicy;
 import org.apache.qpid.proton.amqp.transaction.TransactionalState;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
-import org.apache.qpid.proton.amqp.transport.DeliveryState.DeliveryStateType;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
 import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
 import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
-import org.apache.qpid.proton.codec.ReadableBuffer;
 import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.EndpointState;
 import org.apache.qpid.proton.engine.Link;
 import org.apache.qpid.proton.engine.Sender;
 import org.jboss.logging.Logger;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+
 /**
- * This is the Equivalent for the ServerConsumer
+ * TODO: Merge {@link ProtonServerSenderContext} and {@link org.apache.activemq.artemis.protocol.amqp.client.ProtonClientSenderContext} once we support 'global' link names. The split is a workaround for outgoing links
  */
 public class ProtonServerSenderContext extends ProtonInitializable implements ProtonDeliveryHandler {
 
@@ -92,10 +89,8 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    private static final Symbol SHARED = Symbol.valueOf("shared");
    private static final Symbol GLOBAL = Symbol.valueOf("global");
 
-   private final ConnectionFlushIOCallback connectionFlusher = new ConnectionFlushIOCallback();
-
    private Consumer brokerConsumer;
-   private ReadyListener onflowControlReady;
+
    protected final AMQPSessionContext protonSession;
    protected final Sender sender;
    protected final AMQPConnectionContext connection;
@@ -108,26 +103,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    private boolean shared = false;
    private boolean global = false;
    private boolean isVolatile = false;
-   private boolean preSettle;
-   private SimpleString tempQueueName;
-   private final AtomicBoolean draining = new AtomicBoolean(false);
-
-   // once a large message is accepted, we shouldn't accept any further messages
-   // as large message could be interrupted due to flow control and resumed at the same message
-   volatile boolean hasLarge = false;
-   volatile LargeMessageDeliveryContext pendingLargeMessage = null;
-
-
-   private int credits = 0;
-
-   private AtomicInteger pending = new AtomicInteger(0);
-   /**
-    * The model proton uses requires us to hold a lock in certain times
-    * to sync the credits we have versus the credits that are being held in proton
-    * */
-   private final Object creditsLock = new Object();
-   private final java.util.function.Consumer<? super MessageReference> executeDelivery;
-   private final boolean amqpTreatRejectAsUnmodifiedDeliveryFailed;
+   private String tempQueueName;
 
    public ProtonServerSenderContext(AMQPConnectionContext connection,
                                     Sender sender,
@@ -138,9 +114,6 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       this.sender = sender;
       this.protonSession = protonSession;
       this.sessionSPI = server;
-      this.executeDelivery = this::executeDelivery;
-      amqpTreatRejectAsUnmodifiedDeliveryFailed = this.connection.getProtocolManager()
-                                                                 .isAmqpTreatRejectAsUnmodifiedDeliveryFailed();
    }
 
    public Object getBrokerConsumer() {
@@ -149,56 +122,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
 
    @Override
    public void onFlow(int currentCredits, boolean drain) {
-      connection.requireInHandler();
-
-      setupCredit();
-
-      ServerConsumerImpl serverConsumer = (ServerConsumerImpl) brokerConsumer;
-      if (drain) {
-         // If the draining is already running, then don't do anything
-         if (draining.compareAndSet(false, true)) {
-            final ProtonServerSenderContext plugSender = (ProtonServerSenderContext) serverConsumer.getProtocolContext();
-            serverConsumer.forceDelivery(1, new Runnable() {
-               @Override
-               public void run() {
-                  try {
-                     connection.runNow(() -> {
-                        plugSender.reportDrained();
-                        setupCredit();
-                     });
-                  } finally {
-                     draining.set(false);
-                  }
-               }
-            });
-         }
-      } else {
-         serverConsumer.receiveCredits(-1);
-      }
-   }
-
-   public boolean hasCredits() {
-      if (hasLarge) {
-         // we will resume accepting once the large message is finished
-         return false;
-      }
-
-      if (!connection.flowControl(onflowControlReady)) {
-         return false;
-      }
-
-      synchronized (creditsLock) {
-         return credits > 0 && sender.getLocalState() != EndpointState.CLOSED;
-      }
-   }
-
-   private void setupCredit() {
-      synchronized (creditsLock) {
-         this.credits = sender.getCredit() - pending.get();
-         if (credits < 0) {
-            credits = 0;
-         }
-      }
+      sessionSPI.onFlowConsumer(brokerConsumer, currentCredits, drain);
    }
 
    public Sender getSender() {
@@ -234,7 +158,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       super.initialise();
 
       Source source = (Source) sender.getRemoteSource();
-      SimpleString queue = null;
+      String queue = null;
       String selector = null;
       final Map<Symbol, Object> supportedFilters = new HashMap<>();
 
@@ -276,7 +200,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          // the lifetime policy and capabilities of the new subscription.
          if (result.isExists()) {
             source = new org.apache.qpid.proton.amqp.messaging.Source();
-            source.setAddress(queue.toString());
+            source.setAddress(queue);
             source.setDurable(TerminusDurability.UNSETTLED_STATE);
             source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
             source.setDistributionMode(COPY);
@@ -317,7 +241,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       } else if (source.getDynamic()) {
          // if dynamic we have to create the node (queue) and set the address on the target, the
          // node is temporary and  will be deleted on closing of the session
-         queue = SimpleString.toSimpleString(java.util.UUID.randomUUID().toString());
+         queue = java.util.UUID.randomUUID().toString();
          tempQueueName = queue;
          try {
             sessionSPI.createTemporaryQueue(queue, RoutingType.ANYCAST);
@@ -325,7 +249,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          } catch (Exception e) {
             throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCreatingTemporaryQueue(e.getMessage());
          }
-         source.setAddress(queue.toString());
+         source.setAddress(queue);
       } else {
          SimpleString addressToUse;
          SimpleString queueNameToUse = null;
@@ -334,10 +258,11 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
 
          //find out if we have an address made up of the address and queue name, if yes then set queue name
          if (CompositeAddress.isFullyQualified(source.getAddress())) {
-            addressToUse = SimpleString.toSimpleString(CompositeAddress.extractAddressName(source.getAddress()));
-            queueNameToUse = SimpleString.toSimpleString(CompositeAddress.extractQueueName(source.getAddress()));
+            CompositeAddress compositeAddress = CompositeAddress.getQueueName(source.getAddress());
+            addressToUse = new SimpleString(compositeAddress.getAddress());
+            queueNameToUse = new SimpleString(compositeAddress.getQueueName());
          } else {
-            addressToUse = SimpleString.toSimpleString(source.getAddress());
+            addressToUse = new SimpleString(source.getAddress());
          }
          //check to see if the client has defined how we act
          boolean clientDefined = hasCapabilities(TOPIC, source) || hasCapabilities(QUEUE, source);
@@ -345,7 +270,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
             multicast = hasCapabilities(TOPIC, source);
             AddressQueryResult addressQueryResult = null;
             try {
-               addressQueryResult = sessionSPI.addressQuery(addressToUse, multicast ? RoutingType.MULTICAST : RoutingType.ANYCAST, true);
+               addressQueryResult = sessionSPI.addressQuery(addressToUse.toString(), multicast ? RoutingType.MULTICAST : RoutingType.ANYCAST, true);
             } catch (ActiveMQSecurityException e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(e.getMessage());
             } catch (ActiveMQAMQPException e) {
@@ -364,16 +289,13 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
             if (multicast && !routingTypes.contains(RoutingType.MULTICAST)) {
                throw new ActiveMQAMQPIllegalStateException("Address " + addressToUse + " is not configured for topic support");
             } else if (!multicast && !routingTypes.contains(RoutingType.ANYCAST)) {
-               //if client specifies fully qualified name that's allowed, don't throw exception.
-               if (queueNameToUse == null) {
-                  throw new ActiveMQAMQPIllegalStateException("Address " + addressToUse + " is not configured for queue support");
-               }
+               throw new ActiveMQAMQPIllegalStateException("Address " + addressToUse + " is not configured for queue support");
             }
          } else {
             // if not we look up the address
             AddressQueryResult addressQueryResult = null;
             try {
-               addressQueryResult = sessionSPI.addressQuery(addressToUse, defaultRoutingType, true);
+               addressQueryResult = sessionSPI.addressQuery(addressToUse.toString(), defaultRoutingType, true);
             } catch (ActiveMQSecurityException e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(e.getMessage());
             } catch (ActiveMQAMQPException e) {
@@ -411,9 +333,10 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                supportedFilters.put(filter.getKey(), filter.getValue());
             }
 
-            queue = getMatchingQueue(queueNameToUse, addressToUse, RoutingType.MULTICAST);
-            SimpleString simpleStringSelector = SimpleString.toSimpleString(selector);
-
+            if (queueNameToUse != null) {
+               SimpleString matchingAnycastQueue = sessionSPI.getMatchingQueue(addressToUse, queueNameToUse, RoutingType.MULTICAST);
+               queue = matchingAnycastQueue.toString();
+            }
             //if the address specifies a broker configured queue then we always use this, treat it as a queue
             if (queue != null) {
                multicast = false;
@@ -425,23 +348,24 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                String pubId = sender.getName();
                queue = createQueueName(connection.isUseCoreSubscriptionNaming(), clientId, pubId, shared, global, false);
                QueueQueryResult result = sessionSPI.queueQuery(queue, routingTypeToUse, false);
+
                if (result.isExists()) {
                   // If a client reattaches to a durable subscription with a different no-local
                   // filter value, selector or address then we must recreate the queue (JMS semantics).
-                  if (!Objects.equals(result.getFilterString(), simpleStringSelector) || (sender.getSource() != null && !sender.getSource().getAddress().equals(result.getAddress().toString()))) {
+                  if (!Objects.equals(result.getFilterString(), SimpleString.toSimpleString(selector)) || (sender.getSource() != null && !sender.getSource().getAddress().equals(result.getAddress().toString()))) {
 
                      if (result.getConsumerCount() == 0) {
                         sessionSPI.deleteQueue(queue);
-                        sessionSPI.createUnsharedDurableQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                        sessionSPI.createUnsharedDurableQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
                      } else {
                         throw new ActiveMQAMQPIllegalStateException("Unable to recreate subscription, consumers already exist");
                      }
                   }
                } else {
                   if (shared) {
-                     sessionSPI.createSharedDurableQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                     sessionSPI.createSharedDurableQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
                   } else {
-                     sessionSPI.createUnsharedDurableQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                     sessionSPI.createUnsharedDurableQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
                   }
                }
             } else {
@@ -449,15 +373,16 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                isVolatile = true;
                if (shared && sender.getName() != null) {
                   queue = createQueueName(connection.isUseCoreSubscriptionNaming(), getClientId(), sender.getName(), shared, global, isVolatile);
-                  QueueQueryResult result = sessionSPI.queueQuery(queue, routingTypeToUse, false);
-                  if (!(result.isExists() && Objects.equals(result.getAddress(), addressToUse) && Objects.equals(result.getFilterString(), simpleStringSelector))) {
-                     sessionSPI.createSharedVolatileQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                  try {
+                     sessionSPI.createSharedVolatileQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
+                  } catch (ActiveMQQueueExistsException e) {
+                     //this is ok, just means its shared
                   }
                } else {
-                  queue = SimpleString.toSimpleString(java.util.UUID.randomUUID().toString());
+                  queue = java.util.UUID.randomUUID().toString();
                   tempQueueName = queue;
                   try {
-                     sessionSPI.createTemporaryQueue(addressToUse, queue, RoutingType.MULTICAST, simpleStringSelector);
+                     sessionSPI.createTemporaryQueue(source.getAddress(), queue, RoutingType.MULTICAST, selector);
                   } catch (Exception e) {
                      throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCreatingTemporaryQueue(e.getMessage());
                   }
@@ -465,21 +390,18 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
             }
          } else {
             if (queueNameToUse != null) {
-               //a queue consumer can receive from a multicast queue if it uses a fully qualified name
-               //setting routingType to null means do not check the routingType against the Queue's routing type.
-               routingTypeToUse = null;
-               SimpleString matchingAnycastQueue = getMatchingQueue(queueNameToUse, addressToUse, null);
+               SimpleString matchingAnycastQueue = sessionSPI.getMatchingQueue(addressToUse, queueNameToUse, RoutingType.ANYCAST);
                if (matchingAnycastQueue != null) {
-                  queue = matchingAnycastQueue;
+                  queue = matchingAnycastQueue.toString();
                } else {
                   throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.sourceAddressDoesntExist();
                }
             } else {
                SimpleString matchingAnycastQueue = sessionSPI.getMatchingQueue(addressToUse, RoutingType.ANYCAST);
                if (matchingAnycastQueue != null) {
-                  queue = matchingAnycastQueue;
+                  queue = matchingAnycastQueue.toString();
                } else {
-                  queue = addressToUse;
+                  queue = addressToUse.toString();
                }
             }
 
@@ -500,9 +422,6 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          }
       }
 
-      // Detect if sender is in pre-settle mode.
-      preSettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
-
       // We need to update the source with any filters we support otherwise the client
       // is free to consider the attach as having failed if we don't send back what we
       // do support or if we send something we don't support the client won't know we
@@ -512,7 +431,6 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       boolean browseOnly = !multicast && source.getDistributionMode() != null && source.getDistributionMode().equals(COPY);
       try {
          brokerConsumer = (Consumer) sessionSPI.createSender(this, queue, multicast ? null : selector, browseOnly);
-         onflowControlReady = brokerConsumer::promptDelivery;
       } catch (ActiveMQAMQPResourceLimitExceededException e1) {
          throw new ActiveMQAMQPResourceLimitExceededException(e1.getMessage());
       } catch (ActiveMQSecurityException e) {
@@ -522,21 +440,6 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       }
    }
 
-   private SimpleString getMatchingQueue(SimpleString queueName, SimpleString address, RoutingType routingType) throws Exception {
-      if (queueName != null) {
-         QueueQueryResult result = sessionSPI.queueQuery(queueName, routingType, false);
-         if (!result.isExists()) {
-            throw new ActiveMQAMQPNotFoundException("Queue: '" + queueName + "' does not exist");
-         } else {
-            if (!result.getAddress().equals(address)) {
-               throw new ActiveMQAMQPNotFoundException("Queue: '" + queueName + "' does not exist for address '" + address + "'");
-            }
-            return sessionSPI.getMatchingQueue(address, queueName, routingType);
-         }
-      }
-      return null;
-   }
-
    protected String getClientId() {
       return connection.getRemoteContainer();
    }
@@ -551,17 +454,20 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          sender.setCondition(condition);
       }
       protonSession.removeSender(sender);
-
-      connection.runLater(() -> {
-         sender.close();
-         try {
-            sessionSPI.closeSender(brokerConsumer);
-         } catch (Exception e) {
-            log.warn(e.getMessage(), e);
-         }
+      connection.lock();
+      try {
          sender.close();
-         connection.flush();
-      });
+      } finally {
+         connection.unlock();
+      }
+      connection.flush();
+
+      try {
+         sessionSPI.closeSender(brokerConsumer);
+      } catch (Exception e) {
+         log.warn(e.getMessage(), e);
+         throw new ActiveMQAMQPInternalErrorException(e.getMessage());
+      }
    }
 
    /*
@@ -571,14 +477,13 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    public void close(boolean remoteLinkClose) throws ActiveMQAMQPException {
       try {
          closed = true;
-         protonSession.removeSender(sender);
          sessionSPI.closeSender(brokerConsumer);
          // if this is a link close rather than a connection close or detach, we need to delete
          // any durable resources for say pub subs
          if (remoteLinkClose) {
             Source source = (Source) sender.getSource();
             if (source != null && source.getAddress() != null && multicast) {
-               SimpleString queueName = SimpleString.toSimpleString(source.getAddress());
+               String queueName = source.getAddress();
                QueueQueryResult result = sessionSPI.queueQuery(queueName, routingTypeToUse, false);
                if (result.isExists() && source.getDynamic()) {
                   sessionSPI.deleteQueue(queueName);
@@ -591,7 +496,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                      if (pubId.contains("|")) {
                         pubId = pubId.split("\\|")[0];
                      }
-                     SimpleString queue = createQueueName(connection.isUseCoreSubscriptionNaming(), clientId, pubId, shared, global, isVolatile);
+                     String queue = createQueueName(connection.isUseCoreSubscriptionNaming(), clientId, pubId, shared, global, isVolatile);
                      result = sessionSPI.queueQuery(queue, multicast ? RoutingType.MULTICAST : RoutingType.ANYCAST, false);
                      //only delete if it isn't volatile and has no consumers
                      if (result.isExists() && !isVolatile && result.getConsumerCount() == 0) {
@@ -601,7 +506,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                }
             } else if (source != null && source.getDynamic() && (source.getExpiryPolicy() == TerminusExpiryPolicy.LINK_DETACH || source.getExpiryPolicy() == TerminusExpiryPolicy.SESSION_END)) {
                try {
-                  sessionSPI.removeTemporaryQueue(SimpleString.toSimpleString(source.getAddress()));
+                  sessionSPI.removeTemporaryQueue(source.getAddress());
                } catch (Exception e) {
                   //ignore on close, its temp anyway and will be removed later
                }
@@ -623,69 +528,35 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
 
       try {
          Message message = ((MessageReference) delivery.getContext()).getMessage();
-         DeliveryState remoteState = delivery.getRemoteState();
 
-         if (remoteState != null && remoteState.getType() == DeliveryStateType.Accepted) {
-            // this can happen in the twice ack mode, that is the receiver accepts and settles separately
-            // acking again would show an exception but would have no negative effect but best to handle anyway.
-            if (!delivery.isSettled()) {
-               inSessionACK(delivery, message);
-            }
-         } else {
-            handleExtendedDeliveryOutcomes(message, delivery, remoteState);
-         }
+         boolean preSettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
 
-         if (!preSettle) {
-            protonSession.replaceTag(delivery.getTag());
-         }
-      } finally {
-         sessionSPI.afterIO(connectionFlusher);
-         sessionSPI.resetContext(oldContext);
-      }
-   }
+         DeliveryState remoteState;
 
-   private void inSessionACK(Delivery delivery, Message message) throws ActiveMQAMQPIllegalStateException {
-      OperationContext oldContext = sessionSPI.recoverContext();
-      try {
-         // we have to individual ack as we can't guarantee we will get the delivery updates
-         // (including acks) in order from dealer, a performance hit but a must
+         connection.lock();
          try {
-            sessionSPI.ack(null, brokerConsumer, message);
-         } catch (Exception e) {
-            log.warn(e.toString(), e);
-            throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorAcknowledgingMessage(message.toString(), e.getMessage());
+            remoteState = delivery.getRemoteState();
+         } finally {
+            connection.unlock();
          }
 
-         sessionSPI.afterIO(new IOCallback() {
-            @Override
-            public void done() {
-               connection.runLater(() -> {
-                  delivery.settle();
-                  connection.instantFlush();
-               });
+         boolean settleImmediate = true;
+         if (remoteState instanceof Accepted) {
+            // this can happen in the twice ack mode, that is the receiver accepts and settles separately
+            // acking again would show an exception but would have no negative effect but best to handle anyway.
+            if (delivery.isSettled()) {
+               return;
             }
-
-            @Override
-            public void onError(int errorCode, String errorMessage) {
-
+            // we have to individual ack as we can't guarantee we will get the delivery updates
+            // (including acks) in order
+            // from dealer, a perf hit but a must
+            try {
+               sessionSPI.ack(null, brokerConsumer, message);
+            } catch (Exception e) {
+               log.warn(e.toString(), e);
+               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorAcknowledgingMessage(message.toString(), e.getMessage());
             }
-         });
-      } finally {
-         sessionSPI.resetContext(oldContext);
-      }
-   }
-
-   private boolean handleExtendedDeliveryOutcomes(Message message, Delivery delivery, DeliveryState remoteState) throws ActiveMQAMQPException {
-      boolean settleImmediate = true;
-      boolean handled = true;
-
-      if (remoteState == null) {
-         log.debug("Received null disposition for delivery update: " + remoteState);
-         return true;
-      }
-
-      switch (remoteState.getType()) {
-         case Transactional:
+         } else if (remoteState instanceof TransactionalState) {
             // When the message arrives with a TransactionState disposition the ack should
             // enlist the message into the transaction associated with the given txn ID.
             TransactionalState txState = (TransactionalState) remoteState;
@@ -699,10 +570,16 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                      TransactionalState txAccepted = new TransactionalState();
                      txAccepted.setOutcome(Accepted.getInstance());
                      txAccepted.setTxnId(txState.getTxnId());
-                     delivery.disposition(txAccepted);
+                     connection.lock();
+                     try {
+                        delivery.disposition(txAccepted);
+                     } finally {
+                        connection.unlock();
+                     }
                   }
                   // we have to individual ack as we can't guarantee we will get the delivery
-                  // (including acks) in order from dealer, a performance hit but a must
+                  // updates (including acks) in order
+                  // from dealer, a perf hit but a must
                   try {
                      sessionSPI.ack(tx, brokerConsumer, message);
                      tx.addDelivery(delivery, this);
@@ -711,27 +588,19 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                   }
                }
             }
-            break;
-         case Released:
+         } else if (remoteState instanceof Released) {
             try {
                sessionSPI.cancel(brokerConsumer, message, false);
             } catch (Exception e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCancellingMessage(message.toString(), e.getMessage());
             }
-            break;
-         case Rejected:
+         } else if (remoteState instanceof Rejected) {
             try {
-               if (amqpTreatRejectAsUnmodifiedDeliveryFailed) {
-                  // We could be more discriminating - for instance check for AmqpError#RESOURCE_LIMIT_EXCEEDED
-                  sessionSPI.cancel(brokerConsumer, message, true);
-               } else {
-                  sessionSPI.reject(brokerConsumer, message);
-               }
+               sessionSPI.reject(brokerConsumer, message);
             } catch (Exception e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCancellingMessage(message.toString(), e.getMessage());
             }
-            break;
-         case Modified:
+         } else if (remoteState instanceof Modified) {
             try {
                Modified modification = (Modified) remoteState;
 
@@ -747,34 +616,43 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
             } catch (Exception e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCancellingMessage(message.toString(), e.getMessage());
             }
-            break;
-         default:
+         } else {
             log.debug("Received null or unknown disposition for delivery update: " + remoteState);
-            handled = false;
-      }
+            return;
+         }
 
-      if (settleImmediate) {
-         delivery.settle();
-      }
+         if (!preSettle) {
+            protonSession.replaceTag(delivery.getTag());
+         }
 
-      return handled;
-   }
+         if (settleImmediate) {
+            settle(delivery);
+         }
 
-   private final class ConnectionFlushIOCallback implements IOCallback {
-      @Override
-      public void done() {
-         connection.flush();
-      }
+      } finally {
+         sessionSPI.afterIO(new IOCallback() {
+            @Override
+            public void done() {
+               connection.flush();
+            }
 
-      @Override
-      public void onError(int errorCode, String errorMessage) {
-         connection.flush();
+            @Override
+            public void onError(int errorCode, String errorMessage) {
+               connection.flush();
+            }
+         });
+
+         sessionSPI.resetContext(oldContext);
       }
    }
 
    public void settle(Delivery delivery) {
-      connection.requireInHandler();
-      delivery.settle();
+      connection.lock();
+      try {
+         delivery.settle();
+      } finally {
+         connection.unlock();
+      }
    }
 
    public synchronized void checkState() {
@@ -784,205 +662,64 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    /**
     * handle an out going message from ActiveMQ Artemis, send via the Proton Sender
     */
-   public int deliverMessage(final MessageReference messageReference, final ServerConsumer consumer) throws Exception {
+   public int deliverMessage(MessageReference messageReference, int deliveryCount, Connection transportConnection) throws Exception {
 
       if (closed) {
          return 0;
       }
 
-      try {
-         synchronized (creditsLock) {
-            if (sender.getLocalState() == EndpointState.CLOSED) {
-               return 0;
-            }
-            pending.incrementAndGet();
-            credits--;
-         }
-
-         if (messageReference.getMessage() instanceof AMQPLargeMessage) {
-            hasLarge = true;
-         }
-
-         if (messageReference instanceof Runnable && consumer.allowReferenceCallback()) {
-            messageReference.onDelivery(executeDelivery);
-            connection.runNow((Runnable) messageReference);
-         } else {
-            connection.runNow(() -> executeDelivery(messageReference));
-         }
-
-         // This is because on AMQP we only send messages based in credits, not bytes
-         return 1;
-      } finally {
+      AMQPMessage message = CoreAmqpConverter.checkAMQP(messageReference.getMessage());
+      sessionSPI.invokeOutgoing(message, (ActiveMQProtonRemotingConnection) transportConnection.getProtocolConnection());
 
-      }
-   }
+      // presettle means we can settle the message on the dealer side before we send it, i.e.
+      // for browsers
+      boolean preSettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
 
-   private void executeDelivery(MessageReference messageReference) {
+      // we only need a tag if we are going to settle later
+      byte[] tag = preSettle ? new byte[0] : protonSession.getTag();
 
+      ByteBuf nettyBuffer = PooledByteBufAllocator.DEFAULT.heapBuffer(message.getEncodeSize());
       try {
-         if (sender.getLocalState() == EndpointState.CLOSED) {
-            log.debug("Not delivering message " + messageReference + " as the sender is closed and credits were available, if you see too many of these it means clients are issuing credits and closing the connection with pending credits a lot of times");
-            return;
-         }
-         AMQPMessage message = CoreAmqpConverter.checkAMQP(messageReference.getMessage(), sessionSPI.getStorageManager());
-
-         if (sessionSPI.invokeOutgoing(message, (ActiveMQProtonRemotingConnection) sessionSPI.getTransportConnection().getProtocolConnection()) != null) {
-            return;
-         }
-         if (message instanceof AMQPLargeMessage) {
-            deliverLarge(messageReference, (AMQPLargeMessage) message);
-         } else {
-            deliverStandard(messageReference, message);
-         }
-
-      } catch (Exception e) {
-         log.warn(e.getMessage(), e);
-         brokerConsumer.errorProcessing(e, messageReference);
-      }
-   }
+         message.sendBuffer(nettyBuffer, deliveryCount);
 
-   private class LargeMessageDeliveryContext {
+         int size = nettyBuffer.writerIndex();
 
-      LargeMessageDeliveryContext(MessageReference reference, AMQPLargeMessage message, Delivery delivery) {
-         this.position = 0L;
-         this.reference = reference;
-         this.message = message;
-         this.delivery = delivery;
-      }
-
-      long position;
-      final MessageReference reference;
-      final AMQPLargeMessage message;
-      final Delivery delivery;
-
-      void resume() {
-         connection.runNow(this::deliver);
-      }
-      private static final int BUFFER_LENGTH = 1024;
+         while (!connection.tryLock(1, TimeUnit.SECONDS)) {
+            if (closed || sender.getLocalState() == EndpointState.CLOSED) {
+               // If we're waiting on the connection lock, the link might be in the process of closing.  If this happens
+               // we return.
+               return 0;
+            } else {
+               if (log.isDebugEnabled()) {
+                  log.debug("Couldn't get lock on deliverMessage " + this);
+               }
+            }
+         }
 
-      void deliver() {
-         // Let the Message decide how to present the message bytes
-         LargeBodyReader context = message.getLargeBodyReader();
          try {
+            final Delivery delivery;
+            delivery = sender.delivery(tag, 0, tag.length);
+            delivery.setMessageFormat((int) message.getMessageFormat());
+            delivery.setContext(messageReference);
 
-            context.open();
-            try {
-               context.position(position);
-               long bodySize = context.getSize();
-
-               // TODO: it would be nice to use pooled buffer here,
-               //       however I would need a version of ReadableBuffer for Netty
-               ByteBuffer buf = ByteBuffer.allocate(BUFFER_LENGTH);
-
-               for (; position < bodySize; ) {
-                  if (!connection.flowControl(this::resume)) {
-                     context.close();
-                     return;
-                  }
-                  buf.clear();
-                  int size = context.readInto(buf);
-
-                  sender.send(buf.array(), 0, size);
-
-                  connection.instantFlush();
-
-                  position += size;
-               }
-            } finally {
-               context.close();
-            }
+            // this will avoid a copy.. patch provided by Norman using buffer.array()
+            sender.send(nettyBuffer.array(), nettyBuffer.arrayOffset() + nettyBuffer.readerIndex(), nettyBuffer.readableBytes());
 
             if (preSettle) {
                // Presettled means the client implicitly accepts any delivery we send it.
-               try {
-                  sessionSPI.ack(null, brokerConsumer, reference.getMessage());
-               } catch (Exception e) {
-                  log.debug(e.getMessage(), e);
-               }
+               sessionSPI.ack(null, brokerConsumer, messageReference.getMessage());
                delivery.settle();
             } else {
                sender.advance();
             }
-
             connection.flush();
-
-            synchronized (creditsLock) {
-               pending.decrementAndGet();
-            }
-
-            finishLargeMessage();
-         } catch (Exception e) {
-            log.warn(e.getMessage(), e);
-            brokerConsumer.errorProcessing(e, reference);
+         } finally {
+            connection.unlock();
          }
-      }
-   }
-
-   private void finishLargeMessage() {
-      pendingLargeMessage = null;
-      hasLarge = false;
-      brokerConsumer.promptDelivery();
-   }
-
-   private void deliverLarge(MessageReference messageReference, AMQPLargeMessage message) {
-
-      // we only need a tag if we are going to settle later
-      byte[] tag = preSettle ? new byte[0] : protonSession.getTag();
-
-      final Delivery delivery;
-      delivery = sender.delivery(tag, 0, tag.length);
-      delivery.setMessageFormat((int) message.getMessageFormat());
-      delivery.setContext(messageReference);
 
-      pendingLargeMessage = new LargeMessageDeliveryContext(messageReference, message, delivery);
-      pendingLargeMessage.deliver();
-
-   }
-
-   private void deliverStandard(MessageReference messageReference, AMQPMessage message) {
-      // Let the Message decide how to present the message bytes
-      ReadableBuffer sendBuffer = message.getSendBuffer(messageReference.getDeliveryCount());
-      // we only need a tag if we are going to settle later
-      byte[] tag = preSettle ? new byte[0] : protonSession.getTag();
-
-      boolean releaseRequired = sendBuffer instanceof NettyReadable;
-      final Delivery delivery;
-      delivery = sender.delivery(tag, 0, tag.length);
-      delivery.setMessageFormat((int) message.getMessageFormat());
-      delivery.setContext(messageReference);
-
-      try {
-
-         if (releaseRequired) {
-            sender.send(sendBuffer);
-            // Above send copied, so release now if needed
-            releaseRequired = false;
-            ((NettyReadable) sendBuffer).getByteBuf().release();
-         } else {
-            // Don't have pooled content, no need to release or copy.
-            sender.sendNoCopy(sendBuffer);
-         }
-
-         if (preSettle) {
-            // Presettled means the client implicitly accepts any delivery we send it.
-            try {
-               sessionSPI.ack(null, brokerConsumer, messageReference.getMessage());
-            } catch (Exception e) {
-               log.debug(e.getMessage(), e);
-            }
-            delivery.settle();
-         } else {
-            sender.advance();
-         }
-
-         connection.flush();
+         return size;
       } finally {
-         synchronized (creditsLock) {
-            pending.decrementAndGet();
-         }
-         if (releaseRequired) {
-            ((NettyReadable) sendBuffer).getByteBuf().release();
-         }
+         nettyBuffer.release();
       }
    }
 
@@ -1011,7 +748,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       return false;
    }
 
-   private static SimpleString createQueueName(boolean useCoreSubscriptionNaming,
+   private static String createQueueName(boolean useCoreSubscriptionNaming,
                                          String clientId,
                                          String pubId,
                                          boolean shared,
@@ -1035,7 +772,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                queue += ":global";
             }
          }
-         return SimpleString.toSimpleString(queue);
+         return queue;
       }
    }
 
@@ -1043,12 +780,13 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
     * Update link state to reflect that the previous drain attempt has completed.
     */
    public void reportDrained() {
-      connection.requireInHandler();
-      sender.drained();
-      connection.instantFlush();
-   }
+      connection.lock();
+      try {
+         sender.drained();
+      } finally {
+         connection.unlock();
+      }
 
-   public AMQPSessionContext getSessionContext() {
-      return protonSession;
+      connection.flush();
    }
 }