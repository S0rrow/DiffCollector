diff --git a/src/org/apache/axis/transport/http/HTTPSender.java b/src/org/apache/axis/transport/http/HTTPSender.java
index f8d5e8bbb..b648d0ee6 100644
--- a/src/org/apache/axis/transport/http/HTTPSender.java
+++ b/src/org/apache/axis/transport/http/HTTPSender.java
@@ -2,7 +2,7 @@
  * The Apache Software License, Version 1.1
  *
  *
- * Copyright (c) 2001 The Apache Software Foundation.  All rights
+ * Copyright (c) 1999 The Apache Software Foundation.  All rights
  * reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -55,30 +55,21 @@
 
 package org.apache.axis.transport.http;
 
-import org.apache.axis.AxisFault;
-import org.apache.axis.Message;
-import org.apache.axis.MessageContext;
-import org.apache.axis.encoding.Base64;
+import java.io.* ;
+import java.net.* ;
+import java.util.* ;
+import java.lang.reflect.*;
+
+import org.apache.axis.* ;
+import org.apache.axis.utils.* ;
+import org.apache.axis.message.SOAPEnvelope;
+import org.apache.axis.message.SOAPHeader;
+import org.apache.axis.message.MessageElement;
 import org.apache.axis.handlers.BasicHandler;
-import org.apache.axis.utils.JavaUtils;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
+import org.apache.axis.transport.http.NonBlockingBufferedInputStream;
+import org.apache.axis.encoding.Base64 ;
 
-import java.io.BufferedInputStream;
-import java.io.BufferedOutputStream;
-import java.io.BufferedWriter;
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.io.OutputStreamWriter;
-import java.io.PrintWriter;
-import java.lang.reflect.Method;
-import java.net.Socket;
-import java.net.URL;
-import java.util.Enumeration;
-import java.util.Hashtable;
-import java.util.StringTokenizer;
+import org.w3c.dom.* ;
 
 /**
  * This is meant to be used on a SOAP Client to call a SOAP server.
@@ -86,36 +77,100 @@ import java.util.StringTokenizer;
  * @author Doug Davis (dug@us.ibm.com)
  */
 public class HTTPSender extends BasicHandler {
-    protected static Log log =
-        LogFactory.getLog(HTTPSender.class.getName());
-
-    class BooleanHolder {
-        public boolean value;
-        public BooleanHolder(boolean value) {
-            this.value = value;
-        }
-    }
-
     public void invoke(MessageContext msgContext) throws AxisFault {
-        if (log.isDebugEnabled()) {
-            log.debug( JavaUtils.getMessage("enter00", 
-                "HTTPSender::invoke") );
-        }
-
+        Debug.Print( 1, "Enter: HTTPSender::invoke" );
         /* Find the service we're invoking so we can grab it's options */
         /***************************************************************/
+        String   targetURL = null ;
+        Message  outMsg    = null ;
+        String   reqEnv    = null ;
+
+        targetURL = msgContext.getStrProp( MessageContext.TRANS_URL);
         try {
-            BooleanHolder useFullURL = new BooleanHolder(false);
-            StringBuffer  otherHeaders = new StringBuffer();
-            String        targetURL = msgContext.getStrProp( MessageContext.TRANS_URL);
-            URL           tmpURL = new URL( targetURL );
-            String        host = tmpURL.getHost();
-            Socket        sock = null ;
+            String   host ;
+            int      port   = 80 ;
+            URL      tmpURL = new URL( targetURL );
+            byte[]   buf    = new byte[4097];
+            int      rc     = 0 ;
+            
+            // default SOAPAction to request namespaceURI/method
+            String   action = msgContext.getStrProp(HTTPConstants.MC_HTTP_SOAPACTION);
+            if (action == null) {
+                Message rm = msgContext.getRequestMessage();
+                MessageElement body = rm.getAsSOAPEnvelope().getFirstBody();
+                action = body.getNamespaceURI() + "/" + body.getName();
+            }
+            
+            host = tmpURL.getHost();
+            if ( (port = tmpURL.getPort()) == -1 ) port = 80;
+
+            Socket             sock = null ;
 
             if (tmpURL.getProtocol().equalsIgnoreCase("https")) {
-                sock = getSecureSocket(host, tmpURL);
+                if ( (port = tmpURL.getPort()) == -1 ) port = 443;
+                String tunnelHost = System.getProperty("https.proxyHost");
+                String tunnelPortString = System.getProperty("https.proxyPort");
+                String tunnelUsername = System.getProperty("https.proxyUsername");
+                String tunnelPassword = System.getProperty("https.proxyPassword");
+                try {
+                    Class SSLSocketFactoryClass =
+                                                 Class.forName("javax.net.ssl.SSLSocketFactory");
+                    Class SSLSocketClass = Class.forName("javax.net.ssl.SSLSocket");
+                    Method createSocketMethod =
+                                               SSLSocketFactoryClass.getMethod("createSocket",
+                                                                               new Class[] {String.class, Integer.TYPE});
+                    Method getDefaultMethod =
+                                             SSLSocketFactoryClass.getMethod("getDefault", new Class[] {});
+                    Method startHandshakeMethod =
+                                                 SSLSocketClass.getMethod("startHandshake", new Class[] {});
+                    Object factory = getDefaultMethod.invoke(null, new Object[] {});
+                    Object sslSocket = null;
+                    if (tunnelHost == null || tunnelHost.equals("")) {
+                        // direct SSL connection
+                        sslSocket = createSocketMethod .invoke(factory,
+                                                               new Object[] {host, new Integer(port)});
+                    } else {
+                        // SSL tunnelling through proxy server
+                        Method createSocketMethod2 =
+                                                    SSLSocketFactoryClass.getMethod("createSocket",
+                                                                                    new Class[] {Socket.class, String.class, Integer.TYPE, Boolean.TYPE});
+                        int tunnelPort = (tunnelPortString != null? (Integer.parseInt(tunnelPortString) < 0? 443: Integer.parseInt(tunnelPortString)): 443);
+                        Object tunnel = createSocketMethod .invoke(factory,
+                                                                   new Object[] {tunnelHost, new Integer(tunnelPort)});
+                        // The tunnel handshake method (condensed and made reflexive)
+                        OutputStream tunnelOutputStream = (OutputStream)SSLSocketClass.getMethod("getOutputStream", new Class[] {}).invoke(tunnel, new Object[] {});
+                        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(tunnelOutputStream)));
+                        out.print("CONNECT " + host + ":" + port + " HTTP/1.0\n\r\n\r");
+                        out.flush();
+                        InputStream tunnelInputStream = (InputStream)SSLSocketClass.getMethod("getInputStream", new Class[] {}).invoke(tunnel, new Object[] {});
+                        //BufferedReader in = new BufferedReader(new InputStreamReader(tunnelInputStream));
+                        //DataInputStream in = new DataInputStream(tunnelInputStream);
+                        Debug.Print(1, "Is tunnelInputStream null? " + String.valueOf(tunnelInputStream == null));
+                        String replyStr = ""; int i;
+                        while ((i = tunnelInputStream.read()) != '\n' && i != '\r' && i != -1) { replyStr += String.valueOf((char)i); Debug.Print(1, "got a character in reply, so far: " + replyStr); }
+                        if (!replyStr.startsWith("HTTP/1.0 200") && !replyStr.startsWith("HTTP/1.1 200")) {
+                            throw new IOException("Unable to tunnel through " + tunnelHost + ":" + tunnelPort + ".  Proxy returns \"" + replyStr + "\"");
+                        }
+                        // End of condensed reflective tunnel handshake method
+                        sslSocket = createSocketMethod2.invoke(factory,
+                                                               new Object[] {tunnel, host, new Integer(port), new Boolean(true)});
+                        Debug.Print( 1, "Set up SSL tunnelling through " + tunnelHost + ":" +tunnelPort);
+                    }
+                    // must shake out hidden errors!
+                    startHandshakeMethod.invoke(sslSocket, new Object[] {});
+                    sock = (Socket)sslSocket;
+                } catch (ClassNotFoundException cnfe) {
+                    Debug.Print( 1, "SSL feature disallowed: JSSE files not installed or present in classpath");
+                    throw new AxisFault(cnfe);
+                } catch (NumberFormatException nfe) {
+                      Debug.Print( 1, "Proxy port number, \"" + tunnelPortString + "\", incorrectly formatted");
+                      throw new AxisFault(nfe);
+                }
+                Debug.Print( 1, "Created an SSL connection");
             } else {
-                sock = getSocket(host, tmpURL, otherHeaders, useFullURL);
+                if ((port = tmpURL.getPort()) == -1 ) port = 80;
+                sock    = new Socket( host, port );
+                Debug.Print( 1, "Created an insecure HTTP connection");
             }
 
             // optionally set a timeout for the request
@@ -123,484 +178,193 @@ public class HTTPSender extends BasicHandler {
                 sock.setSoTimeout(msgContext.getTimeout());
             }
 
-            writeToSocket(sock, msgContext, tmpURL, otherHeaders, host, useFullURL);
-            readFromSocket(sock, msgContext);
-        }
-        catch( Exception e ) {
-            log.debug( e );
-            throw AxisFault.makeFault(e);
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug( JavaUtils.getMessage("exit00", 
-                "HTTPDispatchHandler::invoke") );
-        }
-    }
-
-    private Socket getSecureSocket(String host, URL tmpURL) throws Exception
-    {
-        int port = 0;
-        Socket sock = null;
-        if ( (port = tmpURL.getPort()) == -1 ) port = 443;
-
-        // Use http.proxyXXX settings if https.proxyXXX is not set
-        String tunnelHost = System.getProperty("https.proxyHost");
-        String tunnelPortStr = System.getProperty("https.proxyPort");
-
-        if (tunnelHost==null) tunnelHost = System.getProperty("http.proxyHost");
-        if (tunnelPortStr==null) tunnelPortStr = System.getProperty("http.proxyPort");
-
-        try {
-            Class SSLSocketFactoryClass =
-                                         Class.forName("javax.net.ssl.SSLSocketFactory");
-            Class SSLSocketClass = Class.forName("javax.net.ssl.SSLSocket");
-            Method createSocketMethod =
-                                       SSLSocketFactoryClass.getMethod("createSocket",
-                                                                       new Class[] {String.class, Integer.TYPE});
-            Method getDefaultMethod =
-                                     SSLSocketFactoryClass.getMethod("getDefault", new Class[] {});
-            Method startHandshakeMethod =
-                                         SSLSocketClass.getMethod("startHandshake", new Class[] {});
-            Object factory = getDefaultMethod.invoke(null, new Object[] {});
-            Object sslSocket = null;
-            if (tunnelHost == null || tunnelHost.equals("")) {
-                // direct SSL connection
-                sslSocket = createSocketMethod .invoke(factory,
-                                                       new Object[] {host, new Integer(port)});
-            } else {
-                // SSL tunnelling through proxy server
-                Method createSocketMethod2 =
-                                            SSLSocketFactoryClass.getMethod("createSocket",
-                                                                            new Class[] {Socket.class, String.class, Integer.TYPE, Boolean.TYPE});
-
-                // Default proxy port is 80, even for https
-                int tunnelPort = (tunnelPortStr != null? (Integer.parseInt(tunnelPortStr) < 0? 80: Integer.parseInt(tunnelPortStr)): 80);
-
-                // Create the regular socket connection to the proxy
-                Socket tunnel = new Socket(tunnelHost, tunnelPort);
-
-                // The tunnel handshake method (condensed and made reflexive)
-                OutputStream tunnelOutputStream = (OutputStream)SSLSocketClass.getMethod("getOutputStream", new Class[] {}).invoke(tunnel, new Object[] {});
-
-                PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(tunnelOutputStream)));
-
-                String tunnelUser = System.getProperty("https.proxyUser");
-                String tunnelPassword = System.getProperty("https.proxyPassword");
-                if (tunnelUser == null) tunnelUser =
-                       System.getProperty("http.proxyUser");
-                if (tunnelPassword == null) tunnelPassword =
-                       System.getProperty("http.proxyPassword");
-
-// More secure version... engage later?
-//                        PasswordAuthentication pa =
-//                                Authenticator.requestPasswordAuthentication(
-//                                        InetAddress.getByName(tunnelHost),
-//                                        tunnelPort, "SOCK", "Proxy","HTTP");
-//                        if(pa == null){
-//                            printDebug("No Authenticator set.");
-//                        }else{
-//                            printDebug("Using Authenticator.");
-//                            tunnelUser = pa.getUserName();
-//                            tunnelPassword = new String(pa.getPassword());
-//                        }
-
+            reqEnv  = (String) msgContext.getRequestMessage().getAsString();
+            
+            //System.out.println("Msg: " + reqEnv);
 
-                out.print("CONNECT " + host + ":" + port + " HTTP/1.0\r\n"
-                          + "User-Agent: AxisClient");
-                if (tunnelUser != null && tunnelPassword != null) {
-                    //add basic authentication header for the proxy
-                    sun.misc.BASE64Encoder enc = new sun.misc.BASE64Encoder();
-                    String encodedPassword =
-                         enc.encode((tunnelUser + ":" + tunnelPassword).getBytes());
-                    out.print("\nProxy-Authorization: Basic " + encodedPassword);
+            BufferedInputStream inp = new BufferedInputStream(sock.getInputStream());
+            OutputStream  out  = sock.getOutputStream();
+            StringBuffer  otherHeaders = new StringBuffer();
+            String        userID = null ;
+            String        passwd = null ;
+
+            userID = msgContext.getStrProp( MessageContext.USERID );
+            passwd = msgContext.getStrProp( MessageContext.PASSWORD );
+
+            if ( userID != null ) {
+                StringBuffer tmpBuf = new StringBuffer();
+                tmpBuf.append( userID )
+               .append( ":" )
+               .append( (passwd == null) ? "" : passwd) ;
+                otherHeaders.append( HTTPConstants.HEADER_AUTHORIZATION )
+                     .append( ": Basic " )
+                     .append( Base64.encode( tmpBuf.toString().getBytes() ) )
+                     .append("\n" );
+            }
+            
+            // don't forget the cookies!
+            // mmm... cookies
+            if (msgContext.getMaintainSession()) {
+                String cookie = msgContext.getStrProp(HTTPConstants.HEADER_COOKIE);
+                String cookie2 = msgContext.getStrProp(HTTPConstants.HEADER_COOKIE2);
+                
+                if (cookie != null) {
+                    otherHeaders.append(HTTPConstants.HEADER_COOKIE)
+                     .append(": ")
+                     .append(cookie)
+                     .append("\r\n");
                 }
-                out.print("\nContent-Length: 0");
-                out.print("\nPragma: no-cache");
-                out.print("\r\n\r\n");
-                out.flush();
-
-                InputStream tunnelInputStream = (InputStream)SSLSocketClass.getMethod("getInputStream", new Class[] {}).invoke(tunnel, new Object[] {});
-                if (log.isDebugEnabled()) {
-                    log.debug(JavaUtils.getMessage("isNull00",
-                      "tunnelInputStream",
-                      "" + (tunnelInputStream == null)));
+                
+                if (cookie2 != null) {
+                    otherHeaders.append(HTTPConstants.HEADER_COOKIE2)
+                     .append(": ")
+                     .append(cookie2)
+                     .append("\r\n");
                 }
-
-                String replyStr = "";
-
-                // Make sure to read all the response from the proxy to prevent SSL negotiation failure
-                // Response message terminated by two sequential newlines
-                int     newlinesSeen = 0;
-                boolean     headerDone = false; /* Done on first newline */
-
-                while (newlinesSeen < 2) {
-                    int i = tunnelInputStream.read();
-                    if (i < 0) {
-                        throw new IOException("Unexpected EOF from proxy");
+            }
+            
+            StringBuffer header = new StringBuffer();
+
+            header.append( HTTPConstants.HEADER_POST )
+             .append(" " )
+             .append( ((tmpURL.getFile() == null ||
+                        tmpURL.getFile().equals(""))? "/": tmpURL.getFile()) )
+             .append( " HTTP/1.0\r\n" )
+             .append( HTTPConstants.HEADER_CONTENT_LENGTH )
+             .append( ": " )
+             .append( reqEnv.length() )
+             .append( "\r\n" )
+             .append( HTTPConstants.HEADER_HOST )
+             .append( ": " )
+             .append( host )
+             .append( "\r\n" )
+             .append( HTTPConstants.HEADER_CONTENT_TYPE )
+             .append( ": text/xml; charset=utf-8\r\n" )
+             .append( (otherHeaders == null ? "" : otherHeaders.toString()))
+             .append( HTTPConstants.HEADER_SOAP_ACTION )
+             .append( ": \"" )
+             .append( action )
+             .append( "\"\r\n");
+            
+            header.append("\r\n");
+
+            out.write( header.toString().getBytes() );
+            out.write( reqEnv.getBytes() );
+
+            Debug.Print( 1, "XML sent:" );
+            Debug.Print( 1, "---------------------------------------------------");
+            Debug.Print( 1, header + reqEnv );
+
+            byte       lastB=0, b ;
+            int        len = 0 ;
+            int        colonIndex = -1 ;
+            Hashtable  headers = new Hashtable();
+            String     name, value ;
+
+            // Need to add logic for getting the version # and the return code
+            // but that's for tomorrow!
+
+            for ( ;; ) {
+                if ( (b = (byte) inp.read()) == -1 ) break ;
+                if ( b != '\r' && b != '\n' ) {
+                    if ( b == ':' && colonIndex == -1 ) colonIndex = len ;
+                    lastB = (buf[len++] = b);
+                }
+                else if ( b == '\r' )
+                    continue ;
+                else {
+                    if ( len == 0 ) break ;
+                    if ( colonIndex != -1 ) {
+                        name = new String( buf, 0, colonIndex );
+                        value = new String( buf, colonIndex+1, len-1-colonIndex );
+                        colonIndex = -1 ;
                     }
-                    if (i == '\n') {
-                        headerDone = true;
-                        ++newlinesSeen;
-                    } else if (i != '\r') {
-                        newlinesSeen = 0;
-                        if (!headerDone) {
-                            replyStr += String.valueOf((char)i);
-                        }
+                    else {
+                        name = new String( buf, 0, len );
+                        value = "" ;
                     }
+                    Debug.Print( 1, name + value );
+                    if ( msgContext.getProperty(HTTPConstants.MC_HTTP_STATUS_CODE)==null){
+                        // Reader status code
+                        int start = name.indexOf( ' ' ) + 1 ;
+                        String tmp = name.substring(start).trim();
+                        int end   = tmp.indexOf( ' ' );
+                        if ( end != -1 ) tmp = tmp.substring( 0, end );
+                        rc = Integer.parseInt( tmp );
+                        msgContext.setProperty( HTTPConstants.MC_HTTP_STATUS_CODE,
+                                                new Integer(rc) );
+                        msgContext.setProperty( HTTPConstants.MC_HTTP_STATUS_MESSAGE,
+                                                name.substring(end+1));
+                    }
+                    else
+                        headers.put( name.toLowerCase(), value );
+                    len = 0 ;
                 }
-
-                if (!replyStr.startsWith("HTTP/1.0 200") && !replyStr.startsWith("HTTP/1.1 200")) {
-                    throw new IOException(JavaUtils.getMessage("cantTunnel00",
-                            new String[] {tunnelHost, "" + tunnelPort, replyStr}));
-                }
-                // End of condensed reflective tunnel handshake method
-                sslSocket = createSocketMethod2.invoke(factory,
-                                                       new Object[] {tunnel, host, new Integer(port), new Boolean(true)});
-
-                if (log.isDebugEnabled()) {
-                    log.debug(JavaUtils.getMessage(
-                        "setupTunnel00", tunnelHost, "" + tunnelPort));
-                }
-            }
-            // must shake out hidden errors!
-            startHandshakeMethod.invoke(sslSocket, new Object[] {});
-            sock = (Socket)sslSocket;
-        } catch (ClassNotFoundException cnfe) {
-            if (log.isDebugEnabled()) {
-                log.debug( JavaUtils.getMessage("noJSSE00"));
-            }
-
-            throw AxisFault.makeFault(cnfe);
-        } catch (NumberFormatException nfe) {
-              if (log.isDebugEnabled()) {
-                  log.debug( JavaUtils.getMessage("badProxy00",
-                      tunnelPortStr));
-              }
-
-              throw AxisFault.makeFault(nfe);
-        }
-
-        if (log.isDebugEnabled()) {
-            log.debug( JavaUtils.getMessage("createdSSL00"));
-        }
-        return sock;
-    }
-
-
-    private Socket getSocket(String host, URL tmpURL,
-                             StringBuffer otherHeaders, BooleanHolder useFullURL)
-            throws IOException
-    {
-        int port = 0;
-        Socket sock = null;
-        String proxyHost = System.getProperty("http.proxyHost");
-        String proxyPort = System.getProperty("http.proxyPort");
-        String nonProxyHosts = System.getProperty("http.nonProxyHosts");
-        boolean hostInNonProxyList = isHostInNonProxyList(host, nonProxyHosts);
-        String proxyUsername = System.getProperty("http.proxyUser");
-        String proxyPassword = System.getProperty("http.proxyPassword");
-
-        if ( proxyUsername != null ) {
-            StringBuffer tmpBuf = new StringBuffer();
-            tmpBuf.append( proxyUsername )
-           .append( ":" )
-           .append( (proxyPassword == null) ? "" : proxyPassword) ;
-            otherHeaders.append( HTTPConstants.HEADER_PROXY_AUTHORIZATION )
-                 .append( ": Basic " )
-                 .append( Base64.encode( tmpBuf.toString().getBytes() ) )
-                 .append("\r\n" );
-        }
-
-        if ((port = tmpURL.getPort()) == -1 ) port = 80;
-
-        if (proxyHost == null || proxyHost.equals("")
-            || proxyPort == null || proxyPort.equals("")
-            || hostInNonProxyList) {
-            sock = new Socket( host, port );
-
-            if (log.isDebugEnabled()) {
-                log.debug( JavaUtils.getMessage("createdHTTP00"));
-            }
-        } else {
-            sock = new Socket( proxyHost, new Integer(proxyPort).intValue() );
-
-            if (log.isDebugEnabled()) {
-                log.debug( JavaUtils.getMessage("createdHTTP01",
-                    proxyHost, proxyPort));
-            }
-            useFullURL.value = true;
-        }
-        return sock;
-    }
-
-    private void writeToSocket(Socket sock, MessageContext msgContext,
-                               URL tmpURL, StringBuffer otherHeaders,
-                               String host, BooleanHolder useFullURL)
-            throws IOException
-    {
-        OutputStream  out  = new BufferedOutputStream(sock.getOutputStream(), 8*1024);
-        String        userID = null ;
-        String        passwd = null ;
-        String        reqEnv = null;
-
-        userID = msgContext.getUsername();
-        passwd = msgContext.getPassword();
-
-        //  Get SOAPAction, default to ""
-        String   action = msgContext.useSOAPAction() ?
-                msgContext.getSOAPActionURI() : "";
-        if (action == null)
-            action = "";
-
-        // if UserID is not part of the context, but is in the URL, use
-        // the one in the URL.
-        if ( userID == null && tmpURL.getUserInfo() != null) {
-            String info = tmpURL.getUserInfo();
-            int sep = info.indexOf(':');
-            if ( (sep>=0) && (sep+1<info.length()) ) {
-                userID = info.substring(0,sep);
-                passwd = info.substring(sep+1);
-            } else {
-                userID = info;
-            }
-        }
-
-        if ( userID != null ) {
-            StringBuffer tmpBuf = new StringBuffer();
-            tmpBuf.append( userID )
-           .append( ":" )
-           .append( (passwd == null) ? "" : passwd) ;
-            otherHeaders.append( HTTPConstants.HEADER_AUTHORIZATION )
-                 .append( ": Basic " )
-                 .append( Base64.encode( tmpBuf.toString().getBytes() ) )
-                 .append("\r\n" );
-        }
-
-        // don't forget the cookies!
-        // mmm... cookies
-        if (msgContext.getMaintainSession()) {
-            String cookie = msgContext.getStrProp(HTTPConstants.HEADER_COOKIE);
-            String cookie2 = msgContext.getStrProp(HTTPConstants.HEADER_COOKIE2);
-
-            if (cookie != null) {
-                otherHeaders.append(HTTPConstants.HEADER_COOKIE)
-                 .append(": ")
-                 .append(cookie)
-                 .append("\r\n");
-            }
-
-            if (cookie2 != null) {
-                otherHeaders.append(HTTPConstants.HEADER_COOKIE2)
-                 .append(": ")
-                 .append(cookie2)
-                 .append("\r\n");
-            }
-        }
-
-        StringBuffer header = new StringBuffer();
-        // byte[] request = reqEnv.getBytes();
-
-        header.append( HTTPConstants.HEADER_POST )
-         .append(" " );
-        if (useFullURL.value) {
-            header.append(tmpURL.toExternalForm());
-        } else {
-            header.append( ((tmpURL.getFile() == null ||
-                    tmpURL.getFile().equals(""))? "/": tmpURL.getFile()) );
-        }
-
-        Message reqMessage= msgContext.getRequestMessage();
-
-        header.append( " HTTP/1.0\r\n" )
-         .append( HTTPConstants.HEADER_CONTENT_LENGTH )
-         .append( ": " )
-         .append( reqMessage.getContentLength() )
-         .append( "\r\n" )
-         .append( HTTPConstants.HEADER_HOST )
-         .append( ": " )
-         .append( host )
-         .append( "\r\n" )
-         .append( HTTPConstants.HEADER_CONTENT_TYPE )
-         .append( ": " )
-         .append( reqMessage.getContentType())
-         .append( "\r\n" )
-         .append( (otherHeaders == null ? "" : otherHeaders.toString()))
-         .append( HTTPConstants.HEADER_SOAP_ACTION )
-         .append( ": \"" )
-         .append( action )
-         .append( "\"\r\n");
-
-        // adding user-defined/platform-dependent HTTP headers
-        if (msgContext.getProperty(HTTPConstants.REQUEST_HEADERS)!=null) {
-            Hashtable headerTable =
-                (Hashtable)msgContext.getProperty(HTTPConstants.REQUEST_HEADERS);
-            for (Enumeration e = headerTable.keys(); e.hasMoreElements(); ) {
-                Object key = e.nextElement();
-                header.append(key).append(": ")
-                 .append(headerTable.get(key)).append("\r\n");
             }
-        }
-
-        header.append("\r\n");
-
-        out.write( header.toString().getBytes(HTTPConstants.HEADER_DEFAULT_CHAR_ENCODING) );
-        reqMessage.writeContentToStream(out);
-        out.flush();
-
-        if (log.isDebugEnabled()) {
-            log.debug( JavaUtils.getMessage("xmlSent00") );
-            log.debug( "---------------------------------------------------");
-            log.debug( header + reqEnv );
-        }
-    }
-
-    private void readFromSocket(Socket sock, MessageContext msgContext) throws IOException {
-        Message outMsg = null;
-        byte       b ;
-        int        len = 0 ;
-        int        colonIndex = -1 ;
-        Hashtable  headers = new Hashtable();
-        String     name, value ;
-        String     statusMessage = "";
-        int returnCode = 0;
-
-        BufferedInputStream inp = new BufferedInputStream(sock.getInputStream());
-        //Should help performance. Temporary fix only till its all stream oriented.
 
-        // Need to add logic for getting the version # and the return code
-        // but that's for tomorrow!
-
-        /*Logic to read HTTP response headers */
-        boolean readTooMuch= false;
-        b=0;
-        for(ByteArrayOutputStream buf= new ByteArrayOutputStream(4097);;){
-            if(!readTooMuch)b = (byte) inp.read();
-            if(b == -1 ) break ;
-            readTooMuch=false;
-            if ( b != '\r' && b != '\n' ) {
-                if ( b == ':' && colonIndex == -1 ) colonIndex = len ;
-                len++;
-                buf.write(b);
+            if ( b != -1 && Debug.getDebugLevel() > 8 ) {
+                // Special case - if the debug level is this high then something
+                // really bad must be going on - so just dump the input stream
+                // to stdout.
+                while ( (b = (byte) inp.read()) != -1 )
+                    System.err.print((char)b);
+                System.err.println("");
             }
-            else if ( b == '\r' )
-                continue ;
-            else {  //b== '\n'
-                if ( len == 0 ) break ;
-
-                b = (byte) inp.read();
-                readTooMuch= true;
-                    //A space or tab at the begining of a line means the header continues.
-                if( b == ' ' || b== '\t'){
-                    continue;
-                }
 
-                if ( colonIndex != -1 ) {
-                    buf.close();
-                    byte[]hdata= buf.toByteArray();
-                    buf.reset();
-                    name = new String( hdata, 0, colonIndex, HTTPConstants.HEADER_DEFAULT_CHAR_ENCODING );
-                    value = new String( hdata, colonIndex+1, len-1-colonIndex, HTTPConstants.HEADER_DEFAULT_CHAR_ENCODING );
-                    colonIndex = -1 ;
-                }
-                else {
-                    buf.close();
-                    byte[]hdata= buf.toByteArray();
-                    buf.reset();
-                    name = new String( hdata, 0, len, HTTPConstants.HEADER_DEFAULT_CHAR_ENCODING );
-                    value = "" ;
-                }
-
-                if (log.isDebugEnabled()) {
-                    log.debug( name + value );
+            if ( b != -1 ) {
+                if (Debug.getDebugLevel() > 0) {
+                    String contentLength = (String) headers.get("content-length");
+                    if ( contentLength != null ) {
+                        contentLength = contentLength.trim();
+                        byte[] data = new byte[Integer.parseInt(contentLength)];
+                        for (len=0; len<data.length; )
+                            len+= inp.read(data,len,data.length-len);
+                        String xml = new String(data);
+                        
+                        outMsg = new Message( data );
+                        
+                        Debug.Print( 1, "\nXML received:" );
+                        Debug.Print( 1, "-----------------------------------------------");
+                        Debug.Print( 1, xml );
+                    }
+                    else {
+                        outMsg = new Message( inp );
+                        Debug.Print( 1, "\nNo Content-Length" );
+                        Debug.Print( 1, "\nXML received:" );
+                        Debug.Print( 1, "-----------------------------------------------");
+                        Debug.Print( 1, (String) outMsg.getAsString() );
+                    }
+                } else {
+                    outMsg = new Message( inp );
                 }
 
-                if ( msgContext.getProperty(HTTPConstants.MC_HTTP_STATUS_CODE)==null){
-                    // Reader status code
-                    int start = name.indexOf( ' ' ) + 1 ;
-                    String tmp = name.substring(start).trim();
-                    int end   = tmp.indexOf( ' ' );
-                    if ( end != -1 ) tmp = tmp.substring( 0, end );
-                    returnCode = Integer.parseInt( tmp );
-                    msgContext.setProperty( HTTPConstants.MC_HTTP_STATUS_CODE,
-                                            new Integer(returnCode) );
-                    statusMessage = name.substring(start + end + 1);
-                    msgContext.setProperty( HTTPConstants.MC_HTTP_STATUS_MESSAGE,
-                                            statusMessage);
+                outMsg.setMessageType(org.apache.axis.encoding.
+                                                 ServiceDescription.RESPONSE);
+                msgContext.setResponseMessage( outMsg );
+                
+                // if we are maintaining session state,
+                // handle cookies (if any)
+                if (msgContext.getMaintainSession()) {
+                    handleCookie(HTTPConstants.HEADER_COOKIE,
+                                 HTTPConstants.HEADER_SET_COOKIE,
+                                 headers,
+                                 msgContext);
+                    handleCookie(HTTPConstants.HEADER_COOKIE2,
+                                 HTTPConstants.HEADER_SET_COOKIE2,
+                                 headers,
+                                 msgContext);
                 }
-                else
-                    headers.put( name.toLowerCase(), value );
-                len = 0 ;
-            }
-        }
-        /*All HTTP headers have been read.*/
-
-        String contentType = (String) headers.get(
-                   HTTPConstants.HEADER_CONTENT_TYPE.toLowerCase());
-        contentType= (null == contentType )? null:contentType.trim();
-
-        if (returnCode > 199 && returnCode < 300) {
-            // SOAP return is OK - so fall through
-        } else if (contentType!=null && !contentType.equals("text/html") &&
-                   (returnCode > 499 && returnCode < 600) ) {
-            // SOAP Fault should be in here - so fall through
-        } else {
-            // Unknown return code - so wrap up the content into a
-            // SOAP Fault.
-           ByteArrayOutputStream buf= new ByteArrayOutputStream(4097);
-           while(-1 !=(b = (byte)inp.read())){
-              buf.write(b);
-           }
-
-            AxisFault fault = new AxisFault("HTTP",
-                                            statusMessage,
-                                            null,
-                                            null);
-            fault.setFaultDetailString(JavaUtils.getMessage("return01",
-                    "" + returnCode, buf.toString()));
-            throw fault;
-        }
-
-        if ( b != -1 ) { //more data than just headers.
-
-            String contentLocation = (String) headers.get(
-                HTTPConstants.HEADER_CONTENT_LOCATION.toLowerCase());
-            contentLocation= (null == contentLocation )? null:contentLocation.trim();
-
-            String contentLength = (String) headers.get(
-                HTTPConstants.HEADER_CONTENT_LENGTH.toLowerCase());
-            contentLength= (null == contentLength )? null:contentLength.trim();
-
-            outMsg = new Message( inp, false, contentType, contentLocation);
-
-            outMsg.setMessageType(Message.RESPONSE);
-            msgContext.setResponseMessage( outMsg );
-
-            if (log.isDebugEnabled()) {
-                if(null==contentLength )
-                    log.debug( "\n" + JavaUtils.getMessage("no00",
-                      "Content-Length") );
-                log.debug( "\n" + JavaUtils.getMessage("xmlRecd00") );
-                log.debug( "-----------------------------------------------");
-                log.debug( (String) outMsg.getSOAPPart().getAsString() );
             }
-
         }
-
-
-        // if we are maintaining session state,
-        // handle cookies (if any)
-        if (msgContext.getMaintainSession()) {
-            handleCookie(HTTPConstants.HEADER_COOKIE,
-                         HTTPConstants.HEADER_SET_COOKIE,
-                         headers,
-                         msgContext);
-            handleCookie(HTTPConstants.HEADER_COOKIE2,
-                         HTTPConstants.HEADER_SET_COOKIE2,
-                         headers,
-                         msgContext);
+        catch( Exception e ) {
+            Debug.Print( 1, e );
+            e.printStackTrace();
+            if ( !(e instanceof AxisFault) ) e = new AxisFault(e);
+            throw (AxisFault) e ;
         }
+        Debug.Print( 1, "Exit: HTTPDispatchHandler::invoke" );
     }
-
+    
     // little helper function for cookies
     public void handleCookie
          (String cookieName, String setCookieName, Hashtable headers,
@@ -617,177 +381,12 @@ public class HTTPSender extends BasicHandler {
             msgContext.setProperty(cookieName, cookie);
         }
     }
+    
+    
 
-    private boolean isHostInNonProxyList(String host, String nonProxyHosts)
-    {
-        if(nonProxyHosts == null || host == null)
-            return false;
-        StringTokenizer tokenizer = new StringTokenizer(nonProxyHosts,"|");
-        while(tokenizer.hasMoreTokens()) {
-            String pattern = tokenizer.nextToken();
-
-            if (log.isDebugEnabled()) {
-                log.debug( JavaUtils.getMessage(
-                    "match00",
-                    new String[] {"HTTPSender", host, pattern}));
-            }
-
-            if(match(pattern, host, false))
-                return true;
-        }
-        return false;
-    }
-
-    /**
-     * Matches a string against a pattern. The pattern contains two special
-     * characters:
-     * '*' which means zero or more characters,
-     *
-     * @param pattern the (non-null) pattern to match against
-     * @param str     the (non-null) string that must be matched against the
-     *                pattern
-     *
-     * @return <code>true</code> when the string matches against the pattern,
-     *         <code>false</code> otherwise.
-     */
-    private static boolean match(String pattern, String str, boolean isCaseSensitive) {
-        char[] patArr = pattern.toCharArray();
-        char[] strArr = str.toCharArray();
-        int patIdxStart = 0;
-        int patIdxEnd   = patArr.length-1;
-        int strIdxStart = 0;
-        int strIdxEnd   = strArr.length-1;
-        char ch;
-
-        boolean containsStar = false;
-        for (int i = 0; i < patArr.length; i++) {
-            if (patArr[i] == '*') {
-                containsStar = true;
-                break;
-            }
-        }
-
-        if (!containsStar) {
-            // No '*'s, so we make a shortcut
-            if (patIdxEnd != strIdxEnd) {
-                return false; // Pattern and string do not have the same size
-            }
-            for (int i = 0; i <= patIdxEnd; i++) {
-                ch = patArr[i];
-                if (isCaseSensitive && ch != strArr[i]) {
-                    return false;// Character mismatch
-                }
-                if (!isCaseSensitive && Character.toUpperCase(ch) !=
-                    Character.toUpperCase(strArr[i])) {
-                    return false; // Character mismatch
-                }
-            }
-            return true; // String matches against pattern
-        }
-
-        if (patIdxEnd == 0) {
-            return true; // Pattern contains only '*', which matches anything
-        }
-
-        // Process characters before first star
-        while((ch = patArr[patIdxStart]) != '*' && strIdxStart <= strIdxEnd) {
-            if (isCaseSensitive && ch != strArr[strIdxStart]) {
-                return false;// Character mismatch
-            }
-            if (!isCaseSensitive && Character.toUpperCase(ch) !=
-                Character.toUpperCase(strArr[strIdxStart])) {
-                return false;// Character mismatch
-            }
-            patIdxStart++;
-            strIdxStart++;
-        }
-        if (strIdxStart > strIdxEnd) {
-            // All characters in the string are used. Check if only '*'s are
-            // left in the pattern. If so, we succeeded. Otherwise failure.
-            for (int i = patIdxStart; i <= patIdxEnd; i++) {
-                if (patArr[i] != '*') {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        // Process characters after last star
-        while((ch = patArr[patIdxEnd]) != '*' && strIdxStart <= strIdxEnd) {
-            if (isCaseSensitive && ch != strArr[strIdxEnd]) {
-                return false;// Character mismatch
-            }
-            if (!isCaseSensitive && Character.toUpperCase(ch) !=
-                Character.toUpperCase(strArr[strIdxEnd])) {
-                return false;// Character mismatch
-            }
-            patIdxEnd--;
-            strIdxEnd--;
-        }
-        if (strIdxStart > strIdxEnd) {
-            // All characters in the string are used. Check if only '*'s are
-            // left in the pattern. If so, we succeeded. Otherwise failure.
-            for (int i = patIdxStart; i <= patIdxEnd; i++) {
-                if (patArr[i] != '*') {
-                    return false;
-                }
-            }
-            return true;
-        }
-
-        // process pattern between stars. padIdxStart and patIdxEnd point
-        // always to a '*'.
-        while (patIdxStart != patIdxEnd && strIdxStart <= strIdxEnd) {
-            int patIdxTmp = -1;
-            for (int i = patIdxStart+1; i <= patIdxEnd; i++) {
-                if (patArr[i] == '*') {
-                    patIdxTmp = i;
-                    break;
-                }
-            }
-            if (patIdxTmp == patIdxStart+1) {
-                // Two stars next to each other, skip the first one.
-                patIdxStart++;
-                continue;
-            }
-            // Find the pattern between padIdxStart & padIdxTmp in str between
-            // strIdxStart & strIdxEnd
-            int patLength = (patIdxTmp-patIdxStart-1);
-            int strLength = (strIdxEnd-strIdxStart+1);
-            int foundIdx  = -1;
-            strLoop:
-            for (int i = 0; i <= strLength - patLength; i++) {
-                for (int j = 0; j < patLength; j++) {
-                    ch = patArr[patIdxStart+j+1];
-                    if (isCaseSensitive && ch != strArr[strIdxStart+i+j]) {
-                        continue strLoop;
-                    }
-                    if (!isCaseSensitive && Character.toUpperCase(ch) !=
-                        Character.toUpperCase(strArr[strIdxStart+i+j])) {
-                        continue strLoop;
-                    }
-                }
-
-                foundIdx = strIdxStart+i;
-                break;
-            }
-
-            if (foundIdx == -1) {
-                return false;
-            }
-
-            patIdxStart = patIdxTmp;
-            strIdxStart = foundIdx+patLength;
-        }
-
-        // All characters in the string are used. Check if only '*'s are left
-        // in the pattern. If so, we succeeded. Otherwise failure.
-        for (int i = patIdxStart; i <= patIdxEnd; i++) {
-            if (patArr[i] != '*') {
-                return false;
-            }
-        }
-        return true;
+    public void undo(MessageContext msgContext) {
+        Debug.Print( 1, "Enter: HTTPDispatchHandler::undo" );
+        Debug.Print( 1, "Exit: HTTPDispatchHandler::undo" );
     }
-}
+};
 