diff --git a/asterixdb/asterix-lang-sqlpp/src/main/java/org/apache/asterix/lang/sqlpp/rewrites/SqlppQueryRewriter.java b/asterixdb/asterix-lang-sqlpp/src/main/java/org/apache/asterix/lang/sqlpp/rewrites/SqlppQueryRewriter.java
index 8bc319f0f0..fab5c07602 100644
--- a/asterixdb/asterix-lang-sqlpp/src/main/java/org/apache/asterix/lang/sqlpp/rewrites/SqlppQueryRewriter.java
+++ b/asterixdb/asterix-lang-sqlpp/src/main/java/org/apache/asterix/lang/sqlpp/rewrites/SqlppQueryRewriter.java
@@ -19,27 +19,19 @@
 package org.apache.asterix.lang.sqlpp.rewrites;
 
 import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import org.apache.asterix.common.exceptions.CompilationException;
+import org.apache.asterix.common.exceptions.AsterixException;
 import org.apache.asterix.common.functions.FunctionSignature;
-import org.apache.asterix.lang.common.base.AbstractClause;
 import org.apache.asterix.lang.common.base.Expression;
 import org.apache.asterix.lang.common.base.IQueryRewriter;
-import org.apache.asterix.lang.common.base.IReturningStatement;
-import org.apache.asterix.lang.common.expression.CallExpr;
-import org.apache.asterix.lang.common.expression.ListSliceExpression;
-import org.apache.asterix.lang.common.expression.VariableExpr;
+import org.apache.asterix.lang.common.clause.LetClause;
 import org.apache.asterix.lang.common.rewrites.LangRewritingContext;
 import org.apache.asterix.lang.common.statement.FunctionDecl;
-import org.apache.asterix.lang.common.struct.Identifier;
-import org.apache.asterix.lang.common.struct.VarIdentifier;
+import org.apache.asterix.lang.common.statement.Query;
 import org.apache.asterix.lang.common.util.FunctionUtil;
 import org.apache.asterix.lang.common.visitor.GatherFunctionCallsVisitor;
-import org.apache.asterix.lang.common.visitor.base.ILangVisitor;
 import org.apache.asterix.lang.sqlpp.clause.AbstractBinaryCorrelateClause;
 import org.apache.asterix.lang.sqlpp.clause.FromClause;
 import org.apache.asterix.lang.sqlpp.clause.FromTerm;
@@ -53,263 +45,226 @@ import org.apache.asterix.lang.sqlpp.clause.SelectElement;
 import org.apache.asterix.lang.sqlpp.clause.SelectRegular;
 import org.apache.asterix.lang.sqlpp.clause.SelectSetOperation;
 import org.apache.asterix.lang.sqlpp.clause.UnnestClause;
-import org.apache.asterix.lang.sqlpp.expression.CaseExpression;
+import org.apache.asterix.lang.sqlpp.expression.IndependentSubquery;
 import org.apache.asterix.lang.sqlpp.expression.SelectExpression;
-import org.apache.asterix.lang.sqlpp.expression.WindowExpression;
 import org.apache.asterix.lang.sqlpp.parser.FunctionParser;
 import org.apache.asterix.lang.sqlpp.parser.SqlppParserFactory;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.GenerateColumnNameVisitor;
 import org.apache.asterix.lang.sqlpp.rewrites.visitor.InlineColumnAliasVisitor;
 import org.apache.asterix.lang.sqlpp.rewrites.visitor.InlineWithExpressionVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.OperatorExpressionVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.SetOperationVisitor;
 import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppBuiltinFunctionRewriteVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppGroupByAggregationSugarVisitor;
+import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppGlobalAggregationSugarVisitor;
 import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppGroupByVisitor;
 import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppInlineUdfsVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppListInputFunctionRewriteVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppWindowAggregationSugarVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.SqlppWindowRewriteVisitor;
-import org.apache.asterix.lang.sqlpp.rewrites.visitor.SubstituteGroupbyExpressionWithVariableVisitor;
 import org.apache.asterix.lang.sqlpp.rewrites.visitor.VariableCheckAndRewriteVisitor;
 import org.apache.asterix.lang.sqlpp.struct.SetOperationRight;
 import org.apache.asterix.lang.sqlpp.util.FunctionMapUtil;
-import org.apache.asterix.lang.sqlpp.util.SqlppAstPrintUtil;
-import org.apache.asterix.lang.sqlpp.util.SqlppVariableUtil;
 import org.apache.asterix.lang.sqlpp.visitor.base.ISqlppVisitor;
-import org.apache.asterix.metadata.declared.MetadataProvider;
-import org.apache.hyracks.algebricks.common.utils.Pair;
-import org.apache.hyracks.util.LogRedactionUtil;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-public class SqlppQueryRewriter implements IQueryRewriter {
-
-    private static final Logger LOGGER = LogManager.getLogger(SqlppQueryRewriter.class);
-
-    public static final String INLINE_WITH_OPTION = "inline_with";
-    private static final boolean INLINE_WITH_OPTION_DEFAULT = true;
+import org.apache.asterix.metadata.MetadataManager;
+import org.apache.asterix.metadata.MetadataTransactionContext;
+import org.apache.asterix.metadata.declared.AqlMetadataProvider;
+import org.apache.asterix.metadata.entities.Function;
+import org.apache.asterix.om.functions.AsterixBuiltinFunctions;
+
+class SqlppQueryRewriter implements IQueryRewriter {
+    private static final String INLINE_WITH = "inline_with";
+    private static final String NOT_INLINE_WITH = "false";
     private final FunctionParser functionRepository = new FunctionParser(new SqlppParserFactory());
-    private IReturningStatement topExpr;
+    private Query topExpr;
     private List<FunctionDecl> declaredFunctions;
     private LangRewritingContext context;
-    private MetadataProvider metadataProvider;
-    private Collection<VarIdentifier> externalVars;
-    private boolean isLogEnabled;
+    private MetadataTransactionContext mdTxnCtx;
+    private AqlMetadataProvider metadataProvider;
 
-    protected void setup(List<FunctionDecl> declaredFunctions, IReturningStatement topExpr,
-            MetadataProvider metadataProvider, LangRewritingContext context, Collection<VarIdentifier> externalVars)
-            throws CompilationException {
+    protected void setup(List<FunctionDecl> declaredFunctions, Query topExpr, AqlMetadataProvider metadataProvider,
+            LangRewritingContext context) {
         this.topExpr = topExpr;
         this.context = context;
         this.declaredFunctions = declaredFunctions;
+        this.mdTxnCtx = metadataProvider.getMetadataTxnContext();
         this.metadataProvider = metadataProvider;
-        this.externalVars = externalVars;
-        this.isLogEnabled = LOGGER.isTraceEnabled();
-        logExpression("Starting AST rewrites on", "");
     }
 
     @Override
-    public void rewrite(List<FunctionDecl> declaredFunctions, IReturningStatement topStatement,
-            MetadataProvider metadataProvider, LangRewritingContext context, boolean inlineUdfs,
-            Collection<VarIdentifier> externalVars) throws CompilationException {
-        if (topStatement == null) {
-            return;
-        }
-
+    public void rewrite(List<FunctionDecl> declaredFunctions, Query topExpr, AqlMetadataProvider metadataProvider,
+            LangRewritingContext context) throws AsterixException {
         // Sets up parameters.
-        setup(declaredFunctions, topStatement, metadataProvider, context, externalVars);
-
-        // Generates column names.
-        generateColumnNames();
-
-        // Substitutes group-by key expressions.
-        substituteGroupbyKeyExpression();
-
-        // Group-by core rewrites
-        rewriteGroupBys();
-
-        // Rewrites set operations.
-        rewriteSetOperations();
+        setup(declaredFunctions, topExpr, metadataProvider, context);
 
         // Inlines column aliases.
         inlineColumnAlias();
 
-        // Window expression core rewrites.
-        rewriteWindowExpressions();
-
-        // Generate ids for variables (considering scopes) and replace global variable access with the dataset function.
-        variableCheckAndRewrite();
-
-        // Rewrites SQL-92 aggregate functions
-        rewriteGroupByAggregationSugar();
+        // Inlines WITH expressions.
+        inlineWithExpressions();
 
-        // Rewrite window expression aggregations.
-        rewriteWindowAggregationSugar();
+        // Rewrites SQL-92 global aggregations.
+        rewriteGlobalAggregations();
 
-        // Rewrites like/not-like expressions.
-        rewriteOperatorExpression();
+        // Group-by core/sugar rewrites.
+        rewriteGroupBys();
 
-        // Rewrites several variable-arg functions into their corresponding internal list-input functions.
-        rewriteListInputFunctions();
+        // Generate ids for variables (considering scopes) and replace global variable access with the dataset function.
+        variableCheckAndRewrite(true);
 
         // Inlines functions.
-        inlineDeclaredUdfs(inlineUdfs);
+        inlineDeclaredUdfs();
 
         // Rewrites function names.
         // This should be done after inlineDeclaredUdfs() because user-defined function
         // names could be case sensitive.
         rewriteFunctionNames();
 
-        // Inlines WITH expressions after variableCheckAndRewrite(...) so that the variable scoping for WITH
-        // expression is correct.
-        inlineWithExpressions();
+        // Replace global variable access with the dataset function for inlined expressions.
+        variableCheckAndRewrite(true);
 
         // Sets the var counter of the query.
-        topStatement.setVarCounter(context.getVarCounter().get());
+        topExpr.setVarCounter(context.getVarCounter());
     }
 
-    protected void rewriteGroupByAggregationSugar() throws CompilationException {
-        SqlppGroupByAggregationSugarVisitor visitor = new SqlppGroupByAggregationSugarVisitor(context);
-        rewriteTopExpr(visitor, null);
-    }
-
-    protected void rewriteListInputFunctions() throws CompilationException {
-        SqlppListInputFunctionRewriteVisitor listInputFunctionVisitor = new SqlppListInputFunctionRewriteVisitor();
-        rewriteTopExpr(listInputFunctionVisitor, null);
+    protected void rewriteGlobalAggregations() throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
+        SqlppGlobalAggregationSugarVisitor globalAggregationVisitor = new SqlppGlobalAggregationSugarVisitor();
+        globalAggregationVisitor.visit(topExpr, null);
     }
 
-    protected void rewriteFunctionNames() throws CompilationException {
+    protected void rewriteFunctionNames() throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
         SqlppBuiltinFunctionRewriteVisitor functionNameMapVisitor = new SqlppBuiltinFunctionRewriteVisitor();
-        rewriteTopExpr(functionNameMapVisitor, null);
+        functionNameMapVisitor.visit(topExpr, null);
     }
 
-    protected void inlineWithExpressions() throws CompilationException {
-        if (!metadataProvider.getBooleanProperty(INLINE_WITH_OPTION, INLINE_WITH_OPTION_DEFAULT)) {
+    protected void inlineWithExpressions() throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
+        String inlineWith = metadataProvider.getConfig().get(INLINE_WITH);
+        if (inlineWith != null && inlineWith.equalsIgnoreCase(NOT_INLINE_WITH)) {
             return;
         }
         // Inlines with expressions.
         InlineWithExpressionVisitor inlineWithExpressionVisitor = new InlineWithExpressionVisitor(context);
-        rewriteTopExpr(inlineWithExpressionVisitor, null);
-    }
-
-    protected void generateColumnNames() throws CompilationException {
-        // Generate column names if they are missing in the user query.
-        GenerateColumnNameVisitor generateColumnNameVisitor = new GenerateColumnNameVisitor(context);
-        rewriteTopExpr(generateColumnNameVisitor, null);
-    }
-
-    protected void substituteGroupbyKeyExpression() throws CompilationException {
-        // Substitute group-by key expressions that appear in the select clause.
-        SubstituteGroupbyExpressionWithVariableVisitor substituteGbyExprVisitor =
-                new SubstituteGroupbyExpressionWithVariableVisitor(context);
-        rewriteTopExpr(substituteGbyExprVisitor, null);
-    }
-
-    protected void rewriteSetOperations() throws CompilationException {
-        // Rewrites set operation queries that contain order-by and limit clauses.
-        SetOperationVisitor setOperationVisitor = new SetOperationVisitor(context);
-        rewriteTopExpr(setOperationVisitor, null);
+        inlineWithExpressionVisitor.visit(topExpr, null);
     }
 
-    protected void rewriteOperatorExpression() throws CompilationException {
-        // Rewrites like/not-like/in/not-in operators into function call expressions.
-        OperatorExpressionVisitor operatorExpressionVisitor = new OperatorExpressionVisitor(context);
-        rewriteTopExpr(operatorExpressionVisitor, null);
-    }
-
-    protected void inlineColumnAlias() throws CompilationException {
+    protected void inlineColumnAlias() throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
         // Inline column aliases.
-        InlineColumnAliasVisitor inlineColumnAliasVisitor = new InlineColumnAliasVisitor(context);
-        rewriteTopExpr(inlineColumnAliasVisitor, null);
+        InlineColumnAliasVisitor inlineColumnAliasVisitor = new InlineColumnAliasVisitor();
+        inlineColumnAliasVisitor.visit(topExpr, false);
     }
 
-    protected void variableCheckAndRewrite() throws CompilationException {
-        VariableCheckAndRewriteVisitor variableCheckAndRewriteVisitor =
-                new VariableCheckAndRewriteVisitor(context, metadataProvider, externalVars);
-        rewriteTopExpr(variableCheckAndRewriteVisitor, null);
+    protected void variableCheckAndRewrite(boolean overwrite) throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
+        VariableCheckAndRewriteVisitor variableCheckAndRewriteVisitor = new VariableCheckAndRewriteVisitor(context,
+                overwrite, metadataProvider);
+        variableCheckAndRewriteVisitor.visit(topExpr, null);
     }
 
-    protected void rewriteGroupBys() throws CompilationException {
+    protected void rewriteGroupBys() throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
         SqlppGroupByVisitor groupByVisitor = new SqlppGroupByVisitor(context);
-        rewriteTopExpr(groupByVisitor, null);
+        groupByVisitor.visit(topExpr, null);
     }
 
-    protected void rewriteWindowExpressions() throws CompilationException {
-        // Create window variables and extract aggregation inputs into LET clauses
-        SqlppWindowRewriteVisitor windowVisitor = new SqlppWindowRewriteVisitor(context);
-        rewriteTopExpr(windowVisitor, null);
-    }
-
-    protected void rewriteWindowAggregationSugar() throws CompilationException {
-        SqlppWindowAggregationSugarVisitor windowVisitor = new SqlppWindowAggregationSugarVisitor(context);
-        rewriteTopExpr(windowVisitor, null);
-    }
-
-    protected void inlineDeclaredUdfs(boolean inlineUdfs) throws CompilationException {
+    protected void inlineDeclaredUdfs() throws AsterixException {
+        if (topExpr == null) {
+            return;
+        }
         List<FunctionSignature> funIds = new ArrayList<FunctionSignature>();
         for (FunctionDecl fdecl : declaredFunctions) {
             funIds.add(fdecl.getSignature());
         }
 
-        List<FunctionDecl> usedStoredFunctionDecls = new ArrayList<>();
-        for (Expression topLevelExpr : topExpr.getDirectlyEnclosedExpressions()) {
-            usedStoredFunctionDecls.addAll(FunctionUtil.retrieveUsedStoredFunctions(metadataProvider, topLevelExpr,
-                    funIds, null, expr -> getFunctionCalls(expr), func -> functionRepository.getFunctionDecl(func),
-                    (signature, sourceLoc) -> FunctionMapUtil.normalizeBuiltinFunctionSignature(signature, false,
-                            sourceLoc)));
-        }
-        declaredFunctions.addAll(usedStoredFunctionDecls);
-        if (inlineUdfs && !declaredFunctions.isEmpty()) {
+        List<FunctionDecl> otherFDecls = new ArrayList<FunctionDecl>();
+        buildOtherUdfs(topExpr.getBody(), otherFDecls, funIds);
+        declaredFunctions.addAll(otherFDecls);
+        if (!declaredFunctions.isEmpty()) {
             SqlppInlineUdfsVisitor visitor = new SqlppInlineUdfsVisitor(context,
                     new SqlppFunctionBodyRewriterFactory() /* the rewriter for function bodies expressions*/,
                     declaredFunctions, metadataProvider);
-            while (rewriteTopExpr(visitor, declaredFunctions)) {
+            while (topExpr.accept(visitor, declaredFunctions)) {
                 // loop until no more changes
             }
         }
-        declaredFunctions.removeAll(usedStoredFunctionDecls);
+        declaredFunctions.removeAll(otherFDecls);
     }
 
-    private <R, T> R rewriteTopExpr(ILangVisitor<R, T> visitor, T arg) throws CompilationException {
-        R result = topExpr.accept(visitor, arg);
-        logExpression(">>>> AST After", visitor.getClass().getSimpleName());
-        return result;
+    protected void buildOtherUdfs(Expression expression, List<FunctionDecl> functionDecls,
+            List<FunctionSignature> declaredFunctions) throws AsterixException {
+        if (expression == null) {
+            return;
+        }
+        String value = metadataProvider.getConfig().get(FunctionUtil.IMPORT_PRIVATE_FUNCTIONS);
+        boolean includePrivateFunctions = (value != null) ? Boolean.valueOf(value.toLowerCase()) : false;
+        Set<FunctionSignature> functionCalls = getFunctionCalls(expression);
+        for (FunctionSignature signature : functionCalls) {
+
+            if (declaredFunctions != null && declaredFunctions.contains(signature)) {
+                continue;
+            }
+
+            Function function = lookupUserDefinedFunctionDecl(signature);
+            if (function == null) {
+                FunctionSignature normalizedSignature = FunctionMapUtil.normalizeBuiltinFunctionSignature(signature,
+                        false);
+                if (AsterixBuiltinFunctions.isBuiltinCompilerFunction(normalizedSignature, includePrivateFunctions)) {
+                    continue;
+                }
+                StringBuilder messageBuilder = new StringBuilder();
+                if (functionDecls.size() > 0) {
+                    messageBuilder.append("function " + functionDecls.get(functionDecls.size() - 1).getSignature()
+                            + " depends upon function " + signature + " which is undefined");
+                } else {
+                    messageBuilder.append("function " + signature + " is undefined ");
+                }
+                throw new AsterixException(messageBuilder.toString());
+            }
+
+            if (function.getLanguage().equalsIgnoreCase(Function.LANGUAGE_AQL)) {
+                FunctionDecl functionDecl = functionRepository.getFunctionDecl(function);
+                if (functionDecl != null) {
+                    if (functionDecls.contains(functionDecl)) {
+                        throw new AsterixException(
+                                "Recursive invocation " + functionDecls.get(functionDecls.size() - 1).getSignature()
+                                        + " <==> " + functionDecl.getSignature());
+                    }
+                    functionDecls.add(functionDecl);
+                    buildOtherUdfs(functionDecl.getFuncBody(), functionDecls, declaredFunctions);
+                }
+            }
+        }
+
     }
 
-    private void logExpression(String p0, String p1) throws CompilationException {
-        if (isLogEnabled) {
-            LOGGER.trace("{} {}\n{}", p0, p1, LogRedactionUtil.userData(SqlppAstPrintUtil.toString(topExpr)));
+    private Function lookupUserDefinedFunctionDecl(FunctionSignature signature) throws AsterixException {
+        if (signature.getNamespace() == null) {
+            return null;
         }
+        return MetadataManager.INSTANCE.getFunction(mdTxnCtx, signature);
     }
 
-    @Override
-    public Set<CallExpr> getFunctionCalls(Expression expression) throws CompilationException {
+    private Set<FunctionSignature> getFunctionCalls(Expression expression) throws AsterixException {
         GatherFunctionCalls gfc = new GatherFunctionCalls();
         expression.accept(gfc, null);
         return gfc.getCalls();
     }
 
-    @Override
-    public Set<VariableExpr> getExternalVariables(Expression expr) throws CompilationException {
-        Set<VariableExpr> freeVars = SqlppVariableUtil.getFreeVariables(expr);
-
-        Set<VariableExpr> extVars = new HashSet<>();
-        for (VariableExpr ve : freeVars) {
-            if (SqlppVariableUtil.isExternalVariableReference(ve)) {
-                extVars.add(ve);
-            }
-        }
-        return extVars;
-    }
-
     private static class GatherFunctionCalls extends GatherFunctionCallsVisitor implements ISqlppVisitor<Void, Void> {
 
         public GatherFunctionCalls() {
         }
 
         @Override
-        public Void visit(FromClause fromClause, Void arg) throws CompilationException {
+        public Void visit(FromClause fromClause, Void arg) throws AsterixException {
             for (FromTerm fromTerm : fromClause.getFromTerms()) {
                 fromTerm.accept(this, arg);
             }
@@ -317,7 +272,7 @@ public class SqlppQueryRewriter implements IQueryRewriter {
         }
 
         @Override
-        public Void visit(FromTerm fromTerm, Void arg) throws CompilationException {
+        public Void visit(FromTerm fromTerm, Void arg) throws AsterixException {
             fromTerm.getLeftExpression().accept(this, arg);
             for (AbstractBinaryCorrelateClause correlateClause : fromTerm.getCorrelateClauses()) {
                 correlateClause.accept(this, arg);
@@ -326,51 +281,55 @@ public class SqlppQueryRewriter implements IQueryRewriter {
         }
 
         @Override
-        public Void visit(JoinClause joinClause, Void arg) throws CompilationException {
+        public Void visit(JoinClause joinClause, Void arg) throws AsterixException {
             joinClause.getRightExpression().accept(this, arg);
             joinClause.getConditionExpression().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(NestClause nestClause, Void arg) throws CompilationException {
+        public Void visit(NestClause nestClause, Void arg) throws AsterixException {
             nestClause.getRightExpression().accept(this, arg);
             nestClause.getConditionExpression().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(Projection projection, Void arg) throws CompilationException {
-            if (!projection.star()) {
-                projection.getExpression().accept(this, arg);
-            }
+        public Void visit(Projection projection, Void arg) throws AsterixException {
+            projection.getExpression().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(SelectBlock selectBlock, Void arg) throws CompilationException {
+        public Void visit(SelectBlock selectBlock, Void arg) throws AsterixException {
             if (selectBlock.hasFromClause()) {
                 selectBlock.getFromClause().accept(this, arg);
             }
-            if (selectBlock.hasLetWhereClauses()) {
-                for (AbstractClause letWhereClause : selectBlock.getLetWhereList()) {
-                    letWhereClause.accept(this, arg);
+            if (selectBlock.hasLetClauses()) {
+                for (LetClause letClause : selectBlock.getLetList()) {
+                    letClause.accept(this, arg);
                 }
             }
+            if (selectBlock.hasWhereClause()) {
+                selectBlock.getWhereClause().accept(this, arg);
+            }
             if (selectBlock.hasGroupbyClause()) {
                 selectBlock.getGroupbyClause().accept(this, arg);
             }
-            if (selectBlock.hasLetHavingClausesAfterGroupby()) {
-                for (AbstractClause letHavingClause : selectBlock.getLetHavingListAfterGroupby()) {
-                    letHavingClause.accept(this, arg);
+            if (selectBlock.hasLetClausesAfterGroupby()) {
+                for (LetClause letClause : selectBlock.getLetListAfterGroupby()) {
+                    letClause.accept(this, arg);
                 }
             }
+            if (selectBlock.hasHavingClause()) {
+                selectBlock.getHavingClause().accept(this, arg);
+            }
             selectBlock.getSelectClause().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(SelectClause selectClause, Void arg) throws CompilationException {
+        public Void visit(SelectClause selectClause, Void arg) throws AsterixException {
             if (selectClause.selectElement()) {
                 selectClause.getSelectElement().accept(this, arg);
             } else {
@@ -380,13 +339,13 @@ public class SqlppQueryRewriter implements IQueryRewriter {
         }
 
         @Override
-        public Void visit(SelectElement selectElement, Void arg) throws CompilationException {
+        public Void visit(SelectElement selectElement, Void arg) throws AsterixException {
             selectElement.getExpression().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(SelectRegular selectRegular, Void arg) throws CompilationException {
+        public Void visit(SelectRegular selectRegular, Void arg) throws AsterixException {
             for (Projection projection : selectRegular.getProjections()) {
                 projection.accept(this, arg);
             }
@@ -394,7 +353,7 @@ public class SqlppQueryRewriter implements IQueryRewriter {
         }
 
         @Override
-        public Void visit(SelectSetOperation selectSetOperation, Void arg) throws CompilationException {
+        public Void visit(SelectSetOperation selectSetOperation, Void arg) throws AsterixException {
             selectSetOperation.getLeftInput().accept(this, arg);
             for (SetOperationRight setOperationRight : selectSetOperation.getRightInputs()) {
                 setOperationRight.getSetOperationRightInput().accept(this, arg);
@@ -403,7 +362,7 @@ public class SqlppQueryRewriter implements IQueryRewriter {
         }
 
         @Override
-        public Void visit(SelectExpression selectStatement, Void arg) throws CompilationException {
+        public Void visit(SelectExpression selectStatement, Void arg) throws AsterixException {
             selectStatement.getSelectSetOperation().accept(this, arg);
             if (selectStatement.hasOrderby()) {
                 selectStatement.getOrderbyClause().accept(this, arg);
@@ -415,68 +374,22 @@ public class SqlppQueryRewriter implements IQueryRewriter {
         }
 
         @Override
-        public Void visit(UnnestClause unnestClause, Void arg) throws CompilationException {
+        public Void visit(UnnestClause unnestClause, Void arg) throws AsterixException {
             unnestClause.getRightExpression().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(HavingClause havingClause, Void arg) throws CompilationException {
+        public Void visit(HavingClause havingClause, Void arg) throws AsterixException {
             havingClause.getFilterExpression().accept(this, arg);
             return null;
         }
 
         @Override
-        public Void visit(CaseExpression caseExpression, Void arg) throws CompilationException {
-            caseExpression.getConditionExpr().accept(this, arg);
-            for (Expression expr : caseExpression.getWhenExprs()) {
-                expr.accept(this, arg);
-            }
-            for (Expression expr : caseExpression.getThenExprs()) {
-                expr.accept(this, arg);
-            }
-            caseExpression.getElseExpr().accept(this, arg);
-            return null;
-        }
-
-        @Override
-        public Void visit(WindowExpression winExpr, Void arg) throws CompilationException {
-            if (winExpr.hasPartitionList()) {
-                for (Expression expr : winExpr.getPartitionList()) {
-                    expr.accept(this, arg);
-                }
-            }
-            if (winExpr.hasOrderByList()) {
-                for (Expression expr : winExpr.getOrderbyList()) {
-                    expr.accept(this, arg);
-                }
-            }
-            if (winExpr.hasFrameStartExpr()) {
-                winExpr.getFrameStartExpr().accept(this, arg);
-            }
-            if (winExpr.hasFrameEndExpr()) {
-                winExpr.getFrameEndExpr().accept(this, arg);
-            }
-            if (winExpr.hasWindowFieldList()) {
-                for (Pair<Expression, Identifier> p : winExpr.getWindowFieldList()) {
-                    p.first.accept(this, arg);
-                }
-            }
-            for (Expression expr : winExpr.getExprList()) {
-                expr.accept(this, arg);
-            }
+        public Void visit(IndependentSubquery independentSubquery, Void arg) throws AsterixException {
+            independentSubquery.getExpr().accept(this, arg);
             return null;
         }
 
-        @Override
-        public Void visit(ListSliceExpression expression, Void arg) throws CompilationException {
-            expression.getExpr().accept(this, arg);
-            expression.getStartIndexExpression().accept(this, arg);
-
-            if (expression.hasEndExpression()) {
-                expression.getEndIndexExpression().accept(this, arg);
-            }
-            return null;
-        }
     }
 }