diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java
index 8b91c02a5a..58102d4438 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/replication/ReplicationManager.java
@@ -25,11 +25,8 @@ import java.util.Map;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
-import java.util.concurrent.Executor;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.PooledByteBufAllocator;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.api.core.ActiveMQExceptionType;
@@ -39,7 +36,6 @@ import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.api.core.client.SessionFailureListener;
 import org.apache.activemq.artemis.core.io.SequentialFile;
 import org.apache.activemq.artemis.core.journal.EncodingSupport;
-import org.apache.activemq.artemis.core.persistence.Persister;
 import org.apache.activemq.artemis.core.journal.impl.JournalFile;
 import org.apache.activemq.artemis.core.paging.PagedMessage;
 import org.apache.activemq.artemis.core.persistence.OperationContext;
@@ -86,6 +82,7 @@ import org.jboss.logging.Logger;
  */
 public final class ReplicationManager implements ActiveMQComponent, ReadyListener {
 
+
    private static final Logger logger = Logger.getLogger(ReplicationManager.class);
 
    public enum ADD_OPERATION_TYPE {
@@ -125,14 +122,10 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
 
    private final ExecutorFactory executorFactory;
 
-   private final Executor replicationStream;
-
    private SessionFailureListener failureListener;
 
    private CoreRemotingConnection remotingConnection;
 
-   private final long timeout;
-
    private volatile boolean inSync = true;
 
    private final ReusableLatch synchronizationIsFinishedAcknowledgement = new ReusableLatch(0);
@@ -140,24 +133,19 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
    /**
     * @param remotingConnection
     */
-   public ReplicationManager(CoreRemotingConnection remotingConnection,
-                             final long timeout,
-                             final ExecutorFactory executorFactory) {
+   public ReplicationManager(CoreRemotingConnection remotingConnection, final ExecutorFactory executorFactory) {
       this.executorFactory = executorFactory;
       this.replicatingChannel = remotingConnection.getChannel(CHANNEL_ID.REPLICATION.id, -1);
       this.remotingConnection = remotingConnection;
-      this.replicationStream = executorFactory.getExecutor();
-      this.timeout = timeout;
    }
 
    public void appendUpdateRecord(final byte journalID,
                                   final ADD_OPERATION_TYPE operation,
                                   final long id,
                                   final byte recordType,
-                                  final Persister persister,
-                                  final Object record) throws Exception {
+                                  final EncodingSupport record) throws Exception {
       if (enabled) {
-         sendReplicatePacket(new ReplicationAddMessage(journalID, operation, id, recordType, persister, record));
+         sendReplicatePacket(new ReplicationAddMessage(journalID, operation, id, recordType, record));
       }
    }
 
@@ -172,10 +160,9 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
                                             final long txID,
                                             final long id,
                                             final byte recordType,
-                                            final Persister persister,
-                                            final Object record) throws Exception {
+                                            final EncodingSupport record) throws Exception {
       if (enabled) {
-         sendReplicatePacket(new ReplicationAddTXMessage(journalID, operation, txID, id, recordType, persister, record));
+         sendReplicatePacket(new ReplicationAddTXMessage(journalID, operation, txID, id, recordType, record));
       }
    }
 
@@ -184,7 +171,7 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
                                   boolean sync,
                                   final boolean lineUp) throws Exception {
       if (enabled) {
-         sendReplicatePacket(new ReplicationCommitMessage(journalID, false, txID), lineUp, true);
+         sendReplicatePacket(new ReplicationCommitMessage(journalID, false, txID), lineUp);
       }
    }
 
@@ -322,7 +309,8 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
             logger.trace("Calling ctx.replicationDone()");
             try {
                ctx.replicationDone();
-            } catch (Throwable e) {
+            }
+            catch (Throwable e) {
                ActiveMQServerLogger.LOGGER.errorCompletingCallbackOnReplicationManager(e);
             }
          }
@@ -349,15 +337,15 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
    }
 
    private OperationContext sendReplicatePacket(final Packet packet) {
-      return sendReplicatePacket(packet, true, true);
+      return sendReplicatePacket(packet, true);
    }
 
-   private OperationContext sendReplicatePacket(final Packet packet, boolean lineUp, boolean useExecutor) {
+   private OperationContext sendReplicatePacket(final Packet packet, boolean lineUp) {
       if (!enabled)
          return null;
       boolean runItNow = false;
 
-      final OperationContext repliToken = OperationContextImpl.getContext(executorFactory);
+      OperationContext repliToken = OperationContextImpl.getContext(executorFactory);
       if (lineUp) {
          repliToken.replicationLineUp();
       }
@@ -365,18 +353,12 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
       synchronized (replicationLock) {
          if (enabled) {
             pendingTokens.add(repliToken);
-            if (useExecutor) {
-               replicationStream.execute(() -> {
-                  if (enabled) {
-                     flowControl();
-                     replicatingChannel.send(packet);
-                  }
-               });
-            } else {
-               flowControl();
-               replicatingChannel.send(packet);
+            if (!flowControl()) {
+               return repliToken;
             }
-         } else {
+            replicatingChannel.send(packet);
+         }
+         else {
             // Already replicating channel failed, so just play the action now
             runItNow = true;
          }
@@ -391,41 +373,39 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
       return repliToken;
    }
 
-   /**
-    * This was written as a refactoring of sendReplicatePacket.
-    * In case you refactor this in any way, this method must hold a lock on replication lock. .
-    */
+   /** This was written as a refactoring of sendReplicatePacket.
+    *  In case you refactor this in any way, this method must hold a lock on replication lock. .*/
    private boolean flowControl() {
-      synchronized (replicationLock) {
-         // synchronized (replicationLock) { -- I'm not adding this because the caller already has it
-         // future maintainers of this code please be aware that the intention here is hold the lock on replication lock
-         if (!replicatingChannel.getConnection().isWritable(this)) {
-            try {
-               logger.trace("flowControl waiting on writable replication");
-               writable.set(false);
-               //don't wait for ever as this may hang tests etc, we've probably been closed anyway
-               long now = System.currentTimeMillis();
-               long deadline = now + timeout;
-               while (!writable.get() && now < deadline) {
-                  replicationLock.wait(deadline - now);
-                  now = System.currentTimeMillis();
+      // synchronized (replicationLock) { -- I'm not adding this because the caller already has it
+      // future maintainers of this code please be aware that the intention here is hold the lock on replication lock
+      if (!replicatingChannel.getConnection().isWritable(this)) {
+         try {
+            logger.trace("flowControl waiting on writable");
+            writable.set(false);
+            //don't wait for ever as this may hang tests etc, we've probably been closed anyway
+            long now = System.currentTimeMillis();
+            long deadline = now + 5000;
+            while (!writable.get() && now < deadline)  {
+               replicationLock.wait(deadline - now);
+               now = System.currentTimeMillis();
+            }
+            logger.trace("flow control done");
+
+            if (!writable.get()) {
+               ActiveMQServerLogger.LOGGER.slowReplicationResponse();
+               logger.tracef("There was no response from replication backup after %s seconds, server being stopped now", System.currentTimeMillis() - now);
+               try {
+                  stop();
                }
-               logger.trace("flow control done on replication");
-
-               if (!writable.get()) {
-                  ActiveMQServerLogger.LOGGER.slowReplicationResponse();
-                  logger.tracef("There was no response from replication backup after %s seconds, server being stopped now", System.currentTimeMillis() - now);
-                  try {
-                     stop();
-                  } catch (Exception e) {
-                     logger.warn(e.getMessage(), e);
-                  }
-                  return false;
+               catch (Exception e) {
+                  logger.warn(e.getMessage(), e);
                }
-            } catch (InterruptedException e) {
-               throw new ActiveMQInterruptedException(e);
+               return false;
             }
          }
+         catch (InterruptedException e) {
+            throw new ActiveMQInterruptedException(e);
+         }
       }
       return true;
    }
@@ -462,13 +442,15 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
          if (me.getType() == ActiveMQExceptionType.DISCONNECTED) {
             // Backup has shut down - no need to log a stack trace
             ActiveMQServerLogger.LOGGER.replicationStopOnBackupShutdown();
-         } else {
+         }
+         else {
             ActiveMQServerLogger.LOGGER.replicationStopOnBackupFail(me);
          }
 
          try {
             stop();
-         } catch (Exception e) {
+         }
+         catch (Exception e) {
             ActiveMQServerLogger.LOGGER.errorStoppingReplication(e);
          }
       }
@@ -530,9 +512,10 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
       }
       SequentialFile file = jf.getFile().cloneFile();
       try {
-         ActiveMQServerLogger.LOGGER.replicaSyncFile(file, file.size());
+         ActiveMQServerLogger.LOGGER.journalSynch(jf, file.size(), file);
          sendLargeFile(content, null, jf.getFileID(), file, Long.MAX_VALUE);
-      } finally {
+      }
+      finally {
          if (file.isOpen())
             file.close();
       }
@@ -575,31 +558,31 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
             // We can afford having a single buffer here for this entire loop
             // because sendReplicatePacket will encode the packet as a NettyBuffer
             // through ActiveMQBuffer class leaving this buffer free to be reused on the next copy
-            int size = 1 << 17;
+            final ByteBuffer buffer = ByteBuffer.allocate(1 << 17); // 1 << 17 == 131072 == 128 * 1024
             while (true) {
-               final ByteBuf buffer = PooledByteBufAllocator.DEFAULT.directBuffer(size);
-               ByteBuffer byteBuffer = buffer.writerIndex(size).readerIndex(0).nioBuffer();
-               final int bytesRead = channel.read(byteBuffer);
+               buffer.clear();
+               final int bytesRead = channel.read(buffer);
                int toSend = bytesRead;
                if (bytesRead > 0) {
                   if (bytesRead >= maxBytesToSend) {
                      toSend = (int) maxBytesToSend;
                      maxBytesToSend = 0;
-                  } else {
+                  }
+                  else {
                      maxBytesToSend = maxBytesToSend - bytesRead;
                   }
+                  buffer.limit(toSend);
                }
-               logger.debug("sending " + buffer.writerIndex() + " bytes on file " + file.getFileName());
+               buffer.rewind();
+
                // sending -1 or 0 bytes will close the file at the backup
-               // We cannot simply send everything of a file through the executor,
-               // otherwise we would run out of memory.
-               // so we don't use the executor here
-               sendReplicatePacket(new ReplicationSyncFileMessage(content, pageStore, id, toSend, buffer), true, false);
+               sendReplicatePacket(new ReplicationSyncFileMessage(content, pageStore, id, toSend, buffer));
                if (bytesRead == -1 || bytesRead == 0 || maxBytesToSend == 0)
                   break;
             }
          }
-      } finally {
+      }
+      finally {
          if (file.isOpen())
             file.close();
       }
@@ -642,7 +625,8 @@ public final class ReplicationManager implements ActiveMQComponent, ReadyListene
                logger.trace("sendSynchronizationDone wasn't finished in time");
                throw ActiveMQMessageBundle.BUNDLE.replicationSynchronizationTimeout(initialReplicationSyncTimeout);
             }
-         } catch (InterruptedException e) {
+         }
+         catch (InterruptedException e) {
             logger.debug(e);
          }
          inSync = false;