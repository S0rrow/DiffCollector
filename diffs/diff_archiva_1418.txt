diff --git a/archiva-base/archiva-repository-layer/src/main/java/org/apache/maven/archiva/repository/metadata/MetadataTools.java b/archiva-base/archiva-repository-layer/src/main/java/org/apache/maven/archiva/repository/metadata/MetadataTools.java
index 54374f485..0ea758b30 100644
--- a/archiva-base/archiva-repository-layer/src/main/java/org/apache/maven/archiva/repository/metadata/MetadataTools.java
+++ b/archiva-base/archiva-repository-layer/src/main/java/org/apache/maven/archiva/repository/metadata/MetadataTools.java
@@ -16,10 +16,7 @@
  * limitations under the License.
  */
 
-import org.apache.commons.collections.CollectionUtils;
-import org.apache.commons.lang.StringUtils;
 import org.apache.commons.lang.math.NumberUtils;
-import org.apache.commons.lang.time.DateUtils;
 import org.apache.maven.archiva.common.utils.PathUtil;
 import org.apache.maven.archiva.common.utils.VersionComparator;
 import org.apache.maven.archiva.common.utils.VersionUtil;
@@ -27,14 +24,14 @@
 import org.apache.maven.archiva.configuration.ConfigurationNames;
 import org.apache.maven.archiva.configuration.FileTypes;
 import org.apache.maven.archiva.configuration.ProxyConnectorConfiguration;
+import org.apache.maven.archiva.model.ArchivaRepository;
 import org.apache.maven.archiva.model.ArchivaRepositoryMetadata;
 import org.apache.maven.archiva.model.ArtifactReference;
 import org.apache.maven.archiva.model.ProjectReference;
 import org.apache.maven.archiva.model.SnapshotVersion;
 import org.apache.maven.archiva.model.VersionedReference;
-import org.apache.maven.archiva.repository.ContentNotFoundException;
-import org.apache.maven.archiva.repository.ManagedRepositoryContent;
-import org.apache.maven.archiva.repository.RemoteRepositoryContent;
+import org.apache.maven.archiva.repository.layout.BidirectionalRepositoryLayout;
+import org.apache.maven.archiva.repository.layout.BidirectionalRepositoryLayoutFactory;
 import org.apache.maven.archiva.repository.layout.LayoutException;
 import org.codehaus.plexus.personality.plexus.lifecycle.phase.Initializable;
 import org.codehaus.plexus.personality.plexus.lifecycle.phase.InitializationException;
@@ -46,10 +43,7 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
 import java.util.ArrayList;
-import java.util.Calendar;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
@@ -61,7 +55,7 @@
 import java.util.regex.Matcher;
 
 /**
- * MetadataTools
+ * MetadataTools 
  *
  * @author <a href="mailto:joakime@apache.org">Joakim Erdfelt</a>
  * @version $Id$
@@ -71,13 +65,15 @@
 public class MetadataTools
     implements RegistryListener, Initializable
 {
+    /**
+     * Static Logger. So what? Try and prove to me that IoC monitors are better.
+     */
     private static Logger log = LoggerFactory.getLogger( MetadataTools.class );
 
-    public static final String MAVEN_METADATA = "maven-metadata.xml";
-
-    private static final char PATH_SEPARATOR = '/';
-
-    private static final char GROUP_SEPARATOR = '.';
+    /**
+     * @plexus.requirement
+     */
+    private BidirectionalRepositoryLayoutFactory layoutFactory;
 
     /**
      * @plexus.requirement
@@ -93,16 +89,6 @@
 
     private Map<String, Set<String>> proxies;
 
-    private static final char NUMS[] = new char[] { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
-
-    private static final SimpleDateFormat lastUpdatedFormat;
-
-    static
-    {
-        lastUpdatedFormat = new SimpleDateFormat( "yyyyMMddHHmmss" );
-        lastUpdatedFormat.setTimeZone( DateUtils.UTC_TIME_ZONE );
-    }
-
     public void afterConfigurationChange( Registry registry, String propertyName, Object propertyValue )
     {
         if ( ConfigurationNames.isProxyConnector( propertyName ) )
@@ -117,54 +103,66 @@ public void beforeConfigurationChange( Registry registry, String propertyName, O
     }
 
     /**
-     * Gather the set of snapshot versions found in a particular versioned reference.
-     *
-     * @return the Set of snapshot artifact versions found.
-     * @throws LayoutException
-     * @throws ContentNotFoundException 
+     * Gather the Available Versions (on disk) for a specific Project Reference, based on filesystem
+     * information.
+     * 
+     * @return the Set of available versions, based on the project reference.
+     * @throws LayoutException 
      */
-    public Set<String> gatherSnapshotVersions( ManagedRepositoryContent managedRepository, VersionedReference reference )
-        throws LayoutException, IOException, ContentNotFoundException
+    public Set<String> gatherAvailableVersions( ArchivaRepository managedRepository, ProjectReference reference )
+        throws LayoutException, IOException
     {
-        Set<String> foundVersions = managedRepository.getVersions( reference );
+        BidirectionalRepositoryLayout layout = layoutFactory.getLayout( managedRepository.getLayoutType() );
+        String path = layout.toPath( reference );
 
-        // Next gather up the referenced 'latest' versions found in any proxied repositories
-        // maven-metadata-${proxyId}.xml files that may be present.
+        int idx = path.lastIndexOf( '/' );
+        if ( idx > 0 )
+        {
+            path = path.substring( 0, idx );
+        }
 
-        // Does this repository have a set of remote proxied repositories?
-        Set<String> proxiedRepoIds = this.proxies.get( managedRepository.getId() );
+        File repoDir = new File( managedRepository.getUrl().getPath(), path );
 
-        if ( CollectionUtils.isNotEmpty( proxiedRepoIds ) )
+        if ( !repoDir.exists() )
         {
-            String baseVersion = VersionUtil.getBaseVersion( reference.getVersion() );
-            baseVersion = baseVersion.substring( 0, baseVersion.indexOf( VersionUtil.SNAPSHOT ) - 1 );
+            throw new IOException( "Unable to calculate Available Local Versions on a non-existant directory: "
+                + repoDir.getAbsolutePath() );
+        }
 
-            // Add in the proxied repo version ids too.
-            Iterator<String> it = proxiedRepoIds.iterator();
-            while ( it.hasNext() )
-            {
-                String proxyId = it.next();
+        if ( !repoDir.isDirectory() )
+        {
+            throw new IOException( "Unable to calculate Available Local Versions on a non-directory: "
+                + repoDir.getAbsolutePath() );
+        }
 
-                ArchivaRepositoryMetadata proxyMetadata = readProxyMetadata( managedRepository, reference, proxyId );
-                if ( proxyMetadata == null )
-                {
-                    // There is no proxy metadata, skip it.
-                    continue;
-                }
+        Set<String> foundVersions = new HashSet<String>();
 
-                // Is there some snapshot info?
-                SnapshotVersion snapshot = proxyMetadata.getSnapshotVersion();
-                if ( snapshot != null )
-                {
-                    String timestamp = snapshot.getTimestamp();
-                    int buildNumber = snapshot.getBuildNumber();
+        // TODO: should really determine if valid based on artifactPatterns, not POM existance.
+        //       this method was written before the gatherSnapshotVersions() method, consider
+        //       using the routines from that method used to determine artifacts via pattern.
+        ArtifactReference pomReference = new ArtifactReference();
+        pomReference.setGroupId( reference.getGroupId() );
+        pomReference.setArtifactId( reference.getArtifactId() );
+        pomReference.setType( "pom" );
 
-                    // Only interested in the timestamp + buildnumber.
-                    if ( StringUtils.isNotBlank( timestamp ) && ( buildNumber > 0 ) )
-                    {
-                        foundVersions.add( baseVersion + "-" + timestamp + "-" + buildNumber );
-                    }
-                }
+        File repoFiles[] = repoDir.listFiles();
+        for ( int i = 0; i < repoFiles.length; i++ )
+        {
+            if ( !repoFiles[i].isDirectory() )
+            {
+                // Skip it. not a directory.
+                continue;
+            }
+
+            // Test if dir has pom, which proves to us that it is a valid version directory.
+            String version = repoFiles[i].getName();
+            pomReference.setVersion( version );
+
+            File artifactFile = new File( managedRepository.getUrl().getPath(), layout.toPath( pomReference ) );
+            if ( artifactFile.exists() )
+            {
+                // Found a pom, must be a valid version.
+                foundVersions.add( version );
             }
         }
 
@@ -172,143 +170,159 @@ public Set<String> gatherSnapshotVersions( ManagedRepositoryContent managedRepos
     }
 
     /**
-     * Take a path to a maven-metadata.xml, and attempt to translate it to a VersionedReference.
-     *
-     * @param path
-     * @return
+     * Get the first Artifact found in the provided VersionedReference location. 
+     * 
+     * @param managedRepository the repository to search within.
+     * @param reference the reference to the versioned reference to search within
+     * @return the ArtifactReference to the first artifact located within the versioned reference. or null if
+     *         no artifact was found within the versioned reference.
+     * @throws IOException if the versioned reference is invalid (example: doesn't exist, or isn't a directory)
+     * @throws LayoutException 
      */
-    public VersionedReference toVersionedReference( String path )
-        throws RepositoryMetadataException
+    public ArtifactReference getFirstArtifact( ArchivaRepository managedRepository, VersionedReference reference )
+        throws LayoutException, IOException
     {
-        if ( !path.endsWith( "/" + MAVEN_METADATA ) )
+        BidirectionalRepositoryLayout layout = layoutFactory.getLayout( managedRepository.getLayoutType() );
+        String path = layout.toPath( reference );
+
+        int idx = path.lastIndexOf( '/' );
+        if ( idx > 0 )
         {
-            throw new RepositoryMetadataException( "Cannot convert to versioned reference, not a metadata file. " );
+            path = path.substring( 0, idx );
         }
 
-        VersionedReference reference = new VersionedReference();
-
-        String normalizedPath = StringUtils.replace( path, "\\", "/" );
-        String pathParts[] = StringUtils.split( normalizedPath, '/' );
-
-        int versionOffset = pathParts.length - 2;
-        int artifactIdOffset = versionOffset - 1;
-        int groupIdEnd = artifactIdOffset - 1;
+        File repoDir = new File( managedRepository.getUrl().getPath(), path );
 
-        reference.setVersion( pathParts[versionOffset] );
-
-        if ( !hasNumberAnywhere( reference.getVersion() ) )
+        if ( !repoDir.exists() )
         {
-            // Scary check, but without it, all paths are version references;
-            throw new RepositoryMetadataException(
-                                                   "Not a versioned reference, as version id on path has no number in it." );
+            throw new IOException( "Unable to gather the list of snapshot versions on a non-existant directory: "
+                + repoDir.getAbsolutePath() );
         }
 
-        reference.setArtifactId( pathParts[artifactIdOffset] );
+        if ( !repoDir.isDirectory() )
+        {
+            throw new IOException( "Unable to gather the list of snapshot versions on a non-directory: "
+                + repoDir.getAbsolutePath() );
+        }
 
-        StringBuffer gid = new StringBuffer();
-        for ( int i = 0; i <= groupIdEnd; i++ )
+        File repoFiles[] = repoDir.listFiles();
+        for ( int i = 0; i < repoFiles.length; i++ )
         {
-            if ( i > 0 )
+            if ( repoFiles[i].isDirectory() )
             {
-                gid.append( "." );
+                // Skip it. it's a directory.
+                continue;
             }
-            gid.append( pathParts[i] );
-        }
 
-        reference.setGroupId( gid.toString() );
+            String relativePath = PathUtil.getRelative( managedRepository.getUrl().getPath(), repoFiles[i] );
 
-        return reference;
-    }
+            if ( matchesArtifactPattern( relativePath ) )
+            {
+                ArtifactReference artifact = layout.toArtifactReference( relativePath );
 
-    private boolean hasNumberAnywhere( String version )
-    {
-        return StringUtils.indexOfAny( version, NUMS ) != ( -1 );
+                return artifact;
+            }
+        }
+
+        // No artifact was found.
+        return null;
     }
 
-    public ProjectReference toProjectReference( String path )
-        throws RepositoryMetadataException
+    /**
+     * Gather the set of snapshot versions found in a particular versioned reference.
+     * 
+     * @return the Set of snapshot artifact versions found.
+     * @throws LayoutException 
+     */
+    public Set<String> gatherSnapshotVersions( ArchivaRepository managedRepository, VersionedReference reference )
+        throws LayoutException, IOException
     {
-        if ( !path.endsWith( "/" + MAVEN_METADATA ) )
+        BidirectionalRepositoryLayout layout = layoutFactory.getLayout( managedRepository.getLayoutType() );
+        String path = layout.toPath( reference );
+
+        int idx = path.lastIndexOf( '/' );
+        if ( idx > 0 )
         {
-            throw new RepositoryMetadataException( "Cannot convert to versioned reference, not a metadata file. " );
+            path = path.substring( 0, idx );
         }
 
-        ProjectReference reference = new ProjectReference();
-
-        String normalizedPath = StringUtils.replace( path, "\\", "/" );
-        String pathParts[] = StringUtils.split( normalizedPath, '/' );
+        File repoDir = new File( managedRepository.getUrl().getPath(), path );
 
-        // Assume last part of the path is the version.
+        if ( !repoDir.exists() )
+        {
+            throw new IOException( "Unable to gather the list of snapshot versions on a non-existant directory: "
+                + repoDir.getAbsolutePath() );
+        }
 
-        int artifactIdOffset = pathParts.length - 2;
-        int groupIdEnd = artifactIdOffset - 1;
+        if ( !repoDir.isDirectory() )
+        {
+            throw new IOException( "Unable to gather the list of snapshot versions on a non-directory: "
+                + repoDir.getAbsolutePath() );
+        }
 
-        reference.setArtifactId( pathParts[artifactIdOffset] );
+        Set<String> foundVersions = new HashSet<String>();
 
-        StringBuffer gid = new StringBuffer();
-        for ( int i = 0; i <= groupIdEnd; i++ )
+        File repoFiles[] = repoDir.listFiles();
+        for ( int i = 0; i < repoFiles.length; i++ )
         {
-            if ( i > 0 )
+            if ( repoFiles[i].isDirectory() )
             {
-                gid.append( "." );
+                // Skip it. it's a directory.
+                continue;
             }
-            gid.append( pathParts[i] );
-        }
-
-        reference.setGroupId( gid.toString() );
 
-        return reference;
-    }
+            String relativePath = PathUtil.getRelative( managedRepository.getUrl().getPath(), repoFiles[i] );
 
-    public String toPath( ProjectReference reference )
-    {
-        StringBuffer path = new StringBuffer();
+            if ( matchesArtifactPattern( relativePath ) )
+            {
+                ArtifactReference artifact = layout.toArtifactReference( relativePath );
 
-        path.append( formatAsDirectory( reference.getGroupId() ) ).append( PATH_SEPARATOR );
-        path.append( reference.getArtifactId() ).append( PATH_SEPARATOR );
-        path.append( MAVEN_METADATA );
+                if ( VersionUtil.isSnapshot( artifact.getVersion() ) )
+                {
+                    foundVersions.add( artifact.getVersion() );
+                }
+            }
+        }
 
-        return path.toString();
+        return foundVersions;
     }
 
-    public String toPath( VersionedReference reference )
+    private boolean matchesArtifactPattern( String relativePath )
     {
-        StringBuffer path = new StringBuffer();
-
-        path.append( formatAsDirectory( reference.getGroupId() ) ).append( PATH_SEPARATOR );
-        path.append( reference.getArtifactId() ).append( PATH_SEPARATOR );
-        if ( reference.getVersion() != null )
+        Iterator<String> it = this.artifactPatterns.iterator();
+        while ( it.hasNext() )
         {
-            // add the version only if it is present
-            path.append( VersionUtil.getBaseVersion( reference.getVersion() ) ).append( PATH_SEPARATOR );
+            String pattern = it.next();
+            if ( SelectorUtils.matchPath( pattern, relativePath, false ) )
+            {
+                // Found match
+                return true;
+            }
         }
-        path.append( MAVEN_METADATA );
-
-        return path.toString();
-    }
 
-    private String formatAsDirectory( String directory )
-    {
-        return directory.replace( GROUP_SEPARATOR, PATH_SEPARATOR );
+        // No match.
+        return false;
     }
 
     /**
-     * Adjusts a path for a metadata.xml file to its repository specific path.
-     *
+     * Adjusts a path for a metadata.xml file to its repository specific path. 
+     * 
      * @param repository the repository to base new path off of.
-     * @param path       the path to the metadata.xml file to adjust the name of.
+     * @param path the path to the metadata.xml file to adjust the name of.
+     * 
      * @return the newly adjusted path reference to the repository specific metadata path.
      */
-    public String getRepositorySpecificName( RemoteRepositoryContent repository, String path )
+    public String getRepositorySpecificName( ArchivaRepository repository, String path )
     {
         return getRepositorySpecificName( repository.getId(), path );
     }
 
     /**
-     * Adjusts a path for a metadata.xml file to its repository specific path.
-     *
+     * Adjusts a path for a metadata.xml file to its repository specific path. 
+     * 
      * @param proxyId the repository id to base new path off of.
-     * @param path    the path to the metadata.xml file to adjust the name of.
+     * @param path the path to the metadata.xml file to adjust the name of.
+     * 
      * @return the newly adjusted path reference to the repository specific metadata path.
      */
     public String getRepositorySpecificName( String proxyId, String path )
@@ -337,30 +351,13 @@ public void initialize()
         configuration.addChangeListener( this );
     }
 
-    public ArchivaRepositoryMetadata readProxyMetadata( ManagedRepositoryContent managedRepository,
+    public ArchivaRepositoryMetadata readProxyMetadata( ArchivaRepository managedRepository,
                                                         ProjectReference reference, String proxyId )
+        throws LayoutException
     {
-        String metadataPath = getRepositorySpecificName( proxyId, toPath( reference ) );
-        File metadataFile = new File( managedRepository.getRepoRoot(), metadataPath );
-
-        try
-        {
-            return RepositoryMetadataReader.read( metadataFile );
-        }
-        catch ( RepositoryMetadataException e )
-        {
-            // TODO: [monitor] consider a monitor for this event.
-            // TODO: consider a read-redo on monitor return code?
-            log.warn( "Unable to read metadata: " + metadataFile.getAbsolutePath(), e );
-            return null;
-        }
-    }
-
-    public ArchivaRepositoryMetadata readProxyMetadata( ManagedRepositoryContent managedRepository,
-                                                        VersionedReference reference, String proxyId )
-    {
-        String metadataPath = getRepositorySpecificName( proxyId, toPath( reference ) );
-        File metadataFile = new File( managedRepository.getRepoRoot(), metadataPath );
+        BidirectionalRepositoryLayout layout = layoutFactory.getLayout( managedRepository.getLayoutType() );
+        String metadataPath = getRepositorySpecificName( proxyId, layout.toPath( reference ) );
+        File metadataFile = new File( managedRepository.getUrl().getPath(), metadataPath );
 
         try
         {
@@ -376,37 +373,35 @@ public ArchivaRepositoryMetadata readProxyMetadata( ManagedRepositoryContent man
     }
 
     /**
-     * Update the metadata to represent the all versions of
+     * Update the metadata to represent the all versions of 
      * the provided groupId:artifactId project reference,
      * based off of information present in the repository,
      * the maven-metadata.xml files, and the proxy/repository specific
-     * metadata file contents.
-     *
+     * metadata file contents. 
+     * 
      * @param managedRepository the managed repository where the metadata is kept.
-     * @param reference         the versioned referencfe to update.
-     * @throws LayoutException
-     * @throws RepositoryMetadataException
-     * @throws IOException
-     * @throws ContentNotFoundException 
+     * @param reference the versioned referencfe to update.
+     * @throws LayoutException 
+     * @throws RepositoryMetadataException 
+     * @throws IOException 
      */
-    public void updateMetadata( ManagedRepositoryContent managedRepository, ProjectReference reference )
-        throws LayoutException, RepositoryMetadataException, IOException, ContentNotFoundException
+    public void updateMetadata( ArchivaRepository managedRepository, ProjectReference reference )
+        throws LayoutException, RepositoryMetadataException, IOException
     {
-        File metadataFile = new File( managedRepository.getRepoRoot(), toPath( reference ) );
-
-        long lastUpdated = getExistingLastUpdated( metadataFile );
+        BidirectionalRepositoryLayout layout = layoutFactory.getLayout( managedRepository.getLayoutType() );
+        File metadataFile = new File( managedRepository.getUrl().getPath(), layout.toPath( reference ) );
 
         ArchivaRepositoryMetadata metadata = new ArchivaRepositoryMetadata();
         metadata.setGroupId( reference.getGroupId() );
         metadata.setArtifactId( reference.getArtifactId() );
 
-        // Gather up all versions found in the managed repository.
-        Set<String> allVersions = managedRepository.getVersions( reference );
+        // Gather up the versions found in the managed repository.
+        Set<String> availableVersions = gatherAvailableVersions( managedRepository, reference );
 
         // Does this repository have a set of remote proxied repositories?
-        Set<String> proxiedRepoIds = this.proxies.get( managedRepository.getId() );
+        Set proxiedRepoIds = this.proxies.get( managedRepository.getId() );
 
-        if ( CollectionUtils.isNotEmpty( proxiedRepoIds ) )
+        if ( proxiedRepoIds != null )
         {
             // Add in the proxied repo version ids too.
             Iterator<String> it = proxiedRepoIds.iterator();
@@ -415,165 +410,68 @@ public void updateMetadata( ManagedRepositoryContent managedRepository, ProjectR
                 String proxyId = it.next();
 
                 ArchivaRepositoryMetadata proxyMetadata = readProxyMetadata( managedRepository, reference, proxyId );
-                if ( proxyMetadata != null )
+                if ( proxyMetadata == null )
                 {
-                    allVersions.addAll( proxyMetadata.getAvailableVersions() );
-                    long proxyLastUpdated = getLastUpdated( proxyMetadata );
-
-                    lastUpdated = Math.max( lastUpdated, proxyLastUpdated );
+                    // There is no proxy metadata, skip it.
+                    continue;
                 }
+
+                availableVersions.addAll( proxyMetadata.getAvailableVersions() );
             }
         }
 
-        if ( allVersions.size() == 0 )
+        if ( availableVersions.size() == 0 )
         {
             throw new IOException( "No versions found for reference." );
         }
 
         // Sort the versions
-        List<String> sortedVersions = new ArrayList<String>( allVersions );
-        Collections.sort( sortedVersions, VersionComparator.getInstance() );
-
-        // Split the versions into released and snapshots.
-        List<String> releasedVersions = new ArrayList<String>();
-        List<String> snapshotVersions = new ArrayList<String>();
-
-        for ( String version : sortedVersions )
-        {
-            if ( VersionUtil.isSnapshot( version ) )
-            {
-                snapshotVersions.add( version );
-            }
-            else
-            {
-                releasedVersions.add( version );
-            }
-        }
-
-        Collections.sort( releasedVersions, VersionComparator.getInstance() );
-        Collections.sort( snapshotVersions, VersionComparator.getInstance() );
-
-        String latestVersion = sortedVersions.get( sortedVersions.size() - 1 );
-        String releaseVersion = null;
-
-        if ( CollectionUtils.isNotEmpty( releasedVersions ) )
-        {
-            releaseVersion = releasedVersions.get( releasedVersions.size() - 1 );
-        }
+        List<String> sortedVersions = new ArrayList<String>();
+        sortedVersions.addAll( availableVersions );
+        Collections.sort( sortedVersions, new VersionComparator() );
 
         // Add the versions to the metadata model.
         metadata.setAvailableVersions( sortedVersions );
 
-        metadata.setLatestVersion( latestVersion );
-        metadata.setReleasedVersion( releaseVersion );
-        if ( lastUpdated > 0 )
-        {
-            metadata.setLastUpdatedTimestamp( toLastUpdatedDate( lastUpdated ) );
-        }
-
         // Save the metadata model to disk.
         RepositoryMetadataWriter.write( metadata, metadataFile );
     }
 
-    private Date toLastUpdatedDate( long lastUpdated )
-    {
-        Calendar cal = Calendar.getInstance( DateUtils.UTC_TIME_ZONE );
-        cal.setTimeInMillis( lastUpdated );
-
-        return cal.getTime();
-    }
-
-    private long getLastUpdated( ArchivaRepositoryMetadata metadata )
-    {
-        if ( metadata == null )
-        {
-            // Doesn't exist.
-            return 0;
-        }
-
-        try
-        {
-            String lastUpdated = metadata.getLastUpdated();
-            if ( StringUtils.isBlank( lastUpdated ) )
-            {
-                // Not set.
-                return 0;
-            }
-
-            Date lastUpdatedDate = lastUpdatedFormat.parse( lastUpdated );
-            return lastUpdatedDate.getTime();
-        }
-        catch ( ParseException e )
-        {
-            // Bad format on the last updated string.
-            return 0;
-        }
-    }
-
-    private long getExistingLastUpdated( File metadataFile )
-    {
-        if ( !metadataFile.exists() )
-        {
-            // Doesn't exist.
-            return 0;
-        }
-
-        try
-        {
-            ArchivaRepositoryMetadata metadata = RepositoryMetadataReader.read( metadataFile );
-
-            return getLastUpdated( metadata );
-        }
-        catch ( RepositoryMetadataException e )
-        {
-            // Error.
-            return 0;
-        }
-    }
-
     /**
      * Update the metadata based on the following rules.
-     * <p/>
-     * 1) If this is a SNAPSHOT reference, then utilize the proxy/repository specific
-     * metadata files to represent the current / latest SNAPSHOT available.
-     * 2) If this is a RELEASE reference, and the metadata file does not exist, then
-     * create the metadata file with contents required of the VersionedReference
-     *
+     * 
+     * 1) If this is a SNAPSHOT reference, then utilize the proxy/repository specific 
+     *    metadata files to represent the current / latest SNAPSHOT available.
+     * 2) If this is a RELEASE reference, and the metadata file does not exist, then 
+     *    create the metadata file with contents required of the VersionedReference
+     * 
      * @param managedRepository the managed repository where the metadata is kept.
-     * @param reference         the versioned reference to update
-     * @throws LayoutException
-     * @throws RepositoryMetadataException
-     * @throws IOException
-     * @throws ContentNotFoundException 
+     * @param reference the versioned reference to update
+     * @throws LayoutException 
+     * @throws RepositoryMetadataException 
+     * @throws IOException 
      */
-    public void updateMetadata( ManagedRepositoryContent managedRepository, VersionedReference reference )
-        throws LayoutException, RepositoryMetadataException, IOException, ContentNotFoundException
+    public void updateMetadata( ArchivaRepository managedRepository, VersionedReference reference )
+        throws LayoutException, RepositoryMetadataException, IOException
     {
-        File metadataFile = new File( managedRepository.getRepoRoot(), toPath( reference ) );
-
-        long originalLastUpdated = getExistingLastUpdated( metadataFile );
+        BidirectionalRepositoryLayout layout = layoutFactory.getLayout( managedRepository.getLayoutType() );
+        File metadataFile = new File( managedRepository.getUrl().getPath(), layout.toPath( reference ) );
 
         ArchivaRepositoryMetadata metadata = new ArchivaRepositoryMetadata();
         metadata.setGroupId( reference.getGroupId() );
         metadata.setArtifactId( reference.getArtifactId() );
-        if ( originalLastUpdated > 0 )
-        {
-            metadata.setLastUpdatedTimestamp( toLastUpdatedDate( originalLastUpdated ) );
-        }
 
         if ( VersionUtil.isSnapshot( reference.getVersion() ) )
         {
             // Do SNAPSHOT handling.
             metadata.setVersion( VersionUtil.getBaseVersion( reference.getVersion() ) );
 
-            // Gather up all of the versions found in the reference dir, and any
-            // proxied maven-metadata.xml files.
-            Set<String> snapshotVersions = gatherSnapshotVersions( managedRepository, reference );
+            // Gather up all of the versions found in the reference dir.
+            Set snapshotVersions = gatherSnapshotVersions( managedRepository, reference );
 
             if ( snapshotVersions.isEmpty() )
             {
-                throw new ContentNotFoundException( "No snapshot versions found on reference ["
-                    + VersionedReference.toKey( reference ) + "]." );
+                throw new IOException( "Not snapshot versions found to reference." );
             }
 
             // sort the list to determine to aide in determining the Latest version.
@@ -616,15 +514,15 @@ else if ( VersionUtil.isGenericSnapshot( latestVersion ) )
                  * archive, the most recent timestamp in the archive?
                  */
                 ArtifactReference artifact = getFirstArtifact( managedRepository, reference );
-
+                
                 if ( artifact == null )
                 {
                     throw new IOException( "Not snapshot artifact found to reference in " + reference );
                 }
-
-                File artifactFile = managedRepository.toFile( artifact );
-
-                if ( artifactFile.exists() )
+                
+                File artifactFile = new File( managedRepository.getUrl().getPath(), layout.toPath( artifact ) );
+                
+                if( artifactFile.exists() )
                 {
                     Date lastModified = new Date( artifactFile.lastModified() );
                     metadata.setLastUpdatedTimestamp( lastModified );
@@ -679,83 +577,4 @@ private void initConfigVariables()
             }
         }
     }
-
-    /**
-     * Get the first Artifact found in the provided VersionedReference location.
-     *
-     * @param managedRepository the repository to search within.
-     * @param reference         the reference to the versioned reference to search within
-     * @return the ArtifactReference to the first artifact located within the versioned reference. or null if
-     *         no artifact was found within the versioned reference.
-     * @throws IOException     if the versioned reference is invalid (example: doesn't exist, or isn't a directory)
-     * @throws LayoutException
-     */
-    public ArtifactReference getFirstArtifact( ManagedRepositoryContent managedRepository, VersionedReference reference )
-        throws LayoutException, IOException
-    {
-        String path = toPath( reference );
-
-        int idx = path.lastIndexOf( '/' );
-        if ( idx > 0 )
-        {
-            path = path.substring( 0, idx );
-        }
-
-        File repoDir = new File( managedRepository.getRepoRoot(), path );
-
-        if ( !repoDir.exists() )
-        {
-            throw new IOException( "Unable to gather the list of snapshot versions on a non-existant directory: "
-                + repoDir.getAbsolutePath() );
-        }
-
-        if ( !repoDir.isDirectory() )
-        {
-            throw new IOException( "Unable to gather the list of snapshot versions on a non-directory: "
-                + repoDir.getAbsolutePath() );
-        }
-
-        File repoFiles[] = repoDir.listFiles();
-        for ( int i = 0; i < repoFiles.length; i++ )
-        {
-            if ( repoFiles[i].isDirectory() )
-            {
-                // Skip it. it's a directory.
-                continue;
-            }
-
-            String relativePath = PathUtil.getRelative( managedRepository.getRepoRoot(), repoFiles[i] );
-
-            if ( matchesArtifactPattern( relativePath ) )
-            {
-                ArtifactReference artifact = managedRepository.toArtifactReference( relativePath );
-
-                return artifact;
-            }
-        }
-
-        // No artifact was found.
-        return null;
-    }
-
-    private boolean matchesArtifactPattern( String relativePath )
-    {
-        // Correct the slash pattern.
-        relativePath = relativePath.replace( '\\', '/' );
-
-        Iterator<String> it = this.artifactPatterns.iterator();
-        while ( it.hasNext() )
-        {
-            String pattern = it.next();
-
-            if ( SelectorUtils.matchPath( pattern, relativePath, false ) )
-            {
-                // Found match
-                return true;
-            }
-        }
-
-        // No match.
-        return false;
-    }
 }