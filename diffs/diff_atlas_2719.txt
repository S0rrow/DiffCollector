diff --git a/webapp/src/main/java/org/apache/atlas/web/resources/ExportService.java b/webapp/src/main/java/org/apache/atlas/web/resources/ExportService.java
index 1e98232f6..4499b9c79 100644
--- a/webapp/src/main/java/org/apache/atlas/web/resources/ExportService.java
+++ b/webapp/src/main/java/org/apache/atlas/web/resources/ExportService.java
@@ -17,35 +17,24 @@
  */
 package org.apache.atlas.web.resources;
 
-import com.tinkerpop.gremlin.groovy.jsr223.GremlinGroovyScriptEngine;
-import org.apache.atlas.AtlasErrorCode;
-import org.apache.atlas.AtlasException;
-import org.apache.atlas.AtlasServiceException;
-import org.apache.atlas.exception.AtlasBaseException;
-import org.apache.atlas.model.impexp.AtlasExportRequest;
-import org.apache.atlas.model.impexp.AtlasExportResult;
 import org.apache.atlas.model.instance.AtlasClassification;
-import org.apache.atlas.model.instance.AtlasEntity;
 import org.apache.atlas.model.instance.AtlasObjectId;
-import org.apache.atlas.model.typedef.AtlasClassificationDef;
-import org.apache.atlas.model.typedef.AtlasEntityDef;
 import org.apache.atlas.model.typedef.AtlasTypesDef;
 import org.apache.atlas.repository.graph.AtlasGraphProvider;
 import org.apache.atlas.repository.graphdb.AtlasGraph;
 import org.apache.atlas.repository.store.graph.v1.EntityGraphRetriever;
-import org.apache.atlas.type.AtlasEntityType;
-import org.apache.atlas.type.AtlasStructType.AtlasAttribute;
 import org.apache.atlas.type.AtlasTypeRegistry;
-import org.apache.atlas.type.AtlasTypeUtil;
+import org.apache.atlas.AtlasException;
+import org.apache.atlas.AtlasServiceException;
+import org.apache.atlas.exception.AtlasBaseException;
+import org.apache.atlas.model.instance.AtlasEntity;
+import org.apache.atlas.model.impexp.*;
+import org.apache.atlas.model.typedef.AtlasClassificationDef;
+import org.apache.atlas.model.typedef.AtlasEntityDef;
 import org.apache.commons.collections.CollectionUtils;
-import org.apache.commons.collections.MapUtils;
-import org.apache.commons.lang3.StringUtils;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import javax.script.Bindings;
-import javax.script.ScriptContext;
-import javax.script.ScriptEngine;
 import javax.script.ScriptException;
 import java.util.*;
 
@@ -53,44 +42,22 @@ import java.util.*;
 public class ExportService {
     private static final Logger LOG = LoggerFactory.getLogger(ExportService.class);
 
-    public static final String OPTION_ATTR_MATCH_TYPE = "matchType";
-    public static final String MATCH_TYPE_STARTS_WITH = "startsWith";
-    public static final String MATCH_TYPE_ENDS_WITH   = "endsWith";
-    public static final String MATCH_TYPE_CONTAINS    = "contains";
-    public static final String MATCH_TYPE_MATCHES     = "matches";
-
     private final AtlasTypeRegistry    typeRegistry;
     private final AtlasGraph           atlasGraph;
     private final EntityGraphRetriever entityGraphRetriever;
 
-    // query engine support
-    private final ScriptEngine scriptEngine;
-    private final Bindings     bindings;
-    private final String queryByGuid          = "g.V('__guid', startGuid).bothE().bothV().has('__guid').__guid.dedup().toList()";
-    final private String queryByAttrEquals    = "g.V().has('__typeName','%s').has('%s', attrValue).has('__guid').__guid.toList()";
-    final private String queryByAttrStartWith = "g.V().has('__typeName','%s').filter({it.'%s'.startsWith(attrValue)}).has('__guid').__guid.toList()";
-    final private String queryByAttrEndsWith  = "g.V().has('__typeName','%s').filter({it.'%s'.endsWith(attrValue)}).has('__guid').__guid.toList()";
-    final private String queryByAttrContains  = "g.V().has('__typeName','%s').filter({it.'%s'.contains(attrValue)}).has('__guid').__guid.toList()";
-    final private String queryByAttrMatches   = "g.V().has('__typeName','%s').filter({it.'%s'.matches(attrValue)}).has('__guid').__guid.toList()";
-
-    public ExportService(final AtlasTypeRegistry typeRegistry) throws AtlasBaseException {
+    public ExportService(final AtlasTypeRegistry typeRegistry) {
+
         this.typeRegistry         = typeRegistry;
         this.entityGraphRetriever = new EntityGraphRetriever(this.typeRegistry);
         this.atlasGraph           = AtlasGraphProvider.getGraphInstance();
-
-        this.scriptEngine  = new GremlinGroovyScriptEngine();
-
-        //Do not cache script compilations due to memory implications
-        scriptEngine.getContext().setAttribute("#jsr223.groovy.engine.keep.globals", "phantom",  ScriptContext.ENGINE_SCOPE);
-
-        bindings = scriptEngine.getBindings(ScriptContext.ENGINE_SCOPE);
     }
 
     private class ExportContext {
-        final Set<String>       guidsProcessed = new HashSet<>();
-        final List<String>      guidsToProcess = new ArrayList<>();
-        final AtlasExportResult result;
-        final ZipSink           sink;
+        final Map<String, Boolean> entitiesToBeProcessed = new HashMap<>();
+        final AtlasExportResult    result;
+        final ZipSink              sink;
+        long                       numOfEntitiesExported = 0;
 
         ExportContext(AtlasExportResult result, ZipSink sink) {
             this.result = result;
@@ -99,27 +66,26 @@ public class ExportService {
     }
 
     public AtlasExportResult run(ZipSink exportSink, AtlasExportRequest request, String userName, String hostName,
-                                 String requestingIP) throws AtlasBaseException {
-        long startTimestamp = System.currentTimeMillis();
-        ExportContext context = new ExportContext(new AtlasExportResult(request, userName, hostName, requestingIP,
-                                                                        System.currentTimeMillis()), exportSink);
+                                 String requestingIP) throws AtlasException {
+
+        ExportContext context = new ExportContext(new AtlasExportResult(request, userName, hostName, requestingIP, System.currentTimeMillis()), exportSink);
 
         try {
             LOG.info("==> export(user={}, from={})", userName, requestingIP);
 
+            int i = 0;
             for (AtlasObjectId item : request.getItemsToExport()) {
-                processObjectId(item, context);
+                process(Integer.toString(i++), item, context);
             }
 
             context.sink.setExportOrder(context.result.getData().getEntityCreationOrder());
             context.sink.setTypesDef(context.result.getData().getTypesDef());
-            context.result.setData(null);
-            context.result.setOperationStatus(AtlasExportResult.OperationStatus.SUCCESS);
 
-            long endTimestamp = System.currentTimeMillis();
-            context.result.incrementMeticsCounter("duration", (int) (endTimestamp - startTimestamp));
+            context.result.getData().clear();
+            context.result.setOperationStatus(AtlasExportResult.OperationStatus.SUCCESS);
             context.sink.setResult(context.result);
-        } catch(Exception ex) {
+        }
+        catch(Exception ex) {
             LOG.error("Operation failed: ", ex);
         } finally {
             LOG.info("<== export(user={}, from={}): status {}", userName, requestingIP, context.result.getOperationStatus());
@@ -128,165 +94,80 @@ public class ExportService {
         return context.result;
     }
 
-    private void processObjectId(AtlasObjectId item, ExportContext context) throws AtlasServiceException, AtlasException, AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("==> processObjectId({})", item);
-        }
-
+    private void process(String folder, AtlasObjectId item, ExportContext context) throws AtlasServiceException, AtlasException, AtlasBaseException {
         try {
-            List<AtlasEntity> entities = getStartingEntity(item, context);
-
-            for (AtlasEntity entity: entities) {
-                processEntity(entity, context);
-            }
+            AtlasEntity  entity = entityGraphRetriever.toAtlasEntity(item);
+            List<String> queue  = populateConnectedEntities(entity.getGuid(), context);
 
-            while (!context.guidsToProcess.isEmpty()) {
-                String guid = context.guidsToProcess.remove(0);
+            process(entity, context);
 
-                AtlasEntity e = entityGraphRetriever.toAtlasEntity(guid);
+            for (String guid : queue) {
+                if(context.entitiesToBeProcessed.get(guid)) {
+                    continue;
+                }
 
-                processEntity(e, context);
+                process(entityGraphRetriever.toAtlasEntity(guid), context);
             }
-        } catch (AtlasBaseException excp) {
-            context.result.setOperationStatus(AtlasExportResult.OperationStatus.PARTIAL_SUCCESS);
 
-            LOG.error("Fetching entity failed for: {}", item, excp);
-        }
+            context.result.getData().getEntityCreationOrder().put(folder, queue);
+        } catch (AtlasBaseException e) {
+            context.result.setOperationStatus(AtlasExportResult.OperationStatus.PARTIAL_SUCCESS);
 
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("<== processObjectId({})", item);
+            LOG.error("Fetching entity failed for: {}", item);
         }
     }
 
-    private List<AtlasEntity> getStartingEntity(AtlasObjectId item, ExportContext context) throws AtlasBaseException {
-        List<AtlasEntity> ret = new ArrayList<>();
-
-        if (StringUtils.isNotEmpty(item.getGuid())) {
-            AtlasEntity entity = entityGraphRetriever.toAtlasEntity(item);
-
-            if (entity != null) {
-                ret = Collections.singletonList(entity);
-            }
-        } else if (StringUtils.isNotEmpty(item.getTypeName()) && MapUtils.isNotEmpty(item.getUniqueAttributes())) {
-            String          typeName   = item.getTypeName();
-            AtlasEntityType entityType = typeRegistry.getEntityTypeByName(typeName);
-
-            if (entityType == null) {
-                throw new AtlasBaseException(AtlasErrorCode.UNKNOWN_TYPENAME, typeName);
-            }
-
-            AtlasExportRequest request = context.result.getRequest();
-            String matchType = null;
-
-            if (MapUtils.isNotEmpty(request.getOptions())) {
-                if (request.getOptions().get(OPTION_ATTR_MATCH_TYPE) != null) {
-                    matchType = request.getOptions().get(OPTION_ATTR_MATCH_TYPE).toString();
-                }
-            }
-
-            final String queryTemplate;
-            if (StringUtils.equalsIgnoreCase(matchType, MATCH_TYPE_STARTS_WITH)) {
-                queryTemplate = queryByAttrStartWith;
-            } else if (StringUtils.equalsIgnoreCase(matchType, MATCH_TYPE_ENDS_WITH)) {
-                queryTemplate = queryByAttrEndsWith;
-            } else if (StringUtils.equalsIgnoreCase(matchType, MATCH_TYPE_CONTAINS)) {
-                queryTemplate = queryByAttrContains;
-            } else if (StringUtils.equalsIgnoreCase(matchType, MATCH_TYPE_MATCHES)) {
-                queryTemplate = queryByAttrMatches;
-            } else { // default
-                queryTemplate = queryByAttrEquals;
-            }
-
-            for (Map.Entry<String, Object> e : item.getUniqueAttributes().entrySet()) {
-                String attrName  = e.getKey();
-                Object attrValue = e.getValue();
-
-                AtlasAttribute attribute = entityType.getAttribute(attrName);
-
-                if (attribute == null || attrValue == null) {
-                    continue;
-                }
-
-                String       query = String.format(queryTemplate, typeName, attribute.getQualifiedName());
-                List<String> guids = executeGremlinScriptFor(query, "attrValue", attrValue.toString());
-
-                if (CollectionUtils.isNotEmpty(guids)) {
-                    for (String guid : guids) {
-                        AtlasEntity entity = entityGraphRetriever.toAtlasEntity(guid);
+    private void process(AtlasEntity entity, ExportContext context) throws AtlasBaseException, AtlasException {
+        addTypesAsNeeded(entity.getTypeName(), context);
+        addClassificationsAsNeeded(entity, context);
+        addEntity(entity, context);
+    }
 
-                        if (entity == null) {
-                            continue;
-                        }
+    private void addEntity(AtlasEntity entity, ExportContext context) throws AtlasException, AtlasBaseException {
+        context.entitiesToBeProcessed.put(entity.getGuid(), true);
+        context.sink.add(entity);
 
-                        ret.add(entity);
-                    }
-                }
+        context.result.incrementMeticsCounter(String.format("entity:%s", entity.getTypeName()));
+        context.result.incrementMeticsCounter("Entities");
 
-                break;
-            }
+        context.numOfEntitiesExported++;
 
-            LOG.info("export(item={}; matchType={}): found {} entities", item, matchType, ret.size());
+        if (context.numOfEntitiesExported % 10 == 0) {
+            LOG.info("export(): in progress.. number of entities exported: {}", context.numOfEntitiesExported);
         }
-
-        return ret;
     }
 
-    private void processEntity(AtlasEntity entity, ExportContext context) throws AtlasBaseException {
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("==> processEntity({})", AtlasTypeUtil.getAtlasObjectId(entity));
-        }
+    private List<String> populateConnectedEntities(String startGuid, ExportContext context) {
+        final String gremlinQuery = "g.V('__guid', '%s').bothE().bothV().has('__guid').__guid.toList()";
 
-        if (!context.guidsProcessed.contains(entity.getGuid())) {
-            context.guidsProcessed.add(entity.getGuid());
-            context.result.getData().getEntityCreationOrder().add(entity.getGuid());
+        Map<String, Boolean> entitiesToBeProcessed = context.entitiesToBeProcessed;
 
-            addTypesAsNeeded(entity.getTypeName(), context);
-            addClassificationsAsNeeded(entity, context);
-            addEntity(entity, context);
+        List<String> queue = new ArrayList<>();
 
-            getConnectedEntityGuids(entity, context);
-        }
+        entitiesToBeProcessed.put(startGuid, false);
+        queue.add(startGuid);
 
-        if (LOG.isDebugEnabled()) {
-            LOG.debug("<== processEntity({})", AtlasTypeUtil.getAtlasObjectId(entity));
-        }
-    }
+        for (int i=0; i < queue.size(); i++) {
+            String currentGuid = queue.get(i);
 
-    private void getConnectedEntityGuids(AtlasEntity entity, ExportContext context) {
+            try {
+                List<String> result = (List<String>) atlasGraph.executeGremlinScript(
+                                                        String.format(gremlinQuery, currentGuid), false);
 
-        try {
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("==> getConnectedEntityGuids({}): guidsToProcess {}", AtlasTypeUtil.getAtlasObjectId(entity), context.guidsToProcess.size());
-            }
-
-            List<String> result = executeGremlinScriptForHive(entity.getGuid());
-            if(result == null) {
-                return;
-            }
+                for (String guid : result) {
+                    if (entitiesToBeProcessed.containsKey(guid)) {
+                        continue;
+                    }
 
-            for (String guid : result) {
-                if (!context.guidsProcessed.contains(guid)) {
-                    context.guidsToProcess.add(guid);
+                    entitiesToBeProcessed.put(guid, false);
+                    queue.add(guid);
                 }
+            } catch (ScriptException e) {
+                LOG.error("Child entities could not be added for %s", currentGuid);
             }
-
-            if (LOG.isDebugEnabled()) {
-                LOG.debug("<== getConnectedEntityGuids({}): found {} guids; guidsToProcess {}", entity.getGuid(), result.size(), context.guidsToProcess.size());
-            }
-        } catch (ScriptException e) {
-            LOG.error("Child entities could not be added for %s", entity.getGuid());
         }
-    }
-
-    private void addEntity(AtlasEntity entity, ExportContext context) throws AtlasBaseException {
-        context.sink.add(entity);
 
-        context.result.incrementMeticsCounter(String.format("entity:%s", entity.getTypeName()));
-        context.result.incrementMeticsCounter("entities");
-
-        if (context.guidsProcessed.size() % 10 == 0) {
-            LOG.info("export(): in progress.. number of entities exported: {}", context.guidsProcessed.size());
-        }
+        return queue;
     }
 
     private void addClassificationsAsNeeded(AtlasEntity entity, ExportContext context) {
@@ -302,7 +183,7 @@ public class ExportService {
                 AtlasClassificationDef cd = typeRegistry.getClassificationDefByName(c.getTypeName());
 
                 typesDef.getClassificationDefs().add(cd);
-                result.incrementMeticsCounter("typedef:classification");
+                result.incrementMeticsCounter("Classification");
             }
         }
     }
@@ -315,24 +196,7 @@ public class ExportService {
             AtlasEntityDef typeDefinition = typeRegistry.getEntityDefByName(typeName);
 
             typesDef.getEntityDefs().add(typeDefinition);
-            result.incrementMeticsCounter("typedef:" + typeDefinition.getName());
-        }
-    }
-
-    private List<String> executeGremlinScriptForHive(String guid) throws ScriptException {
-        return executeGremlinScriptFor(this.queryByGuid, "startGuid", guid);
-    }
-
-    private List<String> executeGremlinScriptFor(String query, String parameterName, String parameterValue) {
-        bindings.put(parameterName, parameterValue);
-        try {
-            return (List<String>) atlasGraph.executeGremlinScript(this.scriptEngine,
-                    this.bindings,
-                    query,
-                    false);
-        } catch (ScriptException e) {
-            LOG.error("Script execution failed for query: ", query, e);
-            return null;
+            result.incrementMeticsCounter("Type(s)");
         }
     }
 }