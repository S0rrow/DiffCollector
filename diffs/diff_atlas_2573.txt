diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/GraphHelper.java b/repository/src/main/java/org/apache/atlas/repository/graph/GraphHelper.java
index 7e47d3009..b3711b5f9 100755
--- a/repository/src/main/java/org/apache/atlas/repository/graph/GraphHelper.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/GraphHelper.java
@@ -18,55 +18,43 @@
 
 package org.apache.atlas.repository.graph;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import java.util.Stack;
-import java.util.UUID;
-
-import org.apache.atlas.ApplicationProperties;
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import com.thinkaurelius.titan.core.TitanGraph;
+import com.thinkaurelius.titan.core.TitanProperty;
+import com.thinkaurelius.titan.core.TitanVertex;
+import com.tinkerpop.blueprints.Direction;
+import com.tinkerpop.blueprints.Edge;
+import com.tinkerpop.blueprints.Element;
+import com.tinkerpop.blueprints.Graph;
+import com.tinkerpop.blueprints.GraphQuery;
+import com.tinkerpop.blueprints.Vertex;
 import org.apache.atlas.AtlasException;
 import org.apache.atlas.RequestContext;
 import org.apache.atlas.repository.Constants;
-import org.apache.atlas.repository.RepositoryException;
-import org.apache.atlas.repository.graphdb.AtlasEdge;
-import org.apache.atlas.repository.graphdb.AtlasEdgeDirection;
-import org.apache.atlas.repository.graphdb.AtlasElement;
-import org.apache.atlas.repository.graphdb.AtlasGraph;
-import org.apache.atlas.repository.graphdb.AtlasGraphQuery;
-import org.apache.atlas.repository.graphdb.AtlasVertex;
 import org.apache.atlas.typesystem.IReferenceableInstance;
 import org.apache.atlas.typesystem.ITypedInstance;
 import org.apache.atlas.typesystem.ITypedReferenceableInstance;
-import org.apache.atlas.typesystem.Referenceable;
 import org.apache.atlas.typesystem.exception.EntityNotFoundException;
-import org.apache.atlas.typesystem.exception.TypeNotFoundException;
-import org.apache.atlas.typesystem.json.InstanceSerialization;
 import org.apache.atlas.typesystem.persistence.Id;
-import org.apache.atlas.typesystem.persistence.ReferenceableInstance;
 import org.apache.atlas.typesystem.types.AttributeInfo;
 import org.apache.atlas.typesystem.types.ClassType;
 import org.apache.atlas.typesystem.types.DataTypes;
-import org.apache.atlas.typesystem.types.DataTypes.TypeCategory;
 import org.apache.atlas.typesystem.types.HierarchicalType;
 import org.apache.atlas.typesystem.types.IDataType;
-import org.apache.atlas.typesystem.types.Multiplicity;
 import org.apache.atlas.typesystem.types.TypeSystem;
-import org.apache.atlas.typesystem.types.ValueConversionException;
-import org.apache.atlas.typesystem.types.utils.TypesUtil;
-import org.apache.atlas.utils.ParamChecker;
 import org.apache.commons.lang.StringUtils;
-import org.codehaus.jettison.json.JSONArray;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.annotations.VisibleForTesting;
-import com.google.common.collect.BiMap;
-import com.google.common.collect.HashBiMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
 
 /**
  * Utility class for graph operations.
@@ -78,54 +66,22 @@ public final class GraphHelper {
 
     private static final TypeSystem typeSystem = TypeSystem.getInstance();
 
-    public static final String RETRY_COUNT = "atlas.graph.storage.num.retries";
-    public static final String RETRY_DELAY = "atlas.graph.storage.retry.sleeptime.ms";
-
-    private static volatile GraphHelper INSTANCE;
+    private static final GraphHelper INSTANCE = new GraphHelper(TitanGraphProvider.getGraphInstance());
 
-    private AtlasGraph graph;
-    private static int maxRetries;
-    public static long retrySleepTimeMillis;
+    private TitanGraph titanGraph;
 
-    @VisibleForTesting
-    GraphHelper(AtlasGraph graph) {
-        this.graph = graph;
-        try {
-            maxRetries = ApplicationProperties.get().getInt(RETRY_COUNT, 3);
-            retrySleepTimeMillis = ApplicationProperties.get().getLong(RETRY_DELAY, 1000);
-        } catch (AtlasException e) {
-            LOG.error("Could not load configuration. Setting to default value for " + RETRY_COUNT, e);
-        }
+    private GraphHelper(TitanGraph titanGraph) {
+        this.titanGraph = titanGraph;
     }
 
     public static GraphHelper getInstance() {
-        if ( INSTANCE == null) {
-            synchronized (GraphHelper.class) {
-                if (INSTANCE == null) {
-                    INSTANCE = new GraphHelper(AtlasGraphProvider.getGraphInstance());
-                }
-            }
-        }
         return INSTANCE;
     }
 
-    @VisibleForTesting
-    static GraphHelper getInstance(AtlasGraph graph) {
-        if ( INSTANCE == null) {
-            synchronized (GraphHelper.class) {
-                if (INSTANCE == null) {
-                    INSTANCE = new GraphHelper(graph);
-                }
-            }
-        }
-        return INSTANCE;
-    }
-
-
-    public AtlasVertex createVertexWithIdentity(ITypedReferenceableInstance typedInstance, Set<String> superTypeNames) {
+    public Vertex createVertexWithIdentity(ITypedReferenceableInstance typedInstance, Set<String> superTypeNames) {
         final String guid = UUID.randomUUID().toString();
 
-        final AtlasVertex vertexWithIdentity = createVertexWithoutIdentity(typedInstance.getTypeName(),
+        final Vertex vertexWithIdentity = createVertexWithoutIdentity(typedInstance.getTypeName(),
                 new Id(guid, 0, typedInstance.getTypeName()), superTypeNames);
 
         // add identity
@@ -137,10 +93,10 @@ public final class GraphHelper {
         return vertexWithIdentity;
     }
 
-    public AtlasVertex createVertexWithoutIdentity(String typeName, Id typedInstanceId, Set<String> superTypeNames) {
-        LOG.debug("Creating AtlasVertex for type {} id {}", typeName,
+    public Vertex createVertexWithoutIdentity(String typeName, Id typedInstanceId, Set<String> superTypeNames) {
+        LOG.debug("Creating vertex for type {} id {}", typeName,
                 typedInstanceId != null ? typedInstanceId._getId() : null);
-        final AtlasVertex vertexWithoutIdentity = graph.addVertex();
+        final Vertex vertexWithoutIdentity = titanGraph.addVertex(null);
 
         // add type information
         setProperty(vertexWithoutIdentity, Constants.ENTITY_TYPE_PROPERTY_KEY, typeName);
@@ -162,9 +118,9 @@ public final class GraphHelper {
         return vertexWithoutIdentity;
     }
 
-    private AtlasEdge addEdge(AtlasVertex fromVertex, AtlasVertex toVertex, String edgeLabel) {
+    private Edge addEdge(Vertex fromVertex, Vertex toVertex, String edgeLabel) {
         LOG.debug("Adding edge for {} -> label {} -> {}", string(fromVertex), edgeLabel, string(toVertex));
-        AtlasEdge edge = graph.addEdge(fromVertex, toVertex, edgeLabel);
+        Edge edge = titanGraph.addEdge(null, fromVertex, toVertex, edgeLabel);
 
         setProperty(edge, Constants.STATE_PROPERTY_KEY, Id.EntityState.ACTIVE.name());
         setProperty(edge, Constants.TIMESTAMP_PROPERTY_KEY, RequestContext.get().getRequestTime());
@@ -174,54 +130,30 @@ public final class GraphHelper {
         return edge;
     }
 
-    public AtlasEdge getOrCreateEdge(AtlasVertex outVertex, AtlasVertex inVertex, String edgeLabel) throws RepositoryException {
-        for (int numRetries = 0; numRetries < maxRetries; numRetries++) {
-            try {
-                LOG.debug("Running edge creation attempt {}", numRetries);
-                Iterator<AtlasEdge> edges = getAdjacentEdgesByLabel(inVertex, AtlasEdgeDirection.IN, edgeLabel);
-
-                while (edges.hasNext()) {
-                    AtlasEdge edge = edges.next();
-                    if (edge.getOutVertex().equals(outVertex)) {
-                        Id.EntityState edgeState = getState(edge);
-                        if (edgeState == null || edgeState == Id.EntityState.ACTIVE) {
-                            return edge;
-                        }
-                    }
-                }
-
-                return addEdge(outVertex, inVertex, edgeLabel);
-            } catch (Exception e) {
-                LOG.warn(String.format("Exception while trying to create edge from %s to %s with label %s. Retrying",
-                        vertexString(outVertex), vertexString(inVertex), edgeLabel), e);
-                if (numRetries == (maxRetries - 1)) {
-                    LOG.error("Max retries exceeded for edge creation {} {} {} ", outVertex, inVertex, edgeLabel, e);
-                    throw new RepositoryException("Edge creation failed after retries", e);
-                }
-
-                try {
-                    LOG.info("Retrying with delay of {} ms ", retrySleepTimeMillis);
-                    Thread.sleep(retrySleepTimeMillis);
-                } catch(InterruptedException ie) {
-                    LOG.warn("Retry interrupted during edge creation ");
-                    throw new RepositoryException("Retry interrupted during edge creation", ie);
+    public Edge getOrCreateEdge(Vertex outVertex, Vertex inVertex, String edgeLabel) {
+        Iterable<Edge> edges = inVertex.getEdges(Direction.IN, edgeLabel);
+        for (Edge edge : edges) {
+            if (edge.getVertex(Direction.OUT).getId().toString().equals(outVertex.getId().toString())) {
+                Id.EntityState edgeState = getState(edge);
+                if (edgeState == null || edgeState == Id.EntityState.ACTIVE) {
+                    return edge;
                 }
             }
         }
-        return null;
+        return addEdge(outVertex, inVertex, edgeLabel);
     }
 
 
-    public AtlasEdge getEdgeByEdgeId(AtlasVertex outVertex, String edgeLabel, String edgeId) {
+    public Edge getEdgeByEdgeId(Vertex outVertex, String edgeLabel, String edgeId) {
         if (edgeId == null) {
             return null;
         }
-        return graph.getEdge(edgeId);
+        return titanGraph.getEdge(edgeId);
 
         //TODO get edge id is expensive. Use this logic. But doesn't work for now
         /**
-        Iterable<AtlasEdge> edges = outVertex.getEdges(Direction.OUT, edgeLabel);
-        for (AtlasEdge edge : edges) {
+        Iterable<Edge> edges = outVertex.getEdges(Direction.OUT, edgeLabel);
+        for (Edge edge : edges) {
             if (edge.getId().toString().equals(edgeId)) {
                 return edge;
             }
@@ -232,24 +164,24 @@ public final class GraphHelper {
 
     /**
      * Args of the format prop1, key1, prop2, key2...
-     * Searches for a AtlasVertex with prop1=key1 && prop2=key2
+     * Searches for a vertex with prop1=key1 && prop2=key2
      * @param args
-     * @return AtlasVertex with the given property keys
+     * @return vertex with the given property keys
      * @throws EntityNotFoundException
      */
-    public AtlasVertex findVertex(Object... args) throws EntityNotFoundException {
+    public Vertex findVertex(Object... args) throws EntityNotFoundException {
         StringBuilder condition = new StringBuilder();
-        AtlasGraphQuery query = graph.query();
+        GraphQuery query = titanGraph.query();
         for (int i = 0 ; i < args.length; i+=2) {
             query = query.has((String) args[i], args[i+1]);
             condition.append(args[i]).append(" = ").append(args[i+1]).append(", ");
         }
         String conditionStr = condition.toString();
-        LOG.debug("Finding AtlasVertex with {}", conditionStr);
+        LOG.debug("Finding vertex with {}", conditionStr);
 
-        Iterator<AtlasVertex> results = query.vertices().iterator();
+        Iterator<Vertex> results = query.vertices().iterator();
         // returning one since entityType, qualifiedName should be unique
-        AtlasVertex vertex = results.hasNext() ? results.next() : null;
+        Vertex vertex = results.hasNext() ? results.next() : null;
 
         if (vertex == null) {
             LOG.debug("Could not find a vertex with {}", condition.toString());
@@ -261,49 +193,14 @@ public final class GraphHelper {
         return vertex;
     }
 
-    //In some cases of parallel APIs, the edge is added, but get edge by label doesn't return the edge. ATLAS-1104
-    //So traversing all the edges
-    public Iterator<AtlasEdge> getAdjacentEdgesByLabel(AtlasVertex instanceVertex, AtlasEdgeDirection direction, final String edgeLabel) {
+    public static Iterator<Edge> getOutGoingEdgesByLabel(Vertex instanceVertex, String edgeLabel) {
         LOG.debug("Finding edges for {} with label {}", string(instanceVertex), edgeLabel);
         if(instanceVertex != null && edgeLabel != null) {
-            final Iterator<AtlasEdge> iterator = instanceVertex.getEdges(direction).iterator();
-            return new Iterator<AtlasEdge>() {
-                private AtlasEdge edge = null;
-
-                @Override
-                public boolean hasNext() {
-                    while (edge == null && iterator.hasNext()) {
-                        AtlasEdge localEdge = iterator.next();
-                        if (localEdge.getLabel().equals(edgeLabel)) {
-                            edge = localEdge;
-                        }
-                    }
-                    return edge != null;
-                }
-
-                @Override
-                public AtlasEdge next() {
-                    if (hasNext()) {
-                        AtlasEdge localEdge = edge;
-                        edge = null;
-                        return localEdge;
-                    }
-                    return null;
-                }
-
-                @Override
-                public void remove() {
-                    throw new IllegalStateException("Not handled");
-                }
-            };
+            return instanceVertex.getEdges(Direction.OUT, edgeLabel).iterator();
         }
         return null;
     }
 
-    public Iterator<AtlasEdge> getOutGoingEdgesByLabel(AtlasVertex instanceVertex, String edgeLabel) {
-        return getAdjacentEdgesByLabel(instanceVertex, AtlasEdgeDirection.OUT, edgeLabel);
-    }
-
     /**
      * Returns the active edge for the given edge label.
      * If the vertex is deleted and there is no active edge, it returns the latest deleted edge
@@ -311,50 +208,50 @@ public final class GraphHelper {
      * @param edgeLabel
      * @return
      */
-    public AtlasEdge getEdgeForLabel(AtlasVertex vertex, String edgeLabel) {
-        Iterator<AtlasEdge> iterator = getAdjacentEdgesByLabel(vertex, AtlasEdgeDirection.OUT, edgeLabel);
-        AtlasEdge latestDeletedEdge = null;
+    public static Edge getEdgeForLabel(Vertex vertex, String edgeLabel) {
+        Iterator<Edge> iterator = GraphHelper.getOutGoingEdgesByLabel(vertex, edgeLabel);
+        Edge latestDeletedEdge = null;
         long latestDeletedEdgeTime = Long.MIN_VALUE;
 
         while (iterator != null && iterator.hasNext()) {
-            AtlasEdge edge = iterator.next();
+            Edge edge = iterator.next();
             Id.EntityState edgeState = getState(edge);
             if (edgeState == null || edgeState == Id.EntityState.ACTIVE) {
                 LOG.debug("Found {}", string(edge));
                 return edge;
             } else {
-                Long modificationTime = edge.getProperty(Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY, Long.class);
+                Long modificationTime = getProperty(edge, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY);
                 if (modificationTime != null && modificationTime >= latestDeletedEdgeTime) {
                     latestDeletedEdgeTime = modificationTime;
                     latestDeletedEdge = edge;
                 }
             }
         }
+
         //If the vertex is deleted, return latest deleted edge
         LOG.debug("Found {}", latestDeletedEdge == null ? "null" : string(latestDeletedEdge));
         return latestDeletedEdge;
     }
 
-    public static String vertexString(final AtlasVertex vertex) {
+    public static String vertexString(final Vertex vertex) {
         StringBuilder properties = new StringBuilder();
         for (String propertyKey : vertex.getPropertyKeys()) {
-            Collection<?> propertyValues = vertex.getPropertyValues(propertyKey, Object.class);
-            properties.append(propertyKey).append("=").append(propertyValues.toString()).append(", ");
+            properties.append(propertyKey).append("=").append(vertex.getProperty(propertyKey).toString()).append(", ");
         }
 
-        return "v[" + vertex.getIdForDisplay() + "], Properties[" + properties + "]";
+        return "v[" + vertex.getId() + "], Properties[" + properties + "]";
     }
 
-    public static String edgeString(final AtlasEdge edge) {
-        return "e[" + edge.getLabel() + "], [" + edge.getOutVertex() + " -> " + edge.getLabel() + " -> "
-                + edge.getInVertex() + "]";
+    public static String edgeString(final Edge edge) {
+        return "e[" + edge.getLabel() + "], [" + edge.getVertex(Direction.OUT) + " -> " + edge.getLabel() + " -> "
+                + edge.getVertex(Direction.IN) + "]";
     }
 
-    public static <T extends AtlasElement> void setProperty(T element, String propertyName, Object value) {
+    public static <T extends Element> void setProperty(T element, String propertyName, Object value) {
         String elementStr = string(element);
         String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
         LOG.debug("Setting property {} = \"{}\" to {}", actualPropertyName, value, elementStr);
-        Object existValue = element.getProperty(actualPropertyName, Object.class);
+        Object existValue = element.getProperty(actualPropertyName);
         if(value == null || (value instanceof Collection && ((Collection) value).isEmpty())) {
             if(existValue != null) {
                 LOG.info("Removing property - {} value from {}", actualPropertyName, elementStr);
@@ -368,93 +265,59 @@ public final class GraphHelper {
         }
     }
 
-    /**
-     * Gets the value of a property that is stored in the graph as a single property value.  If
-     * a multi-property such as {@link Constants#TRAIT_NAMES_PROPERTY_KEY} or {@link Constants#SUPER_TYPES_PROPERTY_KEY}
-     * is used, an exception will be thrown.
-     * 
-     * @param element
-     * @param propertyName
-     * @param clazz
-     * @return
-     */
-    public static <T> T getSingleValuedProperty(AtlasElement element, String propertyName, Class<T> clazz) {
+    public static <T extends Element, O> O getProperty(T element, String propertyName) {
         String elementStr = string(element);
         String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        LOG.debug("Reading property {} from {}", actualPropertyName, elementStr);    
-       
-        return (T)element.getProperty(actualPropertyName, clazz);              
+        LOG.debug("Reading property {} from {}", actualPropertyName, elementStr);
+        return element.getProperty(actualPropertyName);
     }
-    
-    
-    public static Object getProperty(AtlasVertex<?,?> vertex, String propertyName) {
+
+    public static Iterable<TitanProperty> getProperties(TitanVertex vertex, String propertyName) {
         String elementStr = string(vertex);
         String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        LOG.debug("Reading property {} from {}", actualPropertyName, elementStr);    
-
-        if(AtlasGraphProvider.getGraphInstance().isMultiProperty(actualPropertyName)) {
-            return vertex.getPropertyValues(actualPropertyName, String.class);
-        }
-        else {
-            return vertex.getProperty(actualPropertyName, Object.class);
-        }
-        
+        LOG.debug("Reading property {} from {}", actualPropertyName, elementStr);
+        return vertex.getProperties(actualPropertyName);
     }
-    
-    public static Object getProperty(AtlasEdge<?,?> edge, String propertyName) {
-        String elementStr = string(edge);
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        LOG.debug("Reading property {} from {}", actualPropertyName, elementStr);      
-        return edge.getProperty(actualPropertyName, Object.class);
-    }    
-    
-    private static <T extends AtlasElement> String string(T element) {
-        if (element instanceof AtlasVertex) {
-            return string((AtlasVertex) element);
-        } else if (element instanceof AtlasEdge) {
-            return string((AtlasEdge)element);
+
+    private static <T extends Element> String string(T element) {
+        if (element instanceof Vertex) {
+            return string((Vertex) element);
+        } else if (element instanceof Edge) {
+            return string((Edge)element);
         }
         return element.toString();
     }
-    
-    /**
-     * Adds an additional value to a multi-property.
-     * 
-     * @param vertex
-     * @param propertyName
-     * @param value
-     */
-    public static void addProperty(AtlasVertex vertex, String propertyName, Object value) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        LOG.debug("Adding property {} = \"{}\" to vertex {}", actualPropertyName, value, string(vertex));
-        vertex.addProperty(actualPropertyName, value);
+
+    public static void addProperty(Vertex vertex, String propertyName, Object value) {
+        LOG.debug("Adding property {} = \"{}\" to vertex {}", propertyName, value, string(vertex));
+        ((TitanVertex)vertex).addProperty(propertyName, value);
     }
 
     /**
      * Remove the specified edge from the graph.
-     *
+     * 
      * @param edge
      */
-    public void removeEdge(AtlasEdge edge) {
+    public void removeEdge(Edge edge) {
         String edgeString = string(edge);
         LOG.debug("Removing {}", edgeString);
-        graph.removeEdge(edge);
+        titanGraph.removeEdge(edge);
         LOG.info("Removed {}", edgeString);
     }
-
+    
     /**
-     * Remove the specified AtlasVertex from the graph.
-     *
-     * @param AtlasVertex
+     * Remove the specified vertex from the graph.
+     * 
+     * @param vertex
      */
-    public void removeVertex(AtlasVertex vertex) {
+    public void removeVertex(Vertex vertex) {
         String vertexString = string(vertex);
         LOG.debug("Removing {}", vertexString);
-        graph.removeVertex(vertex);
+        titanGraph.removeVertex(vertex);
         LOG.info("Removed {}", vertexString);
     }
 
-    public AtlasVertex getVertexForGUID(String guid) throws EntityNotFoundException {
+    public Vertex getVertexForGUID(String guid) throws EntityNotFoundException {
         return findVertex(Constants.GUID_PROPERTY_KEY, guid);
     }
 
@@ -474,15 +337,15 @@ public final class GraphHelper {
     }
 
     public static String getTraitLabel(String typeName, String attrName) {
-        return attrName;
+        return typeName + "." + attrName;
     }
 
-    public static List<String> getTraitNames(AtlasVertex<?,?> entityVertex) {
+    public static List<String> getTraitNames(Vertex entityVertex) {
         ArrayList<String> traits = new ArrayList<>();
-        Collection<String> propertyValues = entityVertex.getPropertyValues(Constants.TRAIT_NAMES_PROPERTY_KEY, String.class);
-        for(String value : propertyValues) {
-            traits.add(value);
+        for (TitanProperty property : ((TitanVertex) entityVertex).getProperties(Constants.TRAIT_NAMES_PROPERTY_KEY)) {
+            traits.add((String) property.getValue());
         }
+
         return traits;
     }
 
@@ -495,26 +358,26 @@ public final class GraphHelper {
         return GraphHelper.EDGE_LABEL_PREFIX + getQualifiedFieldName(dataType, aInfo.name);
     }
 
-    public static Id getIdFromVertex(String dataTypeName, AtlasVertex vertex) {
+    public static Id getIdFromVertex(String dataTypeName, Vertex vertex) {
         return new Id(getIdFromVertex(vertex),
-            vertex.getProperty(Constants.VERSION_PROPERTY_KEY, Integer.class), dataTypeName, getStateAsString(vertex));
+            vertex.<Integer>getProperty(Constants.VERSION_PROPERTY_KEY), dataTypeName, getStateAsString(vertex));
     }
 
-    public static String getIdFromVertex(AtlasVertex vertex) {
-        return vertex.<String>getProperty(Constants.GUID_PROPERTY_KEY, String.class);
+    public static String getIdFromVertex(Vertex vertex) {
+        return vertex.<String>getProperty(Constants.GUID_PROPERTY_KEY);
     }
 
-    public static String getTypeName(AtlasVertex instanceVertex) {
-        return instanceVertex.getProperty(Constants.ENTITY_TYPE_PROPERTY_KEY, String.class);
+    public static String getTypeName(Vertex instanceVertex) {
+        return instanceVertex.getProperty(Constants.ENTITY_TYPE_PROPERTY_KEY);
     }
 
-    public static Id.EntityState getState(AtlasElement element) {
+    public static Id.EntityState getState(Element element) {
         String state = getStateAsString(element);
         return state == null ? null : Id.EntityState.valueOf(state);
     }
 
-    public static String getStateAsString(AtlasElement element) {
-        return element.getProperty(Constants.STATE_PROPERTY_KEY, String.class);
+    public static String getStateAsString(Element element) {
+        return element.getProperty(Constants.STATE_PROPERTY_KEY);
     }
 
     /**
@@ -526,10 +389,10 @@ public final class GraphHelper {
      * @return
      * @throws AtlasException
      */
-    public AtlasVertex getVertexForInstanceByUniqueAttribute(ClassType classType, IReferenceableInstance instance)
+    public Vertex getVertexForInstanceByUniqueAttribute(ClassType classType, IReferenceableInstance instance)
         throws AtlasException {
         LOG.debug("Checking if there is an instance with the same unique attributes for instance {}", instance.toShortString());
-        AtlasVertex result = null;
+        Vertex result = null;
         for (AttributeInfo attributeInfo : classType.fieldMapping().fields.values()) {
             if (attributeInfo.isUnique) {
                 String propertyKey = getQualifiedFieldName(classType, attributeInfo.name);
@@ -547,232 +410,15 @@ public final class GraphHelper {
         return result;
     }
 
-    /**
-     * Guid and AtlasVertex combo
-     */
-    public static class VertexInfo {
-        private String guid;
-        private AtlasVertex vertex;
-        private String typeName;
-
-        public VertexInfo(String guid, AtlasVertex vertex, String typeName) {
-            this.guid = guid;
-            this.vertex = vertex;
-            this.typeName = typeName;
-        }
-
-        public String getGuid() {
-            return guid;
-        }
-        public AtlasVertex getVertex() {
-            return vertex;
-        }
-        public String getTypeName() {
-            return typeName;
-        }
-
-        @Override
-        public int hashCode() {
-
-            final int prime = 31;
-            int result = 1;
-            result = prime * result + ((guid == null) ? 0 : guid.hashCode());
-            result = prime * result + ((vertex == null) ? 0 : vertex.hashCode());
-            return result;
-        }
-
-        @Override
-        public boolean equals(Object obj) {
-
-            if (this == obj)
-                return true;
-            if (obj == null)
-                return false;
-            if (!(obj instanceof VertexInfo))
-                return false;
-            VertexInfo other = (VertexInfo)obj;
-            if (guid == null) {
-                if (other.guid != null)
-                    return false;
-            } else if (!guid.equals(other.guid))
-                return false;
-            return true;
-        }
-    }
-
-    /**
-     * Get the GUIDs and vertices for all composite entities owned/contained by the specified root entity AtlasVertex.
-     * The graph is traversed from the root entity through to the leaf nodes of the containment graph.
-     *
-     * @param entityVertex the root entity vertex
-     * @return set of VertexInfo for all composite entities
-     * @throws AtlasException
-     */
-    public Set<VertexInfo> getCompositeVertices(AtlasVertex entityVertex) throws AtlasException {
-        Set<VertexInfo> result = new HashSet<>();
-        Stack<AtlasVertex> vertices = new Stack<>();
-        vertices.push(entityVertex);
-        while (vertices.size() > 0) {
-            AtlasVertex vertex = vertices.pop();
-            String typeName = GraphHelper.getTypeName(vertex);
-            String guid = GraphHelper.getIdFromVertex(vertex);
-            Id.EntityState state = GraphHelper.getState(vertex);
-            if (state == Id.EntityState.DELETED) {
-                //If the reference vertex is marked for deletion, skip it
-                continue;
-            }
-            result.add(new VertexInfo(guid, vertex, typeName));
-            ClassType classType = typeSystem.getDataType(ClassType.class, typeName);
-            for (AttributeInfo attributeInfo : classType.fieldMapping().fields.values()) {
-                if (!attributeInfo.isComposite) {
-                    continue;
-                }
-                String edgeLabel = GraphHelper.getEdgeLabel(classType, attributeInfo);
-                switch (attributeInfo.dataType().getTypeCategory()) {
-                    case CLASS:
-                        AtlasEdge edge = getEdgeForLabel(vertex, edgeLabel);
-                        if (edge != null && GraphHelper.getState(edge) == Id.EntityState.ACTIVE) {
-                            AtlasVertex compositeVertex = edge.getInVertex();
-                            vertices.push(compositeVertex);
-                        }
-                        break;
-                    case ARRAY:
-                        IDataType elementType = ((DataTypes.ArrayType) attributeInfo.dataType()).getElemType();
-                        DataTypes.TypeCategory elementTypeCategory = elementType.getTypeCategory();
-                        if (elementTypeCategory != TypeCategory.CLASS) {
-                            continue;
-                        }
-                        Iterator<AtlasEdge> edges = getOutGoingEdgesByLabel(vertex, edgeLabel);
-                        if (edges != null) {
-                            while (edges.hasNext()) {
-                                edge = edges.next();
-                                if (edge != null && GraphHelper.getState(edge) == Id.EntityState.ACTIVE) {
-                                    AtlasVertex compositeVertex = edge.getInVertex();
-                                    vertices.push(compositeVertex);
-                                }
-                            }
-                        }
-                        break;
-                    case MAP:
-                        DataTypes.MapType mapType = (DataTypes.MapType) attributeInfo.dataType();
-                        DataTypes.TypeCategory valueTypeCategory = mapType.getValueType().getTypeCategory();
-                        if (valueTypeCategory != TypeCategory.CLASS) {
-                            continue;
-                        }
-                        String propertyName = GraphHelper.getQualifiedFieldName(classType, attributeInfo.name);
-                        List<String> keys = vertex.getProperty(propertyName, List.class);
-                        if (keys != null) {
-                            for (String key : keys) {
-                                String mapEdgeLabel = GraphHelper.getQualifiedNameForMapKey(edgeLabel, key);
-                                edge = getEdgeForLabel(vertex, mapEdgeLabel);
-                                if (edge != null && GraphHelper.getState(edge) == Id.EntityState.ACTIVE) {
-                                    AtlasVertex compositeVertex = edge.getInVertex();
-                                    vertices.push(compositeVertex);
-                                }
-                            }
-                        }
-                        break;
-                    default:
-                        continue;
-                }
-            }
-        }
-        return result;
-    }
-
-    public static ITypedReferenceableInstance[] deserializeClassInstances(TypeSystem typeSystem, String entityInstanceDefinition)
-    throws AtlasException {
-        try {
-            JSONArray referableInstances = new JSONArray(entityInstanceDefinition);
-            ITypedReferenceableInstance[] instances = new ITypedReferenceableInstance[referableInstances.length()];
-            for (int index = 0; index < referableInstances.length(); index++) {
-                Referenceable entityInstance =
-                        InstanceSerialization.fromJsonReferenceable(referableInstances.getString(index), true);
-                ITypedReferenceableInstance typedInstrance = getTypedReferenceableInstance(typeSystem, entityInstance);
-                instances[index] = typedInstrance;
-            }
-            return instances;
-        } catch(ValueConversionException | TypeNotFoundException  e) {
-            throw e;
-        } catch (Exception e) {  // exception from deserializer
-            LOG.error("Unable to deserialize json={}", entityInstanceDefinition, e);
-            throw new IllegalArgumentException("Unable to deserialize json", e);
-        }
-    }
-
-    public static ITypedReferenceableInstance getTypedReferenceableInstance(TypeSystem typeSystem, Referenceable entityInstance)
-            throws AtlasException {
-        final String entityTypeName = ParamChecker.notEmpty(entityInstance.getTypeName(), "Entity type cannot be null");
-    
-        ClassType entityType = typeSystem.getDataType(ClassType.class, entityTypeName);
-    
-        //Both assigned id and values are required for full update
-        //classtype.convert() will remove values if id is assigned. So, set temp id, convert and
-        // then replace with original id
-        Id origId = entityInstance.getId();
-        entityInstance.replaceWithNewId(new Id(entityInstance.getTypeName()));
-        ITypedReferenceableInstance typedInstrance = entityType.convert(entityInstance, Multiplicity.REQUIRED);
-        ((ReferenceableInstance)typedInstrance).replaceWithNewId(origId);
-        return typedInstrance;
-    }
-
-    public static boolean isReference(IDataType type) {
-
-        return type.getTypeCategory() == DataTypes.TypeCategory.STRUCT ||
-                type.getTypeCategory() == DataTypes.TypeCategory.CLASS;
-
-    }
-
-    public static void setArrayElementsProperty(IDataType elementType, AtlasVertex instanceVertex, String propertyName, List<Object> values) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        if(GraphHelper.isReference(elementType)) {
-            setListPropertyFromElementIds(instanceVertex, actualPropertyName, (List)values);
-        }
-        else {
-            setProperty(instanceVertex, actualPropertyName, values);
-        }
-    }
-
-    public static void setMapValueProperty(IDataType elementType, AtlasVertex instanceVertex, String propertyName, Object value) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        if(GraphHelper.isReference(elementType)) {
-            instanceVertex.setPropertyFromElementId(actualPropertyName, (AtlasEdge)value);
-        }
-        else {
-            instanceVertex.setProperty(actualPropertyName, value);
-        }
-    }
-
-    public static Object getMapValueProperty(IDataType elementType, AtlasVertex instanceVertex, String propertyName) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        if(GraphHelper.isReference(elementType)) {
-            return instanceVertex.getProperty(actualPropertyName, AtlasEdge.class);
-        }
-        else {
-            return instanceVertex.getProperty(actualPropertyName, String.class).toString();
-        }
-    }
-
-    public static List<Object> getArrayElementsProperty(IDataType elementType, AtlasVertex instanceVertex, String propertyName) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        if(GraphHelper.isReference(elementType)) {
-            return (List)instanceVertex.getListProperty(actualPropertyName, AtlasEdge.class);
-        }
-        else {
-            return (List)instanceVertex.getListProperty(actualPropertyName);
-        }
-    }
-
-    
-    public static void dumpToLog(final AtlasGraph<?,?> graph) {
+    public static void dumpToLog(final Graph graph) {
         LOG.debug("*******************Graph Dump****************************");
         LOG.debug("Vertices of {}", graph);
-        for (AtlasVertex vertex : graph.getVertices()) {
+        for (Vertex vertex : graph.getVertices()) {
             LOG.debug(vertexString(vertex));
         }
 
         LOG.debug("Edges of {}", graph);
-        for (AtlasEdge edge : graph.getEdges()) {
+        for (Edge edge : graph.getEdges()) {
             LOG.debug(edgeString(edge));
         }
         LOG.debug("*******************Graph Dump****************************");
@@ -782,43 +428,24 @@ public final class GraphHelper {
         return String.format("entity[type=%s guid=%]", instance.getTypeName(), instance.getId()._getId());
     }
 
-    public static String string(AtlasVertex<?,?> vertex) {
-        if(vertex == null) {
-            return "vertex[null]";
+    public static String string(Vertex vertex) {
+        if (LOG.isDebugEnabled()) {
+            return String.format("vertex[id=%s type=%s guid=%s]", vertex.getId().toString(), getTypeName(vertex),
+                    getIdFromVertex(vertex));
         } else {
-            if (LOG.isDebugEnabled()) {
-                return getVertexDetails(vertex);
-            } else {
-                return String.format("vertex[id=%s]", vertex.getIdForDisplay());
-            }
+            return String.format("vertex[id=%s]", vertex.getId().toString());
         }
     }
 
-    public static String getVertexDetails(AtlasVertex<?,?> vertex) {
-
-        return String.format("vertex[id=%s type=%s guid=%s]", vertex.getIdForDisplay(), getTypeName(vertex),
-                getIdFromVertex(vertex));
-    }
-
-
-    public static String string(AtlasEdge<?,?> edge) {
-        if(edge == null) {
-            return "edge[null]";
+    public static String string(Edge edge) {
+        if (LOG.isDebugEnabled()) {
+            return String.format("edge[id=%s label=%s from %s -> to %s]", edge.getId().toString(), edge.getLabel(),
+                    string(edge.getVertex(Direction.OUT)), string(edge.getVertex(Direction.IN)));
         } else {
-            if (LOG.isDebugEnabled()) {
-                return getEdgeDetails(edge);
-            } else {
-                return String.format("edge[id=%s]", edge.getIdForDisplay());
-            }
+            return String.format("edge[id=%s]", edge.getId().toString());
         }
     }
 
-    public static String getEdgeDetails(AtlasEdge<?,?> edge) {
-
-        return String.format("edge[id=%s label=%s from %s -> to %s]", edge.getIdForDisplay(), edge.getLabel(),
-                string(edge.getOutVertex()), string(edge.getInVertex()));
-    }
-
     @VisibleForTesting
     //Keys copied from com.thinkaurelius.titan.graphdb.types.StandardRelationTypeMaker
     //Titan checks that these chars are not part of any keys. So, encoding...
@@ -853,47 +480,4 @@ public final class GraphHelper {
         }
         return key;
     }
-    public static AttributeInfo getAttributeInfoForSystemAttributes(String field) {
-        switch (field) {
-        case Constants.STATE_PROPERTY_KEY:
-        case Constants.GUID_PROPERTY_KEY:
-            return TypesUtil.newAttributeInfo(field, DataTypes.STRING_TYPE);
-
-        case Constants.TIMESTAMP_PROPERTY_KEY:
-        case Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY:
-            return TypesUtil.newAttributeInfo(field, DataTypes.DATE_TYPE);
-        }
-        return null;
-    }
-    
-    public static boolean elementExists(AtlasElement v) {
-        return v != null && v.exists();
-    }
-
-    public static void setListPropertyFromElementIds(AtlasVertex<?, ?> instanceVertex, String propertyName,
-            List<AtlasElement> elements) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        instanceVertex.setPropertyFromElementsIds(actualPropertyName, elements);
-
-    }
-
-    public static void setPropertyFromElementId(AtlasVertex<?, ?> instanceVertex, String propertyName,
-            AtlasElement value) {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        instanceVertex.setPropertyFromElementId(actualPropertyName, value);
-
-    }
-
-    public static void setListProperty(AtlasVertex instanceVertex, String propertyName, ArrayList<String> value) throws AtlasException {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        instanceVertex.setListProperty(actualPropertyName, value);        
-    }
-    
-    public static List<String> getListProperty(AtlasVertex instanceVertex, String propertyName) throws AtlasException {
-        String actualPropertyName = GraphHelper.encodePropertyKey(propertyName);
-        return instanceVertex.getListProperty(actualPropertyName);    
-    }
-    
-
-
-}
+}
\ No newline at end of file