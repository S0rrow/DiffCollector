diff --git a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/ContextManager.java b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/ContextManager.java
index a3d51fcff5..7742cbe7b0 100644
--- a/start/src/main/java/org/apache/accumulo/start/classloader/vfs/ContextManager.java
+++ b/start/src/main/java/org/apache/accumulo/start/classloader/vfs/ContextManager.java
@@ -18,136 +18,146 @@ package org.apache.accumulo.start.classloader.vfs;
 
 import java.io.IOException;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Map;
+import java.util.Map.Entry;
 import java.util.Set;
 
 import org.apache.commons.vfs2.FileSystemException;
 import org.apache.commons.vfs2.FileSystemManager;
 
 public class ContextManager {
-
+  
   // there is a lock per context so that one context can initialize w/o blocking another context
   private class Context {
     AccumuloReloadingVFSClassLoader loader;
     ContextConfig cconfig;
     boolean closed = false;
-
+    
     Context(ContextConfig cconfig) {
       this.cconfig = cconfig;
     }
-
+    
     synchronized ClassLoader getClassLoader() throws FileSystemException {
       if (closed)
         return null;
-
+      
       if (loader == null) {
         loader = new AccumuloReloadingVFSClassLoader(cconfig.uris, vfs, parent, cconfig.preDelegation);
       }
-
+      
       return loader.getClassLoader();
     }
-
+    
     synchronized void close() {
       closed = true;
-      if (loader != null) {
-        loader.close();
-      }
+      loader.close();
       loader = null;
     }
   }
-
-  private Map<String,Context> contexts = new HashMap<>();
-
+  
+  private Map<String,Context> contexts = new HashMap<String,Context>();
+  
   private volatile ContextsConfig config;
   private FileSystemManager vfs;
   private ReloadingClassLoader parent;
-
+  
   ContextManager(FileSystemManager vfs, ReloadingClassLoader parent) {
     this.vfs = vfs;
     this.parent = parent;
   }
-
+  
   public static class ContextConfig {
     String uris;
     boolean preDelegation;
-
+    
     public ContextConfig(String uris, boolean preDelegation) {
       this.uris = uris;
       this.preDelegation = preDelegation;
     }
-
+    
     @Override
     public boolean equals(Object o) {
       if (o instanceof ContextConfig) {
         ContextConfig oc = (ContextConfig) o;
-
+        
         return uris.equals(oc.uris) && preDelegation == oc.preDelegation;
       }
-
+      
       return false;
     }
-
+    
     @Override
     public int hashCode() {
       return uris.hashCode() + (preDelegation ? Boolean.TRUE : Boolean.FALSE).hashCode();
     }
   }
-
+  
   public interface ContextsConfig {
     ContextConfig getContextConfig(String context);
   }
-
-  public static abstract class DefaultContextsConfig implements ContextsConfig {
-
-    public abstract String getProperty(String key);
-
+  
+  public static class DefaultContextsConfig implements ContextsConfig {
+    
+    private Iterable<Entry<String,String>> config;
+    
+    public DefaultContextsConfig(Iterable<Entry<String,String>> config) {
+      this.config = config;
+    }
+    
     @Override
     public ContextConfig getContextConfig(String context) {
-
+      
       String key = AccumuloVFSClassLoader.VFS_CONTEXT_CLASSPATH_PROPERTY + context;
-
-      String uris = getProperty(key);
-
-      if (uris == null) {
-        return null;
-      }
-
-      String delegate = getProperty(key + ".delegation");
-
+      
+      String uris = null;
       boolean preDelegate = true;
-
-      if (delegate != null && delegate.trim().equalsIgnoreCase("post")) {
-        preDelegate = false;
+      
+      Iterator<Entry<String,String>> iter = config.iterator();
+      while (iter.hasNext()) {
+        Entry<String,String> entry = iter.next();
+        if (entry.getKey().equals(key)) {
+          uris = entry.getValue();
+        }
+        
+        if (entry.getKey().equals(key + ".delegation") && entry.getValue().trim().equalsIgnoreCase("post")) {
+          preDelegate = false;
+        }
       }
-
-      return new ContextConfig(uris, preDelegate);
+      
+      if (uris != null)
+        return new ContextConfig(uris, preDelegate);
+      
+      return null;
     }
   }
 
   /**
    * configuration must be injected for ContextManager to work
+   * 
+   * @param config
    */
   public synchronized void setContextConfig(ContextsConfig config) {
     if (this.config != null)
       throw new IllegalStateException("Context manager config already set");
     this.config = config;
   }
-
+  
   public ClassLoader getClassLoader(String contextName) throws FileSystemException {
-
+    
     ContextConfig cconfig = config.getContextConfig(contextName);
-
+    
     if (cconfig == null)
       throw new IllegalArgumentException("Unknown context " + contextName);
-
+    
     Context context = null;
     Context contextToClose = null;
-
+    
     synchronized (this) {
       // only manipulate internal data structs in this sync block... avoid creating or closing classloader, reading config, etc... basically avoid operations
       // that may block
       context = contexts.get(contextName);
-
+      
       if (context == null) {
         context = new Context(cconfig);
         contexts.put(contextName, context);
@@ -157,20 +167,20 @@ public class ContextManager {
         contexts.put(contextName, context);
       }
     }
-
+    
     if (contextToClose != null)
       contextToClose.close();
-
+    
     ClassLoader loader = context.getClassLoader();
     if (loader == null) {
-      // oops, context was closed by another thread, try again
+      // ooppss, context was closed by another thread, try again
       return getClassLoader(contextName);
     }
-
+    
     return loader;
-
+    
   }
-
+  
   public <U> Class<? extends U> loadClass(String context, String classname, Class<U> extension) throws ClassNotFoundException {
     try {
       return getClassLoader(context).loadClass(classname).asSubclass(extension);
@@ -178,20 +188,17 @@ public class ContextManager {
       throw new ClassNotFoundException("IO Error loading class " + classname, e);
     }
   }
-
-  public void removeUnusedContexts(Set<String> configuredContexts) {
-
+  
+  public void removeUnusedContexts(Set<String> inUse) {
+    
     Map<String,Context> unused;
-
-    // ContextManager knows of some set of contexts. This method will be called with
-    // the set of currently configured contexts. We will close the contexts that are
-    // no longer in the configuration.
+    
     synchronized (this) {
-      unused = new HashMap<>(contexts);
-      unused.keySet().removeAll(configuredContexts);
+      unused = new HashMap<String,Context>(contexts);
+      unused.keySet().removeAll(inUse);
       contexts.keySet().removeAll(unused.keySet());
     }
-
+    
     for (Context context : unused.values()) {
       // close outside of lock
       context.close();