diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
index 8e557d3b06..79154f7db1 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/ServerSessionImpl.java
@@ -16,8 +16,11 @@
  */
 package org.apache.activemq.artemis.core.server.impl;
 
-import static org.apache.activemq.artemis.api.core.JsonUtil.nullSafe;
-
+import javax.json.Json;
+import javax.json.JsonArrayBuilder;
+import javax.json.JsonObjectBuilder;
+import javax.transaction.xa.XAException;
+import javax.transaction.xa.Xid;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
@@ -29,28 +32,22 @@ import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.atomic.AtomicLong;
 
-import javax.json.JsonArrayBuilder;
-import javax.json.JsonObjectBuilder;
-import javax.transaction.xa.XAException;
-import javax.transaction.xa.Xid;
-
-import org.apache.activemq.artemis.Closeable;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
-import org.apache.activemq.artemis.api.core.ActiveMQIOErrorException;
 import org.apache.activemq.artemis.api.core.ActiveMQIllegalStateException;
 import org.apache.activemq.artemis.api.core.ActiveMQNonExistentQueueException;
 import org.apache.activemq.artemis.api.core.Message;
 import org.apache.activemq.artemis.api.core.Pair;
-import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.api.core.client.ClientSession;
 import org.apache.activemq.artemis.api.core.management.CoreNotificationType;
 import org.apache.activemq.artemis.api.core.management.ManagementHelper;
+import org.apache.activemq.artemis.api.core.management.ResourceNames;
+import org.apache.activemq.artemis.core.client.impl.ClientMessageImpl;
 import org.apache.activemq.artemis.core.exception.ActiveMQXAException;
 import org.apache.activemq.artemis.core.filter.Filter;
 import org.apache.activemq.artemis.core.filter.impl.FilterImpl;
 import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.paging.PagingManager;
+import org.apache.activemq.artemis.core.message.impl.MessageInternal;
 import org.apache.activemq.artemis.core.paging.PagingStore;
 import org.apache.activemq.artemis.core.persistence.OperationContext;
 import org.apache.activemq.artemis.core.persistence.StorageManager;
@@ -67,18 +64,18 @@ import org.apache.activemq.artemis.core.security.SecurityStore;
 import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
 import org.apache.activemq.artemis.core.server.ActiveMQServer;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
-import org.apache.activemq.artemis.core.server.AddressQueryResult;
 import org.apache.activemq.artemis.core.server.BindingQueryResult;
+import org.apache.activemq.artemis.core.server.LargeServerMessage;
 import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.Queue;
+import org.apache.activemq.artemis.core.server.QueueCreator;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
 import org.apache.activemq.artemis.core.server.RoutingContext;
 import org.apache.activemq.artemis.core.server.ServerConsumer;
+import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
-import org.apache.activemq.artemis.core.server.TempQueueObserver;
 import org.apache.activemq.artemis.core.server.management.ManagementService;
 import org.apache.activemq.artemis.core.server.management.Notification;
-import org.apache.activemq.artemis.core.settings.impl.AddressSettings;
 import org.apache.activemq.artemis.core.transaction.ResourceManager;
 import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.core.transaction.Transaction.State;
@@ -87,11 +84,12 @@ import org.apache.activemq.artemis.core.transaction.TransactionPropertyIndexes;
 import org.apache.activemq.artemis.core.transaction.impl.TransactionImpl;
 import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
 import org.apache.activemq.artemis.spi.core.protocol.SessionCallback;
-import org.apache.activemq.artemis.utils.JsonLoader;
-import org.apache.activemq.artemis.utils.PrefixUtil;
-import org.apache.activemq.artemis.utils.collections.TypedProperties;
+import org.apache.activemq.artemis.utils.TypedProperties;
+import org.apache.activemq.artemis.utils.UUID;
 import org.jboss.logging.Logger;
 
+import static org.apache.activemq.artemis.api.core.JsonUtil.nullSafe;
+
 /**
  * Server side Session implementation
  */
@@ -130,8 +128,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    protected boolean xa;
 
-   protected final PagingManager pagingManager;
-
    protected final StorageManager storageManager;
 
    private final ResourceManager resourceManager;
@@ -152,6 +148,9 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    private final SimpleString managementAddress;
 
+   // The current currentLargeMessage being processed
+   private volatile LargeServerMessage currentLargeMessage;
+
    protected final RoutingContext routingContext = new RoutingContextImpl(null);
 
    protected final SessionCallback callback;
@@ -164,8 +163,10 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    private final OperationContext context;
 
+   private QueueCreator queueCreator;
+
    // Session's usage should be by definition single threaded, hence it's not needed to use a concurrentHashMap here
-   protected final Map<SimpleString, Pair<Object, AtomicLong>> targetAddressInfos = new HashMap<>();
+   protected final Map<SimpleString, Pair<UUID, AtomicLong>> targetAddressInfos = new HashMap<>();
 
    private final long creationTime = System.currentTimeMillis();
 
@@ -177,12 +178,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    // concurrently.
    private volatile boolean closed = false;
 
-   private boolean prefixEnabled = false;
-
-   private Map<SimpleString, RoutingType> prefixes;
-
-   private Set<Closeable> closeables;
-
    public ServerSessionImpl(final String name,
                             final String username,
                             final String password,
@@ -204,8 +199,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                             final SimpleString defaultAddress,
                             final SessionCallback callback,
                             final OperationContext context,
-                            final PagingManager pagingManager,
-                            final Map<SimpleString, RoutingType> prefixes) throws Exception {
+                            final QueueCreator queueCreator) throws Exception {
       this.username = username;
 
       this.password = password;
@@ -230,8 +224,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       this.securityStore = securityStore;
 
-      this.pagingManager = pagingManager;
-
       timeoutSeconds = resourceManager.getTimeoutSeconds();
       this.xa = xa;
 
@@ -243,11 +235,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       this.server = server;
 
-      this.prefixes = prefixes;
-      if (this.prefixes != null && !this.prefixes.isEmpty()) {
-         prefixEnabled = true;
-      }
-
       this.managementAddress = managementAddress;
 
       this.callback = callback;
@@ -257,25 +244,20 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       remotingConnection.addFailureListener(this);
       this.context = context;
 
+      this.queueCreator = queueCreator;
+
       if (!xa) {
          tx = newTransaction();
       }
    }
 
-   // ServerSession implementation ---------------------------------------------------------------------------
+   // ServerSession implementation ----------------------------------------------------------------------------
+
    @Override
    public void enableSecurity() {
       this.securityEnabled = true;
    }
 
-   @Override
-   public void addCloseable(Closeable closeable) {
-      if (closeables == null) {
-         closeables = new HashSet<>();
-      }
-      this.closeables.add(closeable);
-   }
-
    @Override
    public void disableSecurity() {
       this.securityEnabled = false;
@@ -285,7 +267,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    public boolean isClosed() {
       return closed;
    }
-
    /**
     * @return the sessionContext
     */
@@ -331,7 +312,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (currentTX != null) {
          if (e instanceof ActiveMQException) {
             currentTX.markAsRollbackOnly((ActiveMQException) e);
-         } else {
+         }
+         else {
             ActiveMQException exception = new ActiveMQException(e.getMessage());
             exception.initCause(e);
             currentTX.markAsRollbackOnly(exception);
@@ -346,9 +328,6 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    protected void doClose(final boolean failed) throws Exception {
       synchronized (this) {
-         if (!closed) {
-            server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.beforeCloseSession(this, failed) : null);
-         }
          this.setStarted(false);
          if (closed)
             return;
@@ -358,7 +337,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
             try {
                rollback(failed, false);
-            } catch (Exception e) {
+            }
+            catch (Exception e) {
                ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
             }
          }
@@ -371,11 +351,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       for (ServerConsumer consumer : consumersClone) {
          try {
             consumer.close(failed);
-         } catch (Throwable e) {
+         }
+         catch (Throwable e) {
             ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
             try {
                consumer.removeItself();
-            } catch (Throwable e2) {
+            }
+            catch (Throwable e2) {
                ActiveMQServerLogger.LOGGER.warn(e2.getMessage(), e2);
             }
          }
@@ -383,9 +365,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       consumers.clear();
 
-      if (closeables != null) {
-         for (Closeable closeable : closeables) {
-            closeable.close(failed);
+      if (currentLargeMessage != null) {
+         try {
+            currentLargeMessage.deleteFile();
+         }
+         catch (Throwable error) {
+            ActiveMQServerLogger.LOGGER.errorDeletingLargeMessageFile(error);
          }
       }
 
@@ -399,12 +384,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          }
 
          closed = true;
-
-         server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.afterCloseSession(this, failed) : null);
       }
    }
 
-   private void securityCheck(SimpleString address, CheckType checkType, SecurityAuth auth) throws Exception {
+   @Override
+   public QueueCreator getQueueCreator() {
+      return queueCreator;
+   }
+
+   protected void securityCheck(SimpleString address, CheckType checkType, SecurityAuth auth) throws Exception {
       if (securityEnabled) {
          securityStore.check(address, checkType, auth);
       }
@@ -425,43 +413,28 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                                         final boolean browseOnly,
                                         final boolean supportLargeMessage,
                                         final Integer credits) throws Exception {
-      final SimpleString unPrefixedQueueName = removePrefix(queueName);
-
-      Binding binding = postOffice.getBinding(unPrefixedQueueName);
+      Binding binding = postOffice.getBinding(queueName);
 
       if (binding == null || binding.getType() != BindingType.LOCAL_QUEUE) {
-         throw ActiveMQMessageBundle.BUNDLE.noSuchQueue(unPrefixedQueueName);
+         throw ActiveMQMessageBundle.BUNDLE.noSuchQueue(queueName);
       }
 
-      SimpleString address = removePrefix(binding.getAddress());
       if (browseOnly) {
-         try {
-            securityCheck(address, CheckType.BROWSE, this);
-         } catch (Exception e) {
-            securityCheck(address.concat(".").concat(unPrefixedQueueName), CheckType.BROWSE, this);
-         }
-      } else {
-         try {
-            securityCheck(address, CheckType.CONSUME, this);
-         } catch (Exception e) {
-            securityCheck(address.concat(".").concat(unPrefixedQueueName), CheckType.CONSUME, this);
-         }
+         securityCheck(binding.getAddress(), CheckType.BROWSE, this);
+      }
+      else {
+         securityCheck(binding.getAddress(), CheckType.CONSUME, this);
       }
 
       Filter filter = FilterImpl.createFilter(filterString);
 
-      server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.beforeCreateConsumer(consumerID, unPrefixedQueueName,
-            filterString, browseOnly, supportLargeMessage) : null);
-
-      ServerConsumer consumer = new ServerConsumerImpl(consumerID, this, (QueueBinding) binding, filter, started, browseOnly, storageManager, callback, preAcknowledge, strictUpdateDeliveryCount, managementService, supportLargeMessage, credits, server);
+      ServerConsumer consumer = new ServerConsumerImpl(consumerID, this, (QueueBinding)binding, filter, started, browseOnly, storageManager, callback, preAcknowledge, strictUpdateDeliveryCount, managementService, supportLargeMessage, credits, server);
       consumers.put(consumer.getID(), consumer);
 
-      server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.afterCreateConsumer(consumer) : null);
-
       if (!browseOnly) {
          TypedProperties props = new TypedProperties();
 
-         props.putSimpleStringProperty(ManagementHelper.HDR_ADDRESS, address);
+         props.putSimpleStringProperty(ManagementHelper.HDR_ADDRESS, binding.getAddress());
 
          props.putSimpleStringProperty(ManagementHelper.HDR_CLUSTER_NAME, binding.getClusterName());
 
@@ -488,9 +461,9 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
          if (logger.isDebugEnabled()) {
             logger.debug("Session with user=" + username +
-                            ", connection=" + this.remotingConnection +
-                            " created a consumer on queue " + unPrefixedQueueName +
-                            ", filter = " + filterString);
+                                                 ", connection=" + this.remotingConnection +
+                                                 " created a consumer on queue " + queueName +
+                                                 ", filter = " + filterString);
          }
 
          managementService.sendNotification(notification);
@@ -499,11 +472,9 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       return consumer;
    }
 
-   /**
-    * Some protocols may chose to hold their transactions outside of the ServerSession.
-    * This can be used to replace the transaction.
-    * Notice that we set autoCommitACK and autoCommitSends to true if tx == null
-    */
+   /** Some protocols may chose to hold their transactions outside of the ServerSession.
+    *  This can be used to replace the transaction.
+    *  Notice that we set autoCommitACK and autoCommitSends to true if tx == null */
    @Override
    public void resetTX(Transaction transaction) {
       this.tx = transaction;
@@ -517,45 +488,25 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                             final SimpleString filterString,
                             final boolean temporary,
                             final boolean durable) throws Exception {
-      AddressSettings as = server.getAddressSettingsRepository().getMatch(address.toString());
-      return createQueue(address, name, as.getDefaultQueueRoutingType(), filterString, temporary, durable, as.getDefaultMaxConsumers(), as.isDefaultPurgeOnNoConsumers(), false);
-   }
-
-   @Override
-   public Queue createQueue(final SimpleString address,
-                            final SimpleString name,
-                            final RoutingType routingType,
-                            final SimpleString filterString,
-                            final boolean temporary,
-                            final boolean durable) throws Exception {
-      AddressSettings as = server.getAddressSettingsRepository().getMatch(address.toString());
-      return createQueue(address, name, routingType, filterString, temporary, durable, as.getDefaultMaxConsumers(), as.isDefaultPurgeOnNoConsumers(), false);
-   }
-
-   @Override
-   public Queue createQueue(final SimpleString address,
-                            final SimpleString name,
-                            final RoutingType routingType,
-                            final SimpleString filterString,
-                            final boolean temporary,
-                            final boolean durable,
-                            final int maxConsumers,
-                            final boolean purgeOnNoConsumers,
-                            final boolean autoCreated) throws Exception {
-      final SimpleString unPrefixedName = removePrefix(name);
-
-      Pair<SimpleString, RoutingType> art = getAddressAndRoutingType(address, routingType);
-
       if (durable) {
          // make sure the user has privileges to create this queue
          securityCheck(address, CheckType.CREATE_DURABLE_QUEUE, this);
-      } else {
+      }
+      else {
          securityCheck(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
       }
 
       server.checkQueueCreationLimit(getUsername());
 
-      Queue queue = server.createQueue(art.getA(), art.getB(), unPrefixedName, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary, autoCreated, maxConsumers, purgeOnNoConsumers, server.getAddressSettingsRepository().getMatch(address.toString()).isAutoCreateAddresses());
+      Queue queue;
+
+      // any non-temporary JMS destination created via this method should be marked as auto-created
+      if (!temporary && ((address.toString().startsWith(ResourceNames.JMS_QUEUE) && address.equals(name)) || address.toString().startsWith(ResourceNames.JMS_TOPIC)) ) {
+         queue = server.createQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary, true);
+      }
+      else {
+         queue = server.createQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable, temporary);
+      }
 
       if (temporary) {
          // Temporary queue in core simply means the queue will be deleted if
@@ -564,21 +515,18 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          // session is closed.
          // It is up to the user to delete the queue when finished with it
 
-         TempQueueCleanerUpper cleaner = new TempQueueCleanerUpper(server, unPrefixedName);
-         if (remotingConnection instanceof TempQueueObserver) {
-            cleaner.setObserver((TempQueueObserver) remotingConnection);
-         }
+         TempQueueCleanerUpper cleaner = new TempQueueCleanerUpper(server, name);
 
          remotingConnection.addCloseListener(cleaner);
          remotingConnection.addFailureListener(cleaner);
 
-         tempQueueCleannerUppers.put(unPrefixedName, cleaner);
+         tempQueueCleannerUppers.put(name, cleaner);
       }
 
       if (logger.isDebugEnabled()) {
-         logger.debug("Queue " + unPrefixedName + " created on address " + address +
-                         " with filter=" + filterString + " temporary = " +
-                         temporary + " durable=" + durable + " on session user=" + this.username + ", connection=" + this.remotingConnection);
+         logger.debug("Queue " + name + " created on address " + address +
+                                              " with filter=" + filterString + " temporary = " +
+                                              temporary + " durable=" + durable + " on session user=" + this.username + ", connection=" + this.remotingConnection);
       }
 
       return queue;
@@ -586,59 +534,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    }
 
    @Override
-   public Queue createQueue(SimpleString address,
-                            SimpleString name,
-                            RoutingType routingType,
-                            SimpleString filterString,
-                            boolean temporary,
-                            boolean durable,
-                            boolean autoCreated) throws Exception {
-      AddressSettings as = server.getAddressSettingsRepository().getMatch(address.toString());
-      return createQueue(address, name, routingType, filterString, temporary, durable, as.getDefaultMaxConsumers(), as.isDefaultPurgeOnNoConsumers(), autoCreated);
-   }
-
-   @Override
-   public AddressInfo createAddress(final SimpleString address,
-                                    Set<RoutingType> routingTypes,
-                                    final boolean autoCreated) throws Exception {
-      Pair<SimpleString, Set<RoutingType>> art = getAddressAndRoutingTypes(address, routingTypes);
-      securityCheck(art.getA(), CheckType.CREATE_ADDRESS, this);
-      server.addOrUpdateAddressInfo(new AddressInfo(art.getA(), art.getB()).setAutoCreated(autoCreated));
-      return server.getAddressInfo(art.getA());
-   }
-
-   @Override
-   public AddressInfo createAddress(final SimpleString address,
-                                    RoutingType routingType,
-                                    final boolean autoCreated) throws Exception {
-      Pair<SimpleString, RoutingType> art = getAddressAndRoutingType(address, routingType);
-      securityCheck(art.getA(), CheckType.CREATE_ADDRESS, this);
-      server.addOrUpdateAddressInfo(new AddressInfo(art.getA(), art.getB()).setAutoCreated(autoCreated));
-      return server.getAddressInfo(art.getA());
-   }
-
-   @Override
-   public void createSharedQueue(SimpleString address,
+   public void createSharedQueue(final SimpleString address,
                                  final SimpleString name,
-                                 final RoutingType routingType,
                                  boolean durable,
                                  final SimpleString filterString) throws Exception {
-
-      address = removePrefix(address);
-
       securityCheck(address, CheckType.CREATE_NON_DURABLE_QUEUE, this);
 
       server.checkQueueCreationLimit(getUsername());
 
-      server.createSharedQueue(address, routingType, name, filterString, SimpleString.toSimpleString(getUsername()), durable);
-   }
-
-   @Override
-   public void createSharedQueue(final SimpleString address,
-                                 final SimpleString name,
-                                 boolean durable,
-                                 final SimpleString filterString) throws Exception {
-      createSharedQueue(address, name, null, durable, filterString);
+      server.createSharedQueue(address, name, filterString, SimpleString.toSimpleString(getUsername()), durable);
    }
 
    @Override
@@ -652,18 +556,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       private final ActiveMQServer server;
 
-      private TempQueueObserver observer;
-
       public TempQueueCleanerUpper(final ActiveMQServer server, final SimpleString bindingName) {
          this.server = server;
 
          this.bindingName = bindingName;
       }
 
-      public void setObserver(TempQueueObserver observer) {
-         this.observer = observer;
-      }
-
       private void run() {
          try {
             if (logger.isDebugEnabled()) {
@@ -671,14 +569,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             }
             try {
                server.destroyQueue(bindingName, null, false);
-               if (observer != null) {
-                  observer.tempQueueDeleted(bindingName);
-               }
-            } catch (ActiveMQException e) {
+            }
+            catch (ActiveMQException e) {
                // that's fine.. it can happen due to queue already been deleted
                logger.debug(e.getMessage(), e);
             }
-         } catch (Exception e) {
+         }
+         catch (Exception e) {
             ActiveMQServerLogger.LOGGER.errorRemovingTempQueue(e, bindingName);
          }
       }
@@ -707,17 +604,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public void deleteQueue(final SimpleString queueToDelete) throws Exception {
-      final SimpleString unPrefixedQueueName = removePrefix(queueToDelete);
-
-      Binding binding = postOffice.getBinding(unPrefixedQueueName);
+      Binding binding = postOffice.getBinding(queueToDelete);
 
       if (binding == null || binding.getType() != BindingType.LOCAL_QUEUE) {
          throw new ActiveMQNonExistentQueueException();
       }
 
-      server.destroyQueue(unPrefixedQueueName, this, true);
+      server.destroyQueue(queueToDelete, this, true);
 
-      TempQueueCleanerUpper cleaner = this.tempQueueCleannerUppers.remove(unPrefixedQueueName);
+      TempQueueCleanerUpper cleaner = this.tempQueueCleannerUppers.remove(queueToDelete);
 
       if (cleaner != null) {
          remotingConnection.removeCloseListener(cleaner);
@@ -728,17 +623,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public QueueQueryResult executeQueueQuery(final SimpleString name) throws Exception {
-      return server.queueQuery(removePrefix(name));
-   }
-
-   @Override
-   public AddressQueryResult executeAddressQuery(SimpleString name) throws Exception {
-      return server.addressQuery(removePrefix(name));
+      return server.queueQuery(name);
    }
 
    @Override
    public BindingQueryResult executeBindingQuery(final SimpleString address) throws Exception {
-      return server.bindingQuery(removePrefix(address));
+      return server.bindingQuery(address);
    }
 
    @Override
@@ -762,14 +652,16 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          Transaction newTX = newTransaction();
          try {
             consumer.acknowledge(newTX, messageID);
-         } catch (Exception e) {
+         }
+         catch (Exception e) {
             // just ignored
             // will log it just in case
             logger.debug("Ignored exception while acking messageID " + messageID +
-                            " on a rolledback TX", e);
+                                                 " on a rolledback TX", e);
          }
          newTX.rollback();
-      } else {
+      }
+      else {
          consumer.acknowledge(autoCommitAcks ? null : tx, messageID);
       }
    }
@@ -806,7 +698,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          Transaction newTX = newTransaction();
          consumer.individualAcknowledge(tx, messageID);
          newTX.rollback();
-      } else {
+      }
+      else {
          consumer.individualAcknowledge(autoCommitAcks ? null : tx, messageID);
       }
 
@@ -840,10 +733,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          if (tx != null) {
             tx.commit();
          }
-      } finally {
+      }
+      finally {
          if (xa) {
             tx = null;
-         } else {
+         }
+         else {
             tx = newTransaction();
          }
       }
@@ -871,7 +766,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       if (xa) {
          tx = null;
-      } else {
+      }
+      else {
          tx = newTransaction();
       }
    }
@@ -899,7 +795,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          final String msg = "Cannot commit, session is currently doing work in transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else {
          Transaction theTx = resourceManager.removeTransaction(xid);
 
          if (logger.isTraceEnabled()) {
@@ -910,23 +807,27 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             // checked heuristic committed transactions
             if (resourceManager.getHeuristicCommittedTransactions().contains(xid)) {
                throw new ActiveMQXAException(XAException.XA_HEURCOM, "transaction has been heuristically committed: " + xid);
-            } else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid)) {
-               // checked heuristic rolled back transactions
+            }
+            // checked heuristic rolled back transactions
+            else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid)) {
                throw new ActiveMQXAException(XAException.XA_HEURRB, "transaction has been heuristically rolled back: " + xid);
-            } else {
+            }
+            else {
                if (logger.isTraceEnabled()) {
                   logger.trace("XAcommit into " + theTx + ", xid=" + xid + " cannot find it");
                }
 
                throw new ActiveMQXAException(XAException.XAER_NOTA, "Cannot find xid in resource manager: " + xid);
             }
-         } else {
+         }
+         else {
             if (theTx.getState() == Transaction.State.SUSPENDED) {
                // Put it back
                resourceManager.putTransaction(xid, theTx);
 
                throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot commit transaction, it is suspended " + xid);
-            } else {
+            }
+            else {
                theTx.commit(onePhase);
             }
          }
@@ -940,21 +841,19 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             final String msg = "Cannot end, transaction is suspended";
 
             throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-         } else if (tx.getState() == Transaction.State.ROLLEDBACK) {
+         }
+         else if (tx.getState() == Transaction.State.ROLLEDBACK) {
             final String msg = "Cannot end, transaction is rolled back";
 
-            final boolean timeout = tx.hasTimedOut();
             tx = null;
 
-            if (timeout) {
-               throw new ActiveMQXAException(XAException.XA_RBTIMEOUT, msg);
-            } else {
-               throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-            }
-         } else {
+            throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
+         }
+         else {
             tx = null;
          }
-      } else {
+      }
+      else {
          // It's also legal for the TM to call end for a Xid in the suspended
          // state
          // See JTA 1.1 spec 3.4.4 - state diagram
@@ -965,12 +864,14 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             final String msg = "Cannot find suspended transaction to end " + xid;
 
             throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-         } else {
+         }
+         else {
             if (theTx.getState() != Transaction.State.SUSPENDED) {
                final String msg = "Transaction is not suspended " + xid;
 
                throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-            } else {
+            }
+            else {
                theTx.resume();
             }
          }
@@ -984,11 +885,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (id != -1) {
          try {
             storageManager.deleteHeuristicCompletion(id);
-         } catch (Exception e) {
+         }
+         catch (Exception e) {
             ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
             throw new ActiveMQXAException(XAException.XAER_RMFAIL);
          }
-      } else {
+      }
+      else {
          throw new ActiveMQXAException(XAException.XAER_NOTA);
       }
    }
@@ -1001,10 +904,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          final String msg = "Cannot find xid in resource manager: " + xid;
 
          throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-      } else {
+      }
+      else {
          if (theTx.getState() == Transaction.State.SUSPENDED) {
             throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot join tx, it is suspended " + xid);
-         } else {
+         }
+         else {
             tx = theTx;
          }
       }
@@ -1016,17 +921,20 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          final String msg = "Cannot resume, session is currently doing work in a transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else {
          Transaction theTx = resourceManager.getTransaction(xid);
 
          if (theTx == null) {
             final String msg = "Cannot find xid in resource manager: " + xid;
 
             throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-         } else {
+         }
+         else {
             if (theTx.getState() != Transaction.State.SUSPENDED) {
                throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot resume transaction, it is not suspended " + xid);
-            } else {
+            }
+            else {
                tx = theTx;
 
                tx.resume();
@@ -1041,7 +949,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          final String msg = "Cannot roll back, session is currently doing work in a transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else {
          Transaction theTx = resourceManager.removeTransaction(xid);
          if (logger.isTraceEnabled()) {
             logger.trace("xarollback into " + theTx);
@@ -1051,10 +960,12 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             // checked heuristic committed transactions
             if (resourceManager.getHeuristicCommittedTransactions().contains(xid)) {
                throw new ActiveMQXAException(XAException.XA_HEURCOM, "transaction has ben heuristically committed: " + xid);
-            } else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid)) {
-               // checked heuristic rolled back transactions
+            }
+            // checked heuristic rolled back transactions
+            else if (resourceManager.getHeuristicRolledbackTransactions().contains(xid)) {
                throw new ActiveMQXAException(XAException.XA_HEURRB, "transaction has ben heuristically rolled back: " + xid);
-            } else {
+            }
+            else {
                if (logger.isTraceEnabled()) {
                   logger.trace("xarollback into " + theTx + ", xid=" + xid + " forcing a rollback regular");
                }
@@ -1064,13 +975,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                   // This could have happened because the TX timed out,
                   // at this point we would be better on rolling back this session as a way to prevent consumers from holding their messages
                   this.rollback(false);
-               } catch (Exception e) {
+               }
+               catch (Exception e) {
                   ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
                }
 
                throw new ActiveMQXAException(XAException.XAER_NOTA, "Cannot find xid in resource manager: " + xid);
             }
-         } else {
+         }
+         else {
             if (theTx.getState() == Transaction.State.SUSPENDED) {
                if (logger.isTraceEnabled()) {
                   logger.trace("xarollback into " + theTx + " sending tx back as it was suspended");
@@ -1080,7 +993,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                resourceManager.putTransaction(xid, tx);
 
                throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot rollback transaction, it is suspended " + xid);
-            } else {
+            }
+            else {
                doRollback(false, false, theTx);
             }
          }
@@ -1100,7 +1014,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
                }
                tx.rollback();
             }
-         } catch (Exception e) {
+         }
+         catch (Exception e) {
             logger.debug("An exception happened while we tried to debug the previous tx, we can ignore this exception", e);
          }
       }
@@ -1132,7 +1047,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (theTX.isEffective()) {
          logger.debug("Client failed with Xid " + xid + " but the server already had it " + theTX.getState());
          tx = null;
-      } else {
+      }
+      else {
          theTX.markAsRollbackOnly(new ActiveMQException("Can't commit as a Failover happened during the operation"));
          tx = theTX;
       }
@@ -1153,12 +1069,14 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          final String msg = "Cannot suspend, session is not doing work in a transaction ";
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else {
          if (tx.getState() == Transaction.State.SUSPENDED) {
             final String msg = "Cannot suspend, transaction is already suspended " + tx.getXid();
 
             throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-         } else {
+         }
+         else {
             tx.suspend();
 
             tx = null;
@@ -1172,7 +1090,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          final String msg = "Cannot commit, session is currently doing work in a transaction " + tx.getXid();
 
          throw new ActiveMQXAException(XAException.XAER_PROTO, msg);
-      } else {
+      }
+      else {
          Transaction theTx = resourceManager.getTransaction(xid);
 
          if (logger.isTraceEnabled()) {
@@ -1183,12 +1102,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             final String msg = "Cannot find xid in resource manager: " + xid;
 
             throw new ActiveMQXAException(XAException.XAER_NOTA, msg);
-         } else {
+         }
+         else {
             if (theTx.getState() == Transaction.State.SUSPENDED) {
                throw new ActiveMQXAException(XAException.XAER_PROTO, "Cannot prepare transaction, it is suspended " + xid);
-            } else if (theTx.getState() == Transaction.State.PREPARED) {
+            }
+            else if (theTx.getState() == Transaction.State.PREPARED) {
                ActiveMQServerLogger.LOGGER.info("ignoring prepare on xid as already called :" + xid);
-            } else {
+            }
+            else {
                theTx.prepare();
             }
          }
@@ -1229,7 +1151,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          if (!context.waitCompletion(10000)) {
             ActiveMQServerLogger.LOGGER.errorCompletingContext(new Exception("warning"));
          }
-      } catch (Exception e) {
+      }
+      catch (Exception e) {
          ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
       }
    }
@@ -1247,7 +1170,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          public void done() {
             try {
                doClose(failed);
-            } catch (Exception e) {
+            }
+            catch (Exception e) {
                ActiveMQServerLogger.LOGGER.errorClosingSession(e);
             }
          }
@@ -1260,7 +1184,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
       if (consumer != null) {
          consumer.close(false);
-      } else {
+      }
+      else {
          ActiveMQServerLogger.LOGGER.cannotFindConsumer(consumerID);
       }
    }
@@ -1284,54 +1209,60 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
    }
 
    @Override
-   public RoutingStatus send(final Message message, final boolean direct) throws Exception {
-      return send(message, direct, false);
+   public void sendLarge(final MessageInternal message) throws Exception {
+      // need to create the LargeMessage before continue
+      long id = storageManager.generateID();
+
+      LargeServerMessage largeMsg = storageManager.createLargeMessage(id, message);
+
+      if (logger.isTraceEnabled()) {
+         logger.trace("sendLarge::" + largeMsg);
+      }
+
+      if (currentLargeMessage != null) {
+         ActiveMQServerLogger.LOGGER.replacingIncompleteLargeMessage(currentLargeMessage.getMessageID());
+      }
+
+      currentLargeMessage = largeMsg;
    }
 
    @Override
-   public RoutingStatus send(final Message message,
-                             final boolean direct,
-                             boolean noAutoCreateQueue) throws Exception {
-      return send(getCurrentTransaction(), message, direct, noAutoCreateQueue);
+   public RoutingStatus send(final ServerMessage message, final boolean direct) throws Exception {
+      return send(message, direct, false);
    }
 
    @Override
-   public synchronized RoutingStatus send(Transaction tx,
-                                          final Message message,
-                                          final boolean direct,
-                                          boolean noAutoCreateQueue) throws Exception {
-
-      server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.beforeSend(this, tx, message, direct, noAutoCreateQueue) : null);
-
-      // If the protocol doesn't support flow control, we have no choice other than fail the communication
-      if (!this.getRemotingConnection().isSupportsFlowControl() && pagingManager.isDiskFull()) {
-         ActiveMQIOErrorException exception = ActiveMQMessageBundle.BUNDLE.diskBeyondLimit();
-         this.getRemotingConnection().fail(exception);
-         throw exception;
-      }
-
+   public RoutingStatus send(final ServerMessage message, final boolean direct, boolean noAutoCreateQueue) throws Exception {
       RoutingStatus result = RoutingStatus.OK;
       //large message may come from StompSession directly, in which
       //case the id header already generated.
       if (!message.isLargeMessage()) {
          long id = storageManager.generateID();
-         // This will re-encode the message
+
          message.setMessageID(id);
+         message.encodeMessageIDToBuffer();
       }
 
       if (server.getConfiguration().isPopulateValidatedUser() && validatedUser != null) {
-         message.setValidatedUserID(validatedUser);
+         message.putStringProperty(Message.HDR_VALIDATED_USER, SimpleString.toSimpleString(validatedUser));
       }
 
-      SimpleString address = message.getAddressSimpleString();
+      SimpleString address = message.getAddress();
 
       if (defaultAddress == null && address != null) {
          defaultAddress = address;
       }
 
       if (address == null) {
-         // We don't want to force a re-encode when the message gets sent to the consumer
-         message.setAddress(defaultAddress);
+         if (message.isDurable()) {
+            // We need to force a re-encode when the message gets persisted or when it gets reloaded
+            // it will have no address
+            message.setAddress(defaultAddress);
+         }
+         else {
+            // We don't want to force a re-encode when the message gets sent to the consumer
+            message.setAddressTransient(defaultAddress);
+         }
       }
 
       if (logger.isTraceEnabled()) {
@@ -1343,25 +1274,47 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          throw ActiveMQMessageBundle.BUNDLE.noAddress();
       }
 
-      if (message.getAddressSimpleString().equals(managementAddress)) {
+      if (message.getAddress().equals(managementAddress)) {
          // It's a management message
 
-         result = handleManagementMessage(tx, message, direct);
-      } else {
-         result = doSend(tx, message, address, direct, noAutoCreateQueue);
+         handleManagementMessage(message, direct);
+      }
+      else {
+         result = doSend(message, direct, noAutoCreateQueue);
       }
-
-      final RoutingStatus finalResult = result;
-      server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.afterSend(this, tx, message, direct, noAutoCreateQueue, finalResult) : null);
-
       return result;
    }
 
+   @Override
+   public void sendContinuations(final int packetSize,
+                                 final long messageBodySize,
+                                 final byte[] body,
+                                 final boolean continues) throws Exception {
+      if (currentLargeMessage == null) {
+         throw ActiveMQMessageBundle.BUNDLE.largeMessageNotInitialised();
+      }
+
+      // Immediately release the credits for the continuations- these don't contribute to the in-memory size
+      // of the message
+
+      currentLargeMessage.addBytes(body);
+
+      if (!continues) {
+         currentLargeMessage.releaseResources();
+
+         if (messageBodySize >= 0) {
+            currentLargeMessage.putLongProperty(Message.HDR_LARGE_BODY_SIZE, messageBodySize);
+         }
+
+         doSend(currentLargeMessage, false, false);
+
+         currentLargeMessage = null;
+      }
+   }
 
    @Override
-   public void requestProducerCredits(SimpleString address, final int credits) throws Exception {
-      final SimpleString addr = removePrefix(address);
-      PagingStore store = server.getPagingManager().getPageStore(addr);
+   public void requestProducerCredits(final SimpleString address, final int credits) throws Exception {
+      PagingStore store = server.getPagingManager().getPageStore(address);
 
       if (!store.checkMemory(new Runnable() {
          @Override
@@ -1384,12 +1337,10 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public void addMetaData(String key, String data) {
-      server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.beforeSessionMetadataAdded(this, key, data) : null);
       if (metaData == null) {
          metaData = new HashMap<>();
       }
       metaData.put(key, data);
-      server.callBrokerPlugins(server.hasBrokerPlugins() ? plugin -> plugin.afterSessionMetadataAdded(this, key, data) : null);
    }
 
    @Override
@@ -1398,7 +1349,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (sessionWithMetaData != null && sessionWithMetaData != this) {
          // There is a duplication of this property
          return false;
-      } else {
+      }
+      else {
          addMetaData(key, data);
          return true;
       }
@@ -1420,7 +1372,7 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public String[] getTargetAddresses() {
-      Map<SimpleString, Pair<Object, AtomicLong>> copy = cloneTargetAddresses();
+      Map<SimpleString, Pair<UUID, AtomicLong>> copy = cloneTargetAddresses();
       Iterator<SimpleString> iter = copy.keySet().iterator();
       int num = copy.keySet().size();
       String[] addresses = new String[num];
@@ -1434,10 +1386,11 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public String getLastSentMessageID(String address) {
-      Pair<Object, AtomicLong> value = targetAddressInfos.get(SimpleString.toSimpleString(address));
+      Pair<UUID, AtomicLong> value = targetAddressInfos.get(SimpleString.toSimpleString(address));
       if (value != null) {
          return value.getA().toString();
-      } else {
+      }
+      else {
          return null;
       }
    }
@@ -1453,40 +1406,23 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
    @Override
    public void describeProducersInfo(JsonArrayBuilder array) throws Exception {
-      Map<SimpleString, Pair<Object, AtomicLong>> targetCopy = cloneTargetAddresses();
+      Map<SimpleString, Pair<UUID, AtomicLong>> targetCopy = cloneTargetAddresses();
 
-      for (Map.Entry<SimpleString, Pair<Object, AtomicLong>> entry : targetCopy.entrySet()) {
+      for (Map.Entry<SimpleString, Pair<UUID, AtomicLong>> entry : targetCopy.entrySet()) {
          String uuid = null;
          if (entry.getValue().getA() != null) {
             uuid = entry.getValue().getA().toString();
          }
-         JsonObjectBuilder producerInfo = JsonLoader.createObjectBuilder().add("connectionID", this.getConnectionID().toString()).add("sessionID", this.getName()).add("destination", entry.getKey().toString()).add("lastUUIDSent", nullSafe(uuid)).add("msgSent", entry.getValue().getB().longValue());
+         JsonObjectBuilder producerInfo = Json.createObjectBuilder()
+            .add("connectionID", this.getConnectionID().toString())
+            .add("sessionID", this.getName())
+            .add("destination", entry.getKey().toString())
+            .add("lastUUIDSent", nullSafe(uuid))
+            .add("msgSent", entry.getValue().getB().longValue());
          array.add(producerInfo);
       }
    }
 
-   @Override
-   public String getValidatedUser() {
-      return validatedUser;
-   }
-
-   @Override
-   public SimpleString getMatchingQueue(SimpleString address, RoutingType routingType) throws Exception {
-      return server.getPostOffice().getMatchingQueue(address, routingType);
-   }
-
-   @Override
-   public SimpleString getMatchingQueue(SimpleString address,
-                                        SimpleString queueName,
-                                        RoutingType routingType) throws Exception {
-      return server.getPostOffice().getMatchingQueue(address, queueName, routingType);
-   }
-
-   @Override
-   public AddressInfo getAddress(SimpleString address) {
-      return server.getPostOffice().getAddressInfo(removePrefix(address));
-   }
-
    @Override
    public String toString() {
       StringBuffer buffer = new StringBuffer();
@@ -1498,7 +1434,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
             Object tmpValue = value.getValue();
             if (tmpValue == null || tmpValue.toString().isEmpty()) {
                buffer.append(value.getKey() + "=*N/A*");
-            } else {
+            }
+            else {
                buffer.append(value.getKey() + "=" + tmpValue);
             }
          }
@@ -1520,7 +1457,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
          close(true);
 
          ActiveMQServerLogger.LOGGER.clientConnectionFailedClearingSession(name);
-      } catch (Throwable t) {
+      }
+      catch (Throwable t) {
          ActiveMQServerLogger.LOGGER.errorClosingConnection(this);
       }
    }
@@ -1530,10 +1468,15 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       connectionFailed(me, failedOver);
    }
 
+   public void clearLargeMessage() {
+      currentLargeMessage = null;
+   }
+
    private void installJMSHooks() {
+      this.queueCreator = server.getJMSDestinationCreator();
    }
 
-   private Map<SimpleString, Pair<Object, AtomicLong>> cloneTargetAddresses() {
+   private Map<SimpleString, Pair<UUID, AtomicLong>> cloneTargetAddresses() {
       return new HashMap<>(targetAddressInfos);
    }
 
@@ -1547,35 +1490,26 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       started = s;
    }
 
-   private RoutingStatus handleManagementMessage(final Transaction tx,
-                                                 final Message message,
-                                                 final boolean direct) throws Exception {
+   private void handleManagementMessage(final ServerMessage message, final boolean direct) throws Exception {
       try {
-         securityCheck(removePrefix(message.getAddressSimpleString()), CheckType.MANAGE, this);
-      } catch (ActiveMQException e) {
+         securityCheck(message.getAddress(), CheckType.MANAGE, this);
+      }
+      catch (ActiveMQException e) {
          if (!autoCommitSends) {
             tx.markAsRollbackOnly(e);
          }
          throw e;
       }
 
-      Message reply = managementService.handleMessage(message);
+      ServerMessage reply = managementService.handleMessage(message);
 
-      SimpleString replyTo = message.getReplyTo();
+      SimpleString replyTo = message.getSimpleStringProperty(ClientMessageImpl.REPLYTO_HEADER_NAME);
 
       if (replyTo != null) {
-         // TODO: move this check somewhere else? this is a JMS-specific bit of logic in the core impl
-         if (replyTo.toString().startsWith("queue://") || replyTo.toString().startsWith("topic://")) {
-            replyTo = SimpleString.toSimpleString(replyTo.toString().substring(8));
-         } else if (replyTo.toString().startsWith("temp-queue://") || replyTo.toString().startsWith("temp-topic://")) {
-            replyTo = SimpleString.toSimpleString(replyTo.toString().substring(13));
-         }
          reply.setAddress(replyTo);
 
-         doSend(tx, reply, null, direct, false);
+         doSend(reply, direct, false);
       }
-
-      return RoutingStatus.OK;
    }
 
    private void doRollback(final boolean clientFailed,
@@ -1600,7 +1534,8 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       if (theTx.getState() == State.ROLLEDBACK) {
          Transaction newTX = newTransaction();
          cancelAndRollback(clientFailed, newTX, wasStarted, toCancel);
-      } else {
+      }
+      else {
          cancelAndRollback(clientFailed, theTx, wasStarted, toCancel);
       }
    }
@@ -1629,33 +1564,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       theTx.rollback();
    }
 
-   @Override
-   public synchronized RoutingStatus doSend(final Transaction tx,
-                                            final Message msg,
-                                            final SimpleString originalAddress,
-                                            final boolean direct,
-                                            final boolean noAutoCreateQueue) throws Exception {
-
+   protected RoutingStatus doSend(final ServerMessage msg, final boolean direct, final boolean noAutoCreateQueue) throws Exception {
       RoutingStatus result = RoutingStatus.OK;
-
-      RoutingType routingType = msg.getRoutingType();
-
-         /* TODO-now: How to address here with AMQP?
-         if (originalAddress != null) {
-            if (originalAddress.toString().startsWith("anycast:")) {
-               routingType = RoutingType.ANYCAST;
-            } else if (originalAddress.toString().startsWith("multicast:")) {
-               routingType = RoutingType.MULTICAST;
-            }
-         } */
-
-      Pair<SimpleString, RoutingType> art = getAddressAndRoutingType(msg.getAddressSimpleString(), routingType);
-
-      // Consumer
       // check the user has write access to this address.
       try {
-         securityCheck(art.getA(), CheckType.SEND, this);
-      } catch (ActiveMQException e) {
+         securityCheck(msg.getAddress(), CheckType.SEND, this);
+      }
+      catch (ActiveMQException e) {
          if (!autoCommitSends && tx != null) {
             tx.markAsRollbackOnly(e);
          }
@@ -1663,25 +1578,30 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
       }
 
       if (tx == null || autoCommitSends) {
-      } else {
+      }
+      else {
          routingContext.setTransaction(tx);
       }
 
       try {
-         routingContext.setAddress(art.getA());
-         routingContext.setRoutingType(art.getB());
-
-         result = postOffice.route(msg, routingContext, direct);
+         if (noAutoCreateQueue) {
+            result = postOffice.route(msg, null, routingContext, direct);
+         }
+         else {
+            result = postOffice.route(msg, queueCreator, routingContext, direct);
+         }
 
-         Pair<Object, AtomicLong> value = targetAddressInfos.get(msg.getAddressSimpleString());
+         Pair<UUID, AtomicLong> value = targetAddressInfos.get(msg.getAddress());
 
          if (value == null) {
-            targetAddressInfos.put(msg.getAddressSimpleString(), new Pair<>(msg.getUserID(), new AtomicLong(1)));
-         } else {
+            targetAddressInfos.put(msg.getAddress(), new Pair<>(msg.getUserID(), new AtomicLong(1)));
+         }
+         else {
             value.setA(msg.getUserID());
             value.getB().incrementAndGet();
          }
-      } finally {
+      }
+      finally {
          routingContext.clear();
       }
       return result;
@@ -1694,37 +1614,13 @@ public class ServerSessionImpl implements ServerSession, FailureListener {
 
          if (oper == null) {
             return Collections.emptyList();
-         } else {
+         }
+         else {
             return oper.getListOnConsumer(consumerId);
          }
-      } else {
-         return Collections.emptyList();
-      }
-   }
-
-   @Override
-   public SimpleString removePrefix(SimpleString address) {
-      if (prefixEnabled && address != null) {
-         return PrefixUtil.getAddress(address, prefixes);
-      }
-      return address;
-   }
-
-   @Override
-   public Pair<SimpleString, RoutingType> getAddressAndRoutingType(SimpleString address,
-                                                                   RoutingType defaultRoutingType) {
-      if (prefixEnabled) {
-         return PrefixUtil.getAddressAndRoutingType(address, defaultRoutingType, prefixes);
       }
-      return new Pair<>(address, defaultRoutingType);
-   }
-
-   @Override
-   public Pair<SimpleString, Set<RoutingType>> getAddressAndRoutingTypes(SimpleString address,
-                                                                         Set<RoutingType> defaultRoutingTypes) {
-      if (prefixEnabled) {
-         return PrefixUtil.getAddressAndRoutingTypes(address, defaultRoutingTypes, prefixes);
+      else {
+         return Collections.emptyList();
       }
-      return new Pair<>(address, defaultRoutingTypes);
    }
 }