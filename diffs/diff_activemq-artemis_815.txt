diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java
index 72e8eba7fb..43de7c4de3 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerSenderContext.java
@@ -20,37 +20,28 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.Objects;
 import java.util.Set;
-import java.util.concurrent.TimeUnit;
 
+import org.apache.activemq.artemis.api.core.ActiveMQQueueExistsException;
 import org.apache.activemq.artemis.api.core.ActiveMQExceptionType;
-import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
-import org.apache.activemq.artemis.api.core.Message;
-import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.persistence.OperationContext;
+import org.apache.activemq.artemis.core.postoffice.impl.CompositeAddress;
 import org.apache.activemq.artemis.core.server.AddressQueryResult;
-import org.apache.activemq.artemis.core.server.Consumer;
-import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
-import org.apache.activemq.artemis.jms.client.ActiveMQDestination;
-import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessage;
+import org.apache.activemq.artemis.core.server.RoutingType;
+import org.apache.activemq.artemis.core.server.impl.AddressInfo;
+import org.apache.activemq.artemis.core.transaction.Transaction;
+import org.apache.activemq.artemis.jms.client.ActiveMQConnection;
 import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;
-import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;
-import org.apache.activemq.artemis.protocol.amqp.converter.CoreAmqpConverter;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPIllegalStateException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPInternalErrorException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPNotFoundException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPResourceLimitExceededException;
 import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolMessageBundle;
-import org.apache.activemq.artemis.protocol.amqp.proton.transaction.ProtonTransactionImpl;
-import org.apache.activemq.artemis.protocol.amqp.util.NettyReadable;
-import org.apache.activemq.artemis.reader.MessageUtil;
+import org.apache.activemq.artemis.protocol.amqp.util.CreditsSemaphore;
+import org.apache.activemq.artemis.protocol.amqp.util.NettyWritable;
 import org.apache.activemq.artemis.selector.filter.FilterException;
 import org.apache.activemq.artemis.selector.impl.SelectorParser;
-import org.apache.activemq.artemis.spi.core.remoting.Connection;
-import org.apache.activemq.artemis.utils.CompositeAddress;
 import org.apache.qpid.proton.amqp.DescribedType;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
@@ -65,15 +56,14 @@ import org.apache.qpid.proton.amqp.transaction.TransactionalState;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.DeliveryState;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;
 import org.apache.qpid.proton.amqp.transport.SenderSettleMode;
-import org.apache.qpid.proton.codec.ReadableBuffer;
 import org.apache.qpid.proton.engine.Delivery;
-import org.apache.qpid.proton.engine.EndpointState;
-import org.apache.qpid.proton.engine.Link;
 import org.apache.qpid.proton.engine.Sender;
 import org.jboss.logging.Logger;
 
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.PooledByteBufAllocator;
+
 /**
  * TODO: Merge {@link ProtonServerSenderContext} and {@link org.apache.activemq.artemis.protocol.amqp.client.ProtonClientSenderContext} once we support 'global' link names. The split is a workaround for outgoing links
  */
@@ -87,9 +77,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    private static final Symbol SHARED = Symbol.valueOf("shared");
    private static final Symbol GLOBAL = Symbol.valueOf("global");
 
-   private final ConnectionFlushIOCallback connectionFlusher = new ConnectionFlushIOCallback();
-
-   private Consumer brokerConsumer;
+   private Object brokerConsumer;
 
    protected final AMQPSessionContext protonSession;
    protected final Sender sender;
@@ -99,17 +87,13 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    private boolean multicast;
    //todo get this from somewhere
    private RoutingType defaultRoutingType = RoutingType.ANYCAST;
+   protected CreditsSemaphore creditsSemaphore = new CreditsSemaphore(0);
    private RoutingType routingTypeToUse = defaultRoutingType;
    private boolean shared = false;
    private boolean global = false;
    private boolean isVolatile = false;
-   private boolean preSettle;
-   private SimpleString tempQueueName;
 
-   public ProtonServerSenderContext(AMQPConnectionContext connection,
-                                    Sender sender,
-                                    AMQPSessionContext protonSession,
-                                    AMQPSessionCallback server) {
+   public ProtonServerSenderContext(AMQPConnectionContext connection, Sender sender, AMQPSessionContext protonSession, AMQPSessionCallback server) {
       super();
       this.connection = connection;
       this.sender = sender;
@@ -123,6 +107,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
 
    @Override
    public void onFlow(int currentCredits, boolean drain) {
+      this.creditsSemaphore.setCredits(currentCredits);
       sessionSPI.onFlowConsumer(brokerConsumer, currentCredits, drain);
    }
 
@@ -159,16 +144,10 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       super.initialise();
 
       Source source = (Source) sender.getRemoteSource();
-      SimpleString queue = null;
+      String queue = null;
       String selector = null;
       final Map<Symbol, Object> supportedFilters = new HashMap<>();
 
-      // Match the settlement mode of the remote instead of relying on the default of MIXED.
-      sender.setSenderSettleMode(sender.getRemoteSenderSettleMode());
-
-      // We don't currently support SECOND so enforce that the answer is anlways FIRST
-      sender.setReceiverSettleMode(ReceiverSettleMode.FIRST);
-
       if (source != null) {
          // We look for message selectors on every receiver, while in other cases we might only
          // consume the filter depending on the subscription type.
@@ -191,8 +170,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          // subscription queue
          String clientId = getClientId();
          String pubId = sender.getName();
-         global = hasRemoteDesiredCapability(sender, GLOBAL);
-         queue = createQueueName(connection.isUseCoreSubscriptionNaming(), clientId, pubId, true, global, false);
+         queue = createQueueName(clientId, pubId, true, global, false);
          QueueQueryResult result = sessionSPI.queueQuery(queue, RoutingType.MULTICAST, false);
          multicast = true;
          routingTypeToUse = RoutingType.MULTICAST;
@@ -201,7 +179,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          // the lifetime policy and capabilities of the new subscription.
          if (result.isExists()) {
             source = new org.apache.qpid.proton.amqp.messaging.Source();
-            source.setAddress(queue.toString());
+            source.setAddress(queue);
             source.setDurable(TerminusDurability.UNSETTLED_STATE);
             source.setExpiryPolicy(TerminusExpiryPolicy.NEVER);
             source.setDistributionMode(COPY);
@@ -213,7 +191,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                boolean noLocal = false;
 
                String remoteContainerId = sender.getSession().getConnection().getRemoteContainer();
-               String noLocalFilter = MessageUtil.CONNECTION_ID_PROPERTY_NAME.toString() + "<>'" + remoteContainerId + "'";
+               String noLocalFilter = ActiveMQConnection.CONNECTION_ID_PROPERTY_NAME.toString() + "<>'" + remoteContainerId + "'";
 
                if (selector.endsWith(noLocalFilter)) {
                   if (selector.length() > noLocalFilter.length()) {
@@ -242,15 +220,14 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       } else if (source.getDynamic()) {
          // if dynamic we have to create the node (queue) and set the address on the target, the
          // node is temporary and  will be deleted on closing of the session
-         queue = SimpleString.toSimpleString(java.util.UUID.randomUUID().toString());
-         tempQueueName = queue;
+         queue = java.util.UUID.randomUUID().toString();
          try {
             sessionSPI.createTemporaryQueue(queue, RoutingType.ANYCAST);
             // protonSession.getServerSession().createQueue(queue, queue, null, true, false);
          } catch (Exception e) {
             throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCreatingTemporaryQueue(e.getMessage());
          }
-         source.setAddress(queue.toString());
+         source.setAddress(queue);
       } else {
          SimpleString addressToUse;
          SimpleString queueNameToUse = null;
@@ -267,47 +244,19 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          }
          //check to see if the client has defined how we act
          boolean clientDefined = hasCapabilities(TOPIC, source) || hasCapabilities(QUEUE, source);
-         if (clientDefined) {
+         if (clientDefined)  {
             multicast = hasCapabilities(TOPIC, source);
-            AddressQueryResult addressQueryResult = null;
-            try {
-               addressQueryResult = sessionSPI.addressQuery(addressToUse, multicast ? RoutingType.MULTICAST : RoutingType.ANYCAST, true);
-            } catch (ActiveMQSecurityException e) {
-               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(e.getMessage());
-            } catch (ActiveMQAMQPException e) {
-               throw e;
-            } catch (Exception e) {
-               throw new ActiveMQAMQPInternalErrorException(e.getMessage(), e);
-            }
-
-            if (!addressQueryResult.isExists()) {
-               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.sourceAddressDoesntExist();
-            }
-
-            Set<RoutingType> routingTypes = addressQueryResult.getRoutingTypes();
-
+            AddressInfo addressInfo = sessionSPI.getAddress(addressToUse);
+            Set<RoutingType> routingTypes = addressInfo.getRoutingTypes();
             //if the client defines 1 routing type and the broker another then throw an exception
             if (multicast && !routingTypes.contains(RoutingType.MULTICAST)) {
-               throw new ActiveMQAMQPIllegalStateException("Address " + addressToUse + " is not configured for topic support");
+               throw new ActiveMQAMQPIllegalStateException("Address is not configured for topic support");
             } else if (!multicast && !routingTypes.contains(RoutingType.ANYCAST)) {
-               //if client specifies fully qualified name that's allowed, don't throw exception.
-               if (queueNameToUse == null) {
-                  throw new ActiveMQAMQPIllegalStateException("Address " + addressToUse + " is not configured for queue support");
-               }
+               throw new ActiveMQAMQPIllegalStateException("Address is not configured for queue support");
             }
          } else {
-            // if not we look up the address
-            AddressQueryResult addressQueryResult = null;
-            try {
-               addressQueryResult = sessionSPI.addressQuery(addressToUse, defaultRoutingType, true);
-            } catch (ActiveMQSecurityException e) {
-               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(e.getMessage());
-            } catch (ActiveMQAMQPException e) {
-               throw e;
-            } catch (Exception e) {
-               throw new ActiveMQAMQPInternalErrorException(e.getMessage(), e);
-            }
-
+            //if not we look up the address
+            AddressQueryResult addressQueryResult = sessionSPI.addressQuery(addressToUse.toString(), defaultRoutingType, true);
             if (!addressQueryResult.isExists()) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.sourceAddressDoesntExist();
             }
@@ -327,7 +276,7 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
             Map.Entry<Symbol, DescribedType> filter = AmqpSupport.findFilter(source.getFilter(), AmqpSupport.NO_LOCAL_FILTER_IDS);
             if (filter != null) {
                String remoteContainerId = sender.getSession().getConnection().getRemoteContainer();
-               String noLocalFilter = MessageUtil.CONNECTION_ID_PROPERTY_NAME.toString() + "<>'" + remoteContainerId + "'";
+               String noLocalFilter = ActiveMQConnection.CONNECTION_ID_PROPERTY_NAME.toString() + "<>'" + remoteContainerId + "'";
                if (selector != null) {
                   selector += " AND " + noLocalFilter;
                } else {
@@ -337,9 +286,11 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                supportedFilters.put(filter.getKey(), filter.getValue());
             }
 
-            queue = getMatchingQueue(queueNameToUse, addressToUse, RoutingType.MULTICAST);
-            SimpleString simpleStringSelector = SimpleString.toSimpleString(selector);
 
+            if (queueNameToUse != null) {
+               SimpleString matchingAnycastQueue = sessionSPI.getMatchingQueue(addressToUse, queueNameToUse, RoutingType.MULTICAST  );
+               queue = matchingAnycastQueue.toString();
+            }
             //if the address specifies a broker configured queue then we always use this, treat it as a queue
             if (queue != null) {
                multicast = false;
@@ -349,41 +300,43 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
                // id and link name
                String clientId = getClientId();
                String pubId = sender.getName();
-               queue = createQueueName(connection.isUseCoreSubscriptionNaming(), clientId, pubId, shared, global, false);
+               queue = createQueueName(clientId, pubId, shared, global, false);
                QueueQueryResult result = sessionSPI.queueQuery(queue, routingTypeToUse, false);
+
                if (result.isExists()) {
                   // If a client reattaches to a durable subscription with a different no-local
                   // filter value, selector or address then we must recreate the queue (JMS semantics).
-                  if (!Objects.equals(result.getFilterString(), simpleStringSelector) || (sender.getSource() != null && !sender.getSource().getAddress().equals(result.getAddress().toString()))) {
+                  if (!Objects.equals(result.getFilterString(), SimpleString.toSimpleString(selector)) ||
+                     (sender.getSource() != null && !sender.getSource().getAddress().equals(result.getAddress().toString()))) {
 
                      if (result.getConsumerCount() == 0) {
                         sessionSPI.deleteQueue(queue);
-                        sessionSPI.createUnsharedDurableQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                        sessionSPI.createUnsharedDurableQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
                      } else {
                         throw new ActiveMQAMQPIllegalStateException("Unable to recreate subscription, consumers already exist");
                      }
                   }
                } else {
                   if (shared) {
-                     sessionSPI.createSharedDurableQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                     sessionSPI.createSharedDurableQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
                   } else {
-                     sessionSPI.createUnsharedDurableQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                     sessionSPI.createUnsharedDurableQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
                   }
                }
             } else {
                // otherwise we are a volatile subscription
                isVolatile = true;
                if (shared && sender.getName() != null) {
-                  queue = createQueueName(connection.isUseCoreSubscriptionNaming(), getClientId(), sender.getName(), shared, global, isVolatile);
-                  QueueQueryResult result = sessionSPI.queueQuery(queue, routingTypeToUse, false);
-                  if (!(result.isExists() && Objects.equals(result.getAddress(), addressToUse) && Objects.equals(result.getFilterString(), simpleStringSelector))) {
-                     sessionSPI.createSharedVolatileQueue(addressToUse, RoutingType.MULTICAST, queue, simpleStringSelector);
+                  queue = createQueueName(getClientId(), sender.getName(), shared, global, isVolatile);
+                  try {
+                     sessionSPI.createSharedVolatileQueue(source.getAddress(), RoutingType.MULTICAST, queue, selector);
+                  } catch (ActiveMQQueueExistsException e) {
+                     //this is ok, just means its shared
                   }
                } else {
-                  queue = SimpleString.toSimpleString(java.util.UUID.randomUUID().toString());
-                  tempQueueName = queue;
+                  queue = java.util.UUID.randomUUID().toString();
                   try {
-                     sessionSPI.createTemporaryQueue(addressToUse, queue, RoutingType.MULTICAST, simpleStringSelector);
+                     sessionSPI.createTemporaryQueue(source.getAddress(), queue, RoutingType.MULTICAST, selector);
                   } catch (Exception e) {
                      throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCreatingTemporaryQueue(e.getMessage());
                   }
@@ -391,21 +344,18 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
             }
          } else {
             if (queueNameToUse != null) {
-               //a queue consumer can receive from a multicast queue if it uses a fully qualified name
-               //setting routingType to null means do not check the routingType against the Queue's routing type.
-               routingTypeToUse = null;
-               SimpleString matchingAnycastQueue = getMatchingQueue(queueNameToUse, addressToUse, null);
+               SimpleString matchingAnycastQueue = sessionSPI.getMatchingQueue(addressToUse, queueNameToUse, RoutingType.ANYCAST);
                if (matchingAnycastQueue != null) {
-                  queue = matchingAnycastQueue;
+                  queue = matchingAnycastQueue.toString();
                } else {
                   throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.sourceAddressDoesntExist();
                }
             } else {
                SimpleString matchingAnycastQueue = sessionSPI.getMatchingQueue(addressToUse, RoutingType.ANYCAST);
                if (matchingAnycastQueue != null) {
-                  queue = matchingAnycastQueue;
+                  queue = matchingAnycastQueue.toString();
                } else {
-                  queue = addressToUse;
+                  queue = addressToUse.toString();
                }
             }
 
@@ -426,9 +376,6 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          }
       }
 
-      // Detect if sender is in pre-settle mode.
-      preSettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
-
       // We need to update the source with any filters we support otherwise the client
       // is free to consider the attach as having failed if we don't send back what we
       // do support or if we send something we don't support the client won't know we
@@ -437,35 +384,19 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
 
       boolean browseOnly = !multicast && source.getDistributionMode() != null && source.getDistributionMode().equals(COPY);
       try {
-         brokerConsumer = (Consumer) sessionSPI.createSender(this, queue, multicast ? null : selector, browseOnly);
+         brokerConsumer = sessionSPI.createSender(this, queue, multicast ? null : selector, browseOnly);
       } catch (ActiveMQAMQPResourceLimitExceededException e1) {
          throw new ActiveMQAMQPResourceLimitExceededException(e1.getMessage());
-      } catch (ActiveMQSecurityException e) {
-         throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(e.getMessage());
       } catch (Exception e) {
          throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCreatingConsumer(e.getMessage());
       }
    }
 
-   private SimpleString getMatchingQueue(SimpleString queueName, SimpleString address, RoutingType routingType) throws Exception {
-      if (queueName != null) {
-         QueueQueryResult result = sessionSPI.queueQuery(queueName, routingType, false);
-         if (!result.isExists()) {
-            throw new ActiveMQAMQPNotFoundException("Queue: '" + queueName + "' does not exist");
-         } else {
-            if (!result.getAddress().equals(address)) {
-               throw new ActiveMQAMQPNotFoundException("Queue: '" + queueName + "' does not exist for address '" + address + "'");
-            }
-            return sessionSPI.getMatchingQueue(address, queueName, routingType);
-         }
-      }
-      return null;
-   }
-
    protected String getClientId() {
       return connection.getRemoteContainer();
    }
 
+
    /*
     * close the session
     */
@@ -476,11 +407,8 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
          sender.setCondition(condition);
       }
       protonSession.removeSender(sender);
-      connection.lock();
-      try {
+      synchronized (connection.getLock()) {
          sender.close();
-      } finally {
-         connection.unlock();
       }
       connection.flush();
 
@@ -498,37 +426,32 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    @Override
    public void close(boolean remoteLinkClose) throws ActiveMQAMQPException {
       try {
-         closed = true;
          sessionSPI.closeSender(brokerConsumer);
          // if this is a link close rather than a connection close or detach, we need to delete
          // any durable resources for say pub subs
          if (remoteLinkClose) {
             Source source = (Source) sender.getSource();
             if (source != null && source.getAddress() != null && multicast) {
-               SimpleString queueName = SimpleString.toSimpleString(source.getAddress());
-               QueueQueryResult result = sessionSPI.queueQuery(queueName, routingTypeToUse, false);
+               String queueName = source.getAddress();
+               QueueQueryResult result = sessionSPI.queueQuery(queueName, routingTypeToUse,  false);
                if (result.isExists() && source.getDynamic()) {
                   sessionSPI.deleteQueue(queueName);
                } else {
-                  if (source.getDurable() == TerminusDurability.NONE && tempQueueName != null && (source.getExpiryPolicy() == TerminusExpiryPolicy.LINK_DETACH || source.getExpiryPolicy() == TerminusExpiryPolicy.SESSION_END)) {
-                     sessionSPI.removeTemporaryQueue(tempQueueName);
-                  } else {
-                     String clientId = getClientId();
-                     String pubId = sender.getName();
-                     if (pubId.contains("|")) {
-                        pubId = pubId.split("\\|")[0];
-                     }
-                     SimpleString queue = createQueueName(connection.isUseCoreSubscriptionNaming(), clientId, pubId, shared, global, isVolatile);
-                     result = sessionSPI.queueQuery(queue, multicast ? RoutingType.MULTICAST : RoutingType.ANYCAST, false);
-                     //only delete if it isn't volatile and has no consumers
-                     if (result.isExists() && !isVolatile && result.getConsumerCount() == 0) {
-                        sessionSPI.deleteQueue(queue);
-                     }
+                  String clientId = getClientId();
+                  String pubId = sender.getName();
+                  if (pubId.contains("|")) {
+                     pubId = pubId.split("\\|")[0];
+                  }
+                  String queue = createQueueName(clientId, pubId, shared, global, isVolatile);
+                  result = sessionSPI.queueQuery(queue, multicast ? RoutingType.MULTICAST : RoutingType.ANYCAST, false);
+                  //only delete if it isn't volatile and has no consumers
+                  if (result.isExists() && !isVolatile && result.getConsumerCount() == 0) {
+                     sessionSPI.deleteQueue(queue);
                   }
                }
             } else if (source != null && source.getDynamic() && (source.getExpiryPolicy() == TerminusExpiryPolicy.LINK_DETACH || source.getExpiryPolicy() == TerminusExpiryPolicy.SESSION_END)) {
                try {
-                  sessionSPI.removeTemporaryQueue(SimpleString.toSimpleString(source.getAddress()));
+                  sessionSPI.removeTemporaryQueue(source.getAddress());
                } catch (Exception e) {
                   //ignore on close, its temp anyway and will be removed later
                }
@@ -542,122 +465,72 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
 
    @Override
    public void onMessage(Delivery delivery) throws ActiveMQAMQPException {
-      if (closed) {
-         return;
-      }
+      Object message = delivery.getContext();
 
-      OperationContext oldContext = sessionSPI.recoverContext();
+      boolean preSettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
 
-      try {
-         Message message = ((MessageReference) delivery.getContext()).getMessage();
-         DeliveryState remoteState = delivery.getRemoteState();
-
-         boolean settleImmediate = true;
-         if (remoteState instanceof Accepted) {
-            // this can happen in the twice ack mode, that is the receiver accepts and settles separately
-            // acking again would show an exception but would have no negative effect but best to handle anyway.
-            if (delivery.isSettled()) {
-               return;
-            }
-            // we have to individual ack as we can't guarantee we will get the delivery updates
-            // (including acks) in order from dealer, a performance hit but a must
-            try {
-               sessionSPI.ack(null, brokerConsumer, message);
-            } catch (Exception e) {
-               log.warn(e.toString(), e);
-               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorAcknowledgingMessage(message.toString(), e.getMessage());
-            }
-         } else if (remoteState instanceof TransactionalState) {
-            // When the message arrives with a TransactionState disposition the ack should
-            // enlist the message into the transaction associated with the given txn ID.
-            TransactionalState txState = (TransactionalState) remoteState;
-            ProtonTransactionImpl tx = (ProtonTransactionImpl) this.sessionSPI.getTransaction(txState.getTxnId(), false);
+      DeliveryState remoteState = delivery.getRemoteState();
+
+      if (remoteState != null) {
+         // If we are transactional then we need ack if the msg has been accepted
+         if (remoteState instanceof TransactionalState) {
 
+            TransactionalState txState = (TransactionalState) remoteState;
+            Transaction tx = this.sessionSPI.getTransaction(txState.getTxnId());
             if (txState.getOutcome() != null) {
-               settleImmediate = false;
                Outcome outcome = txState.getOutcome();
                if (outcome instanceof Accepted) {
                   if (!delivery.remotelySettled()) {
                      TransactionalState txAccepted = new TransactionalState();
                      txAccepted.setOutcome(Accepted.getInstance());
                      txAccepted.setTxnId(txState.getTxnId());
+
                      delivery.disposition(txAccepted);
                   }
                   // we have to individual ack as we can't guarantee we will get the delivery
-                  // (including acks) in order from dealer, a performance hit but a must
+                  // updates (including acks) in order
+                  // from dealer, a perf hit but a must
                   try {
                      sessionSPI.ack(tx, brokerConsumer, message);
-                     tx.addDelivery(delivery, this);
                   } catch (Exception e) {
                      throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorAcknowledgingMessage(message.toString(), e.getMessage());
                   }
                }
             }
-         } else if (remoteState instanceof Released) {
+         } else if (remoteState instanceof Accepted) {
+            // we have to individual ack as we can't guarantee we will get the delivery updates
+            // (including acks) in order
+            // from dealer, a perf hit but a must
             try {
-               sessionSPI.cancel(brokerConsumer, message, false);
+               sessionSPI.ack(null, brokerConsumer, message);
             } catch (Exception e) {
-               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCancellingMessage(message.toString(), e.getMessage());
+               throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorAcknowledgingMessage(message.toString(), e.getMessage());
             }
-         } else if (remoteState instanceof Rejected) {
+         } else if (remoteState instanceof Released) {
             try {
-               sessionSPI.reject(brokerConsumer, message);
+               sessionSPI.cancel(brokerConsumer, message, false);
             } catch (Exception e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCancellingMessage(message.toString(), e.getMessage());
             }
-         } else if (remoteState instanceof Modified) {
+         } else if (remoteState instanceof Rejected || remoteState instanceof Modified) {
             try {
-               Modified modification = (Modified) remoteState;
-
-               if (Boolean.TRUE.equals(modification.getUndeliverableHere())) {
-                  message.rejectConsumer(brokerConsumer.sequentialID());
-               }
-
-               if (Boolean.TRUE.equals(modification.getDeliveryFailed())) {
-                  sessionSPI.cancel(brokerConsumer, message, true);
-               } else {
-                  sessionSPI.cancel(brokerConsumer, message, false);
-               }
+               sessionSPI.cancel(brokerConsumer, message, true);
             } catch (Exception e) {
                throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.errorCancellingMessage(message.toString(), e.getMessage());
             }
-         } else {
-            log.debug("Received null or unknown disposition for delivery update: " + remoteState);
-            return;
          }
-
+         // todo add tag caching
          if (!preSettle) {
             protonSession.replaceTag(delivery.getTag());
          }
 
-         if (settleImmediate) {
+         synchronized (connection.getLock()) {
             delivery.settle();
+            sender.offer(1);
          }
 
-      } finally {
-         sessionSPI.afterIO(connectionFlusher);
-         sessionSPI.resetContext(oldContext);
-      }
-   }
-
-   private final class ConnectionFlushIOCallback implements IOCallback {
-      @Override
-      public void done() {
-         connection.flush();
-      }
-
-      @Override
-      public void onError(int errorCode, String errorMessage) {
-         connection.flush();
-      }
-   }
-
-   public void settle(Delivery delivery) {
-      connection.lock();
-      try {
-         delivery.settle();
-      } finally {
-         connection.unlock();
+      } else {
+         // todo not sure if we need to do anything here
       }
    }
 
@@ -668,71 +541,67 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
    /**
     * handle an out going message from ActiveMQ Artemis, send via the Proton Sender
     */
-   public int deliverMessage(MessageReference messageReference, int deliveryCount, Connection transportConnection) throws Exception {
-
+   public int deliverMessage(Object message, int deliveryCount) throws Exception {
       if (closed) {
+         System.err.println("Message can't be delivered as it's closed");
          return 0;
       }
 
-      AMQPMessage message = CoreAmqpConverter.checkAMQP(messageReference.getMessage());
-      sessionSPI.invokeOutgoing(message, (ActiveMQProtonRemotingConnection) transportConnection.getProtocolConnection());
+      if (!creditsSemaphore.tryAcquire()) {
+         try {
+            creditsSemaphore.acquire();
+         } catch (InterruptedException e) {
+            Thread.currentThread().interrupt();
+            // nothing to be done here.. we just keep going
+            throw new IllegalStateException(e.getMessage(), e);
+         }
+      }
+
+      // presettle means we can settle the message on the dealer side before we send it, i.e.
+      // for browsers
+      boolean preSettle = sender.getRemoteSenderSettleMode() == SenderSettleMode.SETTLED;
 
       // we only need a tag if we are going to settle later
       byte[] tag = preSettle ? new byte[0] : protonSession.getTag();
 
-      // Let the Message decide how to present the message bytes
-      ReadableBuffer sendBuffer = message.getSendBuffer(deliveryCount);
-      boolean releaseRequired = sendBuffer instanceof NettyReadable;
-
+      ByteBuf nettyBuffer = PooledByteBufAllocator.DEFAULT.heapBuffer(1024);
       try {
-         int size = sendBuffer.remaining();
+         long messageFormat = 0;
 
-         while (!connection.tryLock(1, TimeUnit.SECONDS)) {
-            if (closed || sender.getLocalState() == EndpointState.CLOSED) {
-               // If we're waiting on the connection lock, the link might be in the process of closing.  If this happens
-               // we return.
-               return 0;
-            } else {
-               if (log.isDebugEnabled()) {
-                  log.debug("Couldn't get lock on deliverMessage " + this);
-               }
-            }
+         // Encode the Server Message into the given Netty Buffer as an AMQP
+         // Message transformed from the internal message model.
+         try {
+            messageFormat = sessionSPI.encodeMessage(message, deliveryCount, new NettyWritable(nettyBuffer));
+         } catch (Throwable e) {
+            log.warn(e.getMessage(), e);
+            throw new ActiveMQAMQPInternalErrorException(e.getMessage(), e);
          }
 
-         try {
+         int size = nettyBuffer.writerIndex();
+
+         synchronized (connection.getLock()) {
             final Delivery delivery;
             delivery = sender.delivery(tag, 0, tag.length);
-            delivery.setMessageFormat((int) message.getMessageFormat());
-            delivery.setContext(messageReference);
-
-            if (releaseRequired) {
-               sender.send(sendBuffer);
-               // Above send copied, so release now if needed
-               releaseRequired = false;
-               ((NettyReadable) sendBuffer).getByteBuf().release();
-            } else {
-               // Don't have pooled content, no need to release or copy.
-               sender.sendNoCopy(sendBuffer);
-            }
+            delivery.setMessageFormat((int) messageFormat);
+            delivery.setContext(message);
+
+            // this will avoid a copy.. patch provided by Norman using buffer.array()
+            sender.send(nettyBuffer.array(), nettyBuffer.arrayOffset() + nettyBuffer.readerIndex(), nettyBuffer.readableBytes());
 
             if (preSettle) {
                // Presettled means the client implicitly accepts any delivery we send it.
-               sessionSPI.ack(null, brokerConsumer, messageReference.getMessage());
+               sessionSPI.ack(null, brokerConsumer, message);
                delivery.settle();
             } else {
                sender.advance();
             }
-
-            connection.flush();
-         } finally {
-            connection.unlock();
          }
 
+         connection.flush();
+
          return size;
       } finally {
-         if (releaseRequired) {
-            ((NettyReadable) sendBuffer).getByteBuf().release();
-         }
+         nettyBuffer.release();
       }
    }
 
@@ -749,57 +618,19 @@ public class ProtonServerSenderContext extends ProtonInitializable implements Pr
       return false;
    }
 
-   private static boolean hasRemoteDesiredCapability(Link link, Symbol capability) {
-      Symbol[] remoteDesiredCapabilities = link.getRemoteDesiredCapabilities();
-      if (remoteDesiredCapabilities != null) {
-         for (Symbol cap : remoteDesiredCapabilities) {
-            if (capability.equals(cap)) {
-               return true;
-            }
+   private static String createQueueName(String clientId, String pubId, boolean shared, boolean global, boolean isVolatile) {
+      String queue = clientId == null || clientId.isEmpty() ? pubId : clientId + "." + pubId;
+      if (shared) {
+         if (queue.contains("|")) {
+            queue = queue.split("\\|")[0];
          }
-      }
-      return false;
-   }
-
-   private static SimpleString createQueueName(boolean useCoreSubscriptionNaming,
-                                         String clientId,
-                                         String pubId,
-                                         boolean shared,
-                                         boolean global,
-                                         boolean isVolatile) {
-      if (useCoreSubscriptionNaming) {
-         final boolean durable = !isVolatile;
-         final String subscriptionName = pubId.contains("|") ? pubId.split("\\|")[0] : pubId;
-         final String clientID = clientId == null || clientId.isEmpty() || global ? null : clientId;
-         return ActiveMQDestination.createQueueNameForSubscription(durable, clientID, subscriptionName);
-      } else {
-         String queue = clientId == null || clientId.isEmpty() || global ? pubId : clientId + "." + pubId;
-         if (shared) {
-            if (queue.contains("|")) {
-               queue = queue.split("\\|")[0];
-            }
-            if (isVolatile) {
-               queue += ":shared-volatile";
-            }
-            if (global) {
-               queue += ":global";
-            }
+         if (isVolatile) {
+            queue += ":shared-volatile";
+         }
+         if (global) {
+            queue += ":global";
          }
-         return SimpleString.toSimpleString(queue);
-      }
-   }
-
-   /**
-    * Update link state to reflect that the previous drain attempt has completed.
-    */
-   public void reportDrained() {
-      connection.lock();
-      try {
-         sender.drained();
-      } finally {
-         connection.unlock();
       }
-
-      connection.flush();
+      return queue;
    }
 }