diff --git a/core/src/main/java/org/apache/accumulo/core/security/crypto/DefaultSecretKeyEncryptionStrategy.java b/core/src/main/java/org/apache/accumulo/core/security/crypto/DefaultSecretKeyEncryptionStrategy.java
index f0ece5064b..10690b59bd 100644
--- a/core/src/main/java/org/apache/accumulo/core/security/crypto/DefaultSecretKeyEncryptionStrategy.java
+++ b/core/src/main/java/org/apache/accumulo/core/security/crypto/DefaultSecretKeyEncryptionStrategy.java
@@ -17,16 +17,21 @@
 
 package org.apache.accumulo.core.security.crypto;
 
+import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.security.InvalidAlgorithmParameterException;
 import java.security.InvalidKeyException;
-import java.security.Key;
-import java.security.NoSuchAlgorithmException;
 import java.security.SecureRandom;
+import java.util.HashMap;
+import java.util.Map;
 
 import javax.crypto.Cipher;
-import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.CipherOutputStream;
+import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
 
 import org.apache.accumulo.core.conf.Property;
@@ -37,78 +42,231 @@ import org.apache.log4j.Logger;
 
 public class DefaultSecretKeyEncryptionStrategy implements SecretKeyEncryptionStrategy {
   
-  private static final Logger log = Logger.getLogger(DefaultSecretKeyEncryptionStrategy.class);
+  private static final Logger log = Logger.getLogger(DefaultSecretKeyEncryptionStrategy.class); 
+  
+  public static class DefaultSecretKeyEncryptionStrategyContext implements SecretKeyEncryptionStrategyContext {
+
+    private byte[] plaintextSecretKey;
+    private byte[] encryptedSecretKey;
+    private Map<String, String> context;
+    private String opaqueKeyId;
+    
+    @Override
+    public String getOpaqueKeyEncryptionKeyID() {
+      return opaqueKeyId;
+    }
+
+    @Override
+    public void setOpaqueKeyEncryptionKeyID(String id) {
+      this.opaqueKeyId = id;
+    }
+
+    @Override
+    public byte[] getPlaintextSecretKey() {
+      return plaintextSecretKey;
+    }
+
+    @Override
+    public void setPlaintextSecretKey(byte[] key) {
+      this.plaintextSecretKey = key;
+    }
+
+    @Override
+    public byte[] getEncryptedSecretKey() {
+      return encryptedSecretKey;
+    }
+
+    @Override
+    public void setEncryptedSecretKey(byte[] key) {
+      this.encryptedSecretKey = key;
+    }
+
+    @Override
+    public Map<String,String> getContext() {
+      return context;
+    }
+
+    @Override
+    public void setContext(Map<String,String> context) {
+      this.context = context;
+    }
+  }
+  
+  
+  @Override
+  public SecretKeyEncryptionStrategyContext encryptSecretKey(SecretKeyEncryptionStrategyContext context)  {
+    String hdfsURI = context.getContext().get(Property.CRYPTO_DEFAULT_KEY_STRATEGY_HDFS_URI.getKey());
+    String pathToKeyName = context.getContext().get(Property.CRYPTO_DEFAULT_KEY_STRATEGY_KEY_LOCATION.getKey());
+    Path pathToKey = new Path(pathToKeyName);
+    
+    FileSystem fs = getHadoopFileSystem(hdfsURI);
+    try {
+      
+      doKeyEncryptionOperation(Cipher.ENCRYPT_MODE, context, pathToKeyName, pathToKey, fs);
+      
+    } catch (IOException e) {
+      log.error(e);
+      throw new RuntimeException(e);
+    }
+  
+    return context;
+    
+  }
 
-  private void doKeyEncryptionOperation(int encryptionMode, CryptoModuleParameters params, String pathToKeyName, Path pathToKey, FileSystem fs)
+  private void initializeKeyEncryptingKey(FileSystem fs, Path pathToKey, SecretKeyEncryptionStrategyContext context) throws IOException {
+    Map<String, String> cryptoContext = context.getContext(); 
+    DataOutputStream out = fs.create(pathToKey);
+    // Very important, lets hedge our bets
+    fs.setReplication(pathToKey, (short) 5);
+    
+    // Write number of context entries
+    out.writeInt(cryptoContext.size());
+    
+    for (String key : cryptoContext.keySet()) {
+      out.writeUTF(key);
+      out.writeUTF(cryptoContext.get(key));
+    }
+    
+    SecureRandom random = DefaultCryptoModuleUtils.getSecureRandom(cryptoContext.get(Property.CRYPTO_SECURE_RNG.getKey()), cryptoContext.get(Property.CRYPTO_SECURE_RNG_PROVIDER.getKey()));
+    int keyLength = Integer.parseInt(cryptoContext.get(Property.CRYPTO_CIPHER_KEY_LENGTH.getKey()));
+    byte[] newRandomKeyEncryptionKey = new byte[keyLength / 8];
+    
+    random.nextBytes(newRandomKeyEncryptionKey);
+    
+    Cipher cipher = DefaultCryptoModuleUtils.getCipher(cryptoContext.get(Property.CRYPTO_CIPHER_SUITE.getKey()));
+    try {
+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(newRandomKeyEncryptionKey, cryptoContext.get(Property.CRYPTO_CIPHER_ALGORITHM_NAME.getKey())), random);
+    } catch (InvalidKeyException e) {
+      log.error(e);
+      throw new RuntimeException(e);
+    }
+    
+    byte[] initVector = cipher.getIV();
+    
+    out.writeInt(initVector.length);
+    out.write(initVector);
+    
+    out.writeInt(newRandomKeyEncryptionKey.length);
+    out.write(newRandomKeyEncryptionKey);
+    
+    out.flush();
+    out.close();
+    
+  }
+
+  private FileSystem getHadoopFileSystem(String hdfsURI) {
+    FileSystem fs = null;
+    
+    if (hdfsURI != null && !hdfsURI.equals("")) {
+      try {
+        fs = FileSystem.get(CachedConfiguration.getInstance());
+      } catch (IOException e) {
+        log.error(e);
+        throw new RuntimeException(e);
+      }
+    }
+    else {
+      try {
+        fs = FileSystem.get(new URI(hdfsURI), CachedConfiguration.getInstance());
+      } catch (URISyntaxException e) {
+        log.error(e);
+        throw new RuntimeException(e);
+      } catch (IOException e) {
+        log.error(e);
+        throw new RuntimeException(e);
+      }
+      
+      
+    }
+    return fs;
+  }
+  
+  @Override
+  public SecretKeyEncryptionStrategyContext decryptSecretKey(SecretKeyEncryptionStrategyContext context) {
+    String hdfsURI = context.getContext().get(Property.CRYPTO_DEFAULT_KEY_STRATEGY_HDFS_URI.getKey());
+    String pathToKeyName = context.getContext().get(Property.CRYPTO_DEFAULT_KEY_STRATEGY_KEY_LOCATION.getKey());
+    Path pathToKey = new Path(pathToKeyName);
+    
+    FileSystem fs = getHadoopFileSystem(hdfsURI);
+    try {
+      doKeyEncryptionOperation(Cipher.DECRYPT_MODE, context, pathToKeyName, pathToKey, fs);
+      
+      
+    } catch (IOException e) {
+      log.error(e);
+      throw new RuntimeException(e);
+    }
+    
+    return context;
+  }
+
+  private void doKeyEncryptionOperation(int encryptionMode, SecretKeyEncryptionStrategyContext context, String pathToKeyName, Path pathToKey, FileSystem fs)
       throws IOException {
     DataInputStream in = null;
     try {
       if (!fs.exists(pathToKey)) {
         
-        if (encryptionMode == Cipher.UNWRAP_MODE) {
+        if (encryptionMode == Cipher.DECRYPT_MODE) {
           log.error("There was a call to decrypt the session key but no key encryption key exists.  Either restore it, reconfigure the conf file to point to it in HDFS, or throw the affected data away and begin again.");
           throw new RuntimeException("Could not find key encryption key file in configured location in HDFS ("+pathToKeyName+")");
         } else {
-          DataOutputStream out = null;
-          try {
-            out = fs.create(pathToKey);
-            // Very important, lets hedge our bets
-            fs.setReplication(pathToKey, (short) 5);
-            SecureRandom random = DefaultCryptoModuleUtils.getSecureRandom(params.getRandomNumberGenerator(), params.getRandomNumberGeneratorProvider());
-            int keyLength = params.getKeyLength();
-            byte[] newRandomKeyEncryptionKey = new byte[keyLength / 8];
-            random.nextBytes(newRandomKeyEncryptionKey);
-            out.writeInt(newRandomKeyEncryptionKey.length);
-            out.write(newRandomKeyEncryptionKey);
-            out.flush();
-          } finally {
-            if (out != null) {
-              out.close();        
-            }
-          }
-
+          initializeKeyEncryptingKey(fs, pathToKey, context);
         }
       }
       in = fs.open(pathToKey);
-            
+      
+      int numOfOpts = in.readInt();
+      Map<String, String> optsFromFile = new HashMap<String, String>();
+      
+      for (int i = 0; i < numOfOpts; i++) {
+        String key = in.readUTF();
+        String value = in.readUTF();
+        
+        optsFromFile.put(key, value);
+      }
+      
+      int ivLength = in.readInt();
+      byte[] iv = new byte[ivLength];
+      in.read(iv);
+      
+      
       int keyEncryptionKeyLength = in.readInt();
       byte[] keyEncryptionKey = new byte[keyEncryptionKeyLength];
       in.read(keyEncryptionKey);
       
-      Cipher cipher = DefaultCryptoModuleUtils.getCipher(params.getAllOptions().get(Property.CRYPTO_DEFAULT_KEY_STRATEGY_CIPHER_SUITE.getKey()));
+      Cipher cipher = DefaultCryptoModuleUtils.getCipher(optsFromFile.get(Property.CRYPTO_CIPHER_SUITE.getKey()));
 
       try {
-        cipher.init(encryptionMode, new SecretKeySpec(keyEncryptionKey, params.getAlgorithmName()));
+        cipher.init(encryptionMode, new SecretKeySpec(keyEncryptionKey, optsFromFile.get(Property.CRYPTO_CIPHER_ALGORITHM_NAME.getKey())), new IvParameterSpec(iv));
       } catch (InvalidKeyException e) {
         log.error(e);
         throw new RuntimeException(e);
-      }      
+      } catch (InvalidAlgorithmParameterException e) {
+        log.error(e);
+        throw new RuntimeException(e);
+      }
+
+      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
+      CipherOutputStream cipherStream = new CipherOutputStream(byteArrayOutputStream, cipher);
       
-      if (Cipher.UNWRAP_MODE == encryptionMode) {
-        try {
-          Key plaintextKey = cipher.unwrap(params.getEncryptedKey(), params.getAlgorithmName(), Cipher.SECRET_KEY);
-          params.setPlaintextKey(plaintextKey.getEncoded());
-        } catch (InvalidKeyException e) {
-          log.error(e);
-          throw new RuntimeException(e);
-        } catch (NoSuchAlgorithmException e) {
-          log.error(e);
-          throw new RuntimeException(e);
-        }
+      
+      if (Cipher.DECRYPT_MODE == encryptionMode) {
+        cipherStream.write(context.getEncryptedSecretKey());
+        cipherStream.flush();        
+        byte[] plaintextSecretKey = byteArrayOutputStream.toByteArray();
+
+        cipherStream.close();
+        
+        context.setPlaintextSecretKey(plaintextSecretKey);
       } else {
-        Key plaintextKey = new SecretKeySpec(params.getPlaintextKey(), params.getAlgorithmName());
-        try {
-          byte[] encryptedSecretKey = cipher.wrap(plaintextKey);
-          params.setEncryptedKey(encryptedSecretKey);
-          params.setOpaqueKeyEncryptionKeyID(pathToKeyName);
-        } catch (InvalidKeyException e) {
-          log.error(e);
-          throw new RuntimeException(e);
-        } catch (IllegalBlockSizeException e) {
-          log.error(e);
-          throw new RuntimeException(e);
-        }
+        cipherStream.write(context.getPlaintextSecretKey());
+        cipherStream.flush();        
+        byte[] encryptedSecretKey = byteArrayOutputStream.toByteArray();
+
+        cipherStream.close();
         
+        context.setEncryptedSecretKey(encryptedSecretKey);
+        context.setOpaqueKeyEncryptionKeyID(pathToKeyName);
       }
       
     } finally {
@@ -118,71 +276,9 @@ public class DefaultSecretKeyEncryptionStrategy implements SecretKeyEncryptionSt
     }
   }
 
-
-  private String getFullPathToKey(CryptoModuleParameters params) {
-    String pathToKeyName = params.getAllOptions().get(Property.CRYPTO_DEFAULT_KEY_STRATEGY_KEY_LOCATION.getKey());
-    String instanceDirectory = params.getAllOptions().get(Property.INSTANCE_DFS_DIR.getKey());
-    
-    
-    if (pathToKeyName == null) {
-      pathToKeyName = Property.CRYPTO_DEFAULT_KEY_STRATEGY_KEY_LOCATION.getDefaultValue();
-    }
-    
-    if (instanceDirectory == null) {
-      instanceDirectory = Property.INSTANCE_DFS_DIR.getDefaultValue();
-    }
-    
-    if (!pathToKeyName.startsWith("/")) {
-      pathToKeyName = "/" + pathToKeyName;
-    }
-    
-    String fullPath = instanceDirectory + pathToKeyName;
-    return fullPath;
-  }
-  
   @Override
-  public CryptoModuleParameters encryptSecretKey(CryptoModuleParameters params) {
-    String hdfsURI = params.getAllOptions().get(Property.INSTANCE_DFS_URI.getKey());
-    if (hdfsURI == null) {
-      hdfsURI = Property.INSTANCE_DFS_URI.getDefaultValue();
-    }
-    
-    String fullPath = getFullPathToKey(params);
-    Path pathToKey = new Path(fullPath);
-    
-    try {
-      FileSystem fs = FileSystem.get(CachedConfiguration.getInstance());   
-      doKeyEncryptionOperation(Cipher.WRAP_MODE, params, fullPath, pathToKey, fs);
-      
-    } catch (IOException e) {
-      log.error(e);
-      throw new RuntimeException(e);
-    }
-    
-    return params;
-  }
-  
-  @Override
-  public CryptoModuleParameters decryptSecretKey(CryptoModuleParameters params) {
-    String hdfsURI = params.getAllOptions().get(Property.INSTANCE_DFS_URI.getKey());
-    if (hdfsURI == null) {
-      hdfsURI = Property.INSTANCE_DFS_URI.getDefaultValue(); 
-    }
-    
-    String pathToKeyName = getFullPathToKey(params);
-    Path pathToKey = new Path(pathToKeyName);
-    
-    try {
-      FileSystem fs = FileSystem.get(CachedConfiguration.getInstance());   
-      doKeyEncryptionOperation(Cipher.UNWRAP_MODE, params, pathToKeyName, pathToKey, fs);
-      
-      
-    } catch (IOException e) {
-      log.error(e);
-      throw new RuntimeException(e);
-    }
-        
-    return params;
+  public SecretKeyEncryptionStrategyContext getNewContext() {
+    return new DefaultSecretKeyEncryptionStrategyContext();
   }
   
 }