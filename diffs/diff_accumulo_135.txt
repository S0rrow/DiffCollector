diff --git a/server/src/main/java/org/apache/accumulo/server/util/Initialize.java b/server/src/main/java/org/apache/accumulo/server/util/Initialize.java
index 0293f7348c..afccd324b5 100644
--- a/server/src/main/java/org/apache/accumulo/server/util/Initialize.java
+++ b/server/src/main/java/org/apache/accumulo/server/util/Initialize.java
@@ -18,50 +18,41 @@ package org.apache.accumulo.server.util;
 
 import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Locale;
 import java.util.Map.Entry;
 import java.util.UUID;
 
-import jline.console.ConsoleReader;
+import jline.ConsoleReader;
 
 import org.apache.accumulo.core.Constants;
-import org.apache.accumulo.core.cli.Help;
 import org.apache.accumulo.core.client.AccumuloSecurityException;
-import org.apache.accumulo.core.client.impl.thrift.ThriftSecurityException;
 import org.apache.accumulo.core.conf.AccumuloConfiguration;
 import org.apache.accumulo.core.conf.Property;
-import org.apache.accumulo.core.conf.SiteConfiguration;
 import org.apache.accumulo.core.data.Key;
 import org.apache.accumulo.core.data.KeyExtent;
 import org.apache.accumulo.core.data.Value;
 import org.apache.accumulo.core.file.FileOperations;
 import org.apache.accumulo.core.file.FileSKVWriter;
+import org.apache.accumulo.core.file.FileUtil;
 import org.apache.accumulo.core.iterators.user.VersioningIterator;
 import org.apache.accumulo.core.master.state.tables.TableState;
 import org.apache.accumulo.core.master.thrift.MasterGoalState;
-import org.apache.accumulo.core.security.SecurityUtil;
 import org.apache.accumulo.core.util.CachedConfiguration;
-import org.apache.accumulo.core.util.MetadataTable;
-import org.apache.accumulo.core.util.RootTable;
 import org.apache.accumulo.core.zookeeper.ZooUtil;
-import org.apache.accumulo.fate.zookeeper.IZooReaderWriter;
-import org.apache.accumulo.fate.zookeeper.ZooUtil.NodeExistsPolicy;
-import org.apache.accumulo.fate.zookeeper.ZooUtil.NodeMissingPolicy;
+import org.apache.accumulo.core.zookeeper.ZooUtil.NodeExistsPolicy;
+import org.apache.accumulo.core.zookeeper.ZooUtil.NodeMissingPolicy;
 import org.apache.accumulo.server.ServerConstants;
 import org.apache.accumulo.server.client.HdfsZooInstance;
 import org.apache.accumulo.server.conf.ServerConfiguration;
 import org.apache.accumulo.server.constraints.MetadataConstraints;
-import org.apache.accumulo.server.fs.VolumeManager;
-import org.apache.accumulo.server.fs.VolumeManagerImpl;
 import org.apache.accumulo.server.iterators.MetadataBulkLoadFilter;
 import org.apache.accumulo.server.master.state.tables.TableManager;
-import org.apache.accumulo.server.security.AuditedSecurityOperation;
 import org.apache.accumulo.server.security.SecurityConstants;
+import org.apache.accumulo.server.security.SecurityUtil;
+import org.apache.accumulo.server.security.ZKAuthenticator;
 import org.apache.accumulo.server.tabletserver.TabletTime;
+import org.apache.accumulo.server.zookeeper.IZooReaderWriter;
 import org.apache.accumulo.server.zookeeper.ZooReaderWriter;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.FileStatus;
@@ -72,15 +63,14 @@ import org.apache.log4j.Logger;
 import org.apache.zookeeper.KeeperException;
 import org.apache.zookeeper.ZooDefs.Ids;
 
-import com.beust.jcommander.Parameter;
-
 /**
  * This class is used to setup the directory structure and the root tablet to get an instance started
  * 
  */
 public class Initialize {
   private static final Logger log = Logger.getLogger(Initialize.class);
-  private static final String DEFAULT_ROOT_USER = "root";
+  private static final String ROOT_USER = "root";
+  private static boolean clearInstanceName = false;
   
   private static ConsoleReader reader = null;
   
@@ -96,7 +86,7 @@ public class Initialize {
     initialMetadataConf.put(Property.TABLE_FILE_REPLICATION.getKey(), "5");
     initialMetadataConf.put(Property.TABLE_WALOG_ENABLED.getKey(), "true");
     initialMetadataConf.put(Property.TABLE_MAJC_RATIO.getKey(), "1");
-    initialMetadataConf.put(Property.TABLE_SPLIT_THRESHOLD.getKey(), "64M");
+    initialMetadataConf.put(Property.TABLE_SPLIT_THRESHOLD.getKey(), "4M");
     initialMetadataConf.put(Property.TABLE_CONSTRAINT_PREFIX.getKey() + "1", MetadataConstraints.class.getName());
     initialMetadataConf.put(Property.TABLE_ITERATOR_PREFIX.getKey() + "scan.vers", "10," + VersioningIterator.class.getName());
     initialMetadataConf.put(Property.TABLE_ITERATOR_PREFIX.getKey() + "scan.vers.opt.maxVersions", "1");
@@ -107,23 +97,23 @@ public class Initialize {
     initialMetadataConf.put(Property.TABLE_ITERATOR_PREFIX.getKey() + "majc.bulkLoadFilter", "20," + MetadataBulkLoadFilter.class.getName());
     initialMetadataConf.put(Property.TABLE_FAILURES_IGNORE.getKey(), "false");
     initialMetadataConf.put(Property.TABLE_LOCALITY_GROUP_PREFIX.getKey() + "tablet",
-        String.format("%s,%s", MetadataTable.TABLET_COLUMN_FAMILY.toString(), MetadataTable.CURRENT_LOCATION_COLUMN_FAMILY.toString()));
+        String.format("%s,%s", Constants.METADATA_TABLET_COLUMN_FAMILY.toString(), Constants.METADATA_CURRENT_LOCATION_COLUMN_FAMILY.toString()));
     initialMetadataConf.put(Property.TABLE_LOCALITY_GROUP_PREFIX.getKey() + "server", String.format("%s,%s,%s,%s",
-        MetadataTable.DATAFILE_COLUMN_FAMILY.toString(), MetadataTable.LOG_COLUMN_FAMILY.toString(), MetadataTable.SERVER_COLUMN_FAMILY.toString(),
-        MetadataTable.FUTURE_LOCATION_COLUMN_FAMILY.toString()));
+        Constants.METADATA_DATAFILE_COLUMN_FAMILY.toString(), Constants.METADATA_LOG_COLUMN_FAMILY.toString(),
+        Constants.METADATA_SERVER_COLUMN_FAMILY.toString(), Constants.METADATA_FUTURE_LOCATION_COLUMN_FAMILY.toString()));
     initialMetadataConf.put(Property.TABLE_LOCALITY_GROUPS.getKey(), "tablet,server");
     initialMetadataConf.put(Property.TABLE_DEFAULT_SCANTIME_VISIBILITY.getKey(), "");
     initialMetadataConf.put(Property.TABLE_INDEXCACHE_ENABLED.getKey(), "true");
     initialMetadataConf.put(Property.TABLE_BLOCKCACHE_ENABLED.getKey(), "true");
   }
   
-  public static boolean doInit(Opts opts, Configuration conf, VolumeManager fs) throws IOException {
+  public static boolean doInit(Configuration conf, FileSystem fs) throws IOException {
     if (!ServerConfiguration.getSiteConfiguration().get(Property.INSTANCE_DFS_URI).equals(""))
       log.info("Hadoop Filesystem is " + ServerConfiguration.getSiteConfiguration().get(Property.INSTANCE_DFS_URI));
     else
       log.info("Hadoop Filesystem is " + FileSystem.getDefaultUri(conf));
     
-    log.info("Accumulo data dirs are " + Arrays.asList(ServerConstants.getBaseDirs()));
+    log.info("Accumulo data dir is " + ServerConstants.getBaseDir());
     log.info("Zookeeper server is " + ServerConfiguration.getSiteConfiguration().get(Property.INSTANCE_ZK_HOST));
     log.info("Checking if Zookeeper is available. If this hangs, then you need to make sure zookeeper is running");
     if (!zookeeperAvailable()) {
@@ -133,14 +123,18 @@ public class Initialize {
     if (ServerConfiguration.getSiteConfiguration().get(Property.INSTANCE_SECRET).equals(Property.INSTANCE_SECRET.getDefaultValue())) {
       ConsoleReader c = getConsoleReader();
       c.beep();
-      c.println();
-      c.println();
-      c.println("Warning!!! Your instance secret is still set to the default, this is not secure. We highly recommend you change it.");
-      c.println();
-      c.println();
-      c.println("You can change the instance secret in accumulo by using:");
-      c.println("   bin/accumulo " + org.apache.accumulo.server.util.ChangeSecret.class.getName() + " oldPassword newPassword.");
-      c.println("You will also need to edit your secret in your configuration file by adding the property instance.secret to your conf/accumulo-site.xml. Without this accumulo will not operate correctly");
+      c.printNewline();
+      c.printNewline();
+      c.printString("Warning!!! Your instance secret is still set to the default, this is not secure. We highly recommend you change it.");
+      c.printNewline();
+      c.printNewline();
+      c.printNewline();
+      c.printString("You can change the instance secret in accumulo by using:");
+      c.printNewline();
+      c.printString("   bin/accumulo " + org.apache.accumulo.server.util.ChangeSecret.class.getName() + " oldPassword newPassword.");
+      c.printNewline();
+      c.printString("You will also need to edit your secret in your configuration file by adding the property instance.secret to your conf/accumulo-site.xml. Without this accumulo will not operate correctly");
+      c.printNewline();
     }
     
     try {
@@ -156,34 +150,34 @@ public class Initialize {
     // abort, we don't leave an inconsistent HDFS/ZooKeeper structure
     String instanceNamePath;
     try {
-      instanceNamePath = getInstanceNamePath(opts);
+      instanceNamePath = getInstanceNamePath();
     } catch (Exception e) {
       log.fatal("Failed to talk to zookeeper", e);
       return false;
     }
-    opts.rootpass = getRootPassword(opts);
-    return initialize(opts, instanceNamePath, fs);
+    byte[] rootpass = getRootPassword();
+    return initialize(instanceNamePath, fs, rootpass);
   }
   
-  public static boolean initialize(Opts opts, String instanceNamePath, VolumeManager fs) {
+  public static boolean initialize(String instanceNamePath, FileSystem fs, byte[] rootpass) {
     
     UUID uuid = UUID.randomUUID();
     try {
-      initZooKeeper(opts, uuid.toString(), instanceNamePath);
+      initZooKeeper(uuid.toString(), instanceNamePath);
     } catch (Exception e) {
       log.fatal("Failed to initialize zookeeper", e);
       return false;
     }
     
     try {
-      initFileSystem(opts, fs, uuid);
+      initFileSystem(fs, fs.getConf(), uuid);
     } catch (Exception e) {
       log.fatal("Failed to initialize filesystem", e);
       return false;
     }
     
     try {
-      initSecurity(opts, uuid.toString());
+      initSecurity(uuid.toString(), rootpass);
     } catch (Exception e) {
       log.fatal("Failed to initialize security", e);
       return false;
@@ -191,6 +185,9 @@ public class Initialize {
     return true;
   }
   
+  /**
+   * @return
+   */
   private static boolean zookeeperAvailable() {
     IZooReaderWriter zoo = ZooReaderWriter.getInstance();
     try {
@@ -201,37 +198,19 @@ public class Initialize {
       return false;
     }
   }
-  private static Path[] paths(String[] paths) {
-    Path result[] = new Path[paths.length];
-    for (int i = 0; i < paths.length; i++) {
-      result[i] = new Path(paths[i]);
-    }
-    return result;
-  }
-  
-  private static <T> T[] concat(T[] a, T[] b) {
-    List<T> result = new ArrayList<T>(a.length + b.length);
-    for (int i = 0; i < a.length; i++) {
-      result.add(a[i]);
-    }
-    for (int i = 0; i < b.length; i++) {
-      result.add(b[i]);
-    }
-    return result.toArray(a);
-  }
-  
-  private static void initFileSystem(Opts opts, VolumeManager fs, UUID uuid) throws IOException {
+
+  private static void initFileSystem(FileSystem fs, Configuration conf, UUID uuid) throws IOException {
     FileStatus fstat;
     
     // the actual disk location of the root tablet
     final Path rootTablet = new Path(ServerConstants.getRootTabletDir());
     
-    final Path tableMetadataTabletDirs[] = paths(ServerConstants.prefix(ServerConstants.getMetadataTableDirs(), MetadataTable.TABLE_TABLET_LOCATION));
-    final Path defaultMetadataTabletDirs[] = paths(ServerConstants.prefix(ServerConstants.getMetadataTableDirs(), Constants.DEFAULT_TABLET_LOCATION));
+    final Path tableMetadataTablet = new Path(ServerConstants.getMetadataTableDir() + Constants.TABLE_TABLET_LOCATION);
+    final Path defaultMetadataTablet = new Path(ServerConstants.getMetadataTableDir() + Constants.DEFAULT_TABLET_LOCATION);
     
-    final Path metadataTableDirs[] = paths(ServerConstants.getMetadataTableDirs());
-
-    fs.mkdirs(new Path(ServerConstants.getDataVersionLocation(), "" + ServerConstants.DATA_VERSION));
+    final Path metadataTableDir = new Path(ServerConstants.getMetadataTableDir());
+    
+    fs.mkdirs(new Path(ServerConstants.getDataVersionLocation(), "" + Constants.DATA_VERSION));
     
     // create an instance id
     fs.mkdirs(ServerConstants.getInstanceIdLocation());
@@ -241,18 +220,17 @@ public class Initialize {
     initMetadataConfig();
     
     // create metadata table
-    for (Path mtd : metadataTableDirs) {
-      try {
-        fstat = fs.getFileStatus(mtd);
-        if (!fstat.isDir()) {
-          log.fatal("location " + mtd.toString() + " exists but is not a directory");
-          return;
-        }
-      } catch (FileNotFoundException fnfe) {
-        if (!fs.mkdirs(mtd)) {
-          log.fatal("unable to create directory " + mtd.toString());
-          return;
-        }
+    try {
+      fstat = fs.getFileStatus(metadataTableDir);
+      if (!fstat.isDir()) {
+        log.fatal("location " + metadataTableDir.toString() + " exists but is not a directory");
+        return;
+      }
+    } catch (FileNotFoundException fnfe) {
+      // create btl dir
+      if (!fs.mkdirs(metadataTableDir)) {
+        log.fatal("unable to create directory " + metadataTableDir.toString());
+        return;
       }
     }
     
@@ -264,107 +242,105 @@ public class Initialize {
         return;
       }
     } catch (FileNotFoundException fnfe) {
+      // create btl dir
       if (!fs.mkdirs(rootTablet)) {
         log.fatal("unable to create directory " + rootTablet.toString());
         return;
       }
+      
+      // populate the root tablet with info about the default tablet
+      // the root tablet contains the key extent and locations of all the
+      // metadata tablets
+      String initRootTabFile = ServerConstants.getMetadataTableDir() + "/root_tablet/00000_00000."
+          + FileOperations.getNewFileExtension(AccumuloConfiguration.getDefaultConfiguration());
+      FileSKVWriter mfw = FileOperations.getInstance().openWriter(initRootTabFile, fs, conf, AccumuloConfiguration.getDefaultConfiguration());
+      mfw.startDefaultLocalityGroup();
+      
+      // -----------] root tablet info
+      Text rootExtent = Constants.ROOT_TABLET_EXTENT.getMetadataEntry();
+      
+      // root's directory
+      Key rootDirKey = new Key(rootExtent, Constants.METADATA_DIRECTORY_COLUMN.getColumnFamily(), Constants.METADATA_DIRECTORY_COLUMN.getColumnQualifier(), 0);
+      mfw.append(rootDirKey, new Value("/root_tablet".getBytes()));
+      
+      // root's prev row
+      Key rootPrevRowKey = new Key(rootExtent, Constants.METADATA_PREV_ROW_COLUMN.getColumnFamily(), Constants.METADATA_PREV_ROW_COLUMN.getColumnQualifier(), 0);
+      mfw.append(rootPrevRowKey, new Value(new byte[] {0}));
+      
+      // ----------] table tablet info
+      Text tableExtent = new Text(KeyExtent.getMetadataEntry(new Text(Constants.METADATA_TABLE_ID), Constants.METADATA_RESERVED_KEYSPACE_START_KEY.getRow()));
+      
+      // table tablet's directory
+      Key tableDirKey = new Key(tableExtent, Constants.METADATA_DIRECTORY_COLUMN.getColumnFamily(), Constants.METADATA_DIRECTORY_COLUMN.getColumnQualifier(), 0);
+      mfw.append(tableDirKey, new Value(Constants.TABLE_TABLET_LOCATION.getBytes()));
+      
+      // table tablet time
+      Key tableTimeKey = new Key(tableExtent, Constants.METADATA_TIME_COLUMN.getColumnFamily(), Constants.METADATA_TIME_COLUMN.getColumnQualifier(), 0);
+      mfw.append(tableTimeKey, new Value((TabletTime.LOGICAL_TIME_ID + "0").getBytes()));
+      
+      // table tablet's prevrow
+      Key tablePrevRowKey = new Key(tableExtent, Constants.METADATA_PREV_ROW_COLUMN.getColumnFamily(), Constants.METADATA_PREV_ROW_COLUMN.getColumnQualifier(),
+          0);
+      mfw.append(tablePrevRowKey, KeyExtent.encodePrevEndRow(new Text(KeyExtent.getMetadataEntry(new Text(Constants.METADATA_TABLE_ID), null))));
+      
+      // ----------] default tablet info
+      Text defaultExtent = new Text(KeyExtent.getMetadataEntry(new Text(Constants.METADATA_TABLE_ID), null));
+      
+      // default's directory
+      Key defaultDirKey = new Key(defaultExtent, Constants.METADATA_DIRECTORY_COLUMN.getColumnFamily(),
+          Constants.METADATA_DIRECTORY_COLUMN.getColumnQualifier(), 0);
+      mfw.append(defaultDirKey, new Value(Constants.DEFAULT_TABLET_LOCATION.getBytes()));
+      
+      // default's time
+      Key defaultTimeKey = new Key(defaultExtent, Constants.METADATA_TIME_COLUMN.getColumnFamily(), Constants.METADATA_TIME_COLUMN.getColumnQualifier(), 0);
+      mfw.append(defaultTimeKey, new Value((TabletTime.LOGICAL_TIME_ID + "0").getBytes()));
+      
+      // default's prevrow
+      Key defaultPrevRowKey = new Key(defaultExtent, Constants.METADATA_PREV_ROW_COLUMN.getColumnFamily(),
+          Constants.METADATA_PREV_ROW_COLUMN.getColumnQualifier(), 0);
+      mfw.append(defaultPrevRowKey, KeyExtent.encodePrevEndRow(Constants.METADATA_RESERVED_KEYSPACE_START_KEY.getRow()));
+      
+      mfw.close();
     }
     
-    // populate the root tablet with info about the default tablet
-    // the root tablet contains the key extent and locations of all the
-    // metadata tablets
-    String initRootTabFile = rootTablet + "/00000_00000."
-        + FileOperations.getNewFileExtension(AccumuloConfiguration.getDefaultConfiguration());
-    FileSystem ns = fs.getFileSystemByPath(new Path(initRootTabFile));
-    FileSKVWriter mfw = FileOperations.getInstance().openWriter(initRootTabFile, ns, ns.getConf(), AccumuloConfiguration.getDefaultConfiguration());
-    mfw.startDefaultLocalityGroup();
-    
-    // -----------] root tablet info
-    Text rootExtent = RootTable.ROOT_TABLET_EXTENT.getMetadataEntry();
-    
-    // root's directory
-    Key rootDirKey = new Key(rootExtent, MetadataTable.DIRECTORY_COLUMN.getColumnFamily(), MetadataTable.DIRECTORY_COLUMN.getColumnQualifier(), 0);
-    mfw.append(rootDirKey, new Value("/root_tablet".getBytes()));
-    
-    // root's prev row
-    Key rootPrevRowKey = new Key(rootExtent, MetadataTable.PREV_ROW_COLUMN.getColumnFamily(), MetadataTable.PREV_ROW_COLUMN.getColumnQualifier(), 0);
-    mfw.append(rootPrevRowKey, new Value(new byte[] {0}));
-    
-    // ----------] table tablet info
-    Text tableExtent = new Text(KeyExtent.getMetadataEntry(new Text(MetadataTable.ID), MetadataTable.RESERVED_KEYSPACE_START_KEY.getRow()));
-    
-    // table tablet's directory
-    Key tableDirKey = new Key(tableExtent, MetadataTable.DIRECTORY_COLUMN.getColumnFamily(), MetadataTable.DIRECTORY_COLUMN.getColumnQualifier(), 0);
-    mfw.append(tableDirKey, new Value(MetadataTable.TABLE_TABLET_LOCATION.getBytes()));
-    
-    // table tablet time
-    Key tableTimeKey = new Key(tableExtent, MetadataTable.TIME_COLUMN.getColumnFamily(), MetadataTable.TIME_COLUMN.getColumnQualifier(), 0);
-    mfw.append(tableTimeKey, new Value((TabletTime.LOGICAL_TIME_ID + "0").getBytes()));
-    
-    // table tablet's prevrow
-    Key tablePrevRowKey = new Key(tableExtent, MetadataTable.PREV_ROW_COLUMN.getColumnFamily(), MetadataTable.PREV_ROW_COLUMN.getColumnQualifier(),
-        0);
-    mfw.append(tablePrevRowKey, KeyExtent.encodePrevEndRow(new Text(KeyExtent.getMetadataEntry(new Text(MetadataTable.ID), null))));
-    
-    // ----------] default tablet info
-    Text defaultExtent = new Text(KeyExtent.getMetadataEntry(new Text(MetadataTable.ID), null));
-    
-    // default's directory
-    Key defaultDirKey = new Key(defaultExtent, MetadataTable.DIRECTORY_COLUMN.getColumnFamily(),
-        MetadataTable.DIRECTORY_COLUMN.getColumnQualifier(), 0);
-    mfw.append(defaultDirKey, new Value(Constants.DEFAULT_TABLET_LOCATION.getBytes()));
-    
-    // default's time
-    Key defaultTimeKey = new Key(defaultExtent, MetadataTable.TIME_COLUMN.getColumnFamily(), MetadataTable.TIME_COLUMN.getColumnQualifier(), 0);
-    mfw.append(defaultTimeKey, new Value((TabletTime.LOGICAL_TIME_ID + "0").getBytes()));
-    
-    // default's prevrow
-    Key defaultPrevRowKey = new Key(defaultExtent, MetadataTable.PREV_ROW_COLUMN.getColumnFamily(),
-        MetadataTable.PREV_ROW_COLUMN.getColumnQualifier(), 0);
-    mfw.append(defaultPrevRowKey, KeyExtent.encodePrevEndRow(MetadataTable.RESERVED_KEYSPACE_START_KEY.getRow()));
-    
-    mfw.close();
-    
     // create table and default tablets directories
-    for (Path dir : concat(defaultMetadataTabletDirs, tableMetadataTabletDirs)) {
+    try {
+      fstat = fs.getFileStatus(defaultMetadataTablet);
+      if (!fstat.isDir()) {
+        log.fatal("location " + defaultMetadataTablet.toString() + " exists but is not a directory");
+        return;
+      }
+    } catch (FileNotFoundException fnfe) {
       try {
-        fstat = fs.getFileStatus(dir);
+        fstat = fs.getFileStatus(tableMetadataTablet);
         if (!fstat.isDir()) {
-          log.fatal("location " + dir.toString() + " exists but is not a directory");
+          log.fatal("location " + tableMetadataTablet.toString() + " exists but is not a directory");
           return;
         }
-      } catch (FileNotFoundException fnfe) {
-        try {
-          fstat = fs.getFileStatus(dir);
-          if (!fstat.isDir()) {
-            log.fatal("location " + dir.toString() + " exists but is not a directory");
-            return;
-          }
-        } catch (FileNotFoundException fnfe2) {
-          // create table info dir
-          if (!fs.mkdirs(dir)) {
-            log.fatal("unable to create directory " + dir.toString());
-            return;
-          }
-        }
-        
-        // create default dir
-        if (!fs.mkdirs(dir)) {
-          log.fatal("unable to create directory " + dir.toString());
+      } catch (FileNotFoundException fnfe2) {
+        // create table info dir
+        if (!fs.mkdirs(tableMetadataTablet)) {
+          log.fatal("unable to create directory " + tableMetadataTablet.toString());
           return;
         }
       }
+      
+      // create default dir
+      if (!fs.mkdirs(defaultMetadataTablet)) {
+        log.fatal("unable to create directory " + defaultMetadataTablet.toString());
+        return;
+      }
     }
   }
   
-  private static void initZooKeeper(Opts opts, String uuid, String instanceNamePath) throws KeeperException, InterruptedException {
+  private static void initZooKeeper(String uuid, String instanceNamePath) throws KeeperException, InterruptedException {
     // setup basic data in zookeeper
     IZooReaderWriter zoo = ZooReaderWriter.getInstance();
     ZooUtil.putPersistentData(zoo.getZooKeeper(), Constants.ZROOT, new byte[0], -1, NodeExistsPolicy.SKIP, Ids.OPEN_ACL_UNSAFE);
     ZooUtil.putPersistentData(zoo.getZooKeeper(), Constants.ZROOT + Constants.ZINSTANCES, new byte[0], -1, NodeExistsPolicy.SKIP, Ids.OPEN_ACL_UNSAFE);
     
     // setup instance name
-    if (opts.clearInstanceName)
+    if (clearInstanceName)
       zoo.recursiveDelete(instanceNamePath, NodeMissingPolicy.SKIP);
     zoo.putPersistentData(instanceNamePath, uuid.getBytes(), NodeExistsPolicy.FAIL);
     
@@ -372,11 +348,12 @@ public class Initialize {
     String zkInstanceRoot = Constants.ZROOT + "/" + uuid;
     zoo.putPersistentData(zkInstanceRoot, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZTABLES, Constants.ZTABLES_INITIAL_ID, NodeExistsPolicy.FAIL);
-    TableManager.prepareNewTableState(uuid, MetadataTable.ID, MetadataTable.NAME, TableState.ONLINE, NodeExistsPolicy.FAIL);
+    TableManager.prepareNewTableState(uuid, Constants.METADATA_TABLE_ID, Constants.METADATA_TABLE_NAME, TableState.ONLINE, NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZTSERVERS, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZPROBLEMS, new byte[0], NodeExistsPolicy.FAIL);
-    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET, new byte[0], NodeExistsPolicy.FAIL);
-    zoo.putPersistentData(zkInstanceRoot + RootTable.ZROOT_TABLET_WALOGS, new byte[0], NodeExistsPolicy.FAIL);
+    zoo.putPersistentData(zkInstanceRoot + Constants.ZROOT_TABLET, new byte[0], NodeExistsPolicy.FAIL);
+    zoo.putPersistentData(zkInstanceRoot + Constants.ZROOT_TABLET_WALOGS, new byte[0], NodeExistsPolicy.FAIL);
+    zoo.putPersistentData(zkInstanceRoot + Constants.ZLOGGERS, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZTRACERS, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTERS, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZMASTER_LOCK, new byte[0], NodeExistsPolicy.FAIL);
@@ -387,34 +364,29 @@ public class Initialize {
     zoo.putPersistentData(zkInstanceRoot + Constants.ZTABLE_LOCKS, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZHDFS_RESERVATIONS, new byte[0], NodeExistsPolicy.FAIL);
     zoo.putPersistentData(zkInstanceRoot + Constants.ZNEXT_FILE, new byte[] {'0'}, NodeExistsPolicy.FAIL);
-    zoo.putPersistentData(zkInstanceRoot + Constants.ZRECOVERY, new byte[] {'0'}, NodeExistsPolicy.FAIL);
   }
   
-  private static String getInstanceNamePath(Opts opts) throws IOException, KeeperException, InterruptedException {
+  private static String getInstanceNamePath() throws IOException, KeeperException, InterruptedException {
     // setup the instance name
     String instanceName, instanceNamePath = null;
     boolean exists = true;
     do {
-      if (opts.cliInstanceName == null) {
-        instanceName = getConsoleReader().readLine("Instance name : ");
-      } else {
-        instanceName = opts.cliInstanceName;
-      }
+      instanceName = getConsoleReader().readLine("Instance name : ");
       if (instanceName == null)
         System.exit(0);
       instanceName = instanceName.trim();
       if (instanceName.length() == 0)
         continue;
       instanceNamePath = Constants.ZROOT + Constants.ZINSTANCES + "/" + instanceName;
-      if (opts.clearInstanceName) {
+      if (clearInstanceName) {
         exists = false;
         break;
-      } else if (exists = ZooReaderWriter.getInstance().exists(instanceNamePath)) {
+      } else if ((boolean) (exists = ZooReaderWriter.getInstance().exists(instanceNamePath))) {
         String decision = getConsoleReader().readLine("Instance name \"" + instanceName + "\" exists. Delete existing entry from zookeeper? [Y/N] : ");
         if (decision == null)
           System.exit(0);
         if (decision.length() == 1 && decision.toLowerCase(Locale.ENGLISH).charAt(0) == 'y') {
-          opts.clearInstanceName = true;
+          clearInstanceName = true;
           exists = false;
         }
       }
@@ -422,18 +394,14 @@ public class Initialize {
     return instanceNamePath;
   }
   
-  private static byte[] getRootPassword(Opts opts) throws IOException {
-    if (opts.cliPassword != null) {
-      return opts.cliPassword.getBytes();
-    }
+  private static byte[] getRootPassword() throws IOException {
     String rootpass;
     String confirmpass;
     do {
-      rootpass = getConsoleReader()
-          .readLine("Enter initial password for " + DEFAULT_ROOT_USER + " (this may not be applicable for your security setup): ", '*');
+      rootpass = getConsoleReader().readLine("Enter initial password for " + ROOT_USER + ": ", '*');
       if (rootpass == null)
         System.exit(0);
-      confirmpass = getConsoleReader().readLine("Confirm initial password for " + DEFAULT_ROOT_USER + ": ", '*');
+      confirmpass = getConsoleReader().readLine("Confirm initial password for " + ROOT_USER + ": ", '*');
       if (confirmpass == null)
         System.exit(0);
       if (!rootpass.equals(confirmpass))
@@ -442,22 +410,14 @@ public class Initialize {
     return rootpass.getBytes();
   }
   
-  private static void initSecurity(Opts opts, String iid) throws AccumuloSecurityException, ThriftSecurityException {
-    AuditedSecurityOperation.getInstance(iid, true).initializeSecurity(SecurityConstants.getSystemCredentials(), DEFAULT_ROOT_USER, opts.rootpass);
+  private static void initSecurity(String iid, byte[] rootpass) throws AccumuloSecurityException {
+    new ZKAuthenticator(iid).initializeSecurity(SecurityConstants.getSystemCredentials(), ROOT_USER, rootpass);
   }
   
   protected static void initMetadataConfig() throws IOException {
     try {
-      Configuration conf = CachedConfiguration.getInstance();
-      int max = conf.getInt("dfs.replication.max", 512);
-      // Hadoop 0.23 switched the min value configuration name
-      int min = Math.max(conf.getInt("dfs.replication.min", 1), conf.getInt("dfs.namenode.replication.min", 1));
-      if (max < 5)
-        setMetadataReplication(max, "max");
-      if (min > 5)
-        setMetadataReplication(min, "min");
       for (Entry<String,String> entry : initialMetadataConf.entrySet())
-        if (!TablePropUtil.setTableProperty(MetadataTable.ID, entry.getKey(), entry.getValue()))
+        if (!TablePropUtil.setTableProperty(Constants.METADATA_TABLE_ID, entry.getKey(), entry.getValue()))
           throw new IOException("Cannot create per-table property " + entry.getKey());
     } catch (Exception e) {
       log.fatal("error talking to zookeeper", e);
@@ -465,56 +425,37 @@ public class Initialize {
     }
   }
   
-  private static void setMetadataReplication(int replication, String reason) throws IOException {
-    String rep = getConsoleReader().readLine(
-        "Your HDFS replication " + reason + " is not compatible with our default " + MetadataTable.NAME + " replication of 5. What do you want to set your "
-            + MetadataTable.NAME + " replication to? (" + replication + ") ");
-    if (rep == null || rep.length() == 0)
-      rep = Integer.toString(replication);
-    else
-      // Lets make sure it's a number
-      Integer.parseInt(rep);
-    initialMetadataConf.put(Property.TABLE_FILE_REPLICATION.getKey(), rep);
-  }
-  
-  public static boolean isInitialized(VolumeManager fs) throws IOException {
+  public static boolean isInitialized(FileSystem fs) throws IOException {
     return (fs.exists(ServerConstants.getInstanceIdLocation()) || fs.exists(ServerConstants.getDataVersionLocation()));
   }
   
-  static class Opts extends Help {
-    @Parameter(names = "--reset-security", description = "just update the security information")
-    boolean resetSecurity = false;
-    @Parameter(names = "--clear-instance-name", description = "delete any existing instance name without prompting")
-    boolean clearInstanceName = false;
-    @Parameter(names = "--instance-name", description = "the instance name, if not provided, will prompt")
-    String cliInstanceName;
-    @Parameter(names = "--password", description = "set the password on the command line")
-    String cliPassword;
-    @Parameter(names = "--username", description = "set the root username on the command line")
-    String cliUser;
-    
-    byte[] rootpass = null;
-  }
-  
   public static void main(String[] args) {
-    Opts opts = new Opts();
-    opts.parseArgs(Initialize.class.getName(), args);
+    boolean justSecurity = false;
+    
+    for (String arg : args) {
+      if (arg.equals("--reset-security")) {
+        justSecurity = true;
+      } else if (arg.equals("--clear-instance-name")) {
+        clearInstanceName = true;
+      } else {
+        RuntimeException e = new RuntimeException();
+        log.fatal("Bad argument " + arg, e);
+        throw e;
+      }
+    }
     
     try {
       SecurityUtil.serverLogin();
       Configuration conf = CachedConfiguration.getInstance();
       
-      @SuppressWarnings("deprecation")
-      VolumeManager fs = VolumeManagerImpl.get(SiteConfiguration.getSiteConfiguration());
-      
-      if (opts.resetSecurity) {
-        if (isInitialized(fs)) {
-          opts.rootpass = getRootPassword(opts);
-          initSecurity(opts, HdfsZooInstance.getInstance().getInstanceID());
-        } else {
+      FileSystem fs = FileUtil.getFileSystem(conf, ServerConfiguration.getSiteConfiguration());
+
+      if (justSecurity) {
+        if (isInitialized(fs))
+          initSecurity(HdfsZooInstance.getInstance().getInstanceID(), getRootPassword());
+        else
           log.fatal("Attempted to reset security on accumulo before it was initialized");
-        }
-      } else if (!doInit(opts, conf, fs))
+      } else if (!doInit(conf, fs))
         System.exit(-1);
     } catch (Exception e) {
       log.fatal(e, e);