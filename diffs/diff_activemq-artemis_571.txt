diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/proton/plug/ProtonSessionIntegrationCallback.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/proton/plug/ProtonSessionIntegrationCallback.java
index ab57fe170c..9e60be4585 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/proton/plug/ProtonSessionIntegrationCallback.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/proton/plug/ProtonSessionIntegrationCallback.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -16,41 +16,32 @@
  */
 package org.apache.activemq.artemis.core.protocol.proton.plug;
 
+
 import java.util.concurrent.Executor;
-import java.util.concurrent.atomic.AtomicBoolean;
 
 import io.netty.buffer.ByteBuf;
+import org.apache.qpid.proton.amqp.Binary;
+import org.apache.qpid.proton.amqp.transport.AmqpError;
+import org.apache.qpid.proton.amqp.transport.ErrorCondition;
+import org.apache.qpid.proton.engine.Delivery;
+import org.apache.qpid.proton.engine.Link;
+import org.apache.qpid.proton.engine.Receiver;
+import org.apache.qpid.proton.jms.EncodedMessage;
+import org.apache.qpid.proton.message.ProtonJMessage;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.api.core.client.ActiveMQClient;
-import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.paging.PagingStore;
+import org.apache.activemq.artemis.core.journal.IOAsyncTask;
 import org.apache.activemq.artemis.core.protocol.proton.ProtonProtocolManager;
-import org.apache.activemq.artemis.core.protocol.proton.converter.message.EncodedMessage;
-import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
 import org.apache.activemq.artemis.core.server.ServerConsumer;
 import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
-import org.apache.activemq.artemis.core.server.impl.ServerConsumerImpl;
-import org.apache.activemq.artemis.core.settings.impl.AddressFullMessagePolicy;
-import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.spi.core.protocol.SessionCallback;
-import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
 import org.apache.activemq.artemis.utils.ByteUtil;
 import org.apache.activemq.artemis.utils.IDGenerator;
-import org.apache.activemq.artemis.utils.SelectorTranslator;
 import org.apache.activemq.artemis.utils.SimpleIDGenerator;
 import org.apache.activemq.artemis.utils.UUIDGenerator;
-import org.apache.qpid.proton.amqp.Binary;
-import org.apache.qpid.proton.amqp.messaging.Accepted;
-import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transport.AmqpError;
-import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.engine.Delivery;
-import org.apache.qpid.proton.engine.Link;
-import org.apache.qpid.proton.engine.Receiver;
-import org.apache.qpid.proton.message.ProtonJMessage;
 import org.proton.plug.AMQPConnectionContext;
 import org.proton.plug.AMQPSessionCallback;
 import org.proton.plug.AMQPSessionContext;
@@ -58,8 +49,8 @@ import org.proton.plug.SASLResult;
 import org.proton.plug.context.ProtonPlugSender;
 import org.proton.plug.sasl.PlainSASLResult;
 
-public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, SessionCallback {
-
+public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, SessionCallback
+{
    protected final IDGenerator consumerIDGenerator = new SimpleIDGenerator(0);
 
    private final ActiveMQProtonConnectionCallback protonSPI;
@@ -68,65 +59,27 @@ public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, Se
 
    private final AMQPConnectionContext connection;
 
-   private final Connection transportConnection;
-
    private ServerSession serverSession;
 
    private AMQPSessionContext protonSession;
 
-   private final Executor closeExecutor;
-
-   private final AtomicBoolean draining = new AtomicBoolean(false);
-
-   public ProtonSessionIntegrationCallback(ActiveMQProtonConnectionCallback protonSPI,
-                                           ProtonProtocolManager manager,
-                                           AMQPConnectionContext connection,
-                                           Connection transportConnection,
-                                           Executor executor) {
+   public ProtonSessionIntegrationCallback(ActiveMQProtonConnectionCallback protonSPI, ProtonProtocolManager manager, AMQPConnectionContext connection)
+   {
       this.protonSPI = protonSPI;
       this.manager = manager;
       this.connection = connection;
-      this.transportConnection = transportConnection;
-      this.closeExecutor = executor;
-   }
-
-   @Override
-   public boolean isWritable(ReadyListener callback) {
-      return transportConnection.isWritable(callback);
    }
 
    @Override
-   public void onFlowConsumer(Object consumer, int credits, final boolean drain) {
-      ServerConsumerImpl serverConsumer = (ServerConsumerImpl) consumer;
-      if (drain) {
-         // If the draining is already running, then don't do anything
-         if (draining.compareAndSet(false, true)) {
-            final ProtonPlugSender plugSender = (ProtonPlugSender) serverConsumer.getProtocolContext();
-            serverConsumer.forceDelivery(1, new Runnable() {
-               @Override
-               public void run() {
-                  try {
-                     plugSender.getSender().drained();
-                  }
-                  finally {
-                     draining.set(false);
-                  }
-               }
-            });
-         }
-      }
-      else {
-         serverConsumer.receiveCredits(-1);
-      }
-   }
-
-   @Override
-   public void browserFinished(ServerConsumer consumer) {
-
+   public void onFlowConsumer(Object consumer, int credits)
+   {
+      // We have our own flow control on AMQP, so we set activemq's flow control to 0
+      ((ServerConsumer) consumer).receiveCredits(-1);
    }
 
    @Override
-   public void init(AMQPSessionContext protonSession, SASLResult saslResult) throws Exception {
+   public void init(AMQPSessionContext protonSession, SASLResult saslResult) throws Exception
+   {
 
       this.protonSession = protonSession;
 
@@ -134,41 +87,42 @@ public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, Se
 
       String user = null;
       String passcode = null;
-      if (saslResult != null) {
+      if (saslResult != null)
+      {
          user = saslResult.getUser();
-         if (saslResult instanceof PlainSASLResult) {
-            passcode = ((PlainSASLResult) saslResult).getPassword();
+         if (saslResult instanceof PlainSASLResult)
+         {
+            passcode = ((PlainSASLResult)saslResult).getPassword();
          }
       }
 
-      serverSession = manager.getServer().createSession(name, user, passcode, ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE, protonSPI.getProtonConnectionDelegate(), // RemotingConnection remotingConnection,
+      serverSession = manager.getServer().createSession(name,
+                                                        user,
+                                                        passcode,
+                                                        ActiveMQClient.DEFAULT_MIN_LARGE_MESSAGE_SIZE,
+                                                        protonSPI.getProtonConnectionDelegate(), // RemotingConnection remotingConnection,
                                                         false, // boolean autoCommitSends
                                                         false, // boolean autoCommitAcks,
                                                         false, // boolean preAcknowledge,
                                                         true, //boolean xa,
-                                                        (String) null, this, true);
+                                                        (String) null,
+                                                        this,
+                                                        null,
+                                                        true);
    }
 
    @Override
-   public void afterDelivery() throws Exception {
+   public void start()
+   {
 
    }
 
    @Override
-   public void start() {
-
-   }
-
-   @Override
-   public Object createSender(ProtonPlugSender protonSender,
-                              String queue,
-                              String filter,
-                              boolean browserOnly) throws Exception {
+   public Object createSender(ProtonPlugSender protonSender, String queue, String filer, boolean browserOnly) throws Exception
+   {
       long consumerID = consumerIDGenerator.generateID();
 
-      filter = SelectorTranslator.convertToActiveMQFilterString(filter);
-
-      ServerConsumer consumer = serverSession.createConsumer(consumerID, SimpleString.toSimpleString(queue), SimpleString.toSimpleString(filter), browserOnly);
+      ServerConsumer consumer = serverSession.createConsumer(consumerID, SimpleString.toSimpleString(queue), SimpleString.toSimpleString(filer), browserOnly);
 
       // AMQP handles its own flow control for when it's started
       consumer.setStarted(true);
@@ -179,42 +133,39 @@ public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, Se
    }
 
    @Override
-   public void startSender(Object brokerConsumer) throws Exception {
+   public void startSender(Object brokerConsumer) throws Exception
+   {
       ServerConsumer serverConsumer = (ServerConsumer) brokerConsumer;
       // flow control is done at proton
       serverConsumer.receiveCredits(-1);
    }
 
    @Override
-   public void createTemporaryQueue(String queueName) throws Exception {
+   public void createTemporaryQueue(String queueName) throws Exception
+   {
       serverSession.createQueue(SimpleString.toSimpleString(queueName), SimpleString.toSimpleString(queueName), null, true, false);
    }
 
    @Override
-   public void createTemporaryQueue(String address, String queueName) throws Exception {
-      serverSession.createQueue(SimpleString.toSimpleString(address), SimpleString.toSimpleString(queueName), null, false, true);
-   }
-
-   @Override
-   public void createDurableQueue(String address, String queueName) throws Exception {
-      serverSession.createQueue(SimpleString.toSimpleString(address), SimpleString.toSimpleString(queueName), null, false, true);
-   }
-
-   @Override
-   public boolean queueQuery(String queueName) throws Exception {
+   public boolean queueQuery(String queueName) throws Exception
+   {
       boolean queryResult = false;
 
       QueueQueryResult queueQuery = serverSession.executeQueueQuery(SimpleString.toSimpleString(queueName));
 
-      if (queueQuery.isExists()) {
+      if (queueQuery.isExists())
+      {
          queryResult = true;
       }
-      else {
-         if (queueQuery.isAutoCreateJmsQueues()) {
+      else
+      {
+         if (queueQuery.isAutoCreateJmsQueues())
+         {
             serverSession.createQueue(new SimpleString(queueName), new SimpleString(queueName), null, false, true);
             queryResult = true;
          }
-         else {
+         else
+         {
             queryResult = false;
          }
       }
@@ -223,233 +174,156 @@ public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, Se
    }
 
    @Override
-   public void closeSender(final Object brokerConsumer) throws Exception {
-      Runnable runnable = new Runnable() {
+   public void closeSender(final Object brokerConsumer) throws Exception
+   {
+      Runnable runnable = new Runnable()
+      {
          @Override
-         public void run() {
-            try {
+         public void run()
+         {
+            try
+            {
                ((ServerConsumer) brokerConsumer).close(false);
             }
-            catch (Exception e) {
+            catch (Exception e)
+            {
             }
          }
       };
 
+
       // Due to the nature of proton this could be happening within flushes from the queue-delivery (depending on how it happened on the protocol)
       // to avoid deadlocks the close has to be done outside of the main thread on an executor
       // otherwise you could get a deadlock
       Executor executor = protonSPI.getExeuctor();
 
-      if (executor != null) {
+      if (executor != null)
+      {
          executor.execute(runnable);
       }
-      else {
+      else
+      {
          runnable.run();
       }
    }
 
    @Override
-   public ProtonJMessage encodeMessage(Object message, int deliveryCount) throws Exception {
+   public ProtonJMessage encodeMessage(Object message, int deliveryCount) throws Exception
+   {
       return (ProtonJMessage) manager.getConverter().outbound((ServerMessage) message, deliveryCount);
    }
 
    @Override
-   public Binary getCurrentTXID() {
-      Transaction tx = serverSession.getCurrentTransaction();
-      if (tx == null) {
-         tx = serverSession.newTransaction();
-         serverSession.resetTX(tx);
-      }
-      return new Binary(ByteUtil.longToBytes(tx.getID()));
+   public Binary getCurrentTXID()
+   {
+      return new Binary(ByteUtil.longToBytes(serverSession.getCurrentTransaction().getID()));
    }
 
    @Override
-   public String tempQueueName() {
+   public String tempQueueName()
+   {
       return UUIDGenerator.getInstance().generateStringUUID();
    }
 
    @Override
-   public void commitCurrentTX() throws Exception {
-      recoverContext();
-      try {
-         serverSession.commit();
-      }
-      finally {
-         resetContext();
-      }
+   public void commitCurrentTX() throws Exception
+   {
+      serverSession.commit();
    }
 
    @Override
-   public void rollbackCurrentTX(boolean lastMessageDelivered) throws Exception {
-      //need to check here as this can be called if init fails
-      if (serverSession != null) {
-         recoverContext();
-         try {
-            serverSession.rollback(lastMessageDelivered);
-         }
-         finally {
-            resetContext();
-         }
-      }
+   public void rollbackCurrentTX() throws Exception
+   {
+      serverSession.rollback(false);
    }
 
    @Override
-   public void close() throws Exception {
-      //need to check here as this can be called if init fails
-      if (serverSession != null) {
-         recoverContext();
-         try {
-            serverSession.close(false);
-         }
-         finally {
-            resetContext();
-         }
-      }
+   public void close() throws Exception
+   {
+      serverSession.close(false);
    }
 
    @Override
-   public void ack(Object brokerConsumer, Object message) throws Exception {
-      recoverContext();
-      try {
-         ((ServerConsumer) brokerConsumer).individualAcknowledge(null, ((ServerMessage) message).getMessageID());
-      }
-      finally {
-         resetContext();
-      }
+   public void ack(Object brokerConsumer, Object message) throws Exception
+   {
+      ((ServerConsumer)brokerConsumer).individualAcknowledge(null, ((ServerMessage)message).getMessageID());
    }
 
    @Override
-   public void cancel(Object brokerConsumer, Object message, boolean updateCounts) throws Exception {
-      recoverContext();
-      try {
-         ((ServerConsumer) brokerConsumer).individualCancel(((ServerMessage) message).getMessageID(), updateCounts);
-      }
-      finally {
-         resetContext();
-      }
+   public void cancel(Object brokerConsumer, Object message, boolean updateCounts) throws Exception
+   {
+      ((ServerConsumer)brokerConsumer).individualCancel(((ServerMessage)message).getMessageID(), updateCounts);
    }
 
    @Override
-   public void resumeDelivery(Object consumer) {
+   public void resumeDelivery(Object consumer)
+   {
       ((ServerConsumer) consumer).receiveCredits(-1);
    }
 
    @Override
-   public void serverSend(final Receiver receiver,
-                          final Delivery delivery,
-                          String address,
-                          int messageFormat,
-                          ByteBuf messageEncoded) throws Exception {
+   public void serverSend(final Receiver receiver, final Delivery delivery, String address, int messageFormat, ByteBuf messageEncoded) throws Exception
+   {
       EncodedMessage encodedMessage = new EncodedMessage(messageFormat, messageEncoded.array(), messageEncoded.arrayOffset(), messageEncoded.writerIndex());
 
       ServerMessage message = manager.getConverter().inbound(encodedMessage);
       //use the address on the receiver if not null, if null let's hope it was set correctly on the message
-      if (address != null) {
+      if (address != null)
+      {
          message.setAddress(new SimpleString(address));
       }
 
-      recoverContext();
-
-      PagingStore store = manager.getServer().getPagingManager().getPageStore(message.getAddress());
-      if (store.isFull() && store.getAddressFullMessagePolicy() == AddressFullMessagePolicy.BLOCK) {
-         ErrorCondition ec = new ErrorCondition(AmqpError.RESOURCE_LIMIT_EXCEEDED, "Address is full: " + message.getAddress());
-         Rejected rejected = new Rejected();
-         rejected.setError(ec);
-         delivery.disposition(rejected);
-         connection.flush();
-      }
-      else {
-         serverSend(message, delivery, receiver);
-      }
-   }
-
-   private void serverSend(final ServerMessage message, final Delivery delivery, final Receiver receiver) throws Exception {
-      try {
-         serverSession.send(message, false);
-         // FIXME Potential race here...
-         manager.getServer().getStorageManager().afterCompleteOperations(new IOCallback() {
-            @Override
-            public void done() {
-               synchronized (connection.getLock()) {
-                  delivery.disposition(Accepted.getInstance());
-                  delivery.settle();
-                  connection.flush();
-               }
-            }
+      serverSession.send(message, false);
 
-            @Override
-            public void onError(int errorCode, String errorMessage) {
-               synchronized (connection.getLock()) {
-                  receiver.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, errorCode + ":" + errorMessage));
-                  connection.flush();
-               }
+      manager.getServer().getStorageManager().afterCompleteOperations(new IOAsyncTask()
+      {
+         @Override
+         public void done()
+         {
+            synchronized (connection.getLock())
+            {
+               delivery.settle();
+               connection.flush();
             }
-         });
-      }
-      finally {
-         resetContext();
-      }
-   }
-
-   @Override
-   public String getPubSubPrefix() {
-      return manager.getPubSubPrefix();
-   }
+         }
 
-   @Override
-   public void offerProducerCredit(final String address, final int credits, final int threshold, final Receiver receiver) {
-      try {
-         final PagingStore store = manager.getServer().getPagingManager().getPageStore(new SimpleString(address));
-         store.checkMemory(new Runnable() {
-            @Override
-            public void run() {
-               if (receiver.getRemoteCredit() < threshold) {
-                  receiver.flow(credits);
-               }
+         @Override
+         public void onError(int errorCode, String errorMessage)
+         {
+            synchronized (connection.getLock())
+            {
+               receiver.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, errorCode + ":" + errorMessage));
+               connection.flush();
             }
-         });
-      }
-      catch (Exception e) {
-         throw new RuntimeException(e);
-      }
-   }
-
-   @Override
-   public void deleteQueue(String address) throws Exception {
-      manager.getServer().destroyQueue(new SimpleString(address));
-   }
-
-   private void resetContext() {
-      manager.getServer().getStorageManager().setContext(null);
+         }
+      });
    }
 
-   private void recoverContext() {
-      manager.getServer().getStorageManager().setContext(serverSession.getSessionContext());
-   }
 
    @Override
-   public void sendProducerCreditsMessage(int credits, SimpleString address) {
+   public void sendProducerCreditsMessage(int credits, SimpleString address)
+   {
    }
 
    @Override
-   public boolean updateDeliveryCountAfterCancel(ServerConsumer consumer, MessageReference ref, boolean failed) {
-      return false;
+   public void sendProducerCreditsFailMessage(int credits, SimpleString address)
+   {
    }
 
    @Override
-   public void sendProducerCreditsFailMessage(int credits, SimpleString address) {
-   }
-
-   @Override
-   public int sendMessage(MessageReference ref, ServerMessage message, ServerConsumer consumer, int deliveryCount) {
+   public int sendMessage(ServerMessage message, ServerConsumer consumer, int deliveryCount)
+   {
 
       ProtonPlugSender plugSender = (ProtonPlugSender) consumer.getProtocolContext();
 
-      try {
+      try
+      {
          return plugSender.deliverMessage(message, deliveryCount);
       }
-      catch (Exception e) {
-         synchronized (connection.getLock()) {
+      catch (Exception e)
+      {
+         synchronized (connection.getLock())
+         {
             plugSender.getSender().setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, e.getMessage()));
             connection.flush();
          }
@@ -459,40 +333,59 @@ public class ProtonSessionIntegrationCallback implements AMQPSessionCallback, Se
    }
 
    @Override
-   public int sendLargeMessage(MessageReference ref, ServerMessage message, ServerConsumer consumer, long bodySize, int deliveryCount) {
+   public int sendLargeMessage(ServerMessage message, ServerConsumer consumer, long bodySize, int deliveryCount)
+   {
       return 0;
    }
 
    @Override
-   public int sendLargeMessageContinuation(ServerConsumer consumer,
-                                           byte[] body,
-                                           boolean continues,
-                                           boolean requiresResponse) {
+   public int sendLargeMessageContinuation(ServerConsumer consumer, byte[] body, boolean continues, boolean requiresResponse)
+   {
       return 0;
    }
 
    @Override
-   public void closed() {
+   public void closed()
+   {
+   }
+
+   @Override
+   public void addReadyListener(ReadyListener listener)
+   {
+
    }
 
    @Override
-   public void disconnect(ServerConsumer consumer, String queueName) {
-      synchronized (connection.getLock()) {
+   public void removeReadyListener(ReadyListener listener)
+   {
+
+   }
+
+   @Override
+   public void disconnect(ServerConsumer consumer, String queueName)
+   {
+      synchronized (connection.getLock())
+      {
          ((Link) consumer.getProtocolContext()).close();
          connection.flush();
       }
    }
 
+
    @Override
-   public boolean hasCredits(ServerConsumer consumer) {
+   public boolean hasCredits(ServerConsumer consumer)
+   {
       ProtonPlugSender plugSender = (ProtonPlugSender) consumer.getProtocolContext();
 
-      if (plugSender != null && plugSender.getSender().getCredit() > 0) {
+      if (plugSender != null && plugSender.getSender().getCredit() > 0)
+      {
          return true;
       }
-      else {
+      else
+      {
          return false;
       }
    }
 
+
 }