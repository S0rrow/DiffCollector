diff --git a/asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/AbstractNumericArithmeticEval.java b/asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/AbstractNumericArithmeticEval.java
index b06c13ad23..0dbda8e7f1 100644
--- a/asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/AbstractNumericArithmeticEval.java
+++ b/asterixdb/asterix-runtime/src/main/java/org/apache/asterix/runtime/evaluators/functions/AbstractNumericArithmeticEval.java
@@ -32,7 +32,7 @@ import org.apache.asterix.dataflow.data.nontagged.serde.AInt64SerializerDeserial
 import org.apache.asterix.dataflow.data.nontagged.serde.AInt8SerializerDeserializer;
 import org.apache.asterix.dataflow.data.nontagged.serde.ATimeSerializerDeserializer;
 import org.apache.asterix.dataflow.data.nontagged.serde.AYearMonthDurationSerializerDeserializer;
-import org.apache.asterix.formats.nontagged.SerializerDeserializerProvider;
+import org.apache.asterix.formats.nontagged.AqlSerializerDeserializerProvider;
 import org.apache.asterix.om.base.AMutableDate;
 import org.apache.asterix.om.base.AMutableDateTime;
 import org.apache.asterix.om.base.AMutableDouble;
@@ -53,6 +53,7 @@ import org.apache.asterix.runtime.exceptions.OverflowException;
 import org.apache.asterix.runtime.exceptions.TypeMismatchException;
 import org.apache.asterix.runtime.exceptions.UnderflowException;
 import org.apache.asterix.runtime.exceptions.UnsupportedTypeException;
+import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;
 import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluator;
 import org.apache.hyracks.algebricks.runtime.base.IScalarEvaluatorFactory;
 import org.apache.hyracks.api.context.IHyracksTaskContext;
@@ -94,7 +95,8 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
     abstract protected long evaluateTimeInstanceArithmetic(long chronon0, long chronon1) throws HyracksDataException;
 
     @Override
-    public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args) {
+    public IScalarEvaluatorFactory createEvaluatorFactory(final IScalarEvaluatorFactory[] args)
+            throws AlgebricksException {
         return new IScalarEvaluatorFactory() {
             private static final long serialVersionUID = 1L;
 
@@ -102,102 +104,80 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
             public IScalarEvaluator createScalarEvaluator(IHyracksTaskContext ctx) throws HyracksDataException {
 
                 return new IScalarEvaluator() {
-                    private final ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage();
-                    private final DataOutput out = resultStorage.getDataOutput();
-                    private final IPointable argPtr0 = new VoidPointable();
-                    private final IPointable argPtr1 = new VoidPointable();
-                    private final IScalarEvaluator evalLeft = args[0].createScalarEvaluator(ctx);
-                    private final IScalarEvaluator evalRight = args[1].createScalarEvaluator(ctx);
-                    private final double[] operandsFloating = new double[args.length];
-                    private final long[] operandsInteger = new long[args.length];
-
-                    private final AMutableFloat aFloat = new AMutableFloat(0);
-                    private final AMutableDouble aDouble = new AMutableDouble(0);
-                    private final AMutableInt64 aInt64 = new AMutableInt64(0);
-                    private final AMutableInt32 aInt32 = new AMutableInt32(0);
-                    private final AMutableInt16 aInt16 = new AMutableInt16((short) 0);
-                    private final AMutableInt8 aInt8 = new AMutableInt8((byte) 0);
-
-                    private final AMutableDuration aDuration = new AMutableDuration(0, 0);
-                    private final AMutableDate aDate = new AMutableDate(0);
-                    private final AMutableTime aTime = new AMutableTime(0);
-                    private final AMutableDateTime aDatetime = new AMutableDateTime(0);
-
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer int8Serde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT8);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer int16Serde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT16);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer int32Serde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT32);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer int64Serde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AINT64);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer floatSerde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.AFLOAT);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer doubleSerde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADOUBLE);
+                    private ArrayBackedValueStorage resultStorage = new ArrayBackedValueStorage();
+                    private DataOutput out = resultStorage.getDataOutput();
+                    private IPointable argPtr0 = new VoidPointable();
+                    private IPointable argPtr1 = new VoidPointable();
+                    private IScalarEvaluator evalLeft = args[0].createScalarEvaluator(ctx);
+                    private IScalarEvaluator evalRight = args[1].createScalarEvaluator(ctx);
+                    private double[] operandsFloating = new double[args.length];
+                    private long[] operandsInteger = new long[args.length];
+                    private int resultType;
+                    static protected final int typeInt8 = 1;
+                    static protected final int typeInt16 = 2;
+                    static protected final int typeInt32 = 3;
+                    static protected final int typeInt64 = 4;
+                    static protected final int typeFloat = 5;
+                    static protected final int typeDouble = 6;
+
+                    protected AMutableFloat aFloat = new AMutableFloat(0);
+                    protected AMutableDouble aDouble = new AMutableDouble(0);
+                    protected AMutableInt64 aInt64 = new AMutableInt64(0);
+                    protected AMutableInt32 aInt32 = new AMutableInt32(0);
+                    protected AMutableInt16 aInt16 = new AMutableInt16((short) 0);
+                    protected AMutableInt8 aInt8 = new AMutableInt8((byte) 0);
+
+                    protected AMutableDuration aDuration = new AMutableDuration(0, 0);
+                    protected AMutableDate aDate = new AMutableDate(0);
+                    protected AMutableTime aTime = new AMutableTime(0);
+                    protected AMutableDateTime aDatetime = new AMutableDateTime(0);
+
+                    private ATypeTag typeTag;
                     @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer dateSerde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADATE);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer timeSerde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ATIME);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer dateTimeSerde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADATETIME);
-                    @SuppressWarnings("rawtypes")
-                    private final ISerializerDeserializer durationSerde =
-                            SerializerDeserializerProvider.INSTANCE.getSerializerDeserializer(BuiltinType.ADURATION);
+                    private ISerializerDeserializer serde;
 
-                    @Override
                     @SuppressWarnings("unchecked")
+                    @Override
                     public void evaluate(IFrameTupleReference tuple, IPointable result) throws HyracksDataException {
+                        resultStorage.reset();
+                        resultType = 0;
+                        int currentType;
                         evalLeft.evaluate(tuple, argPtr0);
                         evalRight.evaluate(tuple, argPtr1);
 
-                        resultStorage.reset();
-
-                        ATypeTag argTypeMax = null;
-
-                        for (int i = 0; i < 2; i++) {
+                        for (int i = 0; i < args.length; i++) {
                             IPointable argPtr = i == 0 ? argPtr0 : argPtr1;
                             byte[] bytes = argPtr.getByteArray();
                             int offset = argPtr.getStartOffset();
 
-                            ATypeTag currentType;
-                            ATypeTag typeTag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes[offset]);
+                            typeTag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes[offset]);
                             switch (typeTag) {
-                                case TINYINT:
-                                    currentType = ATypeTag.TINYINT;
+                                case INT8:
+                                    currentType = typeInt8;
                                     operandsInteger[i] = AInt8SerializerDeserializer.getByte(bytes, offset + 1);
                                     operandsFloating[i] = operandsInteger[i];
                                     break;
-                                case SMALLINT:
-                                    currentType = ATypeTag.SMALLINT;
+                                case INT16:
+                                    currentType = typeInt16;
                                     operandsInteger[i] = AInt16SerializerDeserializer.getShort(bytes, offset + 1);
                                     operandsFloating[i] = operandsInteger[i];
                                     break;
-                                case INTEGER:
-                                    currentType = ATypeTag.INTEGER;
+                                case INT32:
+                                    currentType = typeInt32;
                                     operandsInteger[i] = AInt32SerializerDeserializer.getInt(bytes, offset + 1);
                                     operandsFloating[i] = operandsInteger[i];
                                     break;
-                                case BIGINT:
-                                    currentType = ATypeTag.BIGINT;
+                                case INT64:
+                                    currentType = typeInt64;
                                     operandsInteger[i] = AInt64SerializerDeserializer.getLong(bytes, offset + 1);
                                     operandsFloating[i] = operandsInteger[i];
                                     break;
                                 case FLOAT:
-                                    currentType = ATypeTag.FLOAT;
+                                    currentType = typeFloat;
                                     operandsFloating[i] = AFloatSerializerDeserializer.getFloat(bytes, offset + 1);
                                     break;
                                 case DOUBLE:
-                                    currentType = ATypeTag.DOUBLE;
+                                    currentType = typeDouble;
                                     operandsFloating[i] = ADoubleSerializerDeserializer.getDouble(bytes, offset + 1);
                                     break;
                                 case DATE:
@@ -206,7 +186,7 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                 case DURATION:
                                 case YEARMONTHDURATION:
                                 case DAYTIMEDURATION:
-                                    evaluateTemporalArithmeticOperation(typeTag);
+                                    evaluateTemporalArthmeticOperation(typeTag);
                                     result.set(resultStorage);
                                     return;
                                 default:
@@ -221,17 +201,17 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                             ATypeTag.SERIALIZED_DAY_TIME_DURATION_TYPE_TAG);
                             }
 
-                            if (i == 0 || currentType.ordinal() > argTypeMax.ordinal()) {
-                                argTypeMax = currentType;
+                            if (resultType < currentType) {
+                                resultType = currentType;
                             }
                         }
 
-                        ATypeTag resultType = getNumericResultType(argTypeMax);
-
                         long lres;
                         double dres;
                         switch (resultType) {
-                            case TINYINT:
+                            case typeInt8:
+                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                        .getSerializerDeserializer(BuiltinType.AINT8);
                                 lres = evaluateInteger(operandsInteger[0], operandsInteger[1]);
                                 if (lres > Byte.MAX_VALUE) {
                                     throw new OverflowException(getIdentifier());
@@ -240,9 +220,11 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     throw new UnderflowException(getIdentifier());
                                 }
                                 aInt8.setValue((byte) lres);
-                                int8Serde.serialize(aInt8, out);
+                                serde.serialize(aInt8, out);
                                 break;
-                            case SMALLINT:
+                            case typeInt16:
+                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                        .getSerializerDeserializer(BuiltinType.AINT16);
                                 lres = evaluateInteger(operandsInteger[0], operandsInteger[1]);
                                 if (lres > Short.MAX_VALUE) {
                                     throw new OverflowException(getIdentifier());
@@ -251,9 +233,11 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     throw new UnderflowException(getIdentifier());
                                 }
                                 aInt16.setValue((short) lres);
-                                int16Serde.serialize(aInt16, out);
+                                serde.serialize(aInt16, out);
                                 break;
-                            case INTEGER:
+                            case typeInt32:
+                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                        .getSerializerDeserializer(BuiltinType.AINT32);
                                 lres = evaluateInteger(operandsInteger[0], operandsInteger[1]);
                                 if (lres > Integer.MAX_VALUE) {
                                     throw new OverflowException(getIdentifier());
@@ -262,14 +246,18 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     throw new UnderflowException(getIdentifier());
                                 }
                                 aInt32.setValue((int) lres);
-                                int32Serde.serialize(aInt32, out);
+                                serde.serialize(aInt32, out);
                                 break;
-                            case BIGINT:
+                            case typeInt64:
+                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                        .getSerializerDeserializer(BuiltinType.AINT64);
                                 lres = evaluateInteger(operandsInteger[0], operandsInteger[1]);
                                 aInt64.setValue(lres);
-                                int64Serde.serialize(aInt64, out);
+                                serde.serialize(aInt64, out);
                                 break;
-                            case FLOAT:
+                            case typeFloat:
+                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                        .getSerializerDeserializer(BuiltinType.AFLOAT);
                                 dres = evaluateDouble(operandsFloating[0], operandsFloating[1]);
                                 if (dres > Float.MAX_VALUE) {
                                     throw new OverflowException(getIdentifier());
@@ -278,19 +266,21 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     throw new UnderflowException(getIdentifier());
                                 }
                                 aFloat.setValue((float) dres);
-                                floatSerde.serialize(aFloat, out);
+                                serde.serialize(aFloat, out);
                                 break;
-                            case DOUBLE:
-                                dres = evaluateDouble(operandsFloating[0], operandsFloating[1]);
-                                aDouble.setValue(dres);
-                                doubleSerde.serialize(aDouble, out);
+                            case typeDouble:
+                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                        .getSerializerDeserializer(BuiltinType.ADOUBLE);
+                                aDouble.setValue(evaluateDouble(operandsFloating[0], operandsFloating[1]));
+                                serde.serialize(aDouble, out);
                                 break;
                         }
                         result.set(resultStorage);
                     }
 
                     @SuppressWarnings("unchecked")
-                    private void evaluateTemporalArithmeticOperation(ATypeTag leftType) throws HyracksDataException {
+                    private void evaluateTemporalArthmeticOperation(ATypeTag leftType)
+                            throws HyracksDataException {
                         byte[] bytes1 = argPtr1.getByteArray();
                         int offset1 = argPtr1.getStartOffset();
                         ATypeTag rightType = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(bytes1[offset1]);
@@ -299,7 +289,10 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
 
                         if (rightType == leftType) {
 
-                            long leftChronon = 0, rightChronon = 0, dayTime;
+                            serde = AqlSerializerDeserializerProvider.INSTANCE
+                                    .getSerializerDeserializer(BuiltinType.ADURATION);
+
+                            long leftChronon = 0, rightChronon = 0, dayTime = 0;
 
                             int yearMonth = 0;
 
@@ -309,6 +302,7 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                             * GregorianCalendarSystem.CHRONON_OF_DAY;
                                     rightChronon = ADateSerializerDeserializer.getChronon(bytes1, offset1 + 1)
                                             * GregorianCalendarSystem.CHRONON_OF_DAY;
+
                                     break;
                                 case TIME:
                                     leftChronon = ATimeSerializerDeserializer.getChronon(bytes0, offset0 + 1);
@@ -324,10 +318,10 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                             AYearMonthDurationSerializerDeserializer.getYearMonth(bytes1, offset1 + 1));
                                     break;
                                 case DAYTIMEDURATION:
-                                    leftChronon =
-                                            ADayTimeDurationSerializerDeserializer.getDayTime(bytes0, offset0 + 1);
-                                    rightChronon =
-                                            ADayTimeDurationSerializerDeserializer.getDayTime(bytes1, offset1 + 1);
+                                    leftChronon = ADayTimeDurationSerializerDeserializer.getDayTime(bytes0,
+                                            offset0 + 1);
+                                    rightChronon = ADayTimeDurationSerializerDeserializer.getDayTime(bytes1,
+                                            offset1 + 1);
                                     break;
                                 default:
                                     throw new UnsupportedTypeException(getIdentifier(), bytes1[offset1]);
@@ -336,19 +330,20 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                             dayTime = evaluateTimeInstanceArithmetic(leftChronon, rightChronon);
 
                             aDuration.setValue(yearMonth, dayTime);
-                            durationSerde.serialize(aDuration, out);
+
+                            serde.serialize(aDuration, out);
 
                         } else {
                             long chronon = 0, dayTime = 0;
                             int yearMonth = 0;
                             ATypeTag resultType = null;
-                            ISerializerDeserializer serde = null;
 
                             boolean isTimeOnly = false;
 
                             switch (leftType) {
                                 case TIME:
-                                    serde = timeSerde;
+                                    serde = AqlSerializerDeserializerProvider.INSTANCE
+                                            .getSerializerDeserializer(BuiltinType.ATIME);
                                     chronon = ATimeSerializerDeserializer.getChronon(bytes0, offset0 + 1);
                                     isTimeOnly = true;
                                     resultType = ATypeTag.TIME;
@@ -359,8 +354,8 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                             break;
                                         case DURATION:
                                             dayTime = ADurationSerializerDeserializer.getDayTime(bytes1, offset1 + 1);
-                                            yearMonth =
-                                                    ADurationSerializerDeserializer.getYearMonth(bytes1, offset1 + 1);
+                                            yearMonth = ADurationSerializerDeserializer.getYearMonth(bytes1,
+                                                    offset1 + 1);
                                             break;
                                         default:
                                             throw new IncompatibleTypeException(getIdentifier(), bytes0[offset0],
@@ -368,20 +363,22 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     }
                                     break;
                                 case DATE:
-                                    serde = dateSerde;
+                                    serde = AqlSerializerDeserializerProvider.INSTANCE
+                                            .getSerializerDeserializer(BuiltinType.ADATE);
                                     resultType = ATypeTag.DATE;
                                     chronon = ADateSerializerDeserializer.getChronon(bytes0, offset0 + 1)
                                             * GregorianCalendarSystem.CHRONON_OF_DAY;
                                 case DATETIME:
                                     if (leftType == ATypeTag.DATETIME) {
-                                        serde = dateTimeSerde;
+                                        serde = AqlSerializerDeserializerProvider.INSTANCE
+                                                .getSerializerDeserializer(BuiltinType.ADATETIME);
                                         resultType = ATypeTag.DATETIME;
                                         chronon = ADateTimeSerializerDeserializer.getChronon(bytes0, offset0 + 1);
                                     }
                                     switch (rightType) {
                                         case DURATION:
-                                            yearMonth =
-                                                    ADurationSerializerDeserializer.getYearMonth(bytes1, offset1 + 1);
+                                            yearMonth = ADurationSerializerDeserializer.getYearMonth(bytes1,
+                                                    offset1 + 1);
                                             dayTime = ADurationSerializerDeserializer.getDayTime(bytes1, offset1 + 1);
                                             break;
                                         case YEARMONTHDURATION:
@@ -398,16 +395,18 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     }
                                     break;
                                 case YEARMONTHDURATION:
-                                    yearMonth =
-                                            AYearMonthDurationSerializerDeserializer.getYearMonth(bytes0, offset0 + 1);
+                                    yearMonth = AYearMonthDurationSerializerDeserializer.getYearMonth(bytes0,
+                                            offset0 + 1);
                                     switch (rightType) {
                                         case DATETIME:
-                                            serde = dateTimeSerde;
+                                            serde = AqlSerializerDeserializerProvider.INSTANCE
+                                                    .getSerializerDeserializer(BuiltinType.ADATETIME);
                                             resultType = ATypeTag.DATETIME;
                                             chronon = ADateTimeSerializerDeserializer.getChronon(bytes1, offset1 + 1);
                                             break;
                                         case DATE:
-                                            serde = dateSerde;
+                                            serde = AqlSerializerDeserializerProvider.INSTANCE
+                                                    .getSerializerDeserializer(BuiltinType.ADATE);
                                             resultType = ATypeTag.DATE;
                                             chronon = ADateSerializerDeserializer.getChronon(bytes1, offset1 + 1)
                                                     * GregorianCalendarSystem.CHRONON_OF_DAY;
@@ -422,24 +421,27 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
                                     dayTime = ADurationSerializerDeserializer.getDayTime(bytes0, offset0 + 1);
                                 case DAYTIMEDURATION:
                                     if (leftType == ATypeTag.DAYTIMEDURATION) {
-                                        dayTime =
-                                                ADayTimeDurationSerializerDeserializer.getDayTime(bytes0, offset0 + 1);
+                                        dayTime = ADayTimeDurationSerializerDeserializer.getDayTime(bytes0,
+                                                offset0 + 1);
                                     }
                                     switch (rightType) {
                                         case DATETIME:
-                                            serde = dateTimeSerde;
+                                            serde = AqlSerializerDeserializerProvider.INSTANCE
+                                                    .getSerializerDeserializer(BuiltinType.ADATETIME);
                                             resultType = ATypeTag.DATETIME;
                                             chronon = ADateTimeSerializerDeserializer.getChronon(bytes1, offset1 + 1);
                                             break;
                                         case DATE:
-                                            serde = dateSerde;
+                                            serde = AqlSerializerDeserializerProvider.INSTANCE
+                                                    .getSerializerDeserializer(BuiltinType.ADATE);
                                             resultType = ATypeTag.DATE;
                                             chronon = ADateSerializerDeserializer.getChronon(bytes1, offset1 + 1)
                                                     * GregorianCalendarSystem.CHRONON_OF_DAY;
                                             break;
                                         case TIME:
                                             if (yearMonth == 0) {
-                                                serde = timeSerde;
+                                                serde = AqlSerializerDeserializerProvider.INSTANCE
+                                                        .getSerializerDeserializer(BuiltinType.ATIME);
                                                 resultType = ATypeTag.TIME;
                                                 chronon = ATimeSerializerDeserializer.getChronon(bytes1, offset1 + 1);
                                                 isTimeOnly = true;
@@ -485,8 +487,4 @@ public abstract class AbstractNumericArithmeticEval extends AbstractScalarFuncti
             }
         };
     }
-
-    protected ATypeTag getNumericResultType(ATypeTag argTypeMax) {
-        return argTypeMax;
-    }
 }