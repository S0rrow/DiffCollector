diff --git a/archiva-web/archiva-webapp/src/main/java/org/apache/maven/archiva/web/repository/ProxiedDavServer.java b/archiva-web/archiva-webapp/src/main/java/org/apache/maven/archiva/web/repository/ProxiedDavServer.java
index 027f58f54..07b58c5bb 100644
--- a/archiva-web/archiva-webapp/src/main/java/org/apache/maven/archiva/web/repository/ProxiedDavServer.java
+++ b/archiva-web/archiva-webapp/src/main/java/org/apache/maven/archiva/web/repository/ProxiedDavServer.java
@@ -19,19 +19,6 @@
  * under the License.
  */
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.servlet.ServletConfig;
-import javax.servlet.ServletException;
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.maven.archiva.common.utils.PathUtil;
 import org.apache.maven.archiva.model.ArtifactReference;
 import org.apache.maven.archiva.model.ProjectReference;
 import org.apache.maven.archiva.model.VersionedReference;
@@ -41,29 +28,33 @@
 import org.apache.maven.archiva.repository.RepositoryContentFactory;
 import org.apache.maven.archiva.repository.RepositoryException;
 import org.apache.maven.archiva.repository.RepositoryNotFoundException;
-import org.apache.maven.archiva.repository.audit.AuditEvent;
-import org.apache.maven.archiva.repository.audit.AuditListener;
-import org.apache.maven.archiva.repository.audit.Auditable;
 import org.apache.maven.archiva.repository.content.RepositoryRequest;
 import org.apache.maven.archiva.repository.layout.LayoutException;
 import org.apache.maven.archiva.repository.metadata.MetadataTools;
 import org.apache.maven.archiva.repository.metadata.RepositoryMetadataException;
-import org.apache.maven.archiva.security.ArchivaUser;
 import org.apache.maven.model.DistributionManagement;
 import org.apache.maven.model.Model;
 import org.apache.maven.model.Relocation;
 import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
-import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
 import org.codehaus.plexus.webdav.AbstractDavServerComponent;
 import org.codehaus.plexus.webdav.DavServerComponent;
 import org.codehaus.plexus.webdav.DavServerException;
-import org.codehaus.plexus.webdav.DavServerListener;
 import org.codehaus.plexus.webdav.servlet.DavServerRequest;
 import org.codehaus.plexus.webdav.util.WebdavMethodUtil;
 
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.io.PrintWriter;
+
+import javax.servlet.ServletConfig;
+import javax.servlet.ServletException;
+import javax.servlet.http.HttpServletResponse;
+
 /**
  * ProxiedDavServer
- * 
+ *
  * @author <a href="mailto:joakime@apache.org">Joakim Erdfelt</a>
  * @version $Id$
  * @plexus.component role="org.codehaus.plexus.webdav.DavServerComponent"
@@ -71,18 +62,12 @@
  */
 public class ProxiedDavServer
     extends AbstractDavServerComponent
-    implements Auditable
 {
     /**
      * @plexus.requirement role-hint="simple"
      */
     private DavServerComponent davServer;
 
-    /**
-     * @plexus.requirement role="org.apache.maven.archiva.repository.audit.AuditListener"
-     */
-    private List<AuditListener> auditListeners = new ArrayList<AuditListener>();
-
     /**
      * @plexus.requirement
      */
@@ -103,11 +88,6 @@
      */
     private MetadataTools metadataTools;
 
-    /**
-     * @plexus.requirement role-hint="xwork"
-     */
-    private ArchivaUser archivaUser;
-
     private ManagedRepositoryContent managedRepository;
 
     public String getPrefix()
@@ -152,132 +132,47 @@ public void init( ServletConfig servletConfig )
     public void process( DavServerRequest request, HttpServletResponse response )
         throws DavServerException, ServletException, IOException
     {
-        boolean isGet = WebdavMethodUtil.isReadMethod( request.getRequest().getMethod() );
-        boolean isPut = WebdavMethodUtil.isWriteMethod( request.getRequest().getMethod() );
-        String resource = request.getLogicalResource();
-
-        if ( isGet )
+        if ( WebdavMethodUtil.isReadMethod( request.getRequest().getMethod() ) )
         {
-            // Default behaviour is to treat the resource natively.
-            File resourceFile = new File( managedRepository.getRepoRoot(), resource );
-
-            // If this a directory resource, then we are likely browsing.
-            if ( resourceFile.exists() && resourceFile.isDirectory() )
-            {
-                String requestURL = request.getRequest().getRequestURL().toString();
-
-                // [MRM-440] - If webdav URL lacks a trailing /, navigating to
-                // all links in the listing return 404.
-                if ( !requestURL.endsWith( "/" ) )
-                {
-                    String redirectToLocation = requestURL + "/";
-                    response.sendRedirect( redirectToLocation );
-                    return;
-                }
-
-                // Process the request.
-                davServer.process( request, response );
-
-                // All done.
-                return;
-            }
-
-            // At this point the incoming request can either be in default or
-            // legacy layout format.
-            try
-            {
-                boolean fromProxy = fetchContentFromProxies( request, resource );
-
-                // Perform an adjustment of the resource to the managed
-                // repository expected path.
-                resource =
-                    repositoryRequest
-                        .toNativePath( request.getLogicalResource(), managedRepository );
-                resourceFile = new File( managedRepository.getRepoRoot(), resource );                
-
-                // Adjust the pathInfo resource to be in the format that the dav
-                // server impl expects.
-                request.setLogicalResource( resource );
-
-                boolean previouslyExisted = resourceFile.exists();
-
-                // Attempt to fetch the resource from any defined proxy.
-                if ( fromProxy )
-                {
-                    processAuditEvents( request, resource, previouslyExisted, resourceFile,
-                        " (proxied)" );
-                }
-            }
-            catch ( LayoutException e )
-            {
-                // Invalid resource, pass it on.
-                respondResourceMissing( request, response, e );
-
-                // All done.
-                return;
-            }
-
-            if ( resourceFile.exists() )
-            {
-                // [MRM-503] - Metadata file need Pragma:no-cache response
-                // header.
-                if ( request.getLogicalResource().endsWith( "/maven-metadata.xml" ) )
-                {
-                    response.addHeader( "Pragma", "no-cache" );
-                    response.addHeader( "Cache-Control", "no-cache" );
-                }
-
-                // TODO: [MRM-524] determine http caching options for other
-                // types of files (artifacts, sha1, md5, snapshots)
-
-                davServer.process( request, response );
-            }
-            else
-            {
-                respondResourceMissing( request, response, null );
-            }
+            fetchContentFromProxies( request );
         }
-
-        if ( isPut )
+        else
         {
-            /*
-             * Create parent directories that don't exist when writing a file
+            /* Create parent directories that don't exist when writing a file
              * This actually makes this implementation not compliant to the
-             * WebDAV RFC - but we have enough knowledge about how the
-             * collection is being used to do this reasonably and some versions
-             * of Maven's WebDAV don't correctly create the collections
-             * themselves.
+             * WebDAV RFC - but we have enough knowledge
+             * about how the collection is being used to do this reasonably and
+             * some versions of Maven's WebDAV don't
+             * correctly create the collections themselves.
              */
 
             File rootDirectory = getRootDirectory();
             if ( rootDirectory != null )
             {
-                File destDir = new File( rootDirectory, resource ).getParentFile();
-                if ( !destDir.exists() )
-                {
-                    destDir.mkdirs();
-                    String relPath =
-                        PathUtil.getRelative( rootDirectory.getAbsolutePath(), destDir );
-                    triggerAuditEvent( request, relPath, AuditEvent.CREATE_DIR );
-                }
+                new File( rootDirectory, request.getLogicalResource() ).getParentFile().mkdirs();
             }
+        }
 
-            File resourceFile = new File( managedRepository.getRepoRoot(), resource );
+        // [MRM-503] - Metadata file need Pragma:no-cache response header.
+        if ( request.getLogicalResource().endsWith( "/maven-metadata.xml" ) )
+        {
+            response.addHeader( "Pragma", "no-cache" );
+            response.addHeader( "Cache-Control", "no-cache" );
+        }
 
-            boolean previouslyExisted = resourceFile.exists();
+        // TODO: [MRM-524] determine http caching options for other types of files (artifacts, sha1, md5, snapshots)
 
-            // Allow the dav server to process the put request.
+        if( resourceExists( request ) )
+        {
             davServer.process( request, response );
-
-            processAuditEvents( request, resource, previouslyExisted, resourceFile, null );
-
-            // All done.
-            return;
+        }
+        else
+        {
+            respondResourceMissing( request, response );
         }
     }
 
-    private void respondResourceMissing( DavServerRequest request, HttpServletResponse response,
-                                         Throwable t )
+    private void respondResourceMissing( DavServerRequest request, HttpServletResponse response )
     {
         response.setStatus( HttpServletResponse.SC_NOT_FOUND );
 
@@ -288,6 +183,7 @@ private void respondResourceMissing( DavServerRequest request, HttpServletRespon
             missingUrl.append( request.getRequest().getServerName() ).append( ":" );
             missingUrl.append( request.getRequest().getServerPort() );
             missingUrl.append( request.getRequest().getServletPath() );
+            // missingUrl.append( request.getRequest().getPathInfo() );
 
             String message = "Error 404 Not Found";
 
@@ -309,13 +205,6 @@ private void respondResourceMissing( DavServerRequest request, HttpServletRespon
             out.print( missingUrl.toString() );
             out.println( "</a></p>" );
 
-            if ( t != null )
-            {
-                out.println( "<pre>" );
-                t.printStackTrace( out );
-                out.println( "</pre>" );
-            }
-
             out.println( "</body></html>" );
 
             out.flush();
@@ -326,96 +215,102 @@ private void respondResourceMissing( DavServerRequest request, HttpServletRespon
         }
     }
 
-    private boolean fetchContentFromProxies( DavServerRequest request, String resource )
+    private boolean resourceExists( DavServerRequest request )
+    {
+        String resource = request.getLogicalResource();
+        File resourceFile = new File( managedRepository.getRepoRoot(), resource );
+        return resourceFile.exists();
+    }
+
+    private void fetchContentFromProxies( DavServerRequest request )
         throws ServletException
     {
-        if ( repositoryRequest.isSupportFile( resource ) )
+        String resource = request.getLogicalResource();
+        
+        // Cleanup bad requests from maven 1.
+        // Often seen is a double slash.
+        // example: http://hostname:8080/archiva/repository/internal//pmd/jars/pmd-3.0.jar
+        if ( resource.startsWith( "/" ) )
         {
-            // Checksums are fetched with artifact / metadata.
-
-            // Need to adjust the path for the checksum resource.
-            return false;
+            resource = resource.substring( 1 );
         }
 
-        // Is it a Metadata resource?
-        if ( repositoryRequest.isDefault( resource ) && repositoryRequest.isMetadata( resource ) )
+        if ( resource.endsWith( ".sha1" ) || resource.endsWith( ".md5" ) )
         {
-            return fetchMetadataFromProxies( request, resource );
+            // Checksums are fetched with artifact / metadata.
+            return;
         }
 
-        // Not any of the above? Then it's gotta be an artifact reference.
-        try
+        // Is it a Metadata resource?
+        if ( resource.endsWith( "/" + MetadataTools.MAVEN_METADATA ) )
         {
-            // Get the artifact reference in a layout neutral way.
-            ArtifactReference artifact = repositoryRequest.toArtifactReference( resource );
+            ProjectReference project;
+            VersionedReference versioned;
 
-            if ( artifact != null )
+            try
             {
-                applyServerSideRelocation( artifact );
 
-                File proxiedFile = connectors.fetchFromProxies( managedRepository, artifact );
-
-                // Set the path to the resource using managed repository
-                // specific layout format.
-                request.setLogicalResource( managedRepository.toPath( artifact ) );
-                return ( proxiedFile != null );
+                versioned = metadataTools.toVersionedReference( resource );
+                if ( versioned != null )
+                {
+                    connectors.fetchFromProxies( managedRepository, versioned );
+                    request.getRequest().setPathInfo( metadataTools.toPath( versioned ) );
+                    return;
+                }
+            }
+            catch ( RepositoryMetadataException e )
+            {
+                /* eat it */
+            }
+            catch ( ProxyException e )
+            {
+                throw new ServletException( "Unable to fetch versioned metadata resource.", e );
             }
-        }
-        catch ( LayoutException e )
-        {
-            /* eat it */
-        }
-        catch ( ProxyException e )
-        {
-            throw new ServletException( "Unable to fetch artifact resource.", e );
-        }
-        return false;
-    }
-
-    private boolean fetchMetadataFromProxies( DavServerRequest request, String resource )
-        throws ServletException
-    {
-        ProjectReference project;
-        VersionedReference versioned;
-
-        try
-        {
 
-            versioned = metadataTools.toVersionedReference( resource );
-            if ( versioned != null )
+            try
             {
-                connectors.fetchFromProxies( managedRepository, versioned );
-                return true;
+                project = metadataTools.toProjectReference( resource );
+                if ( project != null )
+                {
+                    connectors.fetchFromProxies( managedRepository, project );
+                    request.getRequest().setPathInfo( metadataTools.toPath( project ) );
+                }
+            }
+            catch ( RepositoryMetadataException e )
+            {
+                /* eat it */
+            }
+            catch ( ProxyException e )
+            {
+                throw new ServletException( "Unable to fetch project metadata resource.", e );
             }
-        }
-        catch ( RepositoryMetadataException e )
-        {
-            /* eat it */
-        }
-        catch ( ProxyException e )
-        {
-            throw new ServletException( "Unable to fetch versioned metadata resource.", e );
         }
 
+        // Not any of the above? Then it's gotta be an artifact reference.
         try
         {
-            project = metadataTools.toProjectReference( resource );
-            if ( project != null )
+            // Get the artifact reference in a layout neutral way.
+            ArtifactReference artifact = repositoryRequest.toArtifactReference( resource );
+            
+            if ( artifact != null )
             {
-                connectors.fetchFromProxies( managedRepository, project );
-                return true;
+                applyServerSideRelocation( artifact );
+
+                connectors.fetchFromProxies( managedRepository, artifact );
+                
+                // Set the path to the resource using managed repository specific layout format.
+                request.getRequest().setPathInfo( managedRepository.toPath( artifact ) );
+                return;
             }
         }
-        catch ( RepositoryMetadataException e )
+        catch ( LayoutException e )
         {
             /* eat it */
         }
         catch ( ProxyException e )
         {
-            throw new ServletException( "Unable to fetch project metadata resource.", e );
+            throw new ServletException( "Unable to fetch artifact resource.", e );
         }
-
-        return false;
     }
 
     /**
@@ -448,12 +343,6 @@ protected void applyServerSideRelocation( ArtifactReference artifact )
 
         // Open and read the POM from the managed repo
         File pom = managedRepository.toFile( pomReference );
-
-        if ( !pom.exists() )
-        {
-            return;
-        }
-
         try
         {
             Model model = new MavenXpp3Reader().read( new FileReader( pom ) );
@@ -483,129 +372,14 @@ protected void applyServerSideRelocation( ArtifactReference artifact )
         {
             // Artifact has no POM in repo : ignore
         }
-        catch ( IOException e )
+        catch ( Exception e )
         {
-            // Unable to read POM : ignore.
-        }
-        catch ( XmlPullParserException e )
-        {
-            // Invalid POM : ignore
+            // invalid POM : ignore
         }
     }
 
-    @Override
-    public void addListener( DavServerListener listener )
-    {
-        super.addListener( listener );
-        davServer.addListener( listener );
-    }
-
-    @Override
-    public boolean isUseIndexHtml()
-    {
-        return davServer.isUseIndexHtml();
-    }
-
-    @Override
-    public boolean hasResource( String resource )
-    {
-        return davServer.hasResource( resource );
-    }
-
-    @Override
-    public void removeListener( DavServerListener listener )
-    {
-        davServer.removeListener( listener );
-    }
-
-    @Override
-    public void setUseIndexHtml( boolean useIndexHtml )
-    {
-        super.setUseIndexHtml( useIndexHtml );
-        davServer.setUseIndexHtml( useIndexHtml );
-    }
-
     public ManagedRepositoryContent getRepository()
     {
         return managedRepository;
     }
-
-    private void processAuditEvents( DavServerRequest request, String resource,
-                                     boolean previouslyExisted, File resourceFile, String suffix )
-    {
-        if ( suffix == null )
-        {
-            suffix = "";
-        }
-
-        // Process Create Audit Events.
-        if ( !previouslyExisted && resourceFile.exists() )
-        {
-            if ( resourceFile.isFile() )
-            {
-                triggerAuditEvent( request, resource, AuditEvent.CREATE_FILE + suffix );
-            }
-            else if ( resourceFile.isDirectory() )
-            {
-                triggerAuditEvent( request, resource, AuditEvent.CREATE_DIR + suffix );
-            }
-        }
-        // Process Remove Audit Events.
-        else if ( previouslyExisted && !resourceFile.exists() )
-        {
-            if ( resourceFile.isFile() )
-            {
-                triggerAuditEvent( request, resource, AuditEvent.REMOVE_FILE + suffix );
-            }
-            else if ( resourceFile.isDirectory() )
-            {
-                triggerAuditEvent( request, resource, AuditEvent.REMOVE_DIR + suffix );
-            }
-        }
-        // Process modify events.
-        else
-        {
-            if ( resourceFile.isFile() )
-            {
-                triggerAuditEvent( request, resource, AuditEvent.MODIFY_FILE + suffix );
-            }
-        }
-    }
-
-    private void triggerAuditEvent( String user, String remoteIP, String resource, String action )
-    {
-        AuditEvent event = new AuditEvent( this.getPrefix(), user, resource, action );
-        event.setRemoteIP( remoteIP );
-
-        for ( AuditListener listener : auditListeners )
-        {
-            listener.auditEvent( event );
-        }
-    }
-
-    private void triggerAuditEvent( DavServerRequest request, String resource, String action )
-    {
-        triggerAuditEvent( archivaUser.getActivePrincipal(), getRemoteIP( request ), resource,
-            action );
-    }
-
-    private String getRemoteIP( DavServerRequest request )
-    {
-        return request.getRequest().getRemoteAddr();
-    }
-
-    public void addAuditListener( AuditListener listener )
-    {
-        this.auditListeners.add( listener );
-    }
-
-    public void clearAuditListeners()
-    {
-        this.auditListeners.clear();
-    }
-
-    public void removeAuditListener( AuditListener listener )
-    {
-        this.auditListeners.remove( listener );
-    }
 }