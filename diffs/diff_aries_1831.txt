diff --git a/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/ImportPackageHeader.java b/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/ImportPackageHeader.java
index b665f3f9a..3fea9b36c 100644
--- a/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/ImportPackageHeader.java
+++ b/subsystem-core/src/main/java/org/apache/aries/subsystem/core/archive/ImportPackageHeader.java
@@ -20,70 +20,56 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
-import java.util.Map.Entry;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
 import org.osgi.framework.Constants;
-import org.osgi.framework.Version;
-import org.osgi.framework.namespace.PackageNamespace;
+import org.osgi.framework.Filter;
+import org.osgi.framework.FrameworkUtil;
+import org.osgi.framework.InvalidSyntaxException;
 import org.osgi.framework.wiring.BundleRevision;
-import org.osgi.resource.Requirement;
-import org.osgi.resource.Resource;
+import org.osgi.framework.wiring.Capability;
+import org.osgi.framework.wiring.Requirement;
+import org.osgi.framework.wiring.Resource;
 
 public class ImportPackageHeader implements Header<ImportPackageHeader.Clause> {
 	public static class Clause implements org.apache.aries.subsystem.core.archive.Clause {
-		private static final String REGEX = "\\((" + PackageNamespace.PACKAGE_NAMESPACE + ")(=)([^\\)]+)\\)";
-		private static final String REGEX1 = '(' + Grammar.PACKAGENAMES + ")(?=;|\\z)";
-		private static final String REGEX2 = '(' + Grammar.PARAMETER + ")(?=;|\\z)";
+		private static final String REGEX = '(' + Grammar.PACKAGENAMES + ")(?:\\;(" + Grammar.PARAMETER + "))*";
 		private static final Pattern PATTERN = Pattern.compile(REGEX);
-		private static final Pattern PATTERN1 = Pattern.compile(REGEX1);
-		private static final Pattern PATTERN2 = Pattern.compile(REGEX2);
-
-		private static void fillInDefaults(Map<String, Parameter> parameters) {
-			Parameter parameter = parameters.get(Constants.VERSION_ATTRIBUTE);
-			if (parameter == null)
-				parameters.put(Constants.VERSION_ATTRIBUTE, new VersionRangeAttribute());
-		}
 		
 		private final Map<String, Parameter> myParameters = new HashMap<String, Parameter>();
 		private final String myPath;
 		
-		public Clause(Requirement requirement) {
-			if (!PackageNamespace.PACKAGE_NAMESPACE.equals(requirement.getNamespace()))
-				throw new IllegalArgumentException("Requirement must be in the '" + PackageNamespace.PACKAGE_NAMESPACE + "' namespace");
-			String filter = requirement.getDirectives().get(PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE);
-			String packageName = null;
-			Matcher matcher = PATTERN.matcher(filter);
-			while (matcher.find()) {
-				String name = matcher.group(1);
-				String operator = matcher.group(2);
-				String value = matcher.group(3);
-				if (PackageNamespace.PACKAGE_NAMESPACE.equals(name)) {
-					packageName = value;
-				}
-				else if (PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE.equals(name)) {
-					// TODO Parse the version range from the filter.
-				}
-			}
-			if (packageName == null)
-				throw new IllegalArgumentException("Missing filter key: " + PackageNamespace.PACKAGE_NAMESPACE);
-			myPath = packageName;
-		}
-		
 		public Clause(String clause) {
-			Matcher matcher = PATTERN1.matcher(clause);
-			if (matcher.find())
-				myPath = matcher.group();
-			else
+			Matcher matcher = PATTERN.matcher(clause);
+			if (!matcher.matches()) {
 				throw new IllegalArgumentException("Invalid " + Constants.IMPORT_PACKAGE + " header clause: " + clause);
-			matcher.usePattern(PATTERN2);
-			while (matcher.find()) {
-				Parameter parameter = ParameterFactory.create(matcher.group());
-				myParameters.put(parameter.getName(), parameter);
 			}
-			fillInDefaults(myParameters);
+			myPath = matcher.group(1);
+			for (int i = 2; i <= matcher.groupCount(); i++) {
+				String group = matcher.group(i);
+				if (group != null) {
+					Parameter parameter = ParameterFactory.create(group);
+					myParameters.put(parameter.getName(), parameter);
+				}
+			}
+			Attribute attribute = new GenericAttribute(BundleRevision.PACKAGE_NAMESPACE, getPath());
+			myParameters.put(attribute.getName(), attribute);
+			attribute = getAttribute(Constants.VERSION_ATTRIBUTE);
+			if (attribute == null) {
+				attribute = new VersionRangeAttribute();
+				myParameters.put(attribute.getName(), attribute);
+			}
+			Directive directive = getDirective(Constants.FILTER_DIRECTIVE);
+			if (directive == null) {
+				StringBuilder builder = new StringBuilder("(&");
+				for (Attribute a : getAttributes()) {
+					a.appendToFilter(builder.append('(')).append(')');
+				}
+				directive = new GenericDirective(Constants.FILTER_DIRECTIVE, builder.append(')').toString());
+				myParameters.put(directive.getName(), directive);
+			}
 		}
 		
 		public Attribute getAttribute(String name) {
@@ -142,43 +128,47 @@ public class ImportPackageHeader implements Header<ImportPackageHeader.Clause> {
 		
 		public Requirement getRequirement(final Resource resource) {
 			return new Requirement() {
-				@Override
 				public String getNamespace() {
 					return BundleRevision.PACKAGE_NAMESPACE;
 				}
-				@Override
+
 				public Map<String, String> getDirectives() {
 					Collection<Directive> directives = Clause.this.getDirectives();
 					Map<String, String> result = new HashMap<String, String>(directives.size() + 1);
 					for (Directive directive : directives) {
 						result.put(directive.getName(), directive.getValue());
 					}
-					if (result.get(PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE) == null) {
-						StringBuilder builder = new StringBuilder("(&");
-						for (Entry<String, Object> entry : getAttributes().entrySet())
-							builder.append('(').append(entry.getKey()).append('=').append(entry.getValue()).append(')');
-						result.put(PackageNamespace.REQUIREMENT_FILTER_DIRECTIVE, builder.append(')').toString());
-					}
 					return result;
 				}
-				@Override
+
 				public Map<String, Object> getAttributes() {
 					Collection<Attribute> attributes = Clause.this.getAttributes();
 					Map<String, Object> result = new HashMap<String, Object>(attributes.size() + 1);
 					for (Attribute attribute : attributes) {
 						result.put(attribute.getName(), attribute.getValue());
 					}
-					if (result.get(PackageNamespace.PACKAGE_NAMESPACE) == null) {
-						result.put(PackageNamespace.PACKAGE_NAMESPACE, getPath());
-					}
-					if (result.get(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE) == null)
-						result.put(PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE, Version.emptyVersion.toString());
 					return result;
 				}
-				@Override
+
 				public Resource getResource() {
 					return resource;
 				}
+
+				public boolean matches(Capability capability) {
+					if (!getNamespace().equals(capability.getNamespace()))
+						return false;
+					Filter filter;
+					try {
+						filter = FrameworkUtil.createFilter(getDirectives().get(Constants.FILTER_DIRECTIVE));
+					}
+					catch (InvalidSyntaxException e) {
+						return false;
+					}
+					if (!filter.matches(capability.getAttributes()))
+							return false;
+					
+					return true;
+				}
 			};
 		}
 		
@@ -196,35 +186,25 @@ public class ImportPackageHeader implements Header<ImportPackageHeader.Clause> {
 		}
 	}
 	
-	public static final String ATTRIBUTE_BUNDLE_SYMBOLICNAME = PackageNamespace.CAPABILITY_BUNDLE_SYMBOLICNAME_ATTRIBUTE;
-	public static final String ATTRIBUTE_BUNDLE_VERSION = PackageNamespace.CAPABILITY_BUNDLE_VERSION_ATTRIBUTE;
-	public static final String ATTRIBUTE_VERSION = PackageNamespace.CAPABILITY_VERSION_ATTRIBUTE;
-	public static final String NAME = Constants.IMPORT_PACKAGE;
-	public static final String DIRECTIVE_RESOLUTION = PackageNamespace.REQUIREMENT_RESOLUTION_DIRECTIVE;
-	public static final String RESOLUTION_MANDATORY = PackageNamespace.RESOLUTION_MANDATORY;
-	public static final String RESOLUTION_OPTIONAL = PackageNamespace.RESOLUTION_OPTIONAL;
-	
-	private static final String REGEX = Grammar.IMPORT + "(?=,|\\z)";
+	private static final String REGEX = '(' + Grammar.IMPORT + ")(?:\\,(" + Grammar.IMPORT + "))*";
 	private static final Pattern PATTERN = Pattern.compile(REGEX);
 	
-	private static Collection<Clause> processHeader(String header) {
-		Matcher matcher = PATTERN.matcher(header);
-		Set<Clause> clauses = new HashSet<Clause>();
-		while (matcher.find())
-			clauses.add(new Clause(matcher.group()));
-		return clauses;
-	}
-	
-	private final Set<Clause> clauses;
-	
-	public ImportPackageHeader(Collection<Clause> clauses) {
-		if (clauses.isEmpty())
-			throw new IllegalArgumentException("An Import-Package header must have at least one clause");
-		this.clauses = new HashSet<Clause>(clauses);
-	}
+	private final Set<Clause> clauses = new HashSet<Clause>();
+	private final String value;
 	
 	public ImportPackageHeader(String header) {
-		this(processHeader(header));
+		Matcher matcher = PATTERN.matcher(header);
+		if (!matcher.matches()) {
+			throw new IllegalArgumentException("Invalid " + Constants.IMPORT_PACKAGE + " header: " + header);
+		}
+		for (int i = 1; i <= matcher.groupCount(); i++) {
+			String group = matcher.group(i);
+			if (group != null) {
+				Clause clause = new Clause(group);
+				clauses.add(clause);
+			}
+		}
+		value = header;
 	}
 	
 	public Collection<ImportPackageHeader.Clause> getClauses() {
@@ -244,19 +224,17 @@ public class ImportPackageHeader implements Header<ImportPackageHeader.Clause> {
 		return result;
 	}
 	
-	@Override
 	public String getValue() {
-		return toString();
+		return value;
 	}
 	
-	@Override
 	public String toString() {
-		StringBuilder builder = new StringBuilder();
+		StringBuilder builder = new StringBuilder()
+				.append(getName())
+				.append(": ");
 		for (Clause clause : getClauses()) {
-			builder.append(clause).append(',');
+			builder.append(clause);
 		}
-		// Remove the trailing comma. Note at least one clause is guaranteed to exist.
-		builder.deleteCharAt(builder.length() - 1);
 		return builder.toString();
 	}
 }