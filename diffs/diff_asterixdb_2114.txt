diff --git a/asterix-om/src/main/java/edu/uci/ics/asterix/builders/RecordBuilder.java b/asterix-om/src/main/java/edu/uci/ics/asterix/builders/RecordBuilder.java
index 845d201a79..fb8d2e46e6 100644
--- a/asterix-om/src/main/java/edu/uci/ics/asterix/builders/RecordBuilder.java
+++ b/asterix-om/src/main/java/edu/uci/ics/asterix/builders/RecordBuilder.java
@@ -1,88 +1,66 @@
-/*
- * Copyright 2009-2013 by The Regents of the University of California
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * you may obtain a copy of the License from
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
 package edu.uci.ics.asterix.builders;
 
-import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
-import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.IOException;
 import java.util.Arrays;
 
-import edu.uci.ics.asterix.common.exceptions.AsterixException;
 import edu.uci.ics.asterix.dataflow.data.nontagged.serde.SerializerDeserializerUtil;
 import edu.uci.ics.asterix.om.types.ARecordType;
 import edu.uci.ics.asterix.om.types.ATypeTag;
 import edu.uci.ics.asterix.om.util.NonTaggedFormatUtil;
-import edu.uci.ics.hyracks.api.dataflow.value.IBinaryComparator;
 import edu.uci.ics.hyracks.api.dataflow.value.IBinaryHashFunction;
-import edu.uci.ics.hyracks.api.exceptions.HyracksDataException;
-import edu.uci.ics.hyracks.data.std.accessors.PointableBinaryComparatorFactory;
 import edu.uci.ics.hyracks.data.std.accessors.PointableBinaryHashFunctionFactory;
-import edu.uci.ics.hyracks.data.std.api.IValueReference;
 import edu.uci.ics.hyracks.data.std.primitive.UTF8StringPointable;
-import edu.uci.ics.hyracks.data.std.util.ByteArrayAccessibleOutputStream;
-import edu.uci.ics.hyracks.dataflow.common.data.marshalling.UTF8StringSerializerDeserializer;
+import edu.uci.ics.hyracks.dataflow.common.data.accessors.IValueReference;
 
 public class RecordBuilder implements IARecordBuilder {
-    private final static int DEFAULT_NUM_OPEN_FIELDS = 10;
-    private final static byte SER_NULL_TYPE_TAG = ATypeTag.NULL.serialize();
-    private final static byte RECORD_TYPE_TAG = ATypeTag.RECORD.serialize();
-
-    private int openPartOffsetArraySize;
-    private byte[] openPartOffsetArray;
-    private int offsetPosition;
-    private int headerSize;
-    private boolean isOpen;
-    private boolean isNullable;
-    private int numberOfSchemaFields;
-
     private int openPartOffset;
-    private ARecordType recType;
 
-    private final IBinaryHashFunction utf8HashFunction;
-    private final IBinaryComparator utf8Comparator;
+    private ARecordType recType;
 
-    private final ByteArrayOutputStream closedPartOutputStream;
+    private ByteArrayOutputStream closedPartOutputStream;
     private int[] closedPartOffsets;
     private int numberOfClosedFields;
     private byte[] nullBitMap;
     private int nullBitMapSize;
 
-    private final ByteArrayAccessibleOutputStream openPartOutputStream;
+    private ByteArrayOutputStream openPartOutputStream;
     private long[] openPartOffsets;
-    private int[] openFieldNameLengths;
+    private long[] tempOpenPartOffsets;
 
     private int numberOfOpenFields;
 
+    private int fieldNameHashCode;
+    private final IBinaryHashFunction utf8HashFunction;
+
+    // for write()
+    private int openPartOffsetArraySize;
+    private byte[] openPartOffsetArray;
+    private int offsetPosition;
+    private int headerSize;
+    private boolean isOpen;
+    private boolean isNullable;
+    private int numberOfSchemaFields;
+    private final static byte SER_NULL_TYPE_TAG = ATypeTag.NULL.serialize();
+    private final static byte RECORD_TYPE_TAG = ATypeTag.RECORD.serialize();
+
     public RecordBuilder() {
 
         this.closedPartOutputStream = new ByteArrayOutputStream();
         this.numberOfClosedFields = 0;
 
-        this.openPartOutputStream = new ByteArrayAccessibleOutputStream();
-        this.openPartOffsets = new long[DEFAULT_NUM_OPEN_FIELDS];
-        this.openFieldNameLengths = new int[DEFAULT_NUM_OPEN_FIELDS];
+        this.openPartOutputStream = new ByteArrayOutputStream();
+        this.openPartOffsets = new long[20];
+        this.tempOpenPartOffsets = new long[20];
+
         this.numberOfOpenFields = 0;
 
+        this.fieldNameHashCode = 0;
         this.utf8HashFunction = new PointableBinaryHashFunctionFactory(UTF8StringPointable.FACTORY)
                 .createBinaryHashFunction();
-        this.utf8Comparator = new PointableBinaryComparatorFactory(UTF8StringPointable.FACTORY)
-                .createBinaryComparator();
 
+        // for write()
         this.openPartOffsetArray = null;
         this.openPartOffsetArraySize = 0;
         this.offsetPosition = 0;
@@ -149,60 +127,31 @@ public class RecordBuilder implements IARecordBuilder {
         closedPartOffsets[id] = closedPartOutputStream.size();
         int len = value.getLength() - 1;
         // +1 because we do not store the value tag.
-        closedPartOutputStream.write(value.getByteArray(), value.getStartOffset() + 1, len);
+        closedPartOutputStream.write(value.getBytes(), value.getStartIndex() + 1, len);
         numberOfClosedFields++;
-        if (isNullable && value.getByteArray()[value.getStartOffset()] != SER_NULL_TYPE_TAG) {
-            nullBitMap[id / 8] |= (byte) (1 << (7 - (id % 8)));
-        }
-    }
-    
-    public void addField(int id, byte[] value) {
-        closedPartOffsets[id] = closedPartOutputStream.size();
-        // We assume the tag is not included (closed field)
-        closedPartOutputStream.write(value, 0, value.length);
-        numberOfClosedFields++;
-        if (isNullable && value[0] != SER_NULL_TYPE_TAG) {
+        if (isNullable && value.getBytes()[0] != SER_NULL_TYPE_TAG) {
             nullBitMap[id / 8] |= (byte) (1 << (7 - (id % 8)));
         }
     }
 
     @Override
-    public void addField(IValueReference name, IValueReference value) throws AsterixException {
+    public void addField(IValueReference name, IValueReference value) {
         if (numberOfOpenFields == openPartOffsets.length) {
-            openPartOffsets = Arrays.copyOf(openPartOffsets, openPartOffsets.length + DEFAULT_NUM_OPEN_FIELDS);
-            openFieldNameLengths = Arrays.copyOf(openFieldNameLengths, openFieldNameLengths.length
-                    + DEFAULT_NUM_OPEN_FIELDS);
-        }
-        int fieldNameHashCode;
-        try {
-            fieldNameHashCode = utf8HashFunction.hash(name.getByteArray(), name.getStartOffset() + 1,
-                    name.getLength() - 1);
-        } catch (HyracksDataException e1) {
-            throw new AsterixException(e1);
-        }
-        if (recType != null) {
-            int cFieldPos;
-            try {
-                cFieldPos = recType.findFieldPosition(name.getByteArray(), name.getStartOffset() + 1,
-                        name.getLength() - 1);
-            } catch (HyracksDataException e) {
-                throw new AsterixException(e);
-            }
-            if (cFieldPos >= 0) {
-                throw new AsterixException("Open field \"" + recType.getFieldNames()[cFieldPos]
-                        + "\" has the same field name as closed field at index " + cFieldPos);
-            }
+            tempOpenPartOffsets = openPartOffsets;
+            openPartOffsets = new long[numberOfOpenFields + 20];
+            for (int i = 0; i < tempOpenPartOffsets.length; i++)
+                openPartOffsets[i] = tempOpenPartOffsets[i];
         }
+        fieldNameHashCode = utf8HashFunction.hash(name.getBytes(), name.getStartIndex() + 1, name.getLength());
         openPartOffsets[this.numberOfOpenFields] = fieldNameHashCode;
         openPartOffsets[this.numberOfOpenFields] = (openPartOffsets[numberOfOpenFields] << 32);
-        openPartOffsets[numberOfOpenFields] += openPartOutputStream.size();
-        openFieldNameLengths[numberOfOpenFields++] = name.getLength() - 1;
-        openPartOutputStream.write(name.getByteArray(), name.getStartOffset() + 1, name.getLength() - 1);
-        openPartOutputStream.write(value.getByteArray(), value.getStartOffset(), value.getLength());
+        openPartOffsets[numberOfOpenFields++] += openPartOutputStream.size();
+        openPartOutputStream.write(name.getBytes(), name.getStartIndex() + 1, name.getLength() - 1);
+        openPartOutputStream.write(value.getBytes(), value.getStartIndex(), value.getLength());
     }
 
     @Override
-    public void write(DataOutput out, boolean writeTypeTag) throws IOException, AsterixException {
+    public void write(DataOutput out, boolean writeTypeTag) throws IOException {
         int h = headerSize;
         int recordLength;
         // prepare the open part
@@ -214,27 +163,13 @@ public class RecordBuilder implements IARecordBuilder {
                 openPartOffsetArray = new byte[openPartOffsetArraySize];
 
             Arrays.sort(this.openPartOffsets, 0, numberOfOpenFields);
-            if (numberOfOpenFields > 1) {
-                byte[] openBytes = openPartOutputStream.getByteArray();
-                for (int i = 1; i < numberOfOpenFields; i++) {
-                    if (utf8Comparator.compare(openBytes, (int) openPartOffsets[i - 1], openFieldNameLengths[i - 1],
-                            openBytes, (int) openPartOffsets[i], openFieldNameLengths[i]) == 0) {
-                        String field = UTF8StringSerializerDeserializer.INSTANCE
-                                .deserialize(new DataInputStream(new ByteArrayInputStream(openBytes,
-                                        (int) openPartOffsets[i], openFieldNameLengths[i])));
-                        throw new AsterixException("Open fields " + (i - 1) + " and " + i
-                                + " have the same field name \"" + field + "\"");
-                    }
-                }
-            }
 
             openPartOffset = h + numberOfSchemaFields * 4 + closedPartOutputStream.size();
-            int fieldNameHashCode;
             for (int i = 0; i < numberOfOpenFields; i++) {
                 fieldNameHashCode = (int) (openPartOffsets[i] >> 32);
                 SerializerDeserializerUtil.writeIntToByteArray(openPartOffsetArray, (int) fieldNameHashCode,
                         offsetPosition);
-                int fieldOffset = (int) openPartOffsets[i];
+                int fieldOffset = (int) ((openPartOffsets[i] << 64) >> 64);
                 SerializerDeserializerUtil.writeIntToByteArray(openPartOffsetArray, fieldOffset + openPartOffset + 4
                         + openPartOffsetArraySize, offsetPosition + 4);
                 offsetPosition += 8;