diff --git a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java
index ae850af120..6eed80d7a2 100644
--- a/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java
+++ b/server/gc/src/main/java/org/apache/accumulo/gc/GarbageCollectWriteAheadLogs.java
@@ -40,8 +40,8 @@ import org.apache.accumulo.core.util.AddressUtil;
 import org.apache.accumulo.core.util.ThriftUtil;
 import org.apache.accumulo.core.zookeeper.ZooUtil;
 import org.apache.accumulo.server.ServerConstants;
-import org.apache.accumulo.server.conf.ServerConfiguration;
 import org.apache.accumulo.server.fs.VolumeManager;
+import org.apache.accumulo.server.fs.VolumeManager.FileType;
 import org.apache.accumulo.server.security.SystemCredentials;
 import org.apache.accumulo.server.util.MetadataTableUtil;
 import org.apache.accumulo.server.zookeeper.ZooReaderWriter;
@@ -64,50 +64,17 @@ public class GarbageCollectWriteAheadLogs {
   
   private boolean useTrash;
   
-  /**
-   * Creates a new GC WAL object.
-   *
-   * @param instance instance to use
-   * @param fs volume manager to use
-   * @param useTrash true to move files to trash rather than delete them
-   */
   GarbageCollectWriteAheadLogs(Instance instance, VolumeManager fs, boolean useTrash) throws IOException {
     this.instance = instance;
     this.fs = fs;
-    this.useTrash = useTrash;
   }
   
-  /**
-   * Gets the instance used by this object.
-   *
-   * @return instance
-   */
-  Instance getInstance() {
-    return instance;
-  }
-  /**
-   * Gets the volume manager used by this object.
-   *
-   * @return volume manager
-   */
-  VolumeManager getVolumeManager() {
-    return fs;
-  }
-  /**
-   * Checks if the volume manager should move files to the trash rather than
-   * delete them.
-   *
-   * @return true if trash is used
-   */
-  boolean isUsingTrash() {
-    return useTrash;
-  }
   public void collect(GCStatus status) {
     
     Span span = Trace.start("scanServers");
     try {
       
-      Map<String, Path> sortedWALogs = getSortedWALogs();
+      Set<Path> sortedWALogs = getSortedWALogs();
       
       status.currentLog.started = System.currentTimeMillis();
       
@@ -165,8 +132,8 @@ public class GarbageCollectWriteAheadLogs {
     }
   }
   
-  private int removeFiles(Map<String,Path> nameToFileMap, Map<String,ArrayList<Path>> serverToFileMap, Map<String, Path> sortedWALogs, final GCStatus status) {
-    AccumuloConfiguration conf = ServerConfiguration.getSystemConfiguration(instance);
+  private int removeFiles(Map<String,Path> nameToFileMap, Map<String,ArrayList<Path>> serverToFileMap, Set<Path> sortedWALogs, final GCStatus status) {
+    AccumuloConfiguration conf = instance.getConfiguration();
     for (Entry<String,ArrayList<Path>> entry : serverToFileMap.entrySet()) {
       if (entry.getKey().isEmpty()) {
         // old-style log entry, just remove it
@@ -183,7 +150,7 @@ public class GarbageCollectWriteAheadLogs {
           }
         }
       } else {
-        HostAndPort address = AddressUtil.parseAddress(entry.getKey(), false);
+        HostAndPort address = AddressUtil.parseAddress(entry.getKey());
         if (!holdsLock(address)) {
           for (Path path : entry.getValue()) {
             log.debug("Removing WAL for offline server " + path);
@@ -215,7 +182,7 @@ public class GarbageCollectWriteAheadLogs {
       }
     }
     
-    for (Path swalog : sortedWALogs.values()) {
+    for (Path swalog : sortedWALogs) {
       log.debug("Removing sorted WAL " + swalog);
       try {
         if (!useTrash || !fs.moveToTrash(swalog)) {
@@ -237,29 +204,14 @@ public class GarbageCollectWriteAheadLogs {
     return 0;
   }
   
-  /**
-   * Converts a list of paths to their corresponding strings.
-   *
-   * @param paths list of paths
-   * @return string forms of paths
-   */
-  static List<String> paths2strings(List<Path> paths) {
+  private List<String> paths2strings(ArrayList<Path> paths) {
     List<String> result = new ArrayList<String>(paths.size());
     for (Path path : paths)
       result.add(path.toString());
     return result;
   }
   
-  /**
-   * Reverses the given mapping of file paths to servers. The returned map
-   * provides a list of file paths for each server. Any path whose name is not
-   * in the mapping of file names to paths is skipped.
-   *
-   * @param fileToServerMap map of file paths to servers
-   * @param nameToFileMap map of file names to paths
-   * @return map of servers to lists of file paths
-   */
-  static Map<String,ArrayList<Path>> mapServersToFiles(Map<Path,String> fileToServerMap, Map<String,Path> nameToFileMap) {
+  private static Map<String,ArrayList<Path>> mapServersToFiles(Map<Path,String> fileToServerMap, Map<String,Path> nameToFileMap) {
     Map<String,ArrayList<Path>> result = new HashMap<String,ArrayList<Path>>();
     for (Entry<Path,String> fileServer : fileToServerMap.entrySet()) {
       if (!nameToFileMap.containsKey(fileServer.getKey().getName()))
@@ -274,23 +226,24 @@ public class GarbageCollectWriteAheadLogs {
     return result;
   }
   
-  private int removeMetadataEntries(Map<String,Path>  nameToFileMap, Map<String, Path> sortedWALogs, GCStatus status) throws IOException, KeeperException,
+  private int removeMetadataEntries(Map<String,Path>  nameToFileMap, Set<Path> sortedWALogs, GCStatus status) throws IOException, KeeperException,
       InterruptedException {
     int count = 0;
     Iterator<LogEntry> iterator = MetadataTableUtil.getLogEntries(SystemCredentials.get());
-
     while (iterator.hasNext()) {
       for (String entry : iterator.next().logSet) {
-        String uuid = new Path(entry).getName();
-        if (!isUUID(uuid)) {
-          // fully expect this to be a uuid, if its not then something is wrong and walog GC should not proceed!
-          throw new IllegalArgumentException("Expected uuid, but got " + uuid + " from " + entry);
-        }
-
-        Path pathFromNN = nameToFileMap.remove(uuid);
+        String parts[] = entry.split("/", 2);
+        String filename = parts[1];
+        Path path;
+        if (filename.contains(":"))
+          path = new Path(filename);
+        else
+          path = fs.getFullPath(FileType.WAL, filename);
+        
+        Path pathFromNN = nameToFileMap.remove(path.getName());
         if (pathFromNN != null) {
           status.currentLog.inUse++;
-          sortedWALogs.remove(uuid);
+          sortedWALogs.remove(pathFromNN);
         }
         count++;
       }
@@ -298,31 +251,13 @@ public class GarbageCollectWriteAheadLogs {
     return count;
   }
 
-  private int scanServers(Map<Path,String> fileToServerMap, Map<String,Path> nameToFileMap) throws Exception {
-    return scanServers(ServerConstants.getWalDirs(), fileToServerMap, nameToFileMap);
-  }
   //TODO Remove deprecation warning suppression when Hadoop1 support is dropped
   @SuppressWarnings("deprecation")
-  /**
-   * Scans write-ahead log directories for logs. The maps passed in are
-   * populated with scan information.
-   *
-   * @param walDirs write-ahead log directories
-   * @param fileToServerMap map of file paths to servers
-   * @param nameToFileMap map of file names to paths
-   * @return number of servers located (including those with no logs present)
-   */
-  int scanServers(String[] walDirs, Map<Path,String> fileToServerMap, Map<String,Path> nameToFileMap) throws Exception {
+  private int scanServers(Map<Path,String> fileToServerMap, Map<String,Path> nameToFileMap) throws Exception {
     Set<String> servers = new HashSet<String>();
-    for (String walDir : walDirs) {
+    for (String walDir : ServerConstants.getWalDirs()) {
       Path walRoot = new Path(walDir);
-      FileStatus[] listing = null;
-      try {
-        listing = fs.listStatus(walRoot);
-      } catch (FileNotFoundException e) {
-        // ignore dir
-      }
-
+      FileStatus[] listing = fs.listStatus(walRoot);
       if (listing == null)
         continue;
       for (FileStatus status : listing) {
@@ -345,29 +280,21 @@ public class GarbageCollectWriteAheadLogs {
         }
       }
     }
+    log.debug("fileToServerMap " + fileToServerMap);
+    log.debug("nameToFileMap " + nameToFileMap);
     return servers.size();
   }
   
-  private Map<String, Path> getSortedWALogs() throws IOException {
-    return getSortedWALogs(ServerConstants.getRecoveryDirs());
-  }
-  /**
-   * Looks for write-ahead logs in recovery directories.
-   *
-   * @param recoveryDirs recovery directories
-   * @return map of log file names to paths
-   */
-  Map<String, Path> getSortedWALogs(String[] recoveryDirs) throws IOException {
-    Map<String, Path> result = new HashMap<String, Path>();
+  private Set<Path> getSortedWALogs() throws IOException {
+    Set<Path> result = new HashSet<Path>();
     
-    for (String dir : recoveryDirs) {
+    for (String dir : ServerConstants.getRecoveryDirs()) {
       Path recoveryDir = new Path(dir);
       
       if (fs.exists(recoveryDir)) {
         for (FileStatus status : fs.listStatus(recoveryDir)) {
-          String name = status.getPath().getName();
-          if (isUUID(name)) {
-            result.put(name, status.getPath());
+          if (isUUID(status.getPath().getName())) {
+            result.add(status.getPath());
           } else {
             log.debug("Ignoring file " + status.getPath() + " because it doesn't look like a uuid");
           }
@@ -377,16 +304,7 @@ public class GarbageCollectWriteAheadLogs {
     return result;
   }
   
-  /**
-   * Checks if a string is a valid UUID.
-   *
-   * @param name string to check
-   * @return true if string is a UUID
-   */
-  static boolean isUUID(String name) {
-    if (name == null || name.length() != 36) {
-      return false;
-    }
+  static private boolean isUUID(String name) {
     try {
       UUID.fromString(name);
       return true;