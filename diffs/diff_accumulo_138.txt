diff --git a/server/src/main/java/org/apache/accumulo/server/tabletserver/log/LogSorter.java b/server/src/main/java/org/apache/accumulo/server/tabletserver/log/LogSorter.java
index 7518edbc51..a29947c042 100644
--- a/server/src/main/java/org/apache/accumulo/server/tabletserver/log/LogSorter.java
+++ b/server/src/main/java/org/apache/accumulo/server/tabletserver/log/LogSorter.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -19,8 +19,8 @@ package org.apache.accumulo.server.tabletserver.log;
 import java.io.DataInputStream;
 import java.io.EOFException;
 import java.io.IOException;
+import java.io.InputStream;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashMap;
@@ -34,12 +34,11 @@ import org.apache.accumulo.core.client.Instance;
 import org.apache.accumulo.core.conf.AccumuloConfiguration;
 import org.apache.accumulo.core.conf.Property;
 import org.apache.accumulo.core.master.thrift.RecoveryStatus;
+import org.apache.accumulo.core.security.crypto.CryptoModule;
 import org.apache.accumulo.core.security.crypto.CryptoModuleFactory;
-import org.apache.accumulo.core.security.crypto.CryptoModuleParameters;
 import org.apache.accumulo.core.util.Pair;
 import org.apache.accumulo.core.util.SimpleThreadPool;
 import org.apache.accumulo.core.zookeeper.ZooUtil;
-import org.apache.accumulo.server.fs.VolumeManager;
 import org.apache.accumulo.server.logger.LogFileKey;
 import org.apache.accumulo.server.logger.LogFileValue;
 import org.apache.accumulo.server.zookeeper.DistributedWorkQueue;
@@ -57,7 +56,7 @@ import org.apache.zookeeper.KeeperException;
 public class LogSorter {
   
   private static final Logger log = Logger.getLogger(LogSorter.class);
-  VolumeManager fs;
+  FileSystem fs;
   AccumuloConfiguration conf;
   
   private final Map<String,LogProcessor> currentWork = Collections.synchronizedMap(new HashMap<String,LogProcessor>());
@@ -77,24 +76,21 @@ public class LogSorter {
     
     @Override
     public void process(String child, byte[] data) {
-      String work = new String(data);
-      String[] parts = work.split("\\|");
-      String src = parts[0];
-      String dest = parts[1];
-      String sortId = new Path(src).getName();
-      log.debug("Sorting " + src + " to " + dest + " using sortId " + sortId);
+      String dest = Constants.getRecoveryDir(conf) + "/" + child;
+      String src = new String(data);
+      String name = new Path(src).getName();
       
       synchronized (currentWork) {
-        if (currentWork.containsKey(sortId))
+        if (currentWork.containsKey(name))
           return;
-        currentWork.put(sortId, this);
+        currentWork.put(name, this);
       }
       
       try {
         log.info("Copying " + src + " to " + dest);
-        sort(sortId, new Path(src), dest);
+        sort(name, new Path(src), dest);
       } finally {
-        currentWork.remove(sortId);
+        currentWork.remove(name);
       }
       
     }
@@ -110,47 +106,56 @@ public class LogSorter {
       try {
         
         // the following call does not throw an exception if the file/dir does not exist
-        fs.deleteRecursively(new Path(destPath));
+        fs.delete(new Path(destPath), true);
         
         FSDataInputStream tmpInput = fs.open(srcPath);
-                
-        byte[] magic = DfsLogger.LOG_FILE_HEADER_V2.getBytes();
-        byte[] magicBuffer = new byte[magic.length];
-        tmpInput.readFully(magicBuffer);
-        if (!Arrays.equals(magicBuffer, magic)) {
-          tmpInput.seek(0);
+        DataInputStream tmpDecryptingInput = tmpInput;
+        
+        String logHeader = tmpInput.readUTF();
+        Map<String,String> cryptoOpts = new HashMap<String,String>();
+        
+        if (!logHeader.equals(DfsLogger.LOG_FILE_HEADER_V2)) {
+          
+          log.debug("Not a V2 log file, so re-opening it and passing it on");
+          
+          // Hmmm, this isn't the log file I was expecting, so close it and reopen to unread those bytes.
+          tmpInput.close();
+          tmpInput = fs.open(srcPath);
+          
           synchronized (this) {
-           this.input = tmpInput;
-           this.decryptingInput = tmpInput;
+            this.input = tmpInput;
+            this.decryptingInput = tmpInput;
           }
+          
         } else {
-          // We read the crypto module class name here because we need to boot strap the class.  The class itself will read any 
-          // additional parameters it needs from the underlying stream.
-          String cryptoModuleClassname = tmpInput.readUTF();
-          org.apache.accumulo.core.security.crypto.CryptoModule cryptoModule = org.apache.accumulo.core.security.crypto.CryptoModuleFactory
-              .getCryptoModule(cryptoModuleClassname);
           
-          // Create the parameters and set the input stream into those parameters
-          CryptoModuleParameters params = CryptoModuleFactory.createParamsObjectFromAccumuloConfiguration(conf);
-          params.setEncryptedInputStream(tmpInput);
+          int numEntries = tmpInput.readInt();
+          for (int i = 0; i < numEntries; i++) {
+            cryptoOpts.put(tmpInput.readUTF(), tmpInput.readUTF());
+          }
           
-          // Create the plaintext input stream from the encrypted one
-          params = cryptoModule.getDecryptingInputStream(params);
+          String cryptoModuleName = cryptoOpts.get(Property.CRYPTO_MODULE_CLASS.getKey());
+          if (cryptoModuleName == null) {
+            // If for whatever reason we didn't get a configured crypto module (old log file version, for instance)
+            // default to using the default configuration entry (usually NullCipher).
+            cryptoModuleName = AccumuloConfiguration.getDefaultConfiguration().get(Property.CRYPTO_MODULE_CLASS);
+          }
           
-          // Store the plaintext input stream into member variables
           synchronized (this) {
             this.input = tmpInput;
-            
-            if (params.getPlaintextInputStream() instanceof DataInputStream) {
-              this.decryptingInput = (DataInputStream)params.getPlaintextInputStream();              
-            } else {
-              this.decryptingInput = new DataInputStream(params.getPlaintextInputStream());
-            }
-            
           }
           
+          @SuppressWarnings("deprecation")
+          CryptoModule cryptoOps = CryptoModuleFactory.getCryptoModule(cryptoModuleName);
+          @SuppressWarnings("deprecation")
+          InputStream decryptingInputStream = cryptoOps.getDecryptingInputStream(input, cryptoOpts);
+          
+          tmpDecryptingInput = new DataInputStream(decryptingInputStream);
+          
+          synchronized (this) {
+            this.decryptingInput = tmpDecryptingInput;
+          }
         }
-                
         
         final long bufferSize = conf.getMemoryInBytes(Property.TSERV_SORT_BUFFER_SIZE);
         Thread.currentThread().setName("Sorting " + name + " for recovery");
@@ -187,7 +192,7 @@ public class LogSorter {
         Thread.currentThread().setName(formerThreadName);
         try {
           close();
-        } catch (Exception e) {
+        } catch (IOException e) {
           log.error("Error during cleanup sort/copy " + name, e);
         }
         synchronized (this) {
@@ -197,9 +202,8 @@ public class LogSorter {
     }
     
     private void writeBuffer(String destPath, ArrayList<Pair<LogFileKey,LogFileValue>> buffer, int part) throws IOException {
-      Path path = new Path(destPath, String.format("part-r-%05d", part++));
-      FileSystem ns = fs.getFileSystemByPath(path);
-      MapFile.Writer output = new MapFile.Writer(ns.getConf(), ns, path.toString(), LogFileKey.class, LogFileValue.class);
+      String path = destPath + String.format("/part-r-%05d", part++);
+      MapFile.Writer output = new MapFile.Writer(fs.getConf(), fs, path, LogFileKey.class, LogFileValue.class);
       try {
         Collections.sort(buffer, new Comparator<Pair<LogFileKey,LogFileValue>>() {
           @Override
@@ -237,9 +241,9 @@ public class LogSorter {
   }
   
   ThreadPoolExecutor threadPool;
-  private final Instance instance;
+  private Instance instance;
   
-  public LogSorter(Instance instance, VolumeManager fs, AccumuloConfiguration conf) {
+  public LogSorter(Instance instance, FileSystem fs, AccumuloConfiguration conf) {
     this.instance = instance;
     this.fs = fs;
     this.conf = conf;