diff --git a/src/main/java/org/apache/aries/blueprint/container/BlueprintContainerImpl.java b/src/main/java/org/apache/aries/blueprint/container/BlueprintContainerImpl.java
index a169bb402..e0c2708ea 100644
--- a/src/main/java/org/apache/aries/blueprint/container/BlueprintContainerImpl.java
+++ b/src/main/java/org/apache/aries/blueprint/container/BlueprintContainerImpl.java
@@ -23,9 +23,12 @@ import java.net.URI;
 import java.net.URL;
 import java.security.AccessControlContext;
 import java.security.AccessController;
+import java.security.DomainCombiner;
+import java.security.Permission;
 import java.security.PrivilegedAction;
 import java.security.PrivilegedActionException;
 import java.security.PrivilegedExceptionAction;
+import java.security.ProtectionDomain;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -38,9 +41,8 @@ import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
+import java.util.concurrent.ScheduledThreadPoolExecutor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -48,23 +50,20 @@ import java.util.concurrent.atomic.AtomicBoolean;
 import org.apache.aries.blueprint.BlueprintConstants;
 import org.apache.aries.blueprint.ComponentDefinitionRegistryProcessor;
 import org.apache.aries.blueprint.ExtendedBeanMetadata;
+import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
 import org.apache.aries.blueprint.NamespaceHandler;
 import org.apache.aries.blueprint.Processor;
-import org.apache.aries.blueprint.di.ExecutionContext;
 import org.apache.aries.blueprint.di.Recipe;
 import org.apache.aries.blueprint.di.Repository;
 import org.apache.aries.blueprint.namespace.NamespaceHandlerRegistryImpl;
 import org.apache.aries.blueprint.parser.ComponentDefinitionRegistryImpl;
-import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
 import org.apache.aries.blueprint.parser.Parser;
-import org.apache.aries.blueprint.proxy.ProxyUtils;
+import org.apache.aries.blueprint.parser.NamespaceHandlerSet;
 import org.apache.aries.blueprint.reflect.MetadataUtil;
 import org.apache.aries.blueprint.reflect.PassThroughMetadataImpl;
-import org.apache.aries.blueprint.services.ExtendedBlueprintContainer;
 import org.apache.aries.blueprint.utils.HeaderParser;
-import org.apache.aries.blueprint.utils.HeaderParser.PathElement;
 import org.apache.aries.blueprint.utils.JavaUtils;
-import org.apache.aries.proxy.ProxyManager;
+import org.apache.aries.blueprint.utils.HeaderParser.PathElement;
 import org.apache.aries.util.AriesFrameworkUtil;
 import org.osgi.framework.Bundle;
 import org.osgi.framework.BundleContext;
@@ -100,19 +99,10 @@ import org.slf4j.LoggerFactory;
  *
  * @version $Rev$, $Date$
  */
-@SuppressWarnings("deprecation") // due to the deprecated org.apache.aries.blueprint.ExtendedBlueprintContainer
-public class BlueprintContainerImpl 
-    implements ExtendedBlueprintContainer, NamespaceHandlerSet.Listener, 
-    Runnable, SatisfiableRecipe.SatisfactionListener,
-    org.apache.aries.blueprint.ExtendedBlueprintContainer {
+public class BlueprintContainerImpl implements ExtendedBlueprintContainer, NamespaceHandlerSet.Listener, Runnable, SatisfiableRecipe.SatisfactionListener {
 
     private static final Logger LOGGER = LoggerFactory.getLogger(BlueprintContainerImpl.class);
 
-    private static final Class[] SECURITY_BUGFIX = {
-            BlueprintDomainCombiner.class,
-            BlueprintProtectionDomain.class,
-    };
-    
     private enum State {
         Unknown,
         WaitForNamespaceHandlers,
@@ -126,19 +116,17 @@ public class BlueprintContainerImpl
     }
 
     private final BundleContext bundleContext;
-    private final Bundle bundle;
     private final Bundle extenderBundle;
     private final BlueprintListener eventDispatcher;
     private final NamespaceHandlerRegistry handlers;
     private final List<Object> pathList;
     private final ComponentDefinitionRegistryImpl componentDefinitionRegistry;
     private final AggregateConverter converter;
-    private final ExecutorService executors;
-    private final ScheduledExecutorService timer;
+    private final ScheduledThreadPoolExecutor executors;
     private Set<URI> namespaces;
     private State state = State.Unknown;
     private NamespaceHandlerSet handlerSet;
-    private final AtomicBoolean destroyed = new AtomicBoolean(false);
+    private boolean destroyed;
     private Parser parser;
     private BlueprintRepository repository;
     private ServiceRegistration registration;
@@ -150,15 +138,12 @@ public class BlueprintContainerImpl
     private boolean xmlValidation = true;
     private ScheduledFuture timeoutFuture;
     private final AtomicBoolean scheduled = new AtomicBoolean();
+    private final AtomicBoolean running = new AtomicBoolean();
     private List<ServiceRecipe> services;
-    private final AccessControlContext accessControlContext;
+    private AccessControlContext accessControlContext;
     private final IdSpace tempRecipeIdSpace = new IdSpace();
-    private final ProxyManager proxyManager;
-
-    public BlueprintContainerImpl(Bundle bundle, BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher,
-                                  NamespaceHandlerRegistry handlers, ExecutorService executor, ScheduledExecutorService timer,
-                                  List<Object> pathList, ProxyManager proxyManager) {
-        this.bundle = bundle;
+    
+    public BlueprintContainerImpl(BundleContext bundleContext, Bundle extenderBundle, BlueprintListener eventDispatcher, NamespaceHandlerRegistry handlers, ScheduledThreadPoolExecutor executors, List<Object> pathList) {
         this.bundleContext = bundleContext;
         this.extenderBundle = extenderBundle;
         this.eventDispatcher = eventDispatcher;
@@ -166,29 +151,17 @@ public class BlueprintContainerImpl
         this.pathList = pathList;
         this.converter = new AggregateConverter(this);
         this.componentDefinitionRegistry = new ComponentDefinitionRegistryImpl();
-        this.executors = executor != null ? new ExecutorServiceWrapper(executor) : null;
-        this.timer = timer;
+        this.executors = executors;
         this.processors = new ArrayList<Processor>();
         if (System.getSecurityManager() != null) {
-            this.accessControlContext = BlueprintDomainCombiner.createAccessControlContext(bundleContext);
-        } else {
-            this.accessControlContext = null;
+            this.accessControlContext = createAccessControlContext();
         }
-        this.proxyManager = proxyManager;
-    }
-
-    public ExecutorService getExecutors() {
-        return executors;
     }
 
     public Bundle getExtenderBundle() {
         return extenderBundle;
     }
 
-    public ProxyManager getProxyManager() {
-        return proxyManager;
-    }
-
     public <T extends Processor> List<T> getProcessors(Class<T> clazz) {
         List<T> p = new ArrayList<T>();
         for (Processor processor : processors) {
@@ -203,7 +176,8 @@ public class BlueprintContainerImpl
         return eventDispatcher;
     }
 
-    private void readDirectives() {
+    private void checkDirectives() {
+        Bundle bundle = bundleContext.getBundle();
         Dictionary headers = bundle.getHeaders();
         String symbolicName = (String)headers.get(Constants.BUNDLE_SYMBOLICNAME);
         List<PathElement> paths = HeaderParser.parseHeader(symbolicName);
@@ -226,7 +200,7 @@ public class BlueprintContainerImpl
             xmlValidation = Boolean.parseBoolean(xmlValidationDirective);
         }
     }
-
+    
     public void schedule() {
         if (scheduled.compareAndSet(false, true)) {
             executors.submit(this);
@@ -234,31 +208,29 @@ public class BlueprintContainerImpl
     }
 
     public void reload() {
-        synchronized (scheduled) {
-            if (destroyed.get()) {
-                return;
-            }
-            tidyupComponents();
-            this.componentDefinitionRegistry.reset();
-            this.repository = null;
-            this.processors = new ArrayList<Processor>();
-            timeout = 5 * 60 * 1000;
-            waitForDependencies = true;
-            xmlValidation = true;
-            if (handlerSet != null) {
-                handlerSet.removeListener(this);
-                handlerSet.destroy();
-                handlerSet = null;
-            }
-            state = State.Unknown;
-            schedule();
-        }
+        tidyupComponents();
+        this.componentDefinitionRegistry.reset();
+        this.repository = null;
+        this.processors = new ArrayList<Processor>();
+        timeout = 5 * 60 * 1000;
+        waitForDependencies = true;
+        xmlValidation = true;
+        state = State.Unknown;
+        schedule();
     }
 
     public void run() {
         scheduled.set(false);
         synchronized (scheduled) {
-            doRun();
+            synchronized (running) {
+                running.set(true);
+                try {
+                    doRun();
+                } finally {
+                    running.set(false);
+                    running.notifyAll();
+                }
+            }
         }
     }
 
@@ -268,45 +240,36 @@ public class BlueprintContainerImpl
     private void doRun() {
         try {
             for (;;) {
-                if (destroyed.get()) {
-                    return;
-                }
-                if (bundle.getState() != Bundle.ACTIVE && bundle.getState() != Bundle.STARTING) {
-                    return;
-                }
-                if (bundle.getBundleContext() != bundleContext) {
+                if (destroyed) {
                     return;
                 }
-                LOGGER.debug("Running blueprint container for bundle {} in state {}", bundle.getSymbolicName(), state);
+                LOGGER.debug("Running blueprint container for bundle {} in state {}", bundleContext.getBundle().getSymbolicName(), state);
                 switch (state) {
                     case Unknown:
-                        readDirectives();
-                        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATING, getBundle(), getExtenderBundle()));
+                        checkDirectives();
+                        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATING, getBundleContext().getBundle(), getExtenderBundle()));
                         parser = new Parser();
                         parser.parse(getResources());
                         namespaces = parser.getNamespaces();
-                        handlerSet = handlers.getNamespaceHandlers(namespaces, getBundle());
+                        handlerSet = handlers.getNamespaceHandlers(namespaces, getBundleContext().getBundle());
                         handlerSet.addListener(this);
                         state = State.WaitForNamespaceHandlers;
                         break;
                     case WaitForNamespaceHandlers:
                     {
                         List<String> missing = new ArrayList<String>();
-                        List<URI> missingURIs = new ArrayList<URI>();
                         for (URI ns : namespaces) {
                             if (handlerSet.getNamespaceHandler(ns) == null) {
                                 missing.add("(&(" + Constants.OBJECTCLASS + "=" + NamespaceHandler.class.getName() + ")(" + NamespaceHandlerRegistryImpl.NAMESPACE + "=" + ns + "))");
-                                missingURIs.add(ns);
                             }
                         }
                         if (missing.size() > 0) {
-                            LOGGER.info("Bundle {} is waiting for namespace handlers {}", getBundle().getSymbolicName(), missingURIs);
-                            eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missing.toArray(new String[missing.size()])));
+                            LOGGER.info("Bundle {} is waiting for namespace handlers ", bundleContext.getBundle().getSymbolicName(), missing);
+                            eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundleContext().getBundle(), getExtenderBundle(), missing.toArray(new String[missing.size()])));
                             return;
                         }
-                        componentDefinitionRegistry.reset();
                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintContainer", this));
-                        componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundle));
+                        componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundle", bundleContext.getBundle()));
                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintBundleContext", bundleContext));
                         componentDefinitionRegistry.registerComponentDefinition(new PassThroughMetadataImpl("blueprintConverter", converter));
                         if (xmlValidation) {
@@ -322,27 +285,24 @@ public class BlueprintContainerImpl
                         Runnable r = new Runnable() {
                             public void run() {
                                 synchronized (scheduled) {
-                                    if (destroyed.get()) {
-                                        return;
-                                    }
                                     Throwable t = new TimeoutException();
                                     state = State.Failed;
                                     String[] missingDependecies = getMissingDependencies();
                                     tidyupComponents();
-                                    LOGGER.error("Unable to start blueprint container for bundle " + getBundle().getSymbolicName() + " due to unresolved dependencies " + Arrays.asList(missingDependecies), t);
-                                    eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), missingDependecies, t));
+                                    LOGGER.error("Unable to start blueprint container for bundle " + bundleContext.getBundle().getSymbolicName() + " due to unresolved dependencies " + Arrays.asList(missingDependecies), t);
+                                    eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundleContext().getBundle(), getExtenderBundle(), missingDependecies, t));
                                 }
                             }
                         };
-                        timeoutFuture = timer.schedule(r, timeout, TimeUnit.MILLISECONDS);
+                        timeoutFuture = executors.schedule(r, timeout, TimeUnit.MILLISECONDS);
                         state = State.WaitForInitialReferences;
                         break;
                     case WaitForInitialReferences:
                         if (waitForDependencies) {
                             String[] missingDependencies = getMissingDependencies();
                             if (missingDependencies.length > 0) {
-                                LOGGER.info("Bundle {} is waiting for dependencies {}", getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
-                                eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missingDependencies));
+                                LOGGER.info("Bundle {} is waiting for dependencies {}", bundleContext.getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
+                                eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundleContext().getBundle(), getExtenderBundle(), missingDependencies));
                                 return;
                             }
                         }
@@ -357,28 +317,29 @@ public class BlueprintContainerImpl
                         if (waitForDependencies) {
                             String[] missingDependencies = getMissingDependencies();
                             if (missingDependencies.length > 0) {
-                                LOGGER.info("Bundle {} is waiting for dependencies {}", getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
-                                eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundle(), getExtenderBundle(), missingDependencies));
+                                LOGGER.info("Bundle {} is waiting for dependencies {}", bundleContext.getBundle().getSymbolicName(), Arrays.asList(missingDependencies));
+                                eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.GRACE_PERIOD, getBundleContext().getBundle(), getExtenderBundle(), missingDependencies));
                                 return;
                             }
                         }                       
                         state = State.Create;
                         break;
                     case Create:
-                        cancelFutureIfPresent();
+                        timeoutFuture.cancel(false);
+                        executors.purge();
                         registerServices();
                         instantiateEagerComponents();
                         // Register the BlueprintContainer in the OSGi registry
-                        int bs = bundle.getState();
+                        int bs = bundleContext.getBundle().getState();
                         if (registration == null && (bs == Bundle.ACTIVE || bs == Bundle.STARTING)) {
                             Properties props = new Properties();
                             props.put(BlueprintConstants.CONTAINER_SYMBOLIC_NAME_PROPERTY,
-                                      bundle.getSymbolicName());
+                                      bundleContext.getBundle().getSymbolicName());
                             props.put(BlueprintConstants.CONTAINER_VERSION_PROPERTY,
-                                      JavaUtils.getBundleVersion(bundle));
+                                      JavaUtils.getBundleVersion(bundleContext.getBundle()));
                             registration = registerService(new String [] { BlueprintContainer.class.getName() }, this, props);
                         }
-                        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATED, getBundle(), getExtenderBundle()));
+                        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.CREATED, getBundleContext().getBundle(), getExtenderBundle()));
                         state = State.Created;
                         break;
                     case Created:
@@ -388,10 +349,12 @@ public class BlueprintContainerImpl
             }
         } catch (Throwable t) {
             state = State.Failed;
-            cancelFutureIfPresent();
+            if (timeoutFuture != null) {
+                timeoutFuture.cancel(false);
+            }
             tidyupComponents();
-            LOGGER.error("Unable to start blueprint container for bundle " + getBundle().getSymbolicName(), t);
-            eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundle(), getExtenderBundle(), t));
+            LOGGER.error("Unable to start blueprint container for bundle " + bundleContext.getBundle().getSymbolicName(), t);
+            eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.FAILURE, getBundleContext().getBundle(), getExtenderBundle(), t));
         }
     }
 
@@ -401,7 +364,7 @@ public class BlueprintContainerImpl
             if (path instanceof URL) {
                 resources.add((URL) path);                
             } else if (path instanceof String) {
-                URL url = bundle.getEntry((String) path);
+                URL url = bundleContext.getBundle().getEntry((String) path);
                 if (url == null) {
                     throw new FileNotFoundException("Unable to find configuration file for " + path);
                 } else {
@@ -416,12 +379,12 @@ public class BlueprintContainerImpl
     
     public Class loadClass(final String name) throws ClassNotFoundException {
         if (accessControlContext == null) {
-            return bundle.loadClass(name);
+            return bundleContext.getBundle().loadClass(name);
         } else {
             try {
                 return AccessController.doPrivileged(new PrivilegedExceptionAction<Class>() {
                     public Class run() throws Exception {
-                        return bundle.loadClass(name);
+                        return bundleContext.getBundle().loadClass(name);
                     }            
                 }, accessControlContext);
             } catch (PrivilegedActionException e) {
@@ -458,6 +421,21 @@ public class BlueprintContainerImpl
         }
     }
     
+    private AccessControlContext createAccessControlContext() {
+        return new AccessControlContext(AccessController.getContext(),
+                new DomainCombiner() {               
+                    public ProtectionDomain[] combine(ProtectionDomain[] arg0,
+                                                      ProtectionDomain[] arg1) {                    
+                        return new ProtectionDomain[] { new ProtectionDomain(null, null) {                        
+                            public boolean implies(Permission permission) {                                                           
+                                return bundleContext.getBundle().hasPermission(permission);
+                            }
+                        } 
+                    };
+                }
+        });
+    }
+    
     public AccessControlContext getAccessControlContext() {
         return accessControlContext;
     }
@@ -481,7 +459,7 @@ public class BlueprintContainerImpl
             }
         }
 
-        Map<String, Object> objects = repository.createAll(typeConverters, ProxyUtils.asList(Converter.class));
+        Map<String, Object> objects = repository.createAll(typeConverters);
         for (String name : typeConverters) {
             Object obj = objects.get(name);
             if (obj instanceof Converter) {
@@ -493,7 +471,7 @@ public class BlueprintContainerImpl
     }
 
     private void processProcessors() throws Exception {
-        // Instantiate ComponentDefinitionRegistryProcessor and BeanProcessor
+        // Instanciate ComponentDefinitionRegistryProcessor and BeanProcessor
         for (BeanMetadata bean : getMetadata(BeanMetadata.class)) {
             if (bean instanceof ExtendedBeanMetadata && !((ExtendedBeanMetadata) bean).isProcessor()) {
                 continue;
@@ -511,44 +489,43 @@ public class BlueprintContainerImpl
             }
 
             if (ComponentDefinitionRegistryProcessor.class.isAssignableFrom(clazz)) {
-                Object obj = repository.create(bean.getId(), ProxyUtils.asList(ComponentDefinitionRegistryProcessor.class));
+                Object obj = repository.create(bean.getId());
                 ((ComponentDefinitionRegistryProcessor) obj).process(componentDefinitionRegistry);
             } else if (Processor.class.isAssignableFrom(clazz)) {
-                Object obj = repository.create(bean.getId(), ProxyUtils.asList(Processor.class));
+                Object obj = repository.create(bean.getId());
                 this.processors.add((Processor) obj);
-            } else { 
+            } else {
                 continue;
             }
+            // Update repository with recipes processed by the processors
             untrackServiceReferences();
-            updateUninstantiatedRecipes();
-            getSatisfiableDependenciesMap(true);
-            trackServiceReferences();        
-        }
-    }
-    private void updateUninstantiatedRecipes() {
-        Repository tmpRepo = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
-        
-        LOGGER.debug("Updating blueprint repository");
-        
-        for (String name : repository.getNames()) {
-            if (repository.getInstance(name) == null) {
-                LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
-                repository.removeRecipe(name);
-            } else {
-                LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
+            Repository tmpRepo = new RecipeBuilder(this, tempRecipeIdSpace).createRepository();
+            
+            LOGGER.debug("Updating blueprint repository");
+            
+            for (String name : repository.getNames()) {
+                if (repository.getInstance(name) == null) {
+                    LOGGER.debug("Removing uninstantiated recipe {}", new Object[] { name });
+                    repository.removeRecipe(name);
+                } else {
+                    LOGGER.debug("Recipe {} is already instantiated", new Object[] { name });
+                }
             }
-        }
-        
-        for (String name : tmpRepo.getNames()) {
-            if (repository.getInstance(name) == null) {
-                LOGGER.debug("Adding new recipe {}", new Object[] { name });
-                Recipe r = tmpRepo.getRecipe(name);
-                if (r != null) {
-                    repository.putRecipe(name, r);
+            
+            for (String name : tmpRepo.getNames()) {
+                if (repository.getInstance(name) == null) {
+                    LOGGER.debug("Adding new recipe {}", new Object[] { name });
+                    Recipe r = tmpRepo.getRecipe(name);
+                    if (r != null) {
+                        repository.putRecipe(name, r);
+                    }
+                } else {
+                    LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
                 }
-            } else {
-                LOGGER.debug("Recipe {} is already instantiated and cannot be updated", new Object[] { name });
             }
+            
+            getSatisfiableDependenciesMap(true);
+            trackServiceReferences();
         }
     }
 
@@ -594,10 +571,6 @@ public class BlueprintContainerImpl
                 }
             }
         }
-
-        synchronized (satisfiablesLock) {
-            satisfiables = null;
-        }
     }
 
     private void untrackServiceReference(SatisfiableRecipe recipe, Set<String> stopped, Map<String, List<SatisfiableRecipe>> dependencies) {
@@ -615,11 +588,8 @@ public class BlueprintContainerImpl
     }
 
     public void notifySatisfaction(SatisfiableRecipe satisfiable) {
-        if (destroyed.get()) {
-            return;
-        }
         LOGGER.debug("Notified satisfaction {} in bundle {}: {}",
-                new Object[] { satisfiable.getName(), bundle.getSymbolicName(), satisfiable.isSatisfied() });
+                new Object[] { satisfiable.getName(), bundleContext.getBundle().getSymbolicName(), satisfiable.isSatisfied() });
         if (state == State.Create || state == State.Created ) {
             Map<String, List<SatisfiableRecipe>> dependencies = getSatisfiableDependenciesMap();
             for (Map.Entry<String, List<SatisfiableRecipe>> entry : dependencies.entrySet()) {
@@ -738,7 +708,7 @@ public class BlueprintContainerImpl
     }
     
     public Object getComponentInstance(String id) throws NoSuchComponentException {
-        if (repository == null || destroyed.get()) {
+        if (repository == null) {
             throw new NoSuchComponentException(id);
         }
         try {
@@ -832,52 +802,56 @@ public class BlueprintContainerImpl
     public BundleContext getBundleContext() {
         return bundleContext;
     }
-
-    public Bundle getBundle() {
-        return bundle;
-    }
-
+    
     public void destroy() {
-        synchronized (scheduled) {
-            destroyed.set(true);
-        }
-        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
-        executors.shutdownNow();
-        if (handlerSet != null) {
-            handlerSet.removeListener(this);
-            handlerSet.destroy();
+        destroyed = true;
+        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundleContext().getBundle(), getExtenderBundle()));
+
+        if (timeoutFuture != null) {
+            timeoutFuture.cancel(false);
+            executors.purge();
         }
+        AriesFrameworkUtil.safeUnregisterService(registration);
+        
+        unregisterServices();
 
-        try {
-            executors.awaitTermination(5 * 60, TimeUnit.SECONDS);
-        } catch (InterruptedException e) {
-            LOGGER.debug("Interrupted waiting for executor to shut down");
+        synchronized (running) {
+            if (handlerSet != null) {
+                handlerSet.removeListener(this);
+                handlerSet.destroy();
+            }
+            
+            while (running.get()) {
+                try {
+                    running.wait();
+                } catch (InterruptedException e) {
+                    // Ignore
+                }
+            }
         }
 
-        tidyupComponents();
+        destroyComponents();
+        
+        untrackServiceReferences();
 
-        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYED, getBundle(), getExtenderBundle()));
+        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYED, getBundleContext().getBundle(), getExtenderBundle()));
         LOGGER.debug("Blueprint container destroyed: {}", this.bundleContext);
     }
     
     protected void quiesce() {
-        destroyed.set(true);
-        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundle(), getExtenderBundle()));
+        destroyed = true;
+        eventDispatcher.blueprintEvent(new BlueprintEvent(BlueprintEvent.DESTROYING, getBundleContext().getBundle(), getExtenderBundle()));
 
-        cancelFutureIfPresent();
+        if (timeoutFuture != null) {
+            timeoutFuture.cancel(false);
+            executors.purge();
+        }
         AriesFrameworkUtil.safeUnregisterService(registration);
         if (handlerSet != null) {
             handlerSet.removeListener(this);
             handlerSet.destroy();
         }
-        LOGGER.debug("Blueprint container quiesced: {}", getBundleContext());
-    }
-
-    private void cancelFutureIfPresent()
-    {
-      if (timeoutFuture != null) {
-          timeoutFuture.cancel(false);
-      }
+        LOGGER.debug("Blueprint container quiesced: {}", this.bundleContext);
     }
 
     public void namespaceHandlerRegistered(URI uri) {
@@ -888,48 +862,18 @@ public class BlueprintContainerImpl
 
     public void namespaceHandlerUnregistered(URI uri) {
         if (namespaces != null && namespaces.contains(uri)) {
-            synchronized (scheduled) {
-                if (destroyed.get()) {
-                    return;
-                }
-                tidyupComponents();
-                this.componentDefinitionRegistry.reset();
-                this.repository = null;
-                state = State.WaitForNamespaceHandlers;
-                schedule();
-            }
+            tidyupComponents();
+            state = State.WaitForNamespaceHandlers;
+            schedule();
         }
     }
 
     private void tidyupComponents()
     {
-      untrackServiceReferences();
       unregisterServices();
       destroyComponents();
+      untrackServiceReferences();
     }
 
-    public void injectBeanInstance(BeanMetadata bmd, Object o) 
-        throws IllegalArgumentException, ComponentDefinitionException {
-        ExecutionContext origContext 
-            = ExecutionContext.Holder.setContext((ExecutionContext)getRepository());
-        try {
-            ComponentMetadata cmd = componentDefinitionRegistry.getComponentDefinition(bmd.getId());
-            if (cmd == null || cmd != bmd) {
-                throw new IllegalArgumentException(bmd.getId() + " not found in blueprint container");
-            }
-            Recipe r = this.getRepository().getRecipe(bmd.getId());
-            if (r instanceof BeanRecipe) {
-                BeanRecipe br = (BeanRecipe)r;
-                if (!br.getType().isInstance(o)) {
-                    throw new IllegalArgumentException("Instance class " + o.getClass().getName() 
-                                                       + " is not an instance of " + br.getClass());
-                }
-                br.setProperties(o);
-            } else {
-                throw new IllegalArgumentException(bmd.getId() + " does not refer to a BeanRecipe");
-            }
-        } finally {
-            ExecutionContext.Holder.setContext(origContext);
-        }
-    }
 }
+