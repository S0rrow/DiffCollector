diff --git a/client/src/main/java/org/apache/atlas/AtlasClient.java b/client/src/main/java/org/apache/atlas/AtlasClient.java
index 70e1a0d05..be178dc70 100755
--- a/client/src/main/java/org/apache/atlas/AtlasClient.java
+++ b/client/src/main/java/org/apache/atlas/AtlasClient.java
@@ -20,20 +20,26 @@ package org.apache.atlas;
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableSet;
-
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.sun.jersey.api.client.Client;
+import com.sun.jersey.api.client.ClientHandlerException;
+import com.sun.jersey.api.client.ClientResponse;
 import com.sun.jersey.api.client.WebResource;
-
-import org.apache.atlas.type.AtlasType;
+import com.sun.jersey.api.client.config.DefaultClientConfig;
+import com.sun.jersey.api.client.filter.HTTPBasicAuthFilter;
+import com.sun.jersey.client.urlconnection.URLConnectionClientHandler;
+import org.apache.atlas.security.SecureClientUtils;
 import org.apache.atlas.typesystem.Referenceable;
 import org.apache.atlas.typesystem.Struct;
 import org.apache.atlas.typesystem.TypesDef;
 import org.apache.atlas.typesystem.json.InstanceSerialization;
 import org.apache.atlas.typesystem.json.TypesSerialization;
 import org.apache.atlas.typesystem.types.AttributeDefinition;
-import org.apache.atlas.typesystem.types.DataTypes;
 import org.apache.atlas.typesystem.types.HierarchicalTypeDefinition;
 import org.apache.atlas.typesystem.types.TraitType;
 import org.apache.atlas.typesystem.types.utils.TypesUtil;
+import org.apache.atlas.utils.AuthenticationUtil;
 import org.apache.commons.configuration.Configuration;
 import org.apache.commons.lang.StringUtils;
 import org.apache.hadoop.security.UserGroupInformation;
@@ -43,6 +49,12 @@ import org.codehaus.jettison.json.JSONObject;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.ws.rs.HttpMethod;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import javax.ws.rs.core.UriBuilder;
+import java.io.IOException;
+import java.net.ConnectException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collection;
@@ -50,15 +62,15 @@ import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
-import javax.ws.rs.HttpMethod;
-import javax.ws.rs.core.Response;
+import static org.apache.atlas.security.SecurityProperties.TLS_ENABLED;
 
 /**
  * Client for metadata.
  */
-public class AtlasClient extends AtlasBaseClient {
+public class AtlasClient {
     private static final Logger LOG = LoggerFactory.getLogger(AtlasClient.class);
 
+    public static final String NAME = "name";
     public static final String TYPE = "type";
     public static final String TYPENAME = "typeName";
     public static final String GUID = "GUID";
@@ -78,45 +90,58 @@ public class AtlasClient extends AtlasBaseClient {
     public static final String START_KEY = "startKey";
     public static final String NUM_RESULTS = "count";
 
+    public static final String BASE_URI = "api/atlas/";
+    public static final String ADMIN_VERSION = "admin/version";
+    public static final String ADMIN_STATUS = "admin/status";
+    public static final String TYPES = "types";
     public static final String URI_ENTITY = "entities";
     public static final String URI_ENTITY_AUDIT = "audit";
     public static final String URI_SEARCH = "discovery/search";
     public static final String URI_NAME_LINEAGE = "lineage/hive/table";
     public static final String URI_LINEAGE = "lineage/";
     public static final String URI_TRAITS = "traits";
-    public static final String TRAITS = "traits";
-    public static final String TRAIT_DEFINITIONS = "traitDefinitions";
-
 
     public static final String QUERY = "query";
-    public static final String LIMIT = "limit";
-    public static final String OFFSET = "offset";
     public static final String QUERY_TYPE = "queryType";
     public static final String ATTRIBUTE_NAME = "property";
     public static final String ATTRIBUTE_VALUE = "value";
 
-    public static final String SUPERTYPE = "supertype";
-    public static final String NOT_SUPERTYPE = "notsupertype";
-
-    public static final String ASSET_TYPE = "Asset";
-    public static final String NAME = "name";
-    public static final String DESCRIPTION = "description";
-    public static final String OWNER = "owner";
 
     public static final String INFRASTRUCTURE_SUPER_TYPE = "Infrastructure";
     public static final String DATA_SET_SUPER_TYPE = "DataSet";
     public static final String PROCESS_SUPER_TYPE = "Process";
-    public static final String PROCESS_ATTRIBUTE_INPUTS = "inputs";
-    public static final String PROCESS_ATTRIBUTE_OUTPUTS = "outputs";
-
     public static final String REFERENCEABLE_SUPER_TYPE = "Referenceable";
     public static final String REFERENCEABLE_ATTRIBUTE_NAME = "qualifiedName";
 
+    public static final String PROCESS_ATTRIBUTE_INPUTS = "inputs";
+    public static final String PROCESS_ATTRIBUTE_OUTPUTS = "outputs";
+
+    public static final String JSON_MEDIA_TYPE = MediaType.APPLICATION_JSON + "; charset=UTF-8";
     public static final String UNKNOWN_STATUS = "Unknown status";
 
+    public static final String ATLAS_CLIENT_HA_RETRIES_KEY = "atlas.client.ha.retries";
+    // Setting the default value based on testing failovers while client code like quickstart is running.
+    public static final int DEFAULT_NUM_RETRIES = 4;
+    public static final String ATLAS_CLIENT_HA_SLEEP_INTERVAL_MS_KEY = "atlas.client.ha.sleep.interval.ms";
+
+    public static final String HTTP_AUTHENTICATION_ENABLED = "atlas.http.authentication.enabled";
+
+    // Setting the default value based on testing failovers while client code like quickstart is running.
+    // With number of retries, this gives a total time of about 20s for the server to start.
+    public static final int DEFAULT_SLEEP_BETWEEN_RETRIES_MS = 5000;
+
+    private WebResource service;
+    private AtlasClientContext atlasClientContext;
+    private Configuration configuration;
+    private String basicAuthUser;
+    private String basicAuthPassword;
+
+
     // New constuctor for Basic auth
     public AtlasClient(String[] baseUrl, String[] basicAuthUserNamepassword) {
-        super(baseUrl, basicAuthUserNamepassword);
+        this.basicAuthUser = basicAuthUserNamepassword[0];
+        this.basicAuthPassword = basicAuthUserNamepassword[1];
+        initializeState(baseUrl, null, null);
     }
 
     /**
@@ -143,6 +168,14 @@ public class AtlasClient extends AtlasBaseClient {
         initializeState(baseUrls, ugi, doAsUser);
     }
 
+    private static UserGroupInformation getCurrentUGI() throws AtlasException {
+        try {
+            return UserGroupInformation.getCurrentUser();
+        } catch (IOException e) {
+            throw new AtlasException(e);
+        }
+    }
+
     private AtlasClient(UserGroupInformation ugi, String[] baseUrls) {
         this(ugi, ugi.getShortUserName(), baseUrls);
     }
@@ -152,25 +185,264 @@ public class AtlasClient extends AtlasBaseClient {
         //Do nothing
     }
 
+    private void initializeState(String[] baseUrls, UserGroupInformation ugi, String doAsUser) {
+        configuration = getClientProperties();
+        Client client = getClient(configuration, ugi, doAsUser);
+
+        if ((!AuthenticationUtil.isKerberosAuthicationEnabled()) && basicAuthUser!=null && basicAuthPassword!=null) {
+            final HTTPBasicAuthFilter authFilter = new HTTPBasicAuthFilter(basicAuthUser, basicAuthPassword);
+            client.addFilter(authFilter);
+        }
+
+        String activeServiceUrl = determineActiveServiceURL(baseUrls, client);
+        atlasClientContext = new AtlasClientContext(baseUrls, client, ugi, doAsUser);
+        service = client.resource(UriBuilder.fromUri(activeServiceUrl).build());
+    }
+
     @VisibleForTesting
-    public AtlasClient(Configuration configuration, String[] baseUrl, String[] basicAuthUserNamepassword) {
-        super(configuration, baseUrl, basicAuthUserNamepassword);
+    protected Client getClient(Configuration configuration, UserGroupInformation ugi, String doAsUser) {
+        DefaultClientConfig config = new DefaultClientConfig();
+        Configuration clientConfig = null;
+        int readTimeout = 60000;
+        int connectTimeout = 60000;
+        try {
+            clientConfig = configuration;
+            if (clientConfig.getBoolean(TLS_ENABLED, false)) {
+                // create an SSL properties configuration if one doesn't exist.  SSLFactory expects a file, so forced
+                // to create a
+                // configuration object, persist it, then subsequently pass in an empty configuration to SSLFactory
+                SecureClientUtils.persistSSLClientConfiguration(clientConfig);
+            }
+            readTimeout = clientConfig.getInt("atlas.client.readTimeoutMSecs", readTimeout);
+            connectTimeout = clientConfig.getInt("atlas.client.connectTimeoutMSecs", connectTimeout);
+        } catch (Exception e) {
+            LOG.info("Error processing client configuration.", e);
+        }
+
+        URLConnectionClientHandler handler = null;
+
+        if ((!AuthenticationUtil.isKerberosAuthicationEnabled()) && basicAuthUser!=null && basicAuthPassword!=null) {
+            handler = new URLConnectionClientHandler();
+        } else {
+            handler =
+                    SecureClientUtils.getClientConnectionHandler(config, clientConfig, doAsUser, ugi);
+        }
+        Client client = new Client(handler, config);
+        client.setReadTimeout(readTimeout);
+        client.setConnectTimeout(connectTimeout);
+        return client;
     }
 
     @VisibleForTesting
-    public AtlasClient(Configuration configuration, String... baseUrls) throws AtlasException {
-        initializeState(configuration, baseUrls, getCurrentUGI(), getCurrentUGI().getShortUserName());
+    protected String determineActiveServiceURL(String[] baseUrls, Client client) {
+        if (baseUrls.length == 0) {
+            throw new IllegalArgumentException("Base URLs cannot be null or empty");
+        }
+        String baseUrl;
+        AtlasServerEnsemble atlasServerEnsemble = new AtlasServerEnsemble(baseUrls);
+        if (atlasServerEnsemble.hasSingleInstance()) {
+            baseUrl = atlasServerEnsemble.firstURL();
+            LOG.info("Client has only one service URL, will use that for all actions: {}", baseUrl);
+            return baseUrl;
+        } else {
+            try {
+                baseUrl = selectActiveServerAddress(client, atlasServerEnsemble);
+            } catch (AtlasServiceException e) {
+                LOG.error("None of the passed URLs are active: {}", atlasServerEnsemble, e);
+                throw new IllegalArgumentException("None of the passed URLs are active " + atlasServerEnsemble, e);
+            }
+        }
+        return baseUrl;
+    }
+
+    private String selectActiveServerAddress(Client client, AtlasServerEnsemble serverEnsemble)
+            throws AtlasServiceException {
+        List<String> serverInstances = serverEnsemble.getMembers();
+        String activeServerAddress = null;
+        for (String serverInstance : serverInstances) {
+            LOG.info("Trying with address {}", serverInstance);
+            activeServerAddress = getAddressIfActive(client, serverInstance);
+            if (activeServerAddress != null) {
+                LOG.info("Found service {} as active service.", serverInstance);
+                break;
+            }
+        }
+        if (activeServerAddress != null)
+            return activeServerAddress;
+        else
+            throw new AtlasServiceException(API.STATUS, new RuntimeException("Could not find any active instance"));
+    }
+
+    private String getAddressIfActive(Client client, String serverInstance) {
+        String activeServerAddress = null;
+        for (int i = 0; i < getNumberOfRetries(); i++) {
+            try {
+                WebResource service = client.resource(UriBuilder.fromUri(serverInstance).build());
+                String adminStatus = getAdminStatus(service);
+                if (adminStatus.equals("ACTIVE")) {
+                    activeServerAddress = serverInstance;
+                    break;
+                } else {
+                    LOG.info("Service {} is not active.. will retry.", serverInstance);
+                }
+            } catch (Exception e) {
+                LOG.error("Could not get status from service {} after {} tries.", serverInstance, i, e);
+            }
+            sleepBetweenRetries();
+            LOG.warn("Service {} is not active.", serverInstance);
+        }
+        return activeServerAddress;
+    }
+
+    private void sleepBetweenRetries(){
+        try {
+            Thread.sleep(getSleepBetweenRetriesMs());
+        } catch (InterruptedException e) {
+            LOG.error("Interrupted from sleeping between retries.", e);
+        }
+    }
+
+    private int getSleepBetweenRetriesMs() {
+        return configuration.getInt(ATLAS_CLIENT_HA_SLEEP_INTERVAL_MS_KEY, DEFAULT_SLEEP_BETWEEN_RETRIES_MS);
+    }
+
+    private int getNumberOfRetries() {
+        return configuration.getInt(ATLAS_CLIENT_HA_RETRIES_KEY, DEFAULT_NUM_RETRIES);
     }
 
     @VisibleForTesting
     AtlasClient(WebResource service, Configuration configuration) {
-        super(service, configuration);
+        this.service = service;
+        this.configuration = configuration;
+    }
+
+    protected Configuration getClientProperties() {
+        try {
+            if (configuration == null) {
+                configuration = ApplicationProperties.get();
+            }
+        } catch (AtlasException e) {
+            LOG.error("Exception while loading configuration.", e);
+        }
+        return configuration;
+    }
+
+    public boolean isServerReady() throws AtlasServiceException {
+        WebResource resource = getResource(API.VERSION);
+        try {
+            callAPIWithResource(API.VERSION, resource, null);
+            return true;
+        } catch (ClientHandlerException che) {
+            return false;
+        } catch (AtlasServiceException ase) {
+            if (ase.getStatus().equals(ClientResponse.Status.SERVICE_UNAVAILABLE)) {
+                LOG.warn("Received SERVICE_UNAVAILABLE, server is not yet ready");
+                return false;
+            }
+            throw ase;
+        }
     }
 
     public WebResource getResource() {
         return service;
     }
 
+    public static class EntityResult {
+        private static final Gson gson = new GsonBuilder().setPrettyPrinting().create();
+
+        public static final String OP_CREATED = "created";
+        public static final String OP_UPDATED = "updated";
+        public static final String OP_DELETED = "deleted";
+
+        Map<String, List<String>> entities = new HashMap<>();
+
+        public EntityResult() {
+            //For gson
+        }
+
+        public EntityResult(List<String> created, List<String> updated, List<String> deleted) {
+            add(OP_CREATED, created);
+            add(OP_UPDATED, updated);
+            add(OP_DELETED, deleted);
+        }
+
+        private void add(String type, List<String> list) {
+            if (list != null && list.size() > 0) {
+                entities.put(type, list);
+            }
+        }
+
+        private List<String> get(String type) {
+            List<String> list = entities.get(type);
+            if (list == null) {
+                list = new ArrayList<>();
+            }
+            return list;
+        }
+
+        public List<String> getCreatedEntities() {
+            return get(OP_CREATED);
+        }
+
+        public List<String> getUpdateEntities() {
+            return get(OP_UPDATED);
+        }
+
+        public List<String> getDeletedEntities() {
+            return get(OP_DELETED);
+        }
+
+        @Override
+        public String toString() {
+            return gson.toJson(this);
+        }
+
+        public static EntityResult fromString(String json) throws AtlasServiceException {
+            return gson.fromJson(json, EntityResult.class);
+        }
+    }
+
+    /**
+     * Return status of the service instance the client is pointing to.
+     *
+     * @return One of the values in ServiceState.ServiceStateValue or {@link #UNKNOWN_STATUS} if there is a JSON parse
+     * exception
+     * @throws AtlasServiceException if there is a HTTP error.
+     */
+    public String getAdminStatus() throws AtlasServiceException {
+        return getAdminStatus(service);
+    }
+
+    private void handleClientHandlerException(ClientHandlerException che) {
+        if (isRetryableException(che)) {
+            atlasClientContext.getClient().destroy();
+            LOG.warn("Destroyed current context while handling ClientHandlerEception.");
+            LOG.warn("Will retry and create new context.");
+            sleepBetweenRetries();
+            initializeState(atlasClientContext.getBaseUrls(), atlasClientContext.getUgi(),
+                    atlasClientContext.getDoAsUser());
+            return;
+        }
+        throw che;
+    }
+
+    private boolean isRetryableException(ClientHandlerException che) {
+        return che.getCause().getClass().equals(IOException.class)
+                || che.getCause().getClass().equals(ConnectException.class);
+    }
+
+    private String getAdminStatus(WebResource service) throws AtlasServiceException {
+        String result = UNKNOWN_STATUS;
+        WebResource resource = getResource(service, API.STATUS);
+        JSONObject response = callAPIWithResource(API.STATUS, resource, null);
+        try {
+            result = response.getString(STATUS);
+        } catch (JSONException e) {
+            LOG.error("Exception while parsing admin status response. Returned response {}", response.toString(), e);
+        }
+        return result;
+    }
+
     public enum API {
 
         //Admin operations
@@ -200,12 +472,11 @@ public class AtlasClient extends AtlasBaseClient {
         ADD_TRAITS(BASE_URI + URI_ENTITY, HttpMethod.POST, Response.Status.CREATED),
         DELETE_TRAITS(BASE_URI + URI_ENTITY, HttpMethod.DELETE, Response.Status.OK),
         LIST_TRAITS(BASE_URI + URI_ENTITY, HttpMethod.GET, Response.Status.OK),
-        GET_ALL_TRAIT_DEFINITIONS(BASE_URI + URI_ENTITY, HttpMethod.GET, Response.Status.OK),
-        GET_TRAIT_DEFINITION(BASE_URI + URI_ENTITY, HttpMethod.GET, Response.Status.OK),
 
         //Search operations
         SEARCH(BASE_URI + URI_SEARCH, HttpMethod.GET, Response.Status.OK),
         SEARCH_DSL(BASE_URI + URI_SEARCH + "/dsl", HttpMethod.GET, Response.Status.OK),
+        SEARCH_GREMLIN(BASE_URI + URI_SEARCH + "/gremlin", HttpMethod.GET, Response.Status.OK),
         SEARCH_FULL_TEXT(BASE_URI + URI_SEARCH + "/fulltext", HttpMethod.GET, Response.Status.OK),
 
         //Lineage operations based on dataset name
@@ -235,63 +506,8 @@ public class AtlasClient extends AtlasBaseClient {
         public String getPath() {
             return path;
         }
-
-        public Response.Status getExpectedStatus() {
-            return status;
-        }
-    }
-
-    public static class EntityResult {
-        public static final String OP_CREATED = "created";
-        public static final String OP_UPDATED = "updated";
-        public static final String OP_DELETED = "deleted";
-
-        Map<String, List<String>> entities = new HashMap<>();
-
-        public EntityResult() {
-            //For gson
-        }
-
-        public EntityResult(List<String> created, List<String> updated, List<String> deleted) {
-            add(OP_CREATED, created);
-            add(OP_UPDATED, updated);
-            add(OP_DELETED, deleted);
-        }
-
-        private void add(String type, List<String> list) {
-            if (list != null && list.size() > 0) {
-                entities.put(type, list);
-            }
-        }
-
-        private List<String> get(String type) {
-            List<String> list = entities.get(type);
-            if (list == null) {
-                list = new ArrayList<>();
-            }
-            return list;
-        }
-
-        public List<String> getCreatedEntities() {
-            return get(OP_CREATED);
-        }
-
-        public List<String> getUpdateEntities() {
-            return get(OP_UPDATED);
-        }
-
-        public List<String> getDeletedEntities() {
-            return get(OP_DELETED);
-        }
-
-        @Override
-        public String toString() {
-            return AtlasType.toJson(this);
-        }
-
-        public static EntityResult fromString(String json) throws AtlasServiceException {
-            return AtlasType.fromJson(json, EntityResult.class);
-        }
+        
+        public Response.Status getExpectedStatus() { return status; }
     }
 
     /**
@@ -379,61 +595,11 @@ public class AtlasClient extends AtlasBaseClient {
         return updateType(TypesSerialization.toJson(typeDef));
     }
 
-    /**
-     * Returns all type names in the system
-     * @return list of type names
-     * @throws AtlasServiceException
-     */
     public List<String> listTypes() throws AtlasServiceException {
         final JSONObject jsonObject = callAPI(API.LIST_TYPES, null);
         return extractResults(jsonObject, AtlasClient.RESULTS, new ExtractOperation<String, String>());
     }
 
-    /**
-     * Returns all type names with the given category
-     * @param category
-     * @return list of type names
-     * @throws AtlasServiceException
-     */
-    public List<String> listTypes(final DataTypes.TypeCategory category) throws AtlasServiceException {
-        JSONObject response = callAPIWithRetries(API.LIST_TYPES, null, new ResourceCreator() {
-            @Override
-            public WebResource createResource() {
-                WebResource resource = getResource(API.LIST_TYPES.getPath());
-                resource = resource.queryParam(TYPE, category.name());
-                return resource;
-            }
-        });
-        return extractResults(response, AtlasClient.RESULTS, new ExtractOperation<String, String>());
-    }
-
-    /**
-     * Return the list of type names in the type system which match the specified filter.
-     *
-     * @param category returns types whose category is the given typeCategory
-     * @param superType returns types which contain the given supertype
-     * @param notSupertype returns types which do not contain the given supertype
-     *
-     * Its possible to specify combination of these filters in one request and the conditions are combined with AND
-     * For example, typeCategory = TRAIT && supertype contains 'X' && supertype !contains 'Y'
-     * If there is no filter, all the types are returned
-     * @return list of type names
-     */
-    public List<String> listTypes(final DataTypes.TypeCategory category, final String superType,
-                                  final String notSupertype) throws AtlasServiceException {
-        JSONObject response = callAPIWithRetries(API.LIST_TYPES, null, new ResourceCreator() {
-            @Override
-            public WebResource createResource() {
-                WebResource resource = getResource(API.LIST_TYPES);
-                resource = resource.queryParam(TYPE, category.name());
-                resource = resource.queryParam(SUPERTYPE, superType);
-                resource = resource.queryParam(NOT_SUPERTYPE, notSupertype);
-                return resource;
-            }
-        });
-        return extractResults(response, AtlasClient.RESULTS, new ExtractOperation<String, String>());
-    }
-
     public TypesDef getType(String typeName) throws AtlasServiceException {
         try {
             JSONObject response = callAPI(API.GET_TYPE, null, typeName);;
@@ -540,6 +706,27 @@ public class AtlasClient extends AtlasBaseClient {
         return extractEntityResult(response);
     }
 
+    @VisibleForTesting
+    JSONObject callAPIWithRetries(API api, Object requestObject, ResourceCreator resourceCreator)
+            throws AtlasServiceException {
+        for (int i = 0; i < getNumberOfRetries(); i++) {
+            WebResource resource = resourceCreator.createResource();
+            try {
+                LOG.debug("Using resource {} for {} times", resource.getURI(), i);
+                JSONObject result = callAPIWithResource(api, resource, requestObject);
+                return result;
+            } catch (ClientHandlerException che) {
+                if (i==(getNumberOfRetries()-1)) {
+                    throw che;
+                }
+                LOG.warn("Handled exception in calling api {}", api.getPath(), che);
+                LOG.warn("Exception's cause: {}", che.getCause().getClass());
+                handleClientHandlerException(che);
+            }
+        }
+        throw new AtlasServiceException(api, new RuntimeException("Could not get response after retries."));
+    }
+
     /**
      * Supports Partial updates
      * Updates properties set in the definition for the entity corresponding to guid
@@ -731,40 +918,6 @@ public class AtlasClient extends AtlasBaseClient {
         return extractResults(jsonResponse, AtlasClient.RESULTS, new ExtractOperation<String, String>());
     }
 
-    /**
-     * Get all trait definitions for an entity
-     * @param guid GUID of the entity
-     * @return List<String> trait definitions of the traits associated to the entity
-     * @throws AtlasServiceException
-     */
-    public List<Struct> listTraitDefinitions(final String guid) throws AtlasServiceException{
-        JSONObject jsonResponse = callAPI(API.GET_ALL_TRAIT_DEFINITIONS, null, guid, TRAIT_DEFINITIONS);
-        List<JSONObject> traitDefList = extractResults(jsonResponse, AtlasClient.RESULTS, new ExtractOperation<JSONObject, JSONObject>());
-        ArrayList<Struct> traitStructList = new ArrayList<>();
-        for(JSONObject traitDef:traitDefList){
-            Struct traitStruct = InstanceSerialization.fromJsonStruct(traitDef.toString(), true);
-            traitStructList.add(traitStruct);
-        }
-        return traitStructList;
-    }
-
-    /**
-     * Get trait definition for a given entity and traitname
-     * @param guid GUID of the entity
-     * @param traitName
-     * @return trait definition
-     * @throws AtlasServiceException
-     */
-    public Struct getTraitDefinition(final String guid, final String traitName) throws AtlasServiceException{
-        JSONObject jsonResponse = callAPI(API.GET_TRAIT_DEFINITION, null, guid, TRAIT_DEFINITIONS, traitName);
-
-        try {
-            return InstanceSerialization.fromJsonStruct(jsonResponse.getString(AtlasClient.RESULTS), false);
-        }catch (JSONException e){
-            throw new AtlasServiceException(API.GET_TRAIT_DEFINITION, e);
-        }
-    }
-
     protected class ExtractOperation<T, U> {
         T extractElement(U element) throws JSONException {
             return (T) element;
@@ -825,21 +978,17 @@ public class AtlasClient extends AtlasBaseClient {
     }
 
     /**
-     * Search using dsl/full text
+     * Search using gremlin/dsl/full text
      * @param searchQuery
-     * @param limit number of rows to be returned in the result, used for pagination. maxlimit > limit > 0. -1 maps to atlas.search.defaultlimit property value
-     * @param offset offset to the results returned, used for pagination. offset >= 0. -1 maps to offset 0
-     * @return Query results
+     * @return
      * @throws AtlasServiceException
      */
-    public JSONArray search(final String searchQuery, final int limit, final int offset) throws AtlasServiceException {
+    public JSONArray search(final String searchQuery) throws AtlasServiceException {
         JSONObject result = callAPIWithRetries(API.SEARCH, null, new ResourceCreator() {
             @Override
             public WebResource createResource() {
                 WebResource resource = getResource(API.SEARCH);
                 resource = resource.queryParam(QUERY, searchQuery);
-                resource = resource.queryParam(LIMIT, String.valueOf(limit));
-                resource = resource.queryParam(OFFSET, String.valueOf(offset));
                 return resource;
             }
         });
@@ -854,20 +1003,39 @@ public class AtlasClient extends AtlasBaseClient {
     /**
      * Search given query DSL
      * @param query DSL query
-     * @param limit number of rows to be returned in the result, used for pagination. maxlimit > limit > 0. -1 maps to atlas.search.defaultlimit property value
-     * @param offset offset to the results returned, used for pagination. offset >= 0. -1 maps to offset 0
      * @return result json object
      * @throws AtlasServiceException
      */
-    public JSONArray searchByDSL(final String query, final int limit, final int offset) throws AtlasServiceException {
+    public JSONArray searchByDSL(final String query) throws AtlasServiceException {
         LOG.debug("DSL query: {}", query);
         JSONObject result = callAPIWithRetries(API.SEARCH_DSL, null, new ResourceCreator() {
             @Override
             public WebResource createResource() {
                 WebResource resource = getResource(API.SEARCH_DSL);
                 resource = resource.queryParam(QUERY, query);
-                resource = resource.queryParam(LIMIT, String.valueOf(limit));
-                resource = resource.queryParam(OFFSET, String.valueOf(offset));
+                return resource;
+            }
+        });
+        try {
+            return result.getJSONArray(RESULTS);
+        } catch (JSONException e) {
+            throw new AtlasServiceException(e);
+        }
+    }
+
+    /**
+     * Search given gremlin query
+     * @param gremlinQuery Gremlin query
+     * @return result json object
+     * @throws AtlasServiceException
+     */
+    public JSONArray searchByGremlin(final String gremlinQuery) throws AtlasServiceException {
+        LOG.debug("Gremlin query: " + gremlinQuery);
+        JSONObject result = callAPIWithRetries(API.SEARCH_GREMLIN, null, new ResourceCreator() {
+            @Override
+            public WebResource createResource() {
+                WebResource resource = getResource(API.SEARCH_GREMLIN);
+                resource = resource.queryParam(QUERY, gremlinQuery);
                 return resource;
             }
         });
@@ -881,19 +1049,15 @@ public class AtlasClient extends AtlasBaseClient {
     /**
      * Search given full text search
      * @param query Query
-     * @param limit number of rows to be returned in the result, used for pagination. maxlimit > limit > 0. -1 maps to atlas.search.defaultlimit property value
-     * @param offset offset to the results returned, used for pagination. offset >= 0. -1 maps to offset 0
      * @return result json object
      * @throws AtlasServiceException
      */
-    public JSONObject searchByFullText(final String query, final int limit, final int offset) throws AtlasServiceException {
+    public JSONObject searchByFullText(final String query) throws AtlasServiceException {
         return callAPIWithRetries(API.SEARCH_FULL_TEXT, null, new ResourceCreator() {
             @Override
             public WebResource createResource() {
                 WebResource resource = getResource(API.SEARCH_FULL_TEXT);
                 resource = resource.queryParam(QUERY, query);
-                resource = resource.queryParam(LIMIT, String.valueOf(limit));
-                resource = resource.queryParam(OFFSET, String.valueOf(offset));
                 return resource;
             }
         });
@@ -944,26 +1108,90 @@ public class AtlasClient extends AtlasBaseClient {
         }
     }
 
-    // Wrapper methods for compatibility
-
-    JSONObject callAPIWithResource(API api, WebResource resource, Object requestObject) throws AtlasServiceException {
-        return callAPIWithResource(toAPIInfo(api), resource, requestObject);
+    private WebResource getResource(API api, String... pathParams) {
+        return getResource(service, api, pathParams);
     }
 
-    WebResource getResource(API api, String ... params) {
-        return getResource(toAPIInfo(api), params);
+    private WebResource getResource(WebResource service, API api, String... pathParams) {
+        WebResource resource = service.path(api.getPath());
+        if (pathParams != null) {
+            for (String pathParam : pathParams) {
+                resource = resource.path(pathParam);
+            }
+        }
+        return resource;
     }
 
-    JSONObject callAPI(API api, Object requestObject, String ... params) throws AtlasServiceException {
-        return callAPI(toAPIInfo(api), requestObject, params);
+    private JSONObject callAPIWithResource(API api, WebResource resource, Object requestObject)
+        throws AtlasServiceException {
+        ClientResponse clientResponse = null;
+        for (int i = 0; i < getNumberOfRetries(); i++) {
+            clientResponse = resource.accept(JSON_MEDIA_TYPE).type(JSON_MEDIA_TYPE)
+                .method(api.getMethod(), ClientResponse.class, requestObject);
+
+            LOG.debug("API {} returned status {}", resource.getURI(), clientResponse.getStatus());
+            if (clientResponse.getStatus() == api.getExpectedStatus().getStatusCode()) {
+                String responseAsString = clientResponse.getEntity(String.class);
+                try {
+                    return new JSONObject(responseAsString);
+                } catch (JSONException e) {
+                    throw new AtlasServiceException(api, e);
+                }
+            } else if (clientResponse.getStatus() != ClientResponse.Status.SERVICE_UNAVAILABLE.getStatusCode()) {
+                break;
+            } else {
+                LOG.error("Got a service unavailable when calling: {}, will retry..", resource);
+                sleepBetweenRetries();
+            }
+        }
+
+        throw new AtlasServiceException(api, clientResponse);
     }
 
-    JSONObject callAPIWithRetries(API api, Object requestObject, ResourceCreator resourceCreator) throws AtlasServiceException {
-        return super.callAPIWithRetries(toAPIInfo(api), requestObject, resourceCreator);
+    private JSONObject callAPI(final API api, Object requestObject, final String... pathParams)
+            throws AtlasServiceException {
+        return callAPIWithRetries(api, requestObject, new ResourceCreator() {
+            @Override
+            public WebResource createResource() {
+                return getResource(api, pathParams);
+            }
+        });
     }
 
-    private APIInfo toAPIInfo(API api){
-        return new APIInfo(api.getPath(), api.getMethod(), api.getExpectedStatus());
+    /**
+     * A class to capture input state while creating the client.
+     *
+     * The information here will be reused when the client is re-initialized on switch-over
+     * in case of High Availability.
+     */
+    private class AtlasClientContext {
+        private String[] baseUrls;
+        private Client client;
+        private String doAsUser;
+        private UserGroupInformation ugi;
+
+        public AtlasClientContext(String[] baseUrls, Client client, UserGroupInformation ugi, String doAsUser) {
+            this.baseUrls = baseUrls;
+            this.client = client;
+            this.ugi = ugi;
+            this.doAsUser = doAsUser;
+        }
+
+        public Client getClient() {
+            return client;
+        }
+
+        public String[] getBaseUrls() {
+            return baseUrls;
+        }
+
+        public String getDoAsUser() {
+            return doAsUser;
+        }
+
+        public UserGroupInformation getUgi() {
+            return ugi;
+        }
     }
 
 