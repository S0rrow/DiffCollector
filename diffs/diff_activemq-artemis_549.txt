diff --git a/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java b/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java
index f9e8838b79..b7258c3c3c 100644
--- a/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java
+++ b/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -16,65 +16,32 @@
  */
 package org.apache.activemq.artemis.core.protocol.openwire;
 
-import javax.jms.IllegalStateException;
-import javax.jms.InvalidClientIDException;
 import javax.jms.InvalidDestinationException;
 import javax.jms.JMSSecurityException;
-import javax.transaction.xa.XAException;
-import javax.transaction.xa.XAResource;
-import javax.transaction.xa.Xid;
+import javax.jms.ResourceAllocationException;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
-import java.util.ListIterator;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import org.apache.activemq.advisory.AdvisorySupport;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
+import org.apache.activemq.artemis.api.core.ActiveMQBuffers;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.api.core.ActiveMQNonExistentQueueException;
 import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
 import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.core.postoffice.Binding;
-import org.apache.activemq.artemis.core.postoffice.Bindings;
-import org.apache.activemq.artemis.core.postoffice.QueueBinding;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQCompositeConsumerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConnectionContext;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumer;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQProducerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSingleConsumerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.util.OpenWireUtil;
-import org.apache.activemq.artemis.core.remoting.FailureListener;
-import org.apache.activemq.artemis.core.security.CheckType;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
-import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
-import org.apache.activemq.artemis.core.server.ActiveMQServer;
-import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
-import org.apache.activemq.artemis.core.server.BindingQueryResult;
-import org.apache.activemq.artemis.core.server.MessageReference;
-import org.apache.activemq.artemis.core.server.Queue;
-import org.apache.activemq.artemis.core.server.ServerConsumer;
-import org.apache.activemq.artemis.core.server.ServerSession;
-import org.apache.activemq.artemis.core.server.SlowConsumerDetectionListener;
-import org.apache.activemq.artemis.core.server.impl.RefsOperation;
-import org.apache.activemq.artemis.core.transaction.Transaction;
-import org.apache.activemq.artemis.core.transaction.TransactionOperationAbstract;
-import org.apache.activemq.artemis.core.transaction.TransactionPropertyIndexes;
-import org.apache.activemq.artemis.spi.core.protocol.AbstractRemotingConnection;
-import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
-import org.apache.activemq.artemis.spi.core.remoting.Connection;
-import org.apache.activemq.artemis.utils.ConcurrentHashSet;
-import org.apache.activemq.artemis.utils.UUIDGenerator;
 import org.apache.activemq.command.ActiveMQDestination;
 import org.apache.activemq.command.ActiveMQMessage;
-import org.apache.activemq.command.ActiveMQTopic;
 import org.apache.activemq.command.BrokerInfo;
 import org.apache.activemq.command.Command;
 import org.apache.activemq.command.ConnectionControl;
@@ -89,7 +56,6 @@ import org.apache.activemq.command.DataArrayResponse;
 import org.apache.activemq.command.DestinationInfo;
 import org.apache.activemq.command.ExceptionResponse;
 import org.apache.activemq.command.FlushCommand;
-import org.apache.activemq.command.IntegerResponse;
 import org.apache.activemq.command.KeepAliveInfo;
 import org.apache.activemq.command.Message;
 import org.apache.activemq.command.MessageAck;
@@ -99,6 +65,7 @@ import org.apache.activemq.command.MessagePull;
 import org.apache.activemq.command.ProducerAck;
 import org.apache.activemq.command.ProducerId;
 import org.apache.activemq.command.ProducerInfo;
+import org.apache.activemq.command.RemoveInfo;
 import org.apache.activemq.command.RemoveSubscriptionInfo;
 import org.apache.activemq.command.Response;
 import org.apache.activemq.command.SessionId;
@@ -107,252 +74,450 @@ import org.apache.activemq.command.ShutdownInfo;
 import org.apache.activemq.command.TransactionId;
 import org.apache.activemq.command.TransactionInfo;
 import org.apache.activemq.command.WireFormatInfo;
-import org.apache.activemq.command.XATransactionId;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQBrokerStoppedException;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConnectionContext;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumerBrokerExchange;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQMapTransportConnectionStateRegister;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQMessageAuthorizationPolicy;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQProducerBrokerExchange;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSingleTransportConnectionStateRegister;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQTransaction;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQTransportConnectionState;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQTransportConnectionStateRegister;
+import org.apache.activemq.artemis.core.remoting.CloseListener;
+import org.apache.activemq.artemis.core.remoting.FailureListener;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.openwire.OpenWireFormat;
+import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
+import org.apache.activemq.artemis.spi.core.remoting.Acceptor;
+import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.state.CommandVisitor;
 import org.apache.activemq.state.ConnectionState;
 import org.apache.activemq.state.ConsumerState;
 import org.apache.activemq.state.ProducerState;
 import org.apache.activemq.state.SessionState;
+import org.apache.activemq.thread.TaskRunner;
+import org.apache.activemq.thread.TaskRunnerFactory;
 import org.apache.activemq.transport.TransmitCallback;
 import org.apache.activemq.util.ByteSequence;
+import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.wireformat.WireFormat;
 
 /**
  * Represents an activemq connection.
  */
-public class OpenWireConnection extends AbstractRemotingConnection implements SecurityAuth {
-
+public class OpenWireConnection implements RemotingConnection, CommandVisitor
+{
    private final OpenWireProtocolManager protocolManager;
 
+   private final Connection transportConnection;
+
+   private final AMQConnectorImpl acceptorUsed;
+
+   private final long creationTime;
+
+   private final List<FailureListener> failureListeners = new CopyOnWriteArrayList<FailureListener>();
+
+   private final List<CloseListener> closeListeners = new CopyOnWriteArrayList<CloseListener>();
+
    private boolean destroyed = false;
 
    private final Object sendLock = new Object();
 
-   private final OpenWireFormat wireFormat;
+   private boolean dataReceived;
+
+   private OpenWireFormat wireFormat;
+
+   private AMQTransportConnectionStateRegister connectionStateRegister = new AMQSingleTransportConnectionStateRegister();
+
+   private boolean faultTolerantConnection;
 
    private AMQConnectionContext context;
 
+   private AMQMessageAuthorizationPolicy messageAuthorizationPolicy;
+
+   private boolean networkConnection;
+
+   private boolean manageable;
+
+   private boolean pendingStop;
+
+   private Throwable stopError = null;
+
+   // should come from activemq server
+   private final TaskRunnerFactory stopTaskRunnerFactory = null;
+
+   private boolean starting;
+
    private final AtomicBoolean stopping = new AtomicBoolean(false);
 
+   private final ReentrantReadWriteLock serviceLock = new ReentrantReadWriteLock();
+
+   private final CountDownLatch stopped = new CountDownLatch(1);
+
+   protected TaskRunner taskRunner;
+
+   private boolean active;
+
+   protected final List<Command> dispatchQueue = new LinkedList<Command>();
+
+   private boolean markedCandidate;
+
+   private boolean blockedCandidate;
+
+   private long timeStamp;
+
    private boolean inServiceException;
 
    private final AtomicBoolean asyncException = new AtomicBoolean(false);
 
-   // Clebert: Artemis session has meta-data support, perhaps we could reuse it here
-   private Map<String, SessionId> sessionIdMap = new ConcurrentHashMap<>();
+   private final Map<ConsumerId, AMQConsumerBrokerExchange> consumerExchanges = new HashMap<ConsumerId, AMQConsumerBrokerExchange>();
+   private final Map<ProducerId, AMQProducerBrokerExchange> producerExchanges = new HashMap<ProducerId, AMQProducerBrokerExchange>();
 
-   private final Map<ConsumerId, AMQConsumerBrokerExchange> consumerExchanges = new ConcurrentHashMap<>();
-   private final Map<ProducerId, AMQProducerBrokerExchange> producerExchanges = new ConcurrentHashMap<>();
+   private AMQTransportConnectionState state;
 
-   // Clebert TODO: Artemis already stores the Session. Why do we need a different one here
-   private Map<SessionId, AMQSession> sessions = new ConcurrentHashMap<>();
+   private final Set<String> tempQueues = new ConcurrentHashSet<String>();
 
-   private ConnectionState state;
+   protected final Map<ConnectionId, ConnectionState> brokerConnectionStates;
 
-   private final Set<ActiveMQDestination> tempQueues = new ConcurrentHashSet<>();
+   private DataInputWrapper dataInput = new DataInputWrapper();
 
-   /**
-    * Openwire doesn't sen transactions associated with any sessions.
-    * It will however send beingTX / endTX as it would be doing it with XA Transactions.
-    * But always without any association with Sessions.
-    * This collection will hold nonXA transactions. Hopefully while they are in transit only.
-    */
-   private Map<TransactionId, Transaction> txMap = new ConcurrentHashMap<>();
+   private Map<TransactionId, TransactionInfo> txMap = new ConcurrentHashMap<TransactionId, TransactionInfo>();
 
    private volatile AMQSession advisorySession;
 
-   private final ActiveMQServer server;
-
-   /**
-    * This is to be used with connection operations that don't have  a session.
-    * Such as TM operations.
-    */
-   private ServerSession internalSession;
-
-   // TODO-NOW: check on why there are two connections created for every createConnection on the client.
-   public OpenWireConnection(Connection connection,
-                             ActiveMQServer server,
-                             Executor executor,
-                             OpenWireProtocolManager openWireProtocolManager,
-                             OpenWireFormat wf) {
-      super(connection, executor);
-      this.server = server;
+   public OpenWireConnection(Acceptor acceptorUsed, Connection connection,
+         OpenWireProtocolManager openWireProtocolManager, OpenWireFormat wf)
+   {
       this.protocolManager = openWireProtocolManager;
+      this.transportConnection = connection;
+      this.acceptorUsed = new AMQConnectorImpl(acceptorUsed);
       this.wireFormat = wf;
+      brokerConnectionStates = protocolManager.getConnectionStates();
+      this.creationTime = System.currentTimeMillis();
    }
 
-   // SecurityAuth implementation
    @Override
-   public String getUsername() {
-      ConnectionInfo info = getConnectionInfo();
-      if (info == null) {
-         return null;
+   public void bufferReceived(Object connectionID, ActiveMQBuffer buffer)
+   {
+      try
+      {
+         dataInput.receiveData(buffer);
+      }
+      catch (Throwable t)
+      {
+         ActiveMQServerLogger.LOGGER.error("decoding error", t);
+         return;
+      }
+
+      // this.setDataReceived();
+      while (dataInput.readable())
+      {
+         try
+         {
+            Object object = null;
+            try
+            {
+               object = wireFormat.unmarshal(dataInput);
+               dataInput.mark();
+            }
+            catch (NotEnoughBytesException e)
+            {
+               //meaning the dataInput hasn't enough bytes for a command.
+               //in that case we just return and waiting for the next
+               //call of bufferReceived()
+               return;
+            }
+
+            Command command = (Command) object;
+            boolean responseRequired = command.isResponseRequired();
+            int commandId = command.getCommandId();
+            // the connection handles pings, negotiations directly.
+            // and delegate all other commands to manager.
+            if (command.getClass() == KeepAliveInfo.class)
+            {
+               KeepAliveInfo info = (KeepAliveInfo) command;
+               if (info.isResponseRequired())
+               {
+                  info.setResponseRequired(false);
+                  protocolManager.sendReply(this, info);
+               }
+            }
+            else if (command.getClass() == WireFormatInfo.class)
+            {
+               // amq here starts a read/write monitor thread (detect ttl?)
+               negotiate((WireFormatInfo) command);
+            }
+            else if (command.getClass() == ConnectionInfo.class
+                  || command.getClass() == ConsumerInfo.class
+                  || command.getClass() == RemoveInfo.class
+                  || command.getClass() == SessionInfo.class
+                  || command.getClass() == ProducerInfo.class
+                  || ActiveMQMessage.class.isAssignableFrom(command.getClass())
+                  || command.getClass() == MessageAck.class
+                  || command.getClass() == TransactionInfo.class
+                  || command.getClass() == DestinationInfo.class
+                  || command.getClass() == ShutdownInfo.class)
+            {
+               Response response = null;
+
+               if (pendingStop)
+               {
+                  response = new ExceptionResponse(this.stopError);
+               }
+               else
+               {
+                  response = ((Command) command).visit(this);
+
+                  if (response instanceof ExceptionResponse)
+                  {
+                     if (!responseRequired)
+                     {
+                        Throwable cause = ((ExceptionResponse)response).getException();
+                        serviceException(cause);
+                        response = null;
+                     }
+                  }
+               }
+
+               if (responseRequired)
+               {
+                  if (response == null)
+                  {
+                     response = new Response();
+                  }
+               }
+
+               // The context may have been flagged so that the response is not
+               // sent.
+               if (context != null)
+               {
+                  if (context.isDontSendReponse())
+                  {
+                     context.setDontSendReponse(false);
+                     response = null;
+                  }
+                  context = null;
+               }
+
+               if (response != null && !protocolManager.isStopping())
+               {
+                  response.setCorrelationId(commandId);
+                  dispatchSync(response);
+               }
+
+            }
+            else
+            {
+               // note!!! wait for negotiation (e.g. use a countdown latch)
+               // before handling any other commands
+               this.protocolManager.handleCommand(this, command);
+            }
+         }
+         catch (IOException e)
+         {
+            ActiveMQServerLogger.LOGGER.error("error decoding", e);
+         }
+         catch (Throwable t)
+         {
+            ActiveMQServerLogger.LOGGER.error("error decoding", t);
+         }
       }
-      return info.getUserName();
    }
 
-   // SecurityAuth implementation
+   private void negotiate(WireFormatInfo command) throws IOException
+   {
+      this.wireFormat.renegotiateWireFormat(command);
+   }
+
+   @Override
+   public Object getID()
+   {
+      return transportConnection.getID();
+   }
+
+   @Override
+   public long getCreationTime()
+   {
+      return creationTime;
+   }
+
    @Override
-   public RemotingConnection getRemotingConnection() {
-      return this;
+   public String getRemoteAddress()
+   {
+      return transportConnection.getRemoteAddress();
    }
 
-   // SecurityAuth implementation
    @Override
-   public String getPassword() {
-      ConnectionInfo info = getConnectionInfo();
-      if (info == null) {
-         return null;
+   public void addFailureListener(FailureListener listener)
+   {
+      if (listener == null)
+      {
+         throw new IllegalStateException("FailureListener cannot be null");
       }
-      return info.getPassword();
+
+      failureListeners.add(listener);
    }
 
-   private ConnectionInfo getConnectionInfo() {
-      if (state == null) {
-         return null;
+   @Override
+   public boolean removeFailureListener(FailureListener listener)
+   {
+      if (listener == null)
+      {
+         throw new IllegalStateException("FailureListener cannot be null");
       }
-      ConnectionInfo info = state.getInfo();
-      if (info == null) {
-         return null;
+
+      return failureListeners.remove(listener);
+   }
+
+   @Override
+   public void addCloseListener(CloseListener listener)
+   {
+      if (listener == null)
+      {
+         throw new IllegalStateException("CloseListener cannot be null");
       }
-      return info;
+
+      closeListeners.add(listener);
    }
 
    @Override
-   public void bufferReceived(Object connectionID, ActiveMQBuffer buffer) {
-      super.bufferReceived(connectionID, buffer);
-      try {
+   public boolean removeCloseListener(CloseListener listener)
+   {
+      if (listener == null)
+      {
+         throw new IllegalStateException("CloseListener cannot be null");
+      }
 
-         // TODO-NOW: set OperationContext
+      return closeListeners.remove(listener);
+   }
 
-         Command command = (Command) wireFormat.unmarshal(buffer);
+   @Override
+   public List<CloseListener> removeCloseListeners()
+   {
+      List<CloseListener> ret = new ArrayList<CloseListener>(closeListeners);
 
-         boolean responseRequired = command.isResponseRequired();
-         int commandId = command.getCommandId();
+      closeListeners.clear();
 
-         // TODO-NOW: the server should send packets to the client based on the requested times
-         //           need to look at what Andy did on AMQP
+      return ret;
+   }
 
-         // the connection handles pings, negotiations directly.
-         // and delegate all other commands to manager.
-         if (command.getClass() == KeepAliveInfo.class) {
-            KeepAliveInfo info = (KeepAliveInfo) command;
-            info.setResponseRequired(false);
-            // if we don't respond to KeepAlive commands then the client will think the server is dead and timeout
-            // for some reason KeepAliveInfo.isResponseRequired() is always false
-            sendCommand(info);
-         }
-         else {
-            Response response = null;
+   @Override
+   public void setCloseListeners(List<CloseListener> listeners)
+   {
+      closeListeners.clear();
 
-            try {
-               setLastCommand(command);
-               response = command.visit(commandProcessorInstance);
-            }
-            catch (Exception e) {
-               // TODO: logging
-               e.printStackTrace();
-               if (responseRequired) {
-                  response = convertException(e);
-               }
-            }
-            finally {
-               setLastCommand(null);
-            }
+      closeListeners.addAll(listeners);
+   }
 
-            if (response instanceof ExceptionResponse) {
-               if (!responseRequired) {
-                  Throwable cause = ((ExceptionResponse) response).getException();
-                  serviceException(cause);
-                  response = null;
-               }
-            }
+   @Override
+   public List<FailureListener> getFailureListeners()
+   {
+      // we do not return the listeners otherwise the remoting service
+      // would NOT destroy the connection.
+      return Collections.emptyList();
+   }
 
-            if (responseRequired) {
-               if (response == null) {
-                  response = new Response();
-                  response.setCorrelationId(command.getCommandId());
-               }
-            }
+   @Override
+   public List<FailureListener> removeFailureListeners()
+   {
+      List<FailureListener> ret = new ArrayList<FailureListener>(
+            failureListeners);
 
-            // The context may have been flagged so that the response is not
-            // sent.
-            if (context != null) {
-               if (context.isDontSendReponse()) {
-                  context.setDontSendReponse(false);
-                  response = null;
-               }
-            }
+      failureListeners.clear();
 
-            // TODO-NOW: response through operation-context
+      return ret;
+   }
 
-            if (response != null && !protocolManager.isStopping()) {
-               response.setCorrelationId(commandId);
-               dispatchSync(response);
-            }
+   @Override
+   public void setFailureListeners(List<FailureListener> listeners)
+   {
+      failureListeners.clear();
 
-         }
-      }
-      catch (Exception e) {
-         ActiveMQServerLogger.LOGGER.debug(e);
+      failureListeners.addAll(listeners);
+   }
 
-         sendException(e);
-      }
+   @Override
+   public ActiveMQBuffer createTransportBuffer(int size)
+   {
+      return ActiveMQBuffers.dynamicBuffer(size);
    }
 
-   public void sendException(Exception e) {
-      Response resp = convertException(e);
-      try {
-         dispatch(resp);
-      }
-      catch (IOException e2) {
-         ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e2);
-      }
+   @Override
+   public void fail(ActiveMQException me)
+   {
+      ActiveMQServerLogger.LOGGER.connectionFailureDetected(me.getMessage(),
+            me.getType());
+      // Then call the listeners
+      callFailureListeners(me);
+
+      callClosingListeners();
+
+      destroyed = true;
+
+      transportConnection.close();
    }
 
-   private Response convertException(Exception e) {
-      Response resp;
-      if (e instanceof ActiveMQSecurityException) {
-         resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+   @Override
+   public void destroy()
+   {
+      destroyed = true;
+
+      transportConnection.close();
+
+      try
+      {
+         deleteTempQueues();
       }
-      else if (e instanceof ActiveMQNonExistentQueueException) {
-         resp = new ExceptionResponse(new InvalidDestinationException(e.getMessage()));
+      catch (Exception e)
+      {
+         //log warning
       }
-      else {
-         resp = new ExceptionResponse(e);
+
+      synchronized (sendLock)
+      {
+         callClosingListeners();
       }
-      return resp;
    }
 
-   private void setLastCommand(Command command) {
-      if (context != null) {
-         context.setLastCommand(command);
+   private void deleteTempQueues() throws Exception
+   {
+      Iterator<String> queueNames = tempQueues.iterator();
+      while (queueNames.hasNext())
+      {
+         String q = queueNames.next();
+         protocolManager.deleteQueue(q);
       }
    }
 
    @Override
-   public void destroy() {
-      fail(null, null);
+   public Connection getTransportConnection()
+   {
+      return this.transportConnection;
    }
 
    @Override
-   public boolean isClient() {
+   public boolean isClient()
+   {
       return false;
    }
 
    @Override
-   public boolean isDestroyed() {
+   public boolean isDestroyed()
+   {
       return destroyed;
    }
 
    @Override
-   public void disconnect(boolean criticalError) {
-      this.disconnect(null, null, criticalError);
+   public void disconnect(boolean criticalError)
+   {
+      fail(null);
    }
 
    @Override
-   public boolean checkDataReceived() {
+   public boolean checkDataReceived()
+   {
       boolean res = dataReceived;
 
       dataReceived = false;
@@ -361,17 +526,23 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
    }
 
    @Override
-   public void flush() {
+   public void flush()
+   {
    }
 
-   private void callFailureListeners(final ActiveMQException me) {
-      final List<FailureListener> listenersClone = new ArrayList<>(failureListeners);
+   private void callFailureListeners(final ActiveMQException me)
+   {
+      final List<FailureListener> listenersClone = new ArrayList<FailureListener>(
+            failureListeners);
 
-      for (final FailureListener listener : listenersClone) {
-         try {
+      for (final FailureListener listener : listenersClone)
+      {
+         try
+         {
             listener.connectionFailed(me, false);
          }
-         catch (final Throwable t) {
+         catch (final Throwable t)
+         {
             // Failure of one listener to execute shouldn't prevent others
             // from
             // executing
@@ -380,1010 +551,1238 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
       }
    }
 
-   // send a WireFormatInfo to the peer
-   public void sendHandshake() {
+   private void callClosingListeners()
+   {
+      final List<CloseListener> listenersClone = new ArrayList<CloseListener>(
+            closeListeners);
+
+      for (final CloseListener listener : listenersClone)
+      {
+         try
+         {
+            listener.connectionClosed();
+         }
+         catch (final Throwable t)
+         {
+            // Failure of one listener to execute shouldn't prevent others
+            // from
+            // executing
+            ActiveMQServerLogger.LOGGER.errorCallingFailureListener(t);
+         }
+      }
+   }
+
+   // throw a WireFormatInfo to the peer
+   public void init()
+   {
       WireFormatInfo info = wireFormat.getPreferedWireFormatInfo();
-      sendCommand(info);
+      protocolManager.send(this, info);
    }
 
-   public ConnectionState getState() {
+   public ConnectionState getState()
+   {
       return state;
    }
 
-   public void physicalSend(Command command) throws IOException {
-      try {
+   public void physicalSend(Command command) throws IOException
+   {
+      try
+      {
          ByteSequence bytes = wireFormat.marshal(command);
          ActiveMQBuffer buffer = OpenWireUtil.toActiveMQBuffer(bytes);
-         synchronized (sendLock) {
+         synchronized (sendLock)
+         {
             getTransportConnection().write(buffer, false, false);
          }
       }
-      catch (IOException e) {
+      catch (IOException e)
+      {
          throw e;
       }
-      catch (Throwable t) {
+      catch (Throwable t)
+      {
          ActiveMQServerLogger.LOGGER.error("error sending", t);
       }
 
    }
 
-   public void dispatchAsync(Command message) throws Exception {
-      dispatchSync(message);
-   }
+   @Override
+   public Response processAddConnection(ConnectionInfo info) throws Exception
+   {
+      WireFormatInfo wireFormatInfo = wireFormat.getPreferedWireFormatInfo();
+      // Older clients should have been defaulting this field to true.. but
+      // they were not.
+      if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2)
+      {
+         info.setClientMaster(true);
+      }
 
-   public void dispatchSync(Command message) throws Exception {
-      processDispatch(message);
-   }
+      // Make sure 2 concurrent connections by the same ID only generate 1
+      // TransportConnectionState object.
+      synchronized (brokerConnectionStates)
+      {
+         state = (AMQTransportConnectionState) brokerConnectionStates.get(info
+               .getConnectionId());
+         if (state == null)
+         {
+            state = new AMQTransportConnectionState(info, this);
+            brokerConnectionStates.put(info.getConnectionId(), state);
+         }
+         state.incrementReference();
+      }
+      // If there are 2 concurrent connections for the same connection id,
+      // then last one in wins, we need to sync here
+      // to figure out the winner.
+      synchronized (state.getConnectionMutex())
+      {
+         if (state.getConnection() != this)
+         {
+            state.getConnection().disconnect(true);
+            state.setConnection(this);
+            state.reset(info);
+         }
+      }
 
-   public void serviceException(Throwable e) throws Exception {
-      ConnectionError ce = new ConnectionError();
-      ce.setException(e);
-      dispatchAsync(ce);
-   }
+      registerConnectionState(info.getConnectionId(), state);
 
-   public void dispatch(Command command) throws IOException {
-      this.physicalSend(command);
-   }
+      this.faultTolerantConnection = info.isFaultTolerant();
+      // Setup the context.
+      String clientId = info.getClientId();
+      context = new AMQConnectionContext();
+      context.setBroker(protocolManager);
+      context.setClientId(clientId);
+      context.setClientMaster(info.isClientMaster());
+      context.setConnection(this);
+      context.setConnectionId(info.getConnectionId());
+      // for now we pass the manager as the connector and see what happens
+      // it should be related to activemq's Acceptor
+      context.setConnector(this.acceptorUsed);
+      context.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());
+      context.setNetworkConnection(networkConnection);
+      context.setFaultTolerant(faultTolerantConnection);
+      context
+            .setTransactions(new ConcurrentHashMap<TransactionId, AMQTransaction>());
+      context.setUserName(info.getUserName());
+      context.setWireFormatInfo(wireFormatInfo);
+      context.setReconnect(info.isFailoverReconnect());
+      this.manageable = info.isManageable();
+      context.setConnectionState(state);
+      state.setContext(context);
+      state.setConnection(this);
+      if (info.getClientIp() == null)
+      {
+         info.setClientIp(getRemoteAddress());
+      }
 
-   protected void processDispatch(Command command) throws IOException {
-      MessageDispatch messageDispatch = (MessageDispatch) (command.isMessageDispatch() ? command : null);
-      try {
-         if (!stopping.get()) {
-            if (messageDispatch != null) {
-               protocolManager.preProcessDispatch(messageDispatch);
-            }
-            dispatch(command);
-         }
+      try
+      {
+         protocolManager.addConnection(context, info);
       }
-      catch (IOException e) {
-         if (messageDispatch != null) {
-            TransmitCallback sub = messageDispatch.getTransmitCallback();
-            protocolManager.postProcessDispatch(messageDispatch);
-            if (sub != null) {
-               sub.onFailure();
-            }
-            messageDispatch = null;
-            throw e;
+      catch (Exception e)
+      {
+         synchronized (brokerConnectionStates)
+         {
+            brokerConnectionStates.remove(info.getConnectionId());
+         }
+         unregisterConnectionState(info.getConnectionId());
+
+         if (e instanceof SecurityException)
+         {
+            // close this down - in case the peer of this transport doesn't play
+            // nice
+            delayedStop(2000,
+                  "Failed with SecurityException: " + e.getLocalizedMessage(),
+                  e);
          }
+         Response resp = new ExceptionResponse(e);
+         return resp;
       }
-      finally {
-         if (messageDispatch != null) {
-            TransmitCallback sub = messageDispatch.getTransmitCallback();
-            protocolManager.postProcessDispatch(messageDispatch);
-            if (sub != null) {
-               sub.onSuccess();
-            }
+      if (info.isManageable())
+      {
+         // send ConnectionCommand
+         ConnectionControl command = this.acceptorUsed.getConnectionControl();
+         command.setFaultTolerant(protocolManager
+               .isFaultTolerantConfiguration());
+         if (info.isFailoverReconnect())
+         {
+            command.setRebalanceConnection(false);
          }
+         dispatchAsync(command);
       }
+      return null;
    }
 
-   private void addConsumerBrokerExchange(ConsumerId id, AMQSession amqSession, List<AMQConsumer> consumerList) {
-      AMQConsumerBrokerExchange result = consumerExchanges.get(id);
-      if (result == null) {
-         if (consumerList.size() == 1) {
-            result = new AMQSingleConsumerBrokerExchange(amqSession, consumerList.get(0));
+   public void dispatchAsync(Command message)
+   {
+      if (!stopping.get())
+      {
+         if (taskRunner == null)
+         {
+            dispatchSync(message);
          }
-         else {
-            result = new AMQCompositeConsumerBrokerExchange(amqSession, consumerList);
-         }
-         synchronized (consumerExchanges) {
-            consumerExchanges.put(id, result);
+         else
+         {
+            synchronized (dispatchQueue)
+            {
+               dispatchQueue.add(message);
+            }
+            try
+            {
+               taskRunner.wakeup();
+            }
+            catch (InterruptedException e)
+            {
+               Thread.currentThread().interrupt();
+            }
          }
       }
-   }
-
-   private AMQProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {
-      AMQProducerBrokerExchange result = producerExchanges.get(id);
-      if (result == null) {
-         synchronized (producerExchanges) {
-            result = new AMQProducerBrokerExchange();
-            result.setConnectionContext(context);
-            //todo implement reconnect https://issues.apache.org/jira/browse/ARTEMIS-194
-            //todo: this used to check for  && this.acceptorUsed.isAuditNetworkProducers()
-            if (context.isReconnect() || (context.isNetworkConnection())) {
-               // once implemented ARTEMIS-194, we need to set the storedSequenceID here somehow
-               // We have different semantics on Artemis Journal, but we could adapt something for this
-               // TBD during the implemetnation of ARTEMIS-194
-               result.setLastStoredSequenceId(0);
-            }
-            SessionState ss = state.getSessionState(id.getParentId());
-            if (ss != null) {
-               result.setProducerState(ss.getProducerState(id));
-               ProducerState producerState = ss.getProducerState(id);
-               if (producerState != null && producerState.getInfo() != null) {
-                  ProducerInfo info = producerState.getInfo();
-               }
+      else
+      {
+         if (message.isMessageDispatch())
+         {
+            MessageDispatch md = (MessageDispatch) message;
+            TransmitCallback sub = md.getTransmitCallback();
+            protocolManager.postProcessDispatch(md);
+            if (sub != null)
+            {
+               sub.onFailure();
             }
-            producerExchanges.put(id, result);
          }
       }
-      return result;
    }
 
-   public void deliverMessage(MessageDispatch dispatch) {
-      Message m = dispatch.getMessage();
-      if (m != null) {
-         long endTime = System.currentTimeMillis();
-         m.setBrokerOutTime(endTime);
+   public void dispatchSync(Command message)
+   {
+      try
+      {
+         processDispatch(message);
+      }
+      catch (IOException e)
+      {
+         serviceExceptionAsync(e);
       }
-
-      sendCommand(dispatch);
-   }
-
-   public WireFormat getMarshaller() {
-      return this.wireFormat;
    }
 
-   public void registerTempQueue(ActiveMQDestination queue) {
-      tempQueues.add(queue);
+   public void serviceExceptionAsync(final IOException e)
+   {
+      if (asyncException.compareAndSet(false, true))
+      {
+         new Thread("Async Exception Handler")
+         {
+            @Override
+            public void run()
+            {
+               serviceException(e);
+            }
+         }.start();
+      }
    }
 
-   private void shutdown(boolean fail) {
-      if (fail) {
-         transportConnection.forceClose();
+   public void serviceException(Throwable e)
+   {
+      // are we a transport exception such as not being able to dispatch
+      // synchronously to a transport
+      if (e instanceof IOException)
+      {
+         serviceTransportException((IOException) e);
+      }
+      else if (e.getClass() == AMQBrokerStoppedException.class)
+      {
+         // Handle the case where the broker is stopped
+         // But the client is still connected.
+         if (!stopping.get())
+         {
+            ConnectionError ce = new ConnectionError();
+            ce.setException(e);
+            dispatchSync(ce);
+            // Record the error that caused the transport to stop
+            this.stopError = e;
+            // Wait a little bit to try to get the output buffer to flush
+            // the exception notification to the client.
+            try
+            {
+               Thread.sleep(500);
+            }
+            catch (InterruptedException ie)
+            {
+               Thread.currentThread().interrupt();
+            }
+            // Worst case is we just kill the connection before the
+            // notification gets to him.
+            stopAsync();
+         }
       }
-      else {
-         transportConnection.close();
+      else if (!stopping.get() && !inServiceException)
+      {
+         inServiceException = true;
+         try
+         {
+            ConnectionError ce = new ConnectionError();
+            ce.setException(e);
+            if (pendingStop)
+            {
+               dispatchSync(ce);
+            }
+            else
+            {
+               dispatchAsync(ce);
+            }
+         }
+         finally
+         {
+            inServiceException = false;
+         }
       }
    }
 
-   private void disconnect(ActiveMQException me, String reason, boolean fail) {
+   public void serviceTransportException(IOException e)
+   {
+      /*
+       * deal with it later BrokerService bService =
+       * connector.getBrokerService(); if (bService.isShutdownOnSlaveFailure())
+       * { if (brokerInfo != null) { if (brokerInfo.isSlaveBroker()) {
+       * LOG.error("Slave has exception: {} shutting down master now.",
+       * e.getMessage(), e); try { doStop(); bService.stop(); } catch (Exception
+       * ex) { LOG.warn("Failed to stop the master", ex); } } } } if
+       * (!stopping.get() && !pendingStop) { transportException.set(e); if
+       * (TRANSPORTLOG.isDebugEnabled()) { TRANSPORTLOG.debug(this + " failed: "
+       * + e, e); } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {
+       * TRANSPORTLOG.warn(this + " failed: " + e); } stopAsync(); }
+       */
+   }
 
-      if (context == null || destroyed) {
-         return;
+   public void setMarkedCandidate(boolean markedCandidate)
+   {
+      this.markedCandidate = markedCandidate;
+      if (!markedCandidate)
+      {
+         timeStamp = 0;
+         blockedCandidate = false;
       }
-      // Don't allow things to be added to the connection state while we
-      // are shutting down.
-      // is it necessary? even, do we need state at all?
-      state.shutdown();
-
-      // Then call the listeners
-      // this should closes underlying sessions
-      callFailureListeners(me);
+   }
 
-      // this should clean up temp dests
-      synchronized (sendLock) {
-         callClosingListeners();
+   protected void dispatch(Command command) throws IOException
+   {
+      try
+      {
+         setMarkedCandidate(true);
+         this.physicalSend(command);
       }
-
-      destroyed = true;
-
-      //before closing transport, sendCommand the last response if any
-      Command command = context.getLastCommand();
-      if (command != null && command.isResponseRequired()) {
-         Response lastResponse = new Response();
-         lastResponse.setCorrelationId(command.getCommandId());
-         try {
-            dispatchSync(lastResponse);
-         }
-         catch (Throwable e) {
-            ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
-         }
+      finally
+      {
+         setMarkedCandidate(false);
       }
    }
 
-   @Override
-   public void disconnect(String reason, boolean fail) {
-      this.disconnect(null, reason, fail);
-   }
-
-   @Override
-   public void fail(ActiveMQException me, String message) {
-      if (me != null) {
-         ActiveMQServerLogger.LOGGER.connectionFailureDetected(me.getMessage(), me.getType());
+   protected void processDispatch(Command command) throws IOException
+   {
+      MessageDispatch messageDispatch = (MessageDispatch) (command
+            .isMessageDispatch() ? command : null);
+      try
+      {
+         if (!stopping.get())
+         {
+            if (messageDispatch != null)
+            {
+               protocolManager.preProcessDispatch(messageDispatch);
+            }
+            dispatch(command);
+         }
       }
-      try {
-         protocolManager.removeConnection(this.getConnectionInfo(), me);
+      catch (IOException e)
+      {
+         if (messageDispatch != null)
+         {
+            TransmitCallback sub = messageDispatch.getTransmitCallback();
+            protocolManager.postProcessDispatch(messageDispatch);
+            if (sub != null)
+            {
+               sub.onFailure();
+            }
+            messageDispatch = null;
+            throw e;
+         }
       }
-      catch (InvalidClientIDException e) {
-         ActiveMQServerLogger.LOGGER.warn("Couldn't close connection because invalid clientID", e);
+      finally
+      {
+         if (messageDispatch != null)
+         {
+            TransmitCallback sub = messageDispatch.getTransmitCallback();
+            protocolManager.postProcessDispatch(messageDispatch);
+            if (sub != null)
+            {
+               sub.onSuccess();
+            }
+         }
       }
-      shutdown(true);
    }
 
-   public void setAdvisorySession(AMQSession amqSession) {
-      this.advisorySession = amqSession;
+   private AMQMessageAuthorizationPolicy getMessageAuthorizationPolicy()
+   {
+      return this.messageAuthorizationPolicy;
    }
 
-   public AMQSession getAdvisorySession() {
-      return this.advisorySession;
+   protected synchronized AMQTransportConnectionState unregisterConnectionState(
+         ConnectionId connectionId)
+   {
+      return connectionStateRegister.unregisterConnectionState(connectionId);
    }
 
-   public AMQConnectionContext getContext() {
-      return this.context;
+   protected synchronized AMQTransportConnectionState registerConnectionState(
+         ConnectionId connectionId, AMQTransportConnectionState state)
+   {
+      AMQTransportConnectionState cs = null;
+      if (!connectionStateRegister.isEmpty()
+            && !connectionStateRegister.doesHandleMultipleConnectionStates())
+      {
+         // swap implementations
+         AMQTransportConnectionStateRegister newRegister = new AMQMapTransportConnectionStateRegister();
+         newRegister.intialize(connectionStateRegister);
+         connectionStateRegister = newRegister;
+      }
+      cs = connectionStateRegister.registerConnectionState(connectionId, state);
+      return cs;
    }
 
-   public void updateClient(ConnectionControl control) throws Exception {
-      if (protocolManager.isUpdateClusterClients()) {
-         dispatchAsync(control);
-      }
-   }
-
-   public AMQConnectionContext initContext(ConnectionInfo info) throws Exception {
-      WireFormatInfo wireFormatInfo = wireFormat.getPreferedWireFormatInfo();
-      // Older clients should have been defaulting this field to true.. but
-      // they were not.
-      if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
-         info.setClientMaster(true);
-      }
-
-      state = new ConnectionState(info);
-
-      context = new AMQConnectionContext();
-
-      state.reset(info);
-
-      // Setup the context.
-      String clientId = info.getClientId();
-      context.setBroker(protocolManager);
-      context.setClientId(clientId);
-      context.setClientMaster(info.isClientMaster());
-      context.setConnection(this);
-      context.setConnectionId(info.getConnectionId());
-      // for now we pass the manager as the connector and see what happens
-      // it should be related to activemq's Acceptor
-      context.setFaultTolerant(info.isFaultTolerant());
-      context.setUserName(info.getUserName());
-      context.setWireFormatInfo(wireFormatInfo);
-      context.setReconnect(info.isFailoverReconnect());
-      context.setConnectionState(state);
-      if (info.getClientIp() == null) {
-         info.setClientIp(getRemoteAddress());
-      }
-
-      createInternalSession(info);
-
-      return context;
-   }
-
-   private void createInternalSession(ConnectionInfo info) throws Exception {
-      internalSession = server.createSession(UUIDGenerator.getInstance().generateStringUUID(), context.getUserName(), info.getPassword(), -1, this, true, false, false, false, null, null, true);
-   }
-
-   //raise the refCount of context
-   public void reconnect(AMQConnectionContext existingContext, ConnectionInfo info) {
-      this.context = existingContext;
-      WireFormatInfo wireFormatInfo = wireFormat.getPreferedWireFormatInfo();
-      // Older clients should have been defaulting this field to true.. but
-      // they were not.
-      if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
-         info.setClientMaster(true);
-      }
-      if (info.getClientIp() == null) {
-         info.setClientIp(getRemoteAddress());
+   public void delayedStop(final int waitTime, final String reason,
+         Throwable cause)
+   {
+      if (waitTime > 0)
+      {
+         synchronized (this)
+         {
+            pendingStop = true;
+            stopError = cause;
+         }
+         try
+         {
+            stopTaskRunnerFactory.execute(new Runnable()
+            {
+               @Override
+               public void run()
+               {
+                  try
+                  {
+                     Thread.sleep(waitTime);
+                     stopAsync();
+                  }
+                  catch (InterruptedException e)
+                  {
+                  }
+               }
+            });
+         }
+         catch (Throwable t)
+         {
+            // log error
+         }
       }
-
-      state = new ConnectionState(info);
-      state.reset(info);
-
-      context.setConnection(this);
-      context.setConnectionState(state);
-      context.setClientMaster(info.isClientMaster());
-      context.setFaultTolerant(info.isFaultTolerant());
-      context.setReconnect(true);
-      context.incRefCount();
    }
 
-   /**
-    * This will answer with commands to the client
-    */
-   public boolean sendCommand(final Command command) {
-      if (ActiveMQServerLogger.LOGGER.isTraceEnabled()) {
-         ActiveMQServerLogger.LOGGER.trace("sending " + command);
-      }
-
-      if (isDestroyed()) {
-         return false;
-      }
-
-      try {
-         physicalSend(command);
-      }
-      catch (Exception e) {
-         return false;
-      }
-      catch (Throwable t) {
-         return false;
+   public void stopAsync()
+   {
+      // If we're in the middle of starting then go no further... for now.
+      synchronized (this)
+      {
+         pendingStop = true;
+         if (starting)
+         {
+            // log
+            return;
+         }
       }
-      return true;
-   }
-
-   public void addDestination(DestinationInfo info) throws Exception {
-      ActiveMQDestination dest = info.getDestination();
-      if (dest.isQueue()) {
-         SimpleString qName = OpenWireUtil.toCoreAddress(dest);
-         QueueBinding binding = (QueueBinding) server.getPostOffice().getBinding(qName);
-         if (binding == null) {
-            if (getState().getInfo() != null) {
-
-               CheckType checkType = dest.isTemporary() ? CheckType.CREATE_NON_DURABLE_QUEUE : CheckType.CREATE_DURABLE_QUEUE;
-               server.getSecurityStore().check(qName, checkType, this);
-
-               server.checkQueueCreationLimit(getUsername());
+      if (stopping.compareAndSet(false, true))
+      {
+         // Let all the connection contexts know we are shutting down
+         // so that in progress operations can notice and unblock.
+         List<AMQTransportConnectionState> connectionStates = listConnectionStates();
+         for (AMQTransportConnectionState cs : connectionStates)
+         {
+            AMQConnectionContext connectionContext = cs.getContext();
+            if (connectionContext != null)
+            {
+               connectionContext.getStopping().set(true);
             }
-            ConnectionInfo connInfo = getState().getInfo();
-            server.createQueue(qName, qName, null, connInfo == null ? null : SimpleString.toSimpleString(connInfo.getUserName()), false, dest.isTemporary());
          }
-
-         if (dest.isTemporary()) {
-            registerTempQueue(dest);
+         try
+         {
+            stopTaskRunnerFactory.execute(new Runnable()
+            {
+               @Override
+               public void run()
+               {
+                  serviceLock.writeLock().lock();
+                  try
+                  {
+                     doStop();
+                  }
+                  catch (Throwable e)
+                  {
+                     // LOG
+                  }
+                  finally
+                  {
+                     stopped.countDown();
+                     serviceLock.writeLock().unlock();
+                  }
+               }
+            });
+         }
+         catch (Throwable t)
+         {
+            // LOG
+            stopped.countDown();
          }
-      }
-
-      if (!AdvisorySupport.isAdvisoryTopic(dest)) {
-         AMQConnectionContext context = getContext();
-         DestinationInfo advInfo = new DestinationInfo(context.getConnectionId(), DestinationInfo.ADD_OPERATION_TYPE, dest);
-
-         ActiveMQTopic topic = AdvisorySupport.getDestinationAdvisoryTopic(dest);
-         protocolManager.fireAdvisory(context, topic, advInfo);
       }
    }
 
-   public void updateConsumer(ConsumerControl consumerControl) {
-      ConsumerId consumerId = consumerControl.getConsumerId();
-      AMQConsumerBrokerExchange exchange = this.consumerExchanges.get(consumerId);
-      if (exchange != null) {
-         exchange.updateConsumerPrefetchSize(consumerControl.getPrefetch());
-      }
+   protected synchronized List<AMQTransportConnectionState> listConnectionStates()
+   {
+      return connectionStateRegister.listConnectionStates();
    }
 
-   public void addConsumer(ConsumerInfo info) throws Exception {
-      // Todo: add a destination interceptors holder here (amq supports this)
-      SessionId sessionId = info.getConsumerId().getParentId();
-      ConnectionId connectionId = sessionId.getParentId();
-      ConnectionState cs = getState();
-      if (cs == null) {
-         throw new IllegalStateException("Cannot add a consumer to a connection that had not been registered: " + connectionId);
-      }
-      SessionState ss = cs.getSessionState(sessionId);
-      if (ss == null) {
-         throw new IllegalStateException(server + " Cannot add a consumer to a session that had not been registered: " + sessionId);
-      }
-      // Avoid replaying dup commands
-      if (!ss.getConsumerIds().contains(info.getConsumerId())) {
-
-         AMQSession amqSession = sessions.get(sessionId);
-         if (amqSession == null) {
-            throw new IllegalStateException("Session not exist! : " + sessionId);
+   protected void doStop() throws Exception
+   {
+      this.acceptorUsed.onStopped(this);
+      /*
+       * What's a duplex bridge? try { synchronized (this) { if (duplexBridge !=
+       * null) { duplexBridge.stop(); } } } catch (Exception ignore) {
+       * LOG.trace("Exception caught stopping. This exception is ignored.",
+       * ignore); }
+       */
+      try
+      {
+         getTransportConnection().close();
+      }
+      catch (Exception e)
+      {
+         // log
+      }
+
+      if (taskRunner != null)
+      {
+         taskRunner.shutdown(1);
+         taskRunner = null;
+      }
+
+      active = false;
+      // Run the MessageDispatch callbacks so that message references get
+      // cleaned up.
+      synchronized (dispatchQueue)
+      {
+         for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext();)
+         {
+            Command command = iter.next();
+            if (command.isMessageDispatch())
+            {
+               MessageDispatch md = (MessageDispatch) command;
+               TransmitCallback sub = md.getTransmitCallback();
+               protocolManager.postProcessDispatch(md);
+               if (sub != null)
+               {
+                  sub.onFailure();
+               }
+            }
          }
-
-         List<AMQConsumer> consumersList = amqSession.createConsumer(info, amqSession, new SlowConsumerDetection());
-
-         this.addConsumerBrokerExchange(info.getConsumerId(), amqSession, consumersList);
-         ss.addConsumer(info);
-         amqSession.start();
-      }
-   }
-
-   class SlowConsumerDetection implements SlowConsumerDetectionListener {
-
-      @Override
-      public void onSlowConsumer(ServerConsumer consumer) {
-         if (consumer.getProtocolData() != null && consumer.getProtocolData() instanceof AMQConsumer) {
-            AMQConsumer amqConsumer = (AMQConsumer) consumer.getProtocolData();
-            ActiveMQTopic topic = AdvisorySupport.getSlowConsumerAdvisoryTopic(amqConsumer.getOpenwireDestination());
-            ActiveMQMessage advisoryMessage = new ActiveMQMessage();
-            try {
-               advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_CONSUMER_ID, amqConsumer.getId().toString());
-               protocolManager.fireAdvisory(context, topic, advisoryMessage, amqConsumer.getId());
+         dispatchQueue.clear();
+      }
+      //
+      // Remove all logical connection associated with this connection
+      // from the broker.
+      if (!protocolManager.isStopped())
+      {
+         List<AMQTransportConnectionState> connectionStates = listConnectionStates();
+         connectionStates = listConnectionStates();
+         for (AMQTransportConnectionState cs : connectionStates)
+         {
+            cs.getContext().getStopping().set(true);
+            try
+            {
+               processRemoveConnection(cs.getInfo().getConnectionId(), 0L);
             }
-            catch (Exception e) {
-               // TODO-NOW: LOGGING
-               e.printStackTrace();
+            catch (Throwable ignore)
+            {
+               ignore.printStackTrace();
             }
          }
       }
    }
 
-   public void addSessions(Set<SessionId> sessionSet) {
-      Iterator<SessionId> iter = sessionSet.iterator();
-      while (iter.hasNext()) {
-         SessionId sid = iter.next();
-         addSession(getState().getSessionState(sid).getInfo(), true);
+   @Override
+   public Response processAddConsumer(ConsumerInfo info)
+   {
+      Response resp = null;
+      try
+      {
+         protocolManager.addConsumer(this, info);
+      }
+      catch (Exception e)
+      {
+         if (e instanceof ActiveMQSecurityException)
+         {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+         }
+         else
+         {
+            resp = new ExceptionResponse(e);
+         }
       }
+      return resp;
    }
 
-   public AMQSession addSession(SessionInfo ss) {
-      return addSession(ss, false);
-   }
-
-   public AMQSession addSession(SessionInfo ss, boolean internal) {
-      AMQSession amqSession = new AMQSession(getState().getInfo(), ss, server, this, protocolManager.getScheduledPool());
-      amqSession.initialize();
-
-      if (internal) {
-         amqSession.disableSecurity();
+   AMQConsumerBrokerExchange addConsumerBrokerExchange(ConsumerId id)
+   {
+      AMQConsumerBrokerExchange result = consumerExchanges.get(id);
+      if (result == null)
+      {
+         synchronized (consumerExchanges)
+         {
+            result = new AMQConsumerBrokerExchange();
+            AMQTransportConnectionState state = lookupConnectionState(id);
+            context = state.getContext();
+            result.setConnectionContext(context);
+            SessionState ss = state.getSessionState(id.getParentId());
+            if (ss != null)
+            {
+               ConsumerState cs = ss.getConsumerState(id);
+               if (cs != null)
+               {
+                  ConsumerInfo info = cs.getInfo();
+                  if (info != null)
+                  {
+                     if (info.getDestination() != null
+                           && info.getDestination().isPattern())
+                     {
+                        result.setWildcard(true);
+                     }
+                  }
+               }
+            }
+            consumerExchanges.put(id, result);
+         }
       }
-
-      sessions.put(ss.getSessionId(), amqSession);
-      sessionIdMap.put(amqSession.getCoreSession().getName(), ss.getSessionId());
-      return amqSession;
+      return result;
    }
 
-   public void removeSession(AMQConnectionContext context, SessionInfo info) throws Exception {
-      AMQSession session = sessions.remove(info.getSessionId());
-      if (session != null) {
-         session.close();
-      }
+   protected synchronized AMQTransportConnectionState lookupConnectionState(
+         ConsumerId id)
+   {
+      return connectionStateRegister.lookupConnectionState(id);
    }
 
-   public AMQSession getSession(SessionId sessionId) {
-      return sessions.get(sessionId);
+   protected synchronized AMQTransportConnectionState lookupConnectionState(
+         ProducerId id)
+   {
+      return connectionStateRegister.lookupConnectionState(id);
    }
 
-   public void removeDestination(ActiveMQDestination dest) throws Exception {
-      if (dest.isQueue()) {
-         SimpleString qName = new SimpleString("jms.queue." + dest.getPhysicalName());
-         server.destroyQueue(qName);
-      }
-      else {
-         Bindings bindings = server.getPostOffice().getBindingsForAddress(SimpleString.toSimpleString("jms.topic." + dest.getPhysicalName()));
-         Iterator<Binding> iterator = bindings.getBindings().iterator();
-
-         while (iterator.hasNext()) {
-            Queue b = (Queue) iterator.next().getBindable();
-            if (b.getConsumerCount() > 0) {
-               throw new Exception("Destination still has an active subscription: " + dest.getPhysicalName());
+   public int getConsumerCount(ConnectionId connectionId)
+   {
+      int result = 0;
+      AMQTransportConnectionState cs = lookupConnectionState(connectionId);
+      if (cs != null)
+      {
+         for (SessionId sessionId : cs.getSessionIds())
+         {
+            SessionState sessionState = cs.getSessionState(sessionId);
+            if (sessionState != null)
+            {
+               result += sessionState.getConsumerIds().size();
             }
-            if (b.isDurable()) {
-               throw new Exception("Destination still has durable subscription: " + dest.getPhysicalName());
-            }
-            b.deleteQueue();
          }
       }
-
-      if (!AdvisorySupport.isAdvisoryTopic(dest)) {
-         AMQConnectionContext context = getContext();
-         DestinationInfo advInfo = new DestinationInfo(context.getConnectionId(), DestinationInfo.REMOVE_OPERATION_TYPE, dest);
-
-         ActiveMQTopic topic = AdvisorySupport.getDestinationAdvisoryTopic(dest);
-         protocolManager.fireAdvisory(context, topic, advInfo);
-      }
+      return result;
    }
 
-   /**
-    * Checks to see if this destination exists.  If it does not throw an invalid destination exception.
-    *
-    * @param destination
-    */
-   private void validateDestination(ActiveMQDestination destination) throws Exception {
-      if (destination.isQueue()) {
-         SimpleString physicalName = OpenWireUtil.toCoreAddress(destination);
-         BindingQueryResult result = server.bindingQuery(physicalName);
-         if (!result.isExists() && !result.isAutoCreateJmsQueues()) {
-            throw ActiveMQMessageBundle.BUNDLE.noSuchQueue(physicalName);
+   public int getProducerCount(ConnectionId connectionId)
+   {
+      int result = 0;
+      AMQTransportConnectionState cs = lookupConnectionState(connectionId);
+      if (cs != null)
+      {
+         for (SessionId sessionId : cs.getSessionIds())
+         {
+            SessionState sessionState = cs.getSessionState(sessionId);
+            if (sessionState != null)
+            {
+               result += sessionState.getProducerIds().size();
+            }
          }
       }
+      return result;
    }
 
-   CommandProcessor commandProcessorInstance = new CommandProcessor();
-
-   // This will listen for commands throught the protocolmanager
-   public class CommandProcessor implements CommandVisitor {
+   public synchronized AMQTransportConnectionState lookupConnectionState(
+         ConnectionId connectionId)
+   {
+      return connectionStateRegister.lookupConnectionState(connectionId);
+   }
 
-      public AMQConnectionContext getContext() {
-         return OpenWireConnection.this.getContext();
+   @Override
+   public Response processAddDestination(DestinationInfo dest) throws Exception
+   {
+      Response resp = null;
+      try
+      {
+         protocolManager.addDestination(this, dest);
+      }
+      catch (Exception e)
+      {
+         if (e instanceof ActiveMQSecurityException)
+         {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+         }
+         else
+         {
+            resp = new ExceptionResponse(e);
+         }
       }
+      return resp;
+   }
 
-      @Override
-      public Response processAddConnection(ConnectionInfo info) throws Exception {
-         try {
-            protocolManager.addConnection(OpenWireConnection.this, info);
+   @Override
+   public Response processAddProducer(ProducerInfo info) throws Exception
+   {
+      Response resp = null;
+      try
+      {
+         protocolManager.addProducer(this, info);
+      }
+      catch (Exception e)
+      {
+         if (e instanceof ActiveMQSecurityException)
+         {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
          }
-         catch (Exception e) {
-            Response resp = new ExceptionResponse(e);
-            return resp;
+         else if (e instanceof ActiveMQNonExistentQueueException)
+         {
+            resp = new ExceptionResponse(new InvalidDestinationException(e.getMessage()));
          }
-         if (info.isManageable() && protocolManager.isUpdateClusterClients()) {
-            // send ConnectionCommand
-            ConnectionControl command = protocolManager.newConnectionControl();
-            command.setFaultTolerant(protocolManager.isFaultTolerantConfiguration());
-            if (info.isFailoverReconnect()) {
-               command.setRebalanceConnection(false);
-            }
-            dispatchAsync(command);
+         else
+         {
+            resp = new ExceptionResponse(e);
          }
-         return null;
-
       }
+      return resp;
+   }
 
-      @Override
-      public Response processAddProducer(ProducerInfo info) throws Exception {
-         SessionId sessionId = info.getProducerId().getParentId();
-         ConnectionState cs = getState();
-
-         if (cs == null) {
-            throw new IllegalStateException("Cannot add a producer to a connection that had not been registered: " + sessionId.getParentId());
+   @Override
+   public Response processAddSession(SessionInfo info) throws Exception
+   {
+      ConnectionId connectionId = info.getSessionId().getParentId();
+      AMQTransportConnectionState cs = lookupConnectionState(connectionId);
+      // Avoid replaying dup commands
+      if (cs != null && !cs.getSessionIds().contains(info.getSessionId()))
+      {
+         protocolManager.addSession(this, info);
+         try
+         {
+            cs.addSession(info);
          }
-
-         SessionState ss = cs.getSessionState(sessionId);
-         if (ss == null) {
-            throw new IllegalStateException("Cannot add a producer to a session that had not been registered: " + sessionId);
+         catch (IllegalStateException e)
+         {
+            e.printStackTrace();
+            protocolManager.removeSession(cs.getContext(), info);
          }
-
-         // Avoid replaying dup commands
-         if (!ss.getProducerIds().contains(info.getProducerId())) {
-            ActiveMQDestination destination = info.getDestination();
-
-            if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {
-               if (destination.isQueue()) {
-                  OpenWireConnection.this.validateDestination(destination);
-               }
-               DestinationInfo destInfo = new DestinationInfo(getContext().getConnectionId(), DestinationInfo.ADD_OPERATION_TYPE, destination);
-               OpenWireConnection.this.addDestination(destInfo);
-            }
-
-            ss.addProducer(info);
-
-         }
-         return null;
       }
+      return null;
+   }
 
-      @Override
-      public Response processAddConsumer(ConsumerInfo info) throws Exception {
-         addConsumer(info);
-         return null;
-      }
+   @Override
+   public Response processBeginTransaction(TransactionInfo info) throws Exception
+   {
+      TransactionId txId = info.getTransactionId();
 
-      @Override
-      public Response processRemoveDestination(DestinationInfo info) throws Exception {
-         ActiveMQDestination dest = info.getDestination();
-         removeDestination(dest);
-         return null;
+      if (!txMap.containsKey(txId))
+      {
+         txMap.put(txId, info);
       }
+      return null;
+   }
 
-      @Override
-      public Response processRemoveProducer(ProducerId id) throws Exception {
+   @Override
+   public Response processBrokerInfo(BrokerInfo arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         // TODO-now: proper implement this method
-         return null;
-      }
+   @Override
+   public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception
+   {
+      protocolManager.commitTransactionOnePhase(info);
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
 
-      @Override
-      public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) throws Exception {
-         SessionState session = state.getSessionState(id);
-         if (session == null) {
-            throw new IllegalStateException("Cannot remove session that had not been registered: " + id);
-         }
-         // Don't let new consumers or producers get added while we are closing
-         // this down.
-         session.shutdown();
-         // Cascade the connection stop producers.
-         // we don't stop consumer because in core
-         // closing the session will do the job
-         for (ProducerId producerId : session.getProducerIds()) {
-            try {
-               processRemoveProducer(producerId);
-            }
-            catch (Throwable e) {
-               // LOG.warn("Failed to remove producer: {}", producerId, e);
-            }
-         }
-         state.removeSession(id);
-         removeSession(context, session.getInfo());
-         return null;
-      }
+      return null;
+   }
 
-      @Override
-      public Response processRemoveSubscription(RemoveSubscriptionInfo subInfo) throws Exception {
-         SimpleString subQueueName = new SimpleString(org.apache.activemq.artemis.jms.client.ActiveMQDestination.createQueueNameForDurableSubscription(true, subInfo.getClientId(), subInfo.getSubscriptionName()));
-         server.destroyQueue(subQueueName);
+   @Override
+   public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception
+   {
+      protocolManager.commitTransactionTwoPhase(info);
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
 
-         return null;
-      }
+      return null;
+   }
 
-      @Override
-      public Response processRollbackTransaction(TransactionInfo info) throws Exception {
-         Transaction tx = lookupTX(info.getTransactionId(), null);
-         if (info.getTransactionId().isXATransaction() && tx == null) {
-            throw newXAException("Transaction '" + info.getTransactionId() + "' has not been started.", XAException.XAER_NOTA);
-         }
-         else if (tx != null) {
+   @Override
+   public Response processConnectionControl(ConnectionControl arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-            AMQSession amqSession = (AMQSession) tx.getProtocolData();
+   @Override
+   public Response processConnectionError(ConnectionError arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-            if (amqSession != null) {
-               amqSession.getCoreSession().resetTX(tx);
+   @Override
+   public Response processConsumerControl(ConsumerControl arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-               try {
-                  returnReferences(tx, amqSession);
-               }
-               finally {
-                  amqSession.getCoreSession().resetTX(null);
-               }
-            }
-            tx.rollback();
-         }
+   @Override
+   public Response processControlCommand(ControlCommand arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         return null;
-      }
+   @Override
+   public Response processEndTransaction(TransactionInfo info) throws Exception
+   {
+      TransactionId txId = info.getTransactionId();
 
-      /**
-       * Openwire will redeliver rolled back references.
-       * We need to return those here.
-       */
-      private void returnReferences(Transaction tx, AMQSession session) throws Exception {
-         if (session == null || session.isClosed()) {
-            return;
-         }
+      if (!txMap.containsKey(txId))
+      {
+         txMap.put(txId, info);
+      }
+      return null;
+   }
 
-         RefsOperation oper = (RefsOperation) tx.getProperty(TransactionPropertyIndexes.REFS_OPERATION);
+   @Override
+   public Response processFlush(FlushCommand arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         if (oper != null) {
-            List<MessageReference> ackRefs = oper.getReferencesToAcknowledge();
+   @Override
+   public Response processForgetTransaction(TransactionInfo info) throws Exception
+   {
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
 
-            for (ListIterator<MessageReference> referenceIterator = ackRefs.listIterator(ackRefs.size()); referenceIterator.hasPrevious(); ) {
-               MessageReference ref = referenceIterator.previous();
+      protocolManager.forgetTransaction(info.getTransactionId());
+      return null;
+   }
 
-               Long consumerID = ref.getConsumerId();
+   @Override
+   public Response processKeepAlive(KeepAliveInfo arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-               ServerConsumer consumer = null;
-               if (consumerID != null) {
-                  consumer = session.getCoreSession().locateConsumer(consumerID);
+   @Override
+   public Response processMessage(Message messageSend)
+   {
+      Response resp = null;
+      try
+      {
+         ProducerId producerId = messageSend.getProducerId();
+         AMQProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
+         final AMQConnectionContext pcontext = producerExchange.getConnectionContext();
+         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
+         boolean sendProducerAck = !messageSend.isResponseRequired() && producerInfo.getWindowSize() > 0
+               && !pcontext.isInRecoveryMode();
+
+         AMQSession session = protocolManager.getSession(producerId.getParentId());
+
+         if (producerExchange.canDispatch(messageSend))
+         {
+            SendingResult result = session.send(producerExchange, messageSend, sendProducerAck);
+            if (result.isBlockNextSend())
+            {
+               if (!context.isNetworkConnection() && result.isSendFailIfNoSpace())
+               {
+                  throw new ResourceAllocationException("Usage Manager Memory Limit reached. Stopping producer ("
+                     + producerId + ") to prevent flooding "
+                     + result.getBlockingAddress() + "."
+                     + " See http://activemq.apache.org/producer-flow-control.html for more info");
                }
 
-               if (consumer != null) {
-                  referenceIterator.remove();
-                  ref.incrementDeliveryCount();
-                  consumer.backToDelivering(ref);
+               if (producerInfo.getWindowSize() > 0 || messageSend.isResponseRequired())
+               {
+                  //in that case don't send the response
+                  //this will force the client to wait until
+                  //the response is got.
+                  if (context == null)
+                  {
+                     this.context = new AMQConnectionContext();
+                  }
+                  context.setDontSendReponse(true);
+               }
+               else
+               {
+                  //hang the connection until the space is available
+                  session.blockingWaitForSpace(producerExchange, result);
                }
             }
-         }
-      }
-
-      @Override
-      public Response processShutdown(ShutdownInfo info) throws Exception {
-         OpenWireConnection.this.shutdown(false);
-         return null;
-      }
-
-      @Override
-      public Response processWireFormat(WireFormatInfo command) throws Exception {
-         wireFormat.renegotiateWireFormat(command);
-         //throw back a brokerInfo here
-         protocolManager.sendBrokerInfo(OpenWireConnection.this);
-         return null;
-      }
-
-      @Override
-      public Response processAddDestination(DestinationInfo dest) throws Exception {
-         Response resp = null;
-         try {
-            addDestination(dest);
-         }
-         catch (Exception e) {
-            if (e instanceof ActiveMQSecurityException) {
-               resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
-            }
-            else {
-               resp = new ExceptionResponse(e);
+            else if (sendProducerAck)
+            {
+               ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), messageSend.getSize());
+               this.dispatchAsync(ack);
             }
          }
-         return resp;
       }
-
-      @Override
-      public Response processAddSession(SessionInfo info) throws Exception {
-         // Avoid replaying dup commands
-         if (!state.getSessionIds().contains(info.getSessionId())) {
-            addSession(info);
-            state.addSession(info);
+      catch (Exception e)
+      {
+         if (e instanceof ActiveMQSecurityException)
+         {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+         }
+         else
+         {
+            resp = new ExceptionResponse(e);
          }
-         return null;
       }
+      return resp;
+   }
 
-      @Override
-      public Response processBeginTransaction(TransactionInfo info) throws Exception {
-         final TransactionId txID = info.getTransactionId();
-
-         try {
-            internalSession.resetTX(null);
-            if (txID.isXATransaction()) {
-               Xid xid = OpenWireUtil.toXID(txID);
-               internalSession.xaStart(xid);
+   private AMQProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException
+   {
+      AMQProducerBrokerExchange result = producerExchanges.get(id);
+      if (result == null)
+      {
+         synchronized (producerExchanges)
+         {
+            result = new AMQProducerBrokerExchange();
+            AMQTransportConnectionState state = lookupConnectionState(id);
+            context = state.getContext();
+            result.setConnectionContext(context);
+            if (context.isReconnect()
+                  || (context.isNetworkConnection() && this.acceptorUsed
+                        .isAuditNetworkProducers()))
+            {
+               result.setLastStoredSequenceId(protocolManager
+                     .getPersistenceAdapter().getLastProducerSequenceId(id));
             }
-            else {
-               Transaction transaction = internalSession.newTransaction();
-               txMap.put(txID, transaction);
-               transaction.addOperation(new TransactionOperationAbstract() {
-                  @Override
-                  public void afterCommit(Transaction tx) {
-                     txMap.remove(txID);
-                  }
-               });
+            SessionState ss = state.getSessionState(id.getParentId());
+            if (ss != null)
+            {
+               result.setProducerState(ss.getProducerState(id));
+               ProducerState producerState = ss.getProducerState(id);
+               if (producerState != null && producerState.getInfo() != null)
+               {
+                  ProducerInfo info = producerState.getInfo();
+                  result.setMutable(info.getDestination() == null
+                        || info.getDestination().isComposite());
+               }
             }
+            producerExchanges.put(id, result);
          }
-         finally {
-            internalSession.resetTX(null);
-         }
-         return null;
       }
-
-      @Override
-      public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
-         return processCommit(info, true);
+      else
+      {
+         context = result.getConnectionContext();
       }
+      return result;
+   }
 
-      private Response processCommit(TransactionInfo info, boolean onePhase) throws Exception {
-         TransactionId txID = info.getTransactionId();
+   @Override
+   public Response processMessageAck(MessageAck ack) throws Exception
+   {
+      ConsumerId consumerId = ack.getConsumerId();
+      SessionId sessionId = consumerId.getParentId();
+      AMQSession session = protocolManager.getSession(sessionId);
+      session.acknowledge(ack);
+      return null;
+   }
 
-         Transaction tx = lookupTX(txID, null);
+   @Override
+   public Response processMessageDispatch(MessageDispatch arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         AMQSession session = (AMQSession) tx.getProtocolData();
+   @Override
+   public Response processMessageDispatchNotification(
+         MessageDispatchNotification arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         tx.commit(onePhase);
+   @Override
+   public Response processMessagePull(MessagePull arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         return null;
-      }
+   @Override
+   public Response processPrepareTransaction(TransactionInfo info) throws Exception
+   {
+      protocolManager.prepareTransaction(info);
+      return null;
+   }
 
-      @Override
-      public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
-         return processCommit(info, false);
-      }
+   @Override
+   public Response processProducerAck(ProducerAck arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      @Override
-      public Response processForgetTransaction(TransactionInfo info) throws Exception {
-         TransactionId txID = info.getTransactionId();
+   @Override
+   public Response processRecoverTransactions(TransactionInfo info) throws Exception
+   {
+      AMQTransportConnectionState cs = lookupConnectionState(info.getConnectionId());
+      Set<SessionId> sIds = cs.getSessionIds();
+      TransactionId[] recovered = protocolManager.recoverTransactions(sIds);
+      return new DataArrayResponse(recovered);
+   }
 
-         if (txID.isXATransaction()) {
-            try {
-               Xid xid = OpenWireUtil.toXID(info.getTransactionId());
-               internalSession.xaForget(xid);
+   @Override
+   public Response processRemoveConnection(ConnectionId id,
+         long lastDeliveredSequenceId) throws Exception
+   {
+      AMQTransportConnectionState cs = lookupConnectionState(id);
+      if (cs != null)
+      {
+         // Don't allow things to be added to the connection state while we
+         // are shutting down.
+         cs.shutdown();
+         // Cascade the connection stop to the sessions.
+         for (SessionId sessionId : cs.getSessionIds())
+         {
+            try
+            {
+               processRemoveSession(sessionId, lastDeliveredSequenceId);
             }
-            catch (Exception e) {
-               e.printStackTrace();
-               throw e;
+            catch (Throwable e)
+            {
+               // LOG
             }
          }
-         else {
-            txMap.remove(txID);
-         }
-
-         return null;
-      }
-
-      @Override
-      public Response processPrepareTransaction(TransactionInfo info) throws Exception {
-         TransactionId txID = info.getTransactionId();
 
-         try {
-            if (txID.isXATransaction()) {
-               try {
-                  Xid xid = OpenWireUtil.toXID(info.getTransactionId());
-                  internalSession.xaPrepare(xid);
-               }
-               catch (Exception e) {
-                  e.printStackTrace();
-                  throw e;
-               }
-            }
-            else {
-               Transaction tx = lookupTX(txID, null);
-               tx.prepare();
-            }
+         try
+         {
+            protocolManager.removeConnection(cs.getContext(), cs.getInfo(),
+                  null);
          }
-         finally {
-            internalSession.resetTX(null);
+         catch (Throwable e)
+         {
+            // log
          }
-
-         return new IntegerResponse(XAResource.XA_RDONLY);
-      }
-
-      @Override
-      public Response processEndTransaction(TransactionInfo info) throws Exception {
-         TransactionId txID = info.getTransactionId();
-
-         if (txID.isXATransaction()) {
-            try {
-               Transaction tx = lookupTX(txID, null);
-               internalSession.resetTX(tx);
-               try {
-                  Xid xid = OpenWireUtil.toXID(info.getTransactionId());
-                  internalSession.xaEnd(xid);
-               }
-               finally {
-                  internalSession.resetTX(null);
+         AMQTransportConnectionState state = unregisterConnectionState(id);
+         if (state != null)
+         {
+            synchronized (brokerConnectionStates)
+            {
+               // If we are the last reference, we should remove the state
+               // from the broker.
+               if (state.decrementReference() == 0)
+               {
+                  brokerConnectionStates.remove(id);
                }
             }
-            catch (Exception e) {
-               e.printStackTrace();
-               throw e;
-            }
          }
-         else {
-            txMap.remove(info);
-         }
-
-         return null;
-      }
-
-      @Override
-      public Response processBrokerInfo(BrokerInfo arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
-      }
-
-      @Override
-      public Response processConnectionControl(ConnectionControl connectionControl) throws Exception {
-         //activemq5 keeps a var to remember only the faultTolerant flag
-         //this can be sent over a reconnected transport as the first command
-         //before restoring the connection.
-         return null;
-      }
-
-      @Override
-      public Response processConnectionError(ConnectionError arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
-      }
-
-      @Override
-      public Response processConsumerControl(ConsumerControl consumerControl) throws Exception {
-         //amq5 clients send this command to restore prefetchSize
-         //after successful reconnect
-         try {
-            updateConsumer(consumerControl);
-         }
-         catch (Exception e) {
-            //log error
-         }
-         return null;
       }
+      return null;
+   }
 
-      @Override
-      public Response processControlCommand(ControlCommand arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
+   @Override
+   public Response processRemoveConsumer(ConsumerId id,
+         long lastDeliveredSequenceId) throws Exception
+   {
+      SessionId sessionId = id.getParentId();
+      ConnectionId connectionId = sessionId.getParentId();
+      AMQTransportConnectionState cs = lookupConnectionState(connectionId);
+      if (cs == null)
+      {
+         throw new IllegalStateException(
+               "Cannot remove a consumer from a connection that had not been registered: "
+                     + connectionId);
       }
+      SessionState ss = cs.getSessionState(sessionId);
+      if (ss == null)
+      {
+         throw new IllegalStateException(
+               "Cannot remove a consumer from a session that had not been registered: "
+                     + sessionId);
+      }
+      ConsumerState consumerState = ss.removeConsumer(id);
+      if (consumerState == null)
+      {
+         throw new IllegalStateException(
+               "Cannot remove a consumer that had not been registered: " + id);
+      }
+      ConsumerInfo info = consumerState.getInfo();
+      info.setLastDeliveredSequenceId(lastDeliveredSequenceId);
+      protocolManager.removeConsumer(cs.getContext(), consumerState.getInfo());
+      removeConsumerBrokerExchange(id);
+      return null;
+   }
 
-      @Override
-      public Response processFlush(FlushCommand arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
+   private void removeConsumerBrokerExchange(ConsumerId id)
+   {
+      synchronized (consumerExchanges)
+      {
+         consumerExchanges.remove(id);
       }
+   }
 
-      @Override
-      public Response processKeepAlive(KeepAliveInfo arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
+   @Override
+   public Response processRemoveDestination(DestinationInfo info) throws Exception
+   {
+      ActiveMQDestination dest = info.getDestination();
+      if (dest.isQueue())
+      {
+         String qName = "jms.queue." + dest.getPhysicalName();
+         protocolManager.deleteQueue(qName);
       }
+      return null;
+   }
 
-      @Override
-      public Response processMessage(Message messageSend) throws Exception {
-         ProducerId producerId = messageSend.getProducerId();
-         AMQProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
-         final AMQConnectionContext pcontext = producerExchange.getConnectionContext();
-         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
-         boolean sendProducerAck = !messageSend.isResponseRequired() && producerInfo.getWindowSize() > 0 && !pcontext.isInRecoveryMode();
-
-         AMQSession session = getSession(producerId.getParentId());
-
-         Transaction tx = lookupTX(messageSend.getTransactionId(), session);
+   @Override
+   public Response processRemoveProducer(ProducerId id) throws Exception
+   {
+      protocolManager.removeProducer(id);
+      return null;
+   }
 
-         session.getCoreSession().resetTX(tx);
-         try {
-            session.send(producerInfo, messageSend, sendProducerAck);
+   @Override
+   public Response processRemoveSession(SessionId id,
+         long lastDeliveredSequenceId) throws Exception
+   {
+      ConnectionId connectionId = id.getParentId();
+      AMQTransportConnectionState cs = lookupConnectionState(connectionId);
+      if (cs == null)
+      {
+         throw new IllegalStateException(
+               "Cannot remove session from connection that had not been registered: "
+                     + connectionId);
+      }
+      SessionState session = cs.getSessionState(id);
+      if (session == null)
+      {
+         throw new IllegalStateException(
+               "Cannot remove session that had not been registered: " + id);
+      }
+      // Don't let new consumers or producers get added while we are closing
+      // this down.
+      session.shutdown();
+      // Cascade the connection stop to the consumers and producers.
+      for (ConsumerId consumerId : session.getConsumerIds())
+      {
+         try
+         {
+            processRemoveConsumer(consumerId, lastDeliveredSequenceId);
          }
-         finally {
-            session.getCoreSession().resetTX(null);
+         catch (Throwable e)
+         {
+            // LOG.warn("Failed to remove consumer: {}", consumerId, e);
          }
-
-         return null;
       }
-
-      @Override
-      public Response processMessageAck(MessageAck ack) throws Exception {
-         AMQSession session = getSession(ack.getConsumerId().getParentId());
-         Transaction tx = lookupTX(ack.getTransactionId(), session);
-         session.getCoreSession().resetTX(tx);
-
-         try {
-            AMQConsumerBrokerExchange consumerBrokerExchange = consumerExchanges.get(ack.getConsumerId());
-            consumerBrokerExchange.acknowledge(ack);
+      for (ProducerId producerId : session.getProducerIds())
+      {
+         try
+         {
+            processRemoveProducer(producerId);
          }
-         finally {
-            session.getCoreSession().resetTX(null);
-         }
-         return null;
-      }
-
-      @Override
-      public Response processMessageDispatch(MessageDispatch arg0) throws Exception {
-         return null;
-      }
-
-      @Override
-      public Response processMessageDispatchNotification(MessageDispatchNotification arg0) throws Exception {
-         return null;
-      }
-
-      @Override
-      public Response processMessagePull(MessagePull arg0) throws Exception {
-         AMQConsumerBrokerExchange amqConsumerBrokerExchange = consumerExchanges.get(arg0.getConsumerId());
-         if (amqConsumerBrokerExchange == null) {
-            throw new IllegalStateException("Consumer does not exist");
+         catch (Throwable e)
+         {
+            // LOG.warn("Failed to remove producer: {}", producerId, e);
          }
-         amqConsumerBrokerExchange.processMessagePull(arg0);
-         return null;
       }
+      cs.removeSession(id);
+      protocolManager.removeSession(cs.getContext(), session.getInfo());
+      return null;
+   }
 
-      @Override
-      public Response processProducerAck(ProducerAck arg0) throws Exception {
-         // a broker doesn't do producers.. this shouldn't happen
-         return null;
-      }
+   @Override
+   public Response processRemoveSubscription(RemoveSubscriptionInfo arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      @Override
-      public Response processRecoverTransactions(TransactionInfo info) throws Exception {
-         List<Xid> xids = server.getResourceManager().getInDoubtTransactions();
-         List<TransactionId> recovered = new ArrayList<>();
-         for (Xid xid : xids) {
-            XATransactionId amqXid = new XATransactionId(xid);
-            recovered.add(amqXid);
-         }
-         return new DataArrayResponse(recovered.toArray(new TransactionId[recovered.size()]));
-      }
+   @Override
+   public Response processRollbackTransaction(TransactionInfo info) throws Exception
+   {
+      protocolManager.rollbackTransaction(info);
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
+      return null;
+   }
 
-      @Override
-      public Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws Exception {
-         //we let protocol manager to handle connection add/remove
-         try {
-            protocolManager.removeConnection(state.getInfo(), null);
-         }
-         catch (Throwable e) {
-            // log
-         }
-         return null;
-      }
+   @Override
+   public Response processShutdown(ShutdownInfo info) throws Exception
+   {
+      return null;
+   }
 
-      @Override
-      public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {
-         SessionId sessionId = id.getParentId();
-         SessionState ss = state.getSessionState(sessionId);
-         if (ss == null) {
-            throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: " + sessionId);
-         }
-         ConsumerState consumerState = ss.removeConsumer(id);
-         if (consumerState == null) {
-            throw new IllegalStateException("Cannot remove a consumer that had not been registered: " + id);
-         }
-         ConsumerInfo info = consumerState.getInfo();
-         info.setLastDeliveredSequenceId(lastDeliveredSequenceId);
+   @Override
+   public Response processWireFormat(WireFormatInfo arg0) throws Exception
+   {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-         AMQConsumerBrokerExchange consumerBrokerExchange = consumerExchanges.remove(id);
+   public int getMaximumConsumersAllowedPerConnection()
+   {
+      return this.acceptorUsed.getMaximumConsumersAllowedPerConnection();
+   }
 
-         consumerBrokerExchange.removeConsumer();
+   public int getMaximumProducersAllowedPerConnection()
+   {
+      return this.acceptorUsed.getMaximumProducersAllowedPerConnection();
+   }
 
-         return null;
+   public void deliverMessage(MessageDispatch dispatch)
+   {
+      Message m = dispatch.getMessage();
+      if (m != null)
+      {
+         long endTime = System.currentTimeMillis();
+         m.setBrokerOutTime(endTime);
       }
 
+      protocolManager.send(this, dispatch);
    }
 
-   private Transaction lookupTX(TransactionId txID, AMQSession session) throws IllegalStateException {
-      if (txID == null) {
-         return null;
-      }
+   public WireFormat getMarshaller()
+   {
+      return this.wireFormat;
+   }
 
-      Xid xid = null;
-      Transaction transaction;
-      if (txID.isXATransaction()) {
-         xid = OpenWireUtil.toXID(txID);
-         transaction = server.getResourceManager().getTransaction(xid);
-      }
-      else {
-         transaction = txMap.get(txID);
-      }
+   public void registerTempQueue(SimpleString qName)
+   {
+      tempQueues.add(qName.toString());
+   }
 
-      if (transaction == null) {
-         throw new IllegalStateException("cannot find transactionInfo::" + txID + " xid=" + xid);
-      }
+   @Override
+   public void disconnect(String reason, boolean fail)
+   {
+      destroy();
+   }
 
-      if (session != null && transaction.getProtocolData() != session) {
-         transaction.setProtocolData(session);
-      }
+   @Override
+   public void fail(ActiveMQException e, String message)
+   {
+      destroy();
+   }
 
-      return transaction;
+   public void setAdvisorySession(AMQSession amqSession)
+   {
+      this.advisorySession = amqSession;
+   }
+
+   public AMQSession getAdvisorySession()
+   {
+      return this.advisorySession;
    }
 
-   public static XAException newXAException(String s, int errorCode) {
-      XAException xaException = new XAException(s + " " + "xaErrorCode:" + errorCode);
-      xaException.errorCode = errorCode;
-      return xaException;
+   public AMQConnectionContext getConext()
+   {
+      return this.state.getContext();
    }
 
 }