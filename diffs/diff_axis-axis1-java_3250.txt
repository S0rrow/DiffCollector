diff --git a/src/org/apache/axis/wsdl/toJava/Utils.java b/src/org/apache/axis/wsdl/toJava/Utils.java
index c2126df27..db96e0f44 100644
--- a/src/org/apache/axis/wsdl/toJava/Utils.java
+++ b/src/org/apache/axis/wsdl/toJava/Utils.java
@@ -54,34 +54,26 @@
  */
 package org.apache.axis.wsdl.toJava;
 
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import java.util.StringTokenizer;
+import java.util.Vector;
+
+import javax.wsdl.Fault;
+import javax.wsdl.Message;
+import javax.wsdl.QName;
+
 import org.apache.axis.Constants;
+
 import org.apache.axis.utils.JavaUtils;
-import org.apache.axis.wsdl.symbolTable.MessageEntry;
+
 import org.apache.axis.wsdl.symbolTable.SymbolTable;
 import org.apache.axis.wsdl.symbolTable.TypeEntry;
+
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
-import javax.wsdl.BindingInput;
-import javax.wsdl.BindingOperation;
-import javax.wsdl.Fault;
-import javax.wsdl.Input;
-import javax.wsdl.Message;
-import javax.wsdl.Operation;
-import javax.wsdl.Part;
-import javax.wsdl.QName;
-import javax.wsdl.extensions.ExtensibilityElement;
-import javax.wsdl.extensions.soap.SOAPBody;
-import java.io.File;
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.StringTokenizer;
-import java.util.Vector;
-
 public class Utils extends org.apache.axis.wsdl.symbolTable.Utils {
     /**
      * Given a type, return the Java mapping of that type's holder.
@@ -89,10 +81,13 @@ public class Utils extends org.apache.axis.wsdl.symbolTable.Utils {
     public static String holder(TypeEntry type, Emitter emitter) {
         String typeValue = type.getName();
 
-        // byte[] has a reserved holders
+        // byte[] and Byte[] have reserved holders
         if (typeValue.equals("byte[]")) {
             return "javax.xml.rpc.holders.ByteArrayHolder";
         }
+        else if (typeValue.equals("java.lang.Byte[]")) {
+            return "javax.xml.rpc.holders.ByteWrapperArrayHolder";
+        }
         // Anything else with [] gets its holder from the qname
         else if (typeValue.endsWith("[]")) {
             String name = emitter.getJavaName(type.getQName());
@@ -169,12 +164,12 @@ public class Utils extends org.apache.axis.wsdl.symbolTable.Utils {
     public static String getFullExceptionName(
             Fault fault, Emitter emitter) {
 
+        // Upgraded to JSR 101 version 0.8
+
         // Get the Message referenced in the message attribute of the
         // fault.
         Message faultMessage = fault.getMessage();
-        MessageEntry me = emitter.getSymbolTable().getMessageEntry(
-            faultMessage.getQName()); 
-        return (String) me.getDynamicVar(JavaGeneratorFactory.EXCEPTION_CLASS_NAME);
+        return emitter.getJavaName(faultMessage.getQName());
     } // getFullExceptionName
 
     /**
@@ -383,131 +378,4 @@ public class Utils extends org.apache.axis.wsdl.symbolTable.Utils {
         }
     } // getJavaPackageName
 
-    /**
-     * Does the given file already exist in the given namespace?
-     */
-    public static boolean fileExists(String name, String namespace,
-            Namespaces namespaces) throws IOException
-    {
-        String packageName = namespaces.getAsDir(namespace);
-        String fullName = packageName + name;
-        return new File (fullName).exists();
-    } // fileExists
-
-    /**
-     * A simple map of the primitive types and their holder objects
-     */
-    private static HashMap TYPES = new HashMap(7);
-
-    static {
-        TYPES.put("int", "Integer");
-        TYPES.put("float", "Float");
-        TYPES.put("boolean", "Boolean");
-        TYPES.put("double", "Double");
-        TYPES.put("byte", "Byte");
-        TYPES.put("short", "Short");
-        TYPES.put("long", "Long");
-    }
-
-    /**
-     * Return a string with "var" wrapped as an Object type if needed
-     */
-    public static String wrapPrimitiveType(TypeEntry type, String var) {
-        String objType = type == null ? null : (String) TYPES.get(type.getName());
-        if (objType != null) {
-            return "new " + objType + "(" + var + ")";
-        } else if (type != null && 
-                   type.getName().equals("byte[]") &&
-                   type.getQName().getLocalPart().equals("hexBinary")) {
-            // Need to wrap byte[] in special Hex object to get the correct serialization
-            return "new org.apache.axis.encoding.Hex(" + var + ")";
-        } else {
-            return var;
-        }
-    } // wrapPrimitiveType
-
-    /**
-     * Return the Object variable 'var' cast to the appropriate type
-     * doing the right thing for the primitive types.
-     */
-    public static String getResponseString(TypeEntry type, String var) {
-        if (type == null) {
-            return ";";
-        }
-        else {
-            String objType = (String) TYPES.get(type.getName());
-            if (objType != null) {
-                return "((" + objType + ") " + var + ")." + type.getName() + "Value();";
-            }
-            else {
-                return "(" + type.getName() + ") " + var + ";";
-            }
-        }
-    } // getResponseString
-
-    public static boolean isPrimitiveType(TypeEntry type) {
-        return TYPES.get(type.getName()) != null;
-    } // isPrimitiveType
-
-    /**
-     * Return the XML Element which will trigger a particular operation
-     * or null if the default case (localPart equals operation name) will
-     * work fine.
-     * 
-     * @param operation the operation
-     * @return element QName for doc/lit operation or null
-     */ 
-    public static QName getOperationQName(BindingOperation bindingOper) {
-        Operation operation = bindingOper.getOperation();
-        String operationName = operation.getName();
-        String javaOperName = JavaUtils.xmlNameToJava(operation.getName());
-        QName elementQName = null;
-
-        // Get a namespace from the soap:body tag, if any
-        // example:
-        //   <soap:body namespace="this_is_what_we_want" ..>
-        String ns = null;
-        BindingInput bindInput = bindingOper.getBindingInput();
-        if (bindInput != null) {
-            Iterator it = bindInput.getExtensibilityElements().iterator();
-            while (it.hasNext()) {
-                ExtensibilityElement elem = (ExtensibilityElement) it.next();
-                if (elem instanceof SOAPBody) {
-                    SOAPBody body = (SOAPBody) elem;
-                    ns = body.getNamespaceURI();
-                    break;
-                }
-            }
-        }
-        // Get the qname from the first message part, if it is an element
-        // example:
-        //   <part name="paramters" element="ns:myelem">
-        Input input = operation.getInput();
-        if (input != null) {
-            Map parts = input.getMessage().getParts();
-            if (parts != null && !parts.isEmpty()) {
-                Iterator i = parts.values().iterator();
-                Part p = (Part) i.next();
-                elementQName = p.getElementName();
-            }
-        }
-        
-        // NOTE: it is possible for someone to define a part as an element
-        // while using rpc/encoded, which is wrong and we might want to catch it
-        // here.
-        
-        // If we didn't find an element declared in the part (assume it's a
-        // type), so the QName will be the operation name with the
-        // namespace (if any) from the binding soap:body tag..
-        if (elementQName == null) {
-            // We don't need to even set the QName in the meta data if we don't
-            // have a namespace or we didn't mangle the XML name to a java name
-            if (ns != null || !javaOperName.equals(operationName)) {
-                elementQName = new QName(ns, operationName);
-            }
-        }
-
-        return elementQName;
-    }
-
 } // class Utils