diff --git a/modules/gfac/gfac-service/src/main/java/org/apache/airavata/gfac/server/GfacServerHandler.java b/modules/gfac/gfac-service/src/main/java/org/apache/airavata/gfac/server/GfacServerHandler.java
index 9ebfa05f2..a4a4874cc 100644
--- a/modules/gfac/gfac-service/src/main/java/org/apache/airavata/gfac/server/GfacServerHandler.java
+++ b/modules/gfac/gfac-service/src/main/java/org/apache/airavata/gfac/server/GfacServerHandler.java
@@ -23,14 +23,14 @@ package org.apache.airavata.gfac.server;
 import org.apache.airavata.common.exception.AiravataException;
 import org.apache.airavata.common.exception.AiravataStartupException;
 import org.apache.airavata.common.exception.ApplicationSettingsException;
-import org.apache.airavata.common.utils.AiravataUtils;
+import org.apache.airavata.common.utils.AiravataZKUtils;
+import org.apache.airavata.common.utils.LocalEventPublisher;
 import org.apache.airavata.common.utils.ServerSettings;
 import org.apache.airavata.common.utils.ThriftUtils;
 import org.apache.airavata.common.utils.listener.AbstractActivityListener;
 import org.apache.airavata.gfac.core.GFacConstants;
 import org.apache.airavata.gfac.core.GFacException;
 import org.apache.airavata.gfac.core.GFacUtils;
-import org.apache.airavata.gfac.core.watcher.CancelRequestWatcher;
 import org.apache.airavata.gfac.cpi.GfacService;
 import org.apache.airavata.gfac.cpi.gfac_cpi_serviceConstants;
 import org.apache.airavata.gfac.impl.Factory;
@@ -39,11 +39,13 @@ import org.apache.airavata.messaging.core.MessageContext;
 import org.apache.airavata.messaging.core.MessageHandler;
 import org.apache.airavata.messaging.core.MessagingConstants;
 import org.apache.airavata.messaging.core.Publisher;
-import org.apache.airavata.messaging.core.impl.RabbitMQProcessLaunchConsumer;
-import org.apache.airavata.messaging.core.impl.RabbitMQStatusPublisher;
-import org.apache.airavata.model.messaging.event.*;
-import org.apache.airavata.model.status.ProcessState;
-import org.apache.airavata.model.status.ProcessStatus;
+import org.apache.airavata.messaging.core.PublisherFactory;
+import org.apache.airavata.messaging.core.impl.RabbitMQTaskLaunchConsumer;
+import org.apache.airavata.model.messaging.event.MessageType;
+import org.apache.airavata.model.messaging.event.TaskSubmitEvent;
+import org.apache.airavata.model.messaging.event.TaskTerminateEvent;
+import org.apache.airavata.model.status.ExperimentState;
+import org.apache.airavata.model.status.ExperimentStatus;
 import org.apache.airavata.registry.cpi.AppCatalog;
 import org.apache.airavata.registry.cpi.ExperimentCatalog;
 import org.apache.airavata.registry.cpi.ExperimentCatalogModelType;
@@ -68,13 +70,13 @@ import java.util.concurrent.Executors;
 
 public class GfacServerHandler implements GfacService.Iface {
     private final static Logger log = LoggerFactory.getLogger(GfacServerHandler.class);
-    private RabbitMQProcessLaunchConsumer rabbitMQProcessLaunchConsumer;
+    private RabbitMQTaskLaunchConsumer rabbitMQTaskLaunchConsumer;
     private static int requestCount=0;
     private ExperimentCatalog experimentCatalog;
     private AppCatalog appCatalog;
     private String airavataUserName;
     private CuratorFramework curatorClient;
-    private Publisher statusPublisher;
+    private LocalEventPublisher localEventPublisher;
     private String airavataServerHostPort;
     private BlockingQueue<TaskSubmitEvent> taskSubmitEvents;
     private static List<AbstractActivityListener> activityListeners = new ArrayList<AbstractActivityListener>();
@@ -82,23 +84,19 @@ public class GfacServerHandler implements GfacService.Iface {
 
     public GfacServerHandler() throws AiravataStartupException {
         try {
-	        Factory.loadConfiguration();
             startCuratorClient();
             initZkDataStructure();
             initAMQPClient();
 	        executorService = Executors.newFixedThreadPool(ServerSettings.getGFacThreadPoolSize());
-            startStatusUpdators(experimentCatalog, curatorClient, statusPublisher, rabbitMQProcessLaunchConsumer);
+            startStatusUpdators(experimentCatalog, curatorClient, localEventPublisher, rabbitMQTaskLaunchConsumer);
         } catch (Exception e) {
             throw new AiravataStartupException("Gfac Server Initialization error ", e);
         }
     }
 
     private void initAMQPClient() throws AiravataException {
-	    // init process consumer
-        rabbitMQProcessLaunchConsumer = Factory.getProcessLaunchConsumer();
-        rabbitMQProcessLaunchConsumer.listen(new ProcessLaunchMessageHandler());
-	    // init status publisher
-	    statusPublisher = new RabbitMQStatusPublisher();
+        rabbitMQTaskLaunchConsumer = new RabbitMQTaskLaunchConsumer();
+        rabbitMQTaskLaunchConsumer.listen(new TaskLaunchMessageHandler());
     }
 
     private void startCuratorClient() throws ApplicationSettingsException {
@@ -146,18 +144,19 @@ public class GfacServerHandler implements GfacService.Iface {
      * *
      * *
      *
+     * @param experimentId - ExperimentModel id in registry
      * @param processId - processModel id in registry
      * @param gatewayId - gateway Identification
      */
-    public boolean submitProcess(String processId, String gatewayId, String tokenId) throws
+    public boolean submitJob(String experimentId, String processId, String gatewayId, String tokenId) throws
             TException {
         requestCount++;
         log.info("-----------------------------------" + requestCount + "-----------------------------------------");
-        log.info(processId, "GFac Received submit job request for the Process: {} process: {}", processId,
+        log.info(experimentId, "GFac Received submit job request for the Experiment: {} process: {}", experimentId,
                 processId);
 
         try {
-	        executorService.execute(new GFacWorker(processId, gatewayId, tokenId));
+	        executorService.execute(new GFacWorker(experimentId, processId, gatewayId, tokenId));
         } catch (GFacException e) {
             log.error("Failed to submit process", e);
             return false;
@@ -167,14 +166,29 @@ public class GfacServerHandler implements GfacService.Iface {
 	    return true;
     }
 
-    @Override
-    public boolean cancelProcess(String processId, String gatewayId, String tokenId) throws TException {
-        return false;
+    public boolean cancelJob(String experimentId, String taskId, String gatewayId, String tokenId) throws TException {
+    /*    log.info(experimentId, "GFac Received cancel job request for Experiment: {} TaskId: {} ", experimentId, taskId);
+        try {
+            if (BetterGfacImpl.getInstance().cancel(experimentId, taskId, gatewayId, tokenId)) {
+                log.debug(experimentId, "Successfully cancelled job, experiment {} , task {}", experimentId, taskId);
+                return true;
+            } else {
+                log.error(experimentId, "Job cancellation failed, experiment {} , task {}", experimentId, taskId);
+                return false;
+            }
+        } catch (Exception e) {
+            log.error(experimentId, "Error cancelling the experiment {}.", experimentId);
+            throw new TException("Error cancelling the experiment : " + e.getMessage(), e);
+        }*/
+	    return false;
     }
 
-    public static void startStatusUpdators(ExperimentCatalog experimentCatalog, CuratorFramework curatorClient, Publisher publisher,
 
-                                           RabbitMQProcessLaunchConsumer rabbitMQProcessLaunchConsumer) {
+
+
+    public static void startStatusUpdators(ExperimentCatalog experimentCatalog, CuratorFramework curatorClient, LocalEventPublisher publisher,
+
+                                           RabbitMQTaskLaunchConsumer rabbitMQTaskLaunchConsumer) {
        /* try {
             String[] listenerClassList = ServerSettings.getActivityListeners();
             Publisher rabbitMQPublisher = PublisherFactory.createActivityPublisher();
@@ -182,20 +196,20 @@ public class GfacServerHandler implements GfacService.Iface {
                 Class<? extends AbstractActivityListener> aClass = Class.forName(listenerClass).asSubclass(AbstractActivityListener.class);
                 AbstractActivityListener abstractActivityListener = aClass.newInstance();
                 activityListeners.add(abstractActivityListener);
-                abstractActivityListener.setup(statusPublisher, experimentCatalog, curatorClient, rabbitMQPublisher, rabbitMQTaskLaunchConsumer);
+                abstractActivityListener.setup(publisher, experimentCatalog, curatorClient, rabbitMQPublisher, rabbitMQTaskLaunchConsumer);
                 log.info("Registering listener: " + listenerClass);
-                statusPublisher.registerListener(abstractActivityListener);
+                publisher.registerListener(abstractActivityListener);
             }
         } catch (Exception e) {
             log.error("Error loading the listener classes configured in airavata-server.properties", e);
         }*/
     }
 
-    private class ProcessLaunchMessageHandler implements MessageHandler {
+    private class TaskLaunchMessageHandler implements MessageHandler {
         private String experimentNode;
         private String gfacServerName;
 
-        public ProcessLaunchMessageHandler() throws ApplicationSettingsException {
+        public TaskLaunchMessageHandler() throws ApplicationSettingsException {
             experimentNode = GFacConstants.ZOOKEEPER_EXPERIMENT_NODE;
             gfacServerName = ServerSettings.getGFacServerName();
         }
@@ -211,133 +225,56 @@ public class GfacServerHandler implements GfacService.Iface {
         }
 
         public void onMessage(MessageContext message) {
-            log.info(" Message Received with message id '" + message.getMessageId()
-		            + "' and with message type '" + message.getType());
-            if (message.getType().equals(MessageType.LAUNCHPROCESS)) {
-	            ProcessStatus status = new ProcessStatus();
-	            status.setState(ProcessState.EXECUTING);
+            System.out.println(" Message Received with message id '" + message.getMessageId()
+                    + "' and with message type '" + message.getType());
+            if (message.getType().equals(MessageType.LAUNCHTASK)) {
                 try {
-                    ProcessSubmitEvent event = new ProcessSubmitEvent();
+                    TaskSubmitEvent event = new TaskSubmitEvent();
                     TBase messageEvent = message.getEvent();
                     byte[] bytes = ThriftUtils.serializeThriftObject(messageEvent);
                     ThriftUtils.createThriftFromBytes(bytes, event);
-	                if (message.isRedeliver()) {
-		                // check the process is already active in this instance.
-		                if (Factory.getGfacContext().getProcess(event.getProcessId()) != null) {
-			                // update deliver tag
-			                try {
-				                updateDeliveryTag(curatorClient, gfacServerName, event.getProcessId(), message
-						                .getDeliveryTag());
-				                return;
-			                } catch (Exception e) {
-				                log.error("Error while updating delivery tag for redelivery message , messageId : " +
-						                message.getMessageId(), e);
-				                rabbitMQProcessLaunchConsumer.sendAck(message.getDeliveryTag());
-			                }
-		                } else {
-			                // give time to complete handover logic in previous instance.
-			                try {
-				                Thread.sleep(60000);
-			                } catch (InterruptedException e) {
-				                // ignore
-			                }
-			                // read process status from registry
-			                ProcessStatus processStatus = ((ProcessStatus) Factory.getDefaultExpCatalog().get(ExperimentCatalogModelType
-							                .PROCESS_STATUS,
-					                event.getProcessId()));
-			                status.setState(processStatus.getState());
-		                }
-	                }
-                    // update process status to executing
-	                status.setTimeOfStateChange(Calendar.getInstance().getTimeInMillis());
-	                Factory.getDefaultExpCatalog().update(ExperimentCatalogModelType.PROCESS_STATUS, status, event
-			                .getProcessId());
-	                publishProcessStatus(event, status);
+                    // update experiment status to executing
+                    ExperimentStatus status = new ExperimentStatus();
+                    status.setState(ExperimentState.EXECUTING);
+                    status.setTimeOfStateChange(Calendar.getInstance().getTimeInMillis());
+                    experimentCatalog.update(ExperimentCatalogModelType.EXPERIMENT_STATUS, status, event.getExperimentId());
                     try {
-	                    createProcessZKNode(curatorClient, gfacServerName, event.getProcessId(), message
-			                    .getDeliveryTag(), event.getTokenId());
-	                    submitProcess(event.getProcessId(), event.getGatewayId(), event.getTokenId());
+	                    GFacUtils.createExperimentNode(curatorClient, gfacServerName, event.getExperimentId(), message.getDeliveryTag(),
+			                    event.getTokenId());
+                        submitJob(event.getExperimentId(), event.getTaskId(), event.getGatewayId(), event.getTokenId());
                     } catch (Exception e) {
                         log.error(e.getMessage(), e);
-                        rabbitMQProcessLaunchConsumer.sendAck(message.getDeliveryTag());
+                        rabbitMQTaskLaunchConsumer.sendAck(message.getDeliveryTag());
                     }
                 } catch (TException e) {
                     log.error(e.getMessage(), e); //nobody is listening so nothing to throw
                 } catch (RegistryException e) {
                     log.error("Error while updating experiment status", e);
-                } catch (AiravataException e) {
-	                log.error("Error while publishing process status", e);
                 }
-            } else if (message.getType().equals(MessageType.TERMINATEPROCESS)) {
-                ProcessTerminateEvent event = new ProcessTerminateEvent();
+            } else if (message.getType().equals(MessageType.TERMINATETASK)) {
+                TaskTerminateEvent event = new TaskTerminateEvent();
                 TBase messageEvent = message.getEvent();
                 try {
                     byte[] bytes = ThriftUtils.serializeThriftObject(messageEvent);
                     ThriftUtils.createThriftFromBytes(bytes, event);
-	                boolean success = GFacUtils.setExperimentCancelRequest(event.getProcessId(), curatorClient,
+	                boolean success = GFacUtils.setExperimentCancelRequest(event.getExperimentId(), curatorClient,
 			                message.getDeliveryTag());
 	                if (success) {
-		                log.info("processId:{} - Process cancel request save successfully", event.getProcessId());
+		                log.info("expId:{} - Experiment cancel request save successfully", event.getExperimentId());
 	                }
                 } catch (Exception e) {
-	                log.error("processId:" + event.getProcessId() + " - Process cancel reqeust failed", e);
+	                log.error("expId:" + event.getExperimentId() + " - Experiment cancel reqeust failed", e);
                 }finally {
 	                try {
-		                if (!rabbitMQProcessLaunchConsumer.isOpen()) {
-			                rabbitMQProcessLaunchConsumer.reconnect();
+		                if (!rabbitMQTaskLaunchConsumer.isOpen()) {
+			                rabbitMQTaskLaunchConsumer.reconnect();
 		                }
-		                rabbitMQProcessLaunchConsumer.sendAck(message.getDeliveryTag());
+		                rabbitMQTaskLaunchConsumer.sendAck(message.getDeliveryTag());
 	                } catch (AiravataException e) {
-		                log.error("processId: " + event.getProcessId() + " - Failed to send acknowledgement back to cancel request.", e);
+		                log.error("expId: " + event.getExperimentId() + " - Failed to send acknowledgement back to cancel request.", e);
 	                }
                 }
             }
         }
     }
-
-	private void publishProcessStatus(ProcessSubmitEvent event, ProcessStatus status) throws AiravataException {
-		ProcessIdentifier identifier = new ProcessIdentifier(event.getProcessId(),
-				event.getExperimentId(),
-				event.getGatewayId());
-		ProcessStatusChangeEvent processStatusChangeEvent = new ProcessStatusChangeEvent(status.getState(), identifier);
-		MessageContext msgCtx = new MessageContext(processStatusChangeEvent, MessageType.PROCESS,
-				AiravataUtils.getId(MessageType.PROCESS.name()), event.getGatewayId());
-		msgCtx.setUpdatedTime(AiravataUtils.getCurrentTimestamp());
-		statusPublisher.publish(msgCtx);
-	}
-
-	private void createProcessZKNode(CuratorFramework curatorClient, String gfacServerName, String
-			processId, long deliveryTag, String token) throws Exception {
-		// TODO - To handle multiple processes per experiment, need to create a /experiments/{expId}/{processId} node
-		// create /experiments/{processId} node and set data - serverName, add redelivery listener
-		String zkProcessNodePath = ZKPaths.makePath(GFacConstants.ZOOKEEPER_EXPERIMENT_NODE, processId);
-		ZKPaths.mkdirs(curatorClient.getZookeeperClient().getZooKeeper(), zkProcessNodePath);
-		curatorClient.setData().withVersion(-1).forPath(zkProcessNodePath, gfacServerName.getBytes());
-		curatorClient.getData().usingWatcher(Factory.getRedeliveryReqeustWatcher()).forPath(zkProcessNodePath);
-
-		// create /experiments/{processId}/deliveryTag node and set data - deliveryTag
-		String deliveryTagPath = ZKPaths.makePath(zkProcessNodePath, GFacConstants.ZOOKEEPER_DELIVERYTAG_NODE);
-		ZKPaths.mkdirs(curatorClient.getZookeeperClient().getZooKeeper(), deliveryTagPath);
-		curatorClient.setData().withVersion(-1).forPath(deliveryTagPath, GFacUtils.longToBytes(deliveryTag));
-
-		// create /experiments/{processId}/token node and set data - token
-		String tokenNodePath = ZKPaths.makePath(processId, GFacConstants.ZOOKEEPER_TOKEN_NODE);
-		ZKPaths.mkdirs(curatorClient.getZookeeperClient().getZooKeeper(), tokenNodePath);
-		curatorClient.setData().withVersion(-1).forPath(tokenNodePath, token.getBytes());
-
-		// create /experiments/{processId}/cancelListener node and set watcher for data changes
-		String cancelListenerNode = ZKPaths.makePath(zkProcessNodePath, GFacConstants.ZOOKEEPER_CANCEL_LISTENER_NODE);
-		ZKPaths.mkdirs(curatorClient.getZookeeperClient().getZooKeeper(), cancelListenerNode);
-		curatorClient.getData().usingWatcher(Factory.getCancelRequestWatcher()).forPath(cancelListenerNode);
-	}
-
-	private void updateDeliveryTag(CuratorFramework curatorClient, String gfacServerName, String processId, long
-			deliveryTag) throws Exception {
-		// create /experiments/{processId} node and set data - serverName, add redelivery listener
-		String zkProcessNodePath = ZKPaths.makePath(GFacConstants.ZOOKEEPER_EXPERIMENT_NODE, processId);
-		// create /experiments/{processId}/deliveryTag node and set data - deliveryTag
-		String deliveryTagPath = ZKPaths.makePath(zkProcessNodePath, GFacConstants.ZOOKEEPER_DELIVERYTAG_NODE);
-		curatorClient.setData().withVersion(-1).forPath(deliveryTagPath, GFacUtils.longToBytes(deliveryTag));
-	}
-
 }