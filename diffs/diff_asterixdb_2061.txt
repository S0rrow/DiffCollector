diff --git a/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java b/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java
index 49c07c141e..242f228012 100644
--- a/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java
+++ b/asterix-transactions/src/main/java/edu/uci/ics/asterix/transaction/management/service/logging/LogManager.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2009-2013 by The Regents of the University of California
+ * Copyright 2009-2012 by The Regents of the University of California
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * you may obtain a copy of the License from
@@ -15,399 +15,995 @@
 package edu.uci.ics.asterix.transaction.management.service.logging;
 
 import java.io.File;
-import java.io.FilenameFilter;
 import java.io.IOException;
-import java.io.OutputStream;
+import java.io.InputStream;
 import java.io.RandomAccessFile;
+import java.nio.ByteBuffer;
 import java.nio.channels.FileChannel;
 import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.Set;
 import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 
-import edu.uci.ics.asterix.common.api.AsterixThreadExecutor;
-import edu.uci.ics.asterix.common.exceptions.ACIDException;
-import edu.uci.ics.asterix.common.transactions.ILogManager;
-import edu.uci.ics.asterix.common.transactions.ILogReader;
-import edu.uci.ics.asterix.common.transactions.ILogRecord;
-import edu.uci.ics.asterix.common.transactions.ITransactionContext;
-import edu.uci.ics.asterix.common.transactions.LogManagerProperties;
-import edu.uci.ics.asterix.common.transactions.MutableLong;
-import edu.uci.ics.asterix.transaction.management.service.locking.LockManager;
+import edu.uci.ics.asterix.transaction.management.exception.ACIDException;
+import edu.uci.ics.asterix.transaction.management.service.logging.IndexLogger.ReusableLogContentObject;
+import edu.uci.ics.asterix.transaction.management.service.logging.LogManager.PageOwnershipStatus;
+import edu.uci.ics.asterix.transaction.management.service.logging.LogManager.PageState;
+import edu.uci.ics.asterix.transaction.management.service.transaction.TransactionContext;
+import edu.uci.ics.asterix.transaction.management.service.transaction.TransactionManagementConstants;
 import edu.uci.ics.asterix.transaction.management.service.transaction.TransactionSubsystem;
-import edu.uci.ics.hyracks.api.lifecycle.ILifeCycleComponent;
+import edu.uci.ics.hyracks.api.exceptions.HyracksDataException;
 
-public class LogManager implements ILogManager, ILifeCycleComponent {
+public class LogManager implements ILogManager {
 
-    public static final boolean IS_DEBUG_MODE = false;// true
+    public static final boolean IS_DEBUG_MODE = false;//true
     private static final Logger LOGGER = Logger.getLogger(LogManager.class.getName());
-    private final TransactionSubsystem txnSubsystem;
-    private final LogManagerProperties logManagerProperties;
-    private final long logFileSize;
-    private final int logPageSize;
-    private final int numLogPages;
-    private final String logDir;
-    private final String logFilePrefix;
-    private final MutableLong flushLSN;
-    private LinkedBlockingQueue<LogPage> emptyQ;
-    private LinkedBlockingQueue<LogPage> flushQ;
-    private long appendLSN;
-    private FileChannel appendChannel;
-    private LogPage appendPage;
-    private LogFlusher logFlusher;
-
-    public LogManager(TransactionSubsystem txnSubsystem) throws ACIDException {
-        this.txnSubsystem = txnSubsystem;
-        logManagerProperties = new LogManagerProperties(this.txnSubsystem.getTransactionProperties(),
-                this.txnSubsystem.getId());
-        logFileSize = logManagerProperties.getLogPartitionSize();
-        logPageSize = logManagerProperties.getLogPageSize();
-        numLogPages = logManagerProperties.getNumLogPages();
-        logDir = logManagerProperties.getLogDir();
-        logFilePrefix = logManagerProperties.getLogFilePrefix();
-        flushLSN = new MutableLong();
-        initializeLogManager();
+    private final TransactionSubsystem provider;
+    private LogManagerProperties logManagerProperties;
+    private LogPageFlushThread logPageFlusher;
+
+    /*
+     * the array of log pages. The number of log pages is configurable. Pages
+     * taken together form an in-memory log buffer.
+     */
+    private IFileBasedBuffer[] logPages;
+
+    private ILogRecordHelper logRecordHelper;
+
+    /*
+     * Number of log pages that constitute the in-memory log buffer.
+     */
+    private int numLogPages;
+
+    /*
+     * Initially all pages have an owner count of 1 that is the LogManager. When
+     * a transaction requests to write in a log page, the owner count is
+     * incremented. The log manager reserves space in the log page and puts in
+     * the log header but leaves the space for the content and the checksum
+     * (covering the whole log record). When the content has been put, the log
+     * manager computes the checksum and puts it after the content. At this
+     * point, the ownership count is decremented as the transaction is done with
+     * using the page. When a page is requested to be flushed, logPageFlusher
+     * set the count to 0(LOG_FLUSHER: meaning that the page is being flushed)
+     * only if the count is 1(LOG_WRITER: meaning that there is no other
+     * transactions who own the page to write logs.) After flushing the page,
+     * logPageFlusher set this count to 1.
+     */
+    private AtomicInteger[] logPageOwnerCount;
+
+    static class PageOwnershipStatus {
+        public static final int LOG_WRITER = 1;
+        public static final int LOG_FLUSHER = 0;
     }
 
-    private void initializeLogManager() {
-        emptyQ = new LinkedBlockingQueue<LogPage>(numLogPages);
-        flushQ = new LinkedBlockingQueue<LogPage>(numLogPages);
-        for (int i = 0; i < numLogPages; i++) {
-            emptyQ.offer(new LogPage((LockManager) txnSubsystem.getLockManager(), logPageSize, flushLSN));
-        }
-        appendLSN = initializeLogAnchor();
-        flushLSN.set(appendLSN);
-        if (LOGGER.isLoggable(Level.INFO)) {
-            LOGGER.info("LogManager starts logging in LSN: " + appendLSN);
-        }
-        appendChannel = getFileChannel(appendLSN, false);
-        getAndInitNewPage();
-        logFlusher = new LogFlusher(this, emptyQ, flushQ);
-        logFlusher.setDaemon(true);
-        AsterixThreadExecutor.INSTANCE.execute(logFlusher);
+    /*
+     * LogPageStatus: A page is either ACTIVE or INACTIVE. The status for each
+     * page is maintained in logPageStatus. A page is ACTIVE when the LogManager
+     * can allocate space in the page for writing a log record. Initially all
+     * pages are ACTIVE. As transactions fill up space by writing log records, a
+     * page may not have sufficient space left for serving a request by a
+     * transaction. When this happens, the page is flushed to disk by calling
+     * logPageFlusher.requestFlush(). In the requestFlush(), after
+     * groupCommitWaitTime, the page status is set to INACTIVE. Then, there is
+     * no more writer on the page(meaning the corresponding logPageOwnerCount is
+     * 1), the page is flushed by the logPageFlusher and the status is reset to
+     * ACTIVE by the logPageFlusher.
+     */
+    private AtomicInteger[] logPageStatus;
+
+    static class PageState {
+        public static final int INACTIVE = 0;
+        public static final int ACTIVE = 1;
     }
 
-    @Override
-    public void log(ILogRecord logRecord) {
-        if (logRecord.getLogSize() > logPageSize) {
-            throw new IllegalStateException();
-        }
-        syncLog(logRecord);
-        if (logRecord.getLogType() == LogType.JOB_COMMIT && !logRecord.isFlushed()) {
-            synchronized (logRecord) {
-                while (!logRecord.isFlushed()) {
+    private AtomicLong lastFlushedLSN = new AtomicLong(-1);
+
+    /*
+     * When the transaction eco-system comes to life, the log manager positions
+     * itself to the end of the last written log. the startingLsn represent the
+     * lsn value of the next log record to be written after a system (re)start.
+     * The value is zero when the system is starting for the first time.
+     */
+    private long startingLSN = 0;
+
+    /*
+     * lsn represents the monotonically increasing long value that can be broken
+     * down into a file id and an offset within a log file.
+     */
+    private AtomicLong lsn = new AtomicLong(0);
+
+    private List<HashMap<TransactionContext, Integer>> activeTxnCountMaps;
+
+    public void addFlushRequest(int pageIndex, long lsn, boolean isSynchronous) {
+        logPageFlusher.requestFlush(pageIndex, lsn, isSynchronous);
+    }
+
+    public AtomicLong getLastFlushedLsn() {
+        return lastFlushedLSN;
+    }
+
+    public AtomicInteger getLogPageStatus(int pageIndex) {
+        return logPageStatus[pageIndex];
+    }
+
+    public AtomicLong getCurrentLsn() {
+        return lsn;
+    }
+
+    public long incrementLastFlushedLsn(long delta) {
+        return lastFlushedLSN.addAndGet(delta);
+    }
+
+    public LogManager(TransactionSubsystem provider) throws ACIDException {
+        this.provider = provider;
+        initLogManagerProperties(null);
+        initLogManager();
+    }
+
+    public LogManager(TransactionSubsystem provider, LogManagerProperties logConfiguration) throws ACIDException {
+        this.provider = provider;
+        initLogManagerProperties(logConfiguration);
+        initLogManager();
+    }
+
+    /*
+     * initialize the log manager properties either from the configuration file
+     * on disk or with default values
+     */
+    private void initLogManagerProperties(LogManagerProperties logProperties) throws ACIDException {
+        if (logProperties == null) {
+            InputStream is = null;
+            try {
+                is = this.getClass().getClassLoader()
+                        .getResourceAsStream(TransactionManagementConstants.LogManagerConstants.LOG_CONF_FILE);
+                if (is != null) {
+                    Properties p = new Properties();
+                    p.load(is);
+                    String logDir = p.getProperty(LogManagerProperties.LOG_DIR_KEY);
+                    if (logDir == null) {
+                        p.setProperty(LogManagerProperties.LOG_DIR_KEY,
+                                TransactionManagementConstants.LogManagerConstants.DEFAULT_LOG_DIR + File.separator
+                                        + provider.getId());
+                    }
+                    logProperties = new LogManagerProperties(p);
+
+                    /*
+                    File file = new File(TransactionManagementConstants.LogManagerConstants.LOG_CONF_DIR
+                            + File.pathSeparator + TransactionManagementConstants.LogManagerConstants.LOG_CONF_FILE);
+                    if (LOGGER.isLoggable(Level.INFO)) {
+                        LOGGER.info("Log Configuration file path is " + file.getAbsolutePath());
+                    }
+                    if (file.exists()) {
+                        is = new FileInputStream(TransactionManagementConstants.LogManagerConstants.LOG_CONF_DIR
+                                + File.pathSeparator + TransactionManagementConstants.LogManagerConstants.LOG_CONF_FILE);
+                        Properties configuredProperties = new Properties();
+                        configuredProperties.load(is);
+                        logConfiguration = new LogManagerProperties(configuredProperties);
+                    */
+
+                } else {
+                    if (LOGGER.isLoggable(Level.INFO)) {
+                        LOGGER.info("Log configuration file not found, using defaults !");
+                    }
+                    Properties configuredProperties = new Properties();
+                    configuredProperties.setProperty(LogManagerProperties.LOG_DIR_KEY,
+                            TransactionManagementConstants.LogManagerConstants.DEFAULT_LOG_DIR + File.separator
+                                    + provider.getId());
+                    logProperties = new LogManagerProperties(configuredProperties);
+                }
+            } catch (IOException ioe) {
+                if (is != null) {
                     try {
-                        logRecord.wait();
-                    } catch (InterruptedException e) {
-                        //ignore
+                        is.close();
+                    } catch (IOException e) {
+                        throw new ACIDException("unable to close input stream ", e);
                     }
                 }
             }
         }
+        logManagerProperties = logProperties;
     }
 
-    private synchronized void syncLog(ILogRecord logRecord) {
-        ITransactionContext txnCtx = logRecord.getTxnCtx();
-        if (getLogFileOffset(appendLSN) + logRecord.getLogSize() > logFileSize) {
-            prepareNextLogFile();
-            appendPage.isFull(true);
-            getAndInitNewPage();
-        } else if (!appendPage.hasSpace(logRecord.getLogSize(), getLogFileOffset(appendLSN))) {
-            appendPage.isFull(true);
-            getAndInitNewPage();
-        }
-        if (logRecord.getLogType() == LogType.UPDATE) {
-            logRecord.setPrevLSN(txnCtx.getLastLSN());
+    private void initLogManager() throws ACIDException {
+        logRecordHelper = new LogRecordHelper(this);
+        numLogPages = logManagerProperties.getNumLogPages();
+        logPageOwnerCount = new AtomicInteger[numLogPages];
+        logPageStatus = new AtomicInteger[numLogPages];
+
+        activeTxnCountMaps = new ArrayList<HashMap<TransactionContext, Integer>>(numLogPages);
+        for (int i = 0; i < numLogPages; i++) {
+            activeTxnCountMaps.add(new HashMap<TransactionContext, Integer>());
         }
-        appendPage.append(logRecord, appendLSN);
-        appendLSN += logRecord.getLogSize();
-    }
 
-    private void getAndInitNewPage() {
-        appendPage = null;
-        while (appendPage == null) {
-            try {
-                appendPage = emptyQ.take();
-            } catch (InterruptedException e) {
-                //ignore
-            }
+        logPages = new FileBasedBuffer[numLogPages];
+
+        /*
+         * place the log anchor at the end of the last log record written.
+         */
+        PhysicalLogLocator nextPhysicalLsn = initLSN();
+
+        /*
+         * initialize meta data for each log page.
+         */
+        for (int i = 0; i < numLogPages; i++) {
+            logPageOwnerCount[i] = new AtomicInteger(PageOwnershipStatus.LOG_WRITER);
+            logPageStatus[i] = new AtomicInteger(PageState.ACTIVE);
         }
-        appendPage.reset();
-        appendPage.setFileChannel(appendChannel);
-        appendPage.setInitialFlushOffset(getLogFileOffset(appendLSN));
-        flushQ.offer(appendPage);
-    }
 
-    private void prepareNextLogFile() {
-        appendLSN += logFileSize - getLogFileOffset(appendLSN);
-        appendChannel = getFileChannel(appendLSN, true);
-        appendPage.isLastPage(true);
-        //[Notice]
-        //the current log file channel is closed if 
-        //LogPage.flush() completely flush the last page of the file.
+        /*
+         * initialize the log pages.
+         */
+        initializeLogPages(nextPhysicalLsn);
+
+        /*
+         * Instantiate and begin the LogFlusher thread. The Log Flusher thread
+         * is responsible for putting log pages to disk. It is configured as a
+         * daemon thread so that it does not stop the JVM from exiting when all
+         * other threads are done with their work.
+         */
+        logPageFlusher = new LogPageFlushThread(this);
+        logPageFlusher.setDaemon(true);
+        logPageFlusher.start();
     }
 
-    @Override
-    public ILogReader getLogReader(boolean isRecoveryMode) {
-        return new LogReader(this, logFileSize, logPageSize, flushLSN, isRecoveryMode);
-    }
+    public int getLogPageIndex(long lsnValue) {
+        return (int) ((lsnValue - startingLSN) / logManagerProperties.getLogPageSize()) % numLogPages;
 
-    public LogManagerProperties getLogManagerProperties() {
-        return logManagerProperties;
     }
 
-    public TransactionSubsystem getTransactionSubsystem() {
-        return txnSubsystem;
+    /*
+     * given a lsn, get the file id where the corresponding log record is
+     * located.
+     */
+    public int getLogFileId(long lsnValue) {
+        return (int) ((lsnValue) / logManagerProperties.getLogPartitionSize());
+
     }
 
-    public long getAppendLSN() {
-        return appendLSN;
+    /*
+     * given a lsn, get the offset within a log page where the corresponding log
+     * record is (to be) placed.
+     */
+    public int getLogPageOffset(long lsnValue) {
+        return (int) (lsnValue - startingLSN) % logManagerProperties.getLogPageSize();
     }
 
-    @Override
-    public void start() {
-        // no op
+    /*
+     * a transaction thread under certain scenarios is required to wait until
+     * the page where it has to write a log record becomes available for writing
+     * a log record.
+     */
+    private void waitUntillPageIsAvailableForWritingLog(int pageIndex) throws ACIDException {
+        if (logPageStatus[pageIndex].get() == PageState.ACTIVE
+                && logPageOwnerCount[pageIndex].get() >= PageOwnershipStatus.LOG_WRITER) {
+            return;
+        }
+        try {
+            synchronized (logPages[pageIndex]) {
+                while (!(logPageStatus[pageIndex].get() == PageState.ACTIVE && logPageOwnerCount[pageIndex].get() >= PageOwnershipStatus.LOG_WRITER)) {
+                    logPages[pageIndex].wait();
+                }
+            }
+        } catch (InterruptedException e) {
+            throw new ACIDException(" thread interrupted while waiting for page " + pageIndex + " to be available ", e);
+        }
     }
 
-    @Override
-    public void stop(boolean dumpState, OutputStream os) {
-        if (dumpState) {
-            // #. dump Configurable Variables
-            dumpConfVars(os);
+    /*
+     * The method that reserves the space for a transaction to write log record
+     * in the log buffer. Note that the method is not synchronized for
+     * performance reasons as we do not want transactions to be blocked by each
+     * other when writing log records.
+     * 
+     * @param entrySize: the requested space.
+     * 
+     * @param logType: the type of log record.
+     */
+    private long getLsn(int entrySize, byte logType) throws ACIDException {
+        long pageSize = logManagerProperties.getLogPageSize();
+
+        while (true) {
+            boolean forwardPage = false;
+            long old = lsn.get();
+
+            // get the log page corresponding to the current lsn value
+            int pageIndex = getLogPageIndex(old);
+            long retVal = old;
+
+            // the lsn value for the next request if the current request is
+            // served.
+            long next = old + entrySize;
+            int prevPage = -1;
+
+            // check if the log record will cross page boundaries, a case that
+            // is not allowed.
+            if ((next - 1) / pageSize != old / pageSize || (next % pageSize == 0)) {
+
+                if ((old != 0 && old % pageSize == 0)) {
+                    // On second thought, this shall never be the case as it
+                    // means that the lsn is
+                    // currently at the beginning of a page and we still need to
+                    // forward the page which
+                    // means that the entrySize exceeds a log page size. If this
+                    // is the case, an
+                    // exception is thrown before calling this API. would remove
+                    // this case.
+                    retVal = old;
 
-            // #. dump LSNInfo
-            dumpLSNInfo(os);
+                } else {
+                    // set the lsn to point to the beginning of the next page.
+                    retVal = ((old / pageSize) + 1) * pageSize;
+                }
 
-            try {
-                os.flush();
-            } catch (IOException e) {
-                // ignore
+                next = retVal;
+
+                // as the log record shall cross log page boundary, we must
+                // re-assign the lsn so
+                // that the log record begins on a different location.
+                forwardPage = true;
+
+                prevPage = pageIndex;
+                pageIndex = getNextPageInSequence(pageIndex);
             }
+
+            /*
+             * we do not want to keep allocating LSNs if the corresponding page
+             * is unavailable. Consider a scenario when the log flusher thread
+             * is incredibly slow in flushing pages. Transaction threads will
+             * acquire an lsn each for writing their next log record. When a
+             * page has been made available, mulltiple transaction threads that
+             * were waiting can continue to write their log record at the
+             * assigned LSNs. Two transaction threads may get LSNs that are on
+             * the same log page but actually differ by the size of the log
+             * buffer. This would be erroneous. Transaction threads are made to
+             * wait upfront for avoiding this situation.
+             */
+            waitUntillPageIsAvailableForWritingLog(pageIndex);
+
+            if (!lsn.compareAndSet(old, next)) {
+                // Atomic call -> returns true only when the value represented
+                // by lsn is same as
+                // "old". The value is updated to "next".
+                continue;
+            }
+
+            if (forwardPage) {
+                addFlushRequest(prevPage, old, false);
+
+                // The transaction thread that discovers the need to forward a
+                // page is made to re-acquire a lsn.
+                continue;
+
+            } else {
+                // the transaction thread has been given a space in a log page,
+                // but is made to wait until the page is available.
+                // (Is this needed? when does this wait happen?)
+                waitUntillPageIsAvailableForWritingLog(pageIndex);
+
+                // increment the counter as the transaction thread now holds a
+                // space in the log page and hence is an owner.
+                logPageOwnerCount[pageIndex].incrementAndGet();
+
+                // Before the count is incremented, if the flusher flushed the
+                // allocated page,
+                // then retry to get new LSN. Otherwise, the log with allocated
+                // lsn will be lost.
+                if (lastFlushedLSN.get() >= retVal) {
+                    logPageOwnerCount[pageIndex].decrementAndGet();
+                    continue;
+                }
+            }
+
+            return retVal;
         }
     }
 
-    private void dumpConfVars(OutputStream os) {
-        try {
-            StringBuilder sb = new StringBuilder();
-            sb.append("\n>>dump_begin\t>>----- [ConfVars] -----");
-            sb.append(logManagerProperties.toString());
-            sb.append("\n>>dump_end\t>>----- [ConfVars] -----\n");
-            os.write(sb.toString().getBytes());
-        } catch (Exception e) {
-            // ignore exception and continue dumping as much as possible.
+    @Override
+    public void log(byte logType, TransactionContext txnCtx, int datasetId, int PKHashValue, long resourceId,
+            byte resourceMgrId, int logContentSize, ReusableLogContentObject reusableLogContentObject, ILogger logger,
+            LogicalLogLocator logicalLogLocator) throws ACIDException {
+
+        HashMap<TransactionContext, Integer> map = null;
+        int activeTxnCount;
+
+        // logLocator is a re-usable object that is appropriately set in each
+        // invocation.
+        // If the reference is null, the log manager must throw an exception.
+        if (logicalLogLocator == null) {
+            throw new ACIDException(
+                    " you need to pass in a non-null logLocator, if you dont have it, then pass in a dummy so that the +"
+                            + "log manager can set it approporiately for you");
+        }
+
+        // compute the total log size including the header and the checksum.
+        int totalLogSize = logRecordHelper.getLogRecordSize(logType, logContentSize);
+
+        // check for the total space requirement to be less than a log page.
+        if (totalLogSize > logManagerProperties.getLogPageSize()) {
+            throw new ACIDException(
+                    " Maximum Log Content Size is "
+                            + (logManagerProperties.getLogPageSize() - logRecordHelper.getLogHeaderSize(LogType.UPDATE) - logRecordHelper
+                                    .getLogChecksumSize()));
+        }
+
+        // all constraints checked and we are good to go and acquire a lsn.
+        long previousLSN = -1;
+
+        // the will be set to the location (a long value) where the log record
+        // needs to be placed.
+        long currentLSN;
+
+        // The logs written by a transaction need to be linked to each other for
+        // a successful rollback/recovery. However there could be multiple
+        // threads operating concurrently that are part of a common transaction.
+        // These threads need to synchronize and record the lsn corresponding to
+        // the last log record written by (any thread of) the transaction.
+        synchronized (txnCtx) {
+            previousLSN = txnCtx.getLastLogLocator().getLsn();
+            currentLSN = getLsn(totalLogSize, logType);
+            txnCtx.setLastLSN(currentLSN);
             if (IS_DEBUG_MODE) {
-                e.printStackTrace();
+                System.out.println("--------------> LSN(" + currentLSN + ") is allocated");
             }
+            logicalLogLocator.setLsn(currentLSN);
         }
-    }
 
-    private void dumpLSNInfo(OutputStream os) {
+        /*
+         * At this point, the transaction thread has obtained reserved space for
+         * writing the log record. In doing so, it has acquired (shared)
+         * ownership of the log page. All subsequent actions are under a try
+         * catch block so that if any exception is encountered, a clean can be
+         * performed correctly that is ownership is released.
+         */
+
+        // indicates if the transaction thread has release ownership of the
+        // page.
+        boolean decremented = false;
+
+        int pageIndex = (int) getLogPageIndex(currentLSN);
+
+        // the lsn has been obtained for the log record. need to set the
+        // LogLocator instance accordingly.
         try {
-            StringBuilder sb = new StringBuilder();
-            sb.append("\n>>dump_begin\t>>----- [LSNInfo] -----");
-            sb.append("\nappendLsn: " + appendLSN);
-            sb.append("\nflushLsn: " + flushLSN.get());
-            sb.append("\n>>dump_end\t>>----- [LSNInfo] -----\n");
-            os.write(sb.toString().getBytes());
-        } catch (Exception e) {
-            // ignore exception and continue dumping as much as possible.
+            logicalLogLocator.setBuffer(logPages[pageIndex]);
+            int pageOffset = getLogPageOffset(currentLSN);
+            logicalLogLocator.setMemoryOffset(pageOffset);
+
+            // write the log header.
+            logRecordHelper.writeLogHeader(logicalLogLocator, logType, txnCtx, datasetId, PKHashValue, previousLSN,
+                    resourceId, resourceMgrId, logContentSize);
+
+            // increment the offset so that the transaction can fill up the
+            // content in the correct region of the allocated space.
+            logicalLogLocator.increaseMemoryOffset(logRecordHelper.getLogHeaderSize(logType));
+
+            // a COMMIT log record does not have any content and hence
+            // the logger (responsible for putting the log content) is not
+            // invoked.
+            if (logContentSize != 0) {
+                logger.preLog(txnCtx, reusableLogContentObject);
+            }
+
+            if (logContentSize != 0) {
+                // call the logger implementation and ask to fill in the log
+                // record content at the allocated space.
+                logger.log(txnCtx, logicalLogLocator, logContentSize, reusableLogContentObject);
+                logger.postLog(txnCtx, reusableLogContentObject);
+                if (IS_DEBUG_MODE) {
+                    logicalLogLocator.setMemoryOffset(logicalLogLocator.getMemoryOffset()
+                            - logRecordHelper.getLogHeaderSize(logType));
+                    System.out.println(logRecordHelper.getLogRecordForDisplay(logicalLogLocator));
+                    logicalLogLocator.increaseMemoryOffset(logRecordHelper.getLogHeaderSize(logType));
+                }
+            }
+
+            // The log record has been written. For integrity checks, compute
+            // the checksum and put it at the end of the log record.
+            int startPosChecksum = logicalLogLocator.getMemoryOffset() - logRecordHelper.getLogHeaderSize(logType);
+            int length = totalLogSize - logRecordHelper.getLogChecksumSize();
+            long checksum = DataUtil.getChecksum(logPages[pageIndex], startPosChecksum, length);
+            logPages[pageIndex].writeLong(pageOffset + logRecordHelper.getLogHeaderSize(logType) + logContentSize,
+                    checksum);
+
             if (IS_DEBUG_MODE) {
-                e.printStackTrace();
+                System.out.println("--------------> LSN(" + currentLSN + ") is written");
+            }
+
+            // release the ownership as the log record has been placed in
+            // created space.
+            logPageOwnerCount[pageIndex].decrementAndGet();
+
+            // indicating that the transaction thread has released ownership
+            decremented = true;
+
+            if (logType == LogType.ENTITY_COMMIT) {
+                map = activeTxnCountMaps.get(pageIndex);
+                if (map.containsKey(txnCtx)) {
+                    activeTxnCount = (Integer) map.get(txnCtx);
+                    activeTxnCount++;
+                    map.put(txnCtx, activeTxnCount);
+                } else {
+                    map.put(txnCtx, 1);
+                }
+                addFlushRequest(pageIndex, currentLSN, false);
+            } else if (logType == LogType.COMMIT) {
+                addFlushRequest(pageIndex, currentLSN, true);
+            }
+
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw new ACIDException(txnCtx, "Thread: " + Thread.currentThread().getName()
+                    + " logger encountered exception", e);
+        } finally {
+            if (!decremented) {
+                logPageOwnerCount[pageIndex].decrementAndGet();
             }
         }
     }
 
-    public MutableLong getFlushLSN() {
-        return flushLSN;
+    /*
+     * This method resets the log page and is called by the log flusher thread
+     * after a page has been flushed to disk.
+     */
+    public void resetLogPage(long nextWritePosition, int pageIndex) throws IOException {
+
+        String filePath = LogUtil.getLogFilePath(logManagerProperties, getLogFileId(nextWritePosition));
+
+        logPages[pageIndex].reset(filePath, LogUtil.getFileOffset(this, nextWritePosition),
+                logManagerProperties.getLogPageSize());
     }
 
-    private long initializeLogAnchor() {
-        long fileId = 0;
-        long offset = 0;
-        File fileLogDir = new File(logDir);
+    @Override
+    public ILogCursor readLog(ILogFilter logFilter) throws ACIDException {
+        LogCursor cursor = new LogCursor(this, logFilter);
+        return cursor;
+    }
+
+    @Override
+    public ILogCursor readLog(PhysicalLogLocator physicalLogLocator, ILogFilter logFilter) throws IOException,
+            ACIDException {
+        LogCursor cursor = new LogCursor(this, physicalLogLocator, logFilter);
+        return cursor;
+    }
+
+    /*
+     * Read a log that is residing on the disk.
+     */
+    private void readDiskLog(long lsnValue, LogicalLogLocator logicalLogLocator) throws ACIDException {
+        String filePath = LogUtil.getLogFilePath(logManagerProperties, LogUtil.getFileId(this, lsnValue));
+        long fileOffset = LogUtil.getFileOffset(this, lsnValue);
+
+        ByteBuffer buffer = ByteBuffer.allocate(logManagerProperties.getLogPageSize());
+        RandomAccessFile raf = null;
+        FileChannel fileChannel = null;
         try {
-            if (fileLogDir.exists()) {
-                List<Long> logFileIds = getLogFileIds();
-                if (logFileIds == null) {
-                    createFileIfNotExists(getLogFilePath(0));
-                    if (LOGGER.isLoggable(Level.INFO)) {
-                        LOGGER.info("created a log file: " + getLogFilePath(0));
-                    }
-                } else {
-                    fileId = logFileIds.get(logFileIds.size() - 1);
-                    File logFile = new File(getLogFilePath(fileId));
-                    offset = logFile.length();
-                }
+            raf = new RandomAccessFile(filePath, "r");
+            fileChannel = raf.getChannel();
+            fileChannel.position(fileOffset);
+            fileChannel.read(buffer);
+            buffer.position(0);
+
+            byte logType = buffer.get(4);
+            int logHeaderSize = logRecordHelper.getLogHeaderSize(logType);
+            int logBodySize = buffer.getInt(logHeaderSize - 4);
+            int logRecordSize = logHeaderSize + logBodySize + logRecordHelper.getLogChecksumSize();
+            buffer.limit(logRecordSize);
+            MemBasedBuffer memBuffer = new MemBasedBuffer(buffer.slice());
+            if (logicalLogLocator == null) {
+                logicalLogLocator = new LogicalLogLocator(lsnValue, memBuffer, 0, this);
             } else {
-                createNewDirectory(logDir);
-                if (LOGGER.isLoggable(Level.INFO)) {
-                    LOGGER.info("created the log directory: " + logManagerProperties.getLogDir());
+                logicalLogLocator.setLsn(lsnValue);
+                logicalLogLocator.setBuffer(memBuffer);
+                logicalLogLocator.setMemoryOffset(0);
+            }
+            if (!logRecordHelper.validateLogRecord(logicalLogLocator)) {
+                throw new ACIDException(" invalid log record at lsn " + lsnValue);
+            }
+        } catch (Exception fnfe) {
+            fnfe.printStackTrace();
+            throw new ACIDException(" unable to retrieve log record with lsn " + lsnValue + " from the file system",
+                    fnfe);
+        } finally {
+            try {
+                if (fileChannel != null) {
+                    fileChannel.close();
+                } else if (raf != null) {
+                    raf.close();
                 }
-                createFileIfNotExists(getLogFilePath(0));
-                if (LOGGER.isLoggable(Level.INFO)) {
-                    LOGGER.info("created a log file: " + getLogFilePath(0));
+            } catch (IOException ioe) {
+                ioe.printStackTrace();
+                throw new ACIDException(" exception in closing a file: " + filePath, ioe);
+            }
+        }
+    }
+
+    @Override
+    public void readLog(long lsnValue, LogicalLogLocator logicalLogLocator) throws ACIDException {
+        byte[] logRecord = null;
+
+        if (lsnValue >= lsn.get()) {
+            throw new ACIDException(" invalid lsn " + lsnValue);
+        }
+
+        /* check if the log record in the log buffer or has reached the disk. */
+        if (lsnValue > getLastFlushedLsn().get()) {
+            int pageIndex = getLogPageIndex(lsnValue);
+            int pageOffset = getLogPageOffset(lsnValue);
+
+            // TODO
+            // minimize memory allocation overhead. current code allocates the
+            // log page size per reading a log record.
+
+            byte[] pageContent = new byte[logManagerProperties.getLogPageSize()];
+
+            // take a lock on the log page so that the page is not flushed to
+            // disk interim
+            synchronized (logPages[pageIndex]) {
+
+                // need to check again (this thread may have got de-scheduled
+                // and must refresh!)
+                if (lsnValue > getLastFlushedLsn().get()) {
+
+                    // get the log record length
+                    logPages[pageIndex].getBytes(pageContent, 0, pageContent.length);
+                    byte logType = pageContent[pageOffset + 4];
+                    int logHeaderSize = logRecordHelper.getLogHeaderSize(logType);
+                    int logBodySize = DataUtil.byteArrayToInt(pageContent, pageOffset + logHeaderSize - 4);
+                    int logRecordSize = logHeaderSize + logBodySize + logRecordHelper.getLogChecksumSize();
+                    logRecord = new byte[logRecordSize];
+
+                    // copy the log record content
+                    System.arraycopy(pageContent, pageOffset, logRecord, 0, logRecordSize);
+                    MemBasedBuffer memBuffer = new MemBasedBuffer(logRecord);
+                    if (logicalLogLocator == null) {
+                        logicalLogLocator = new LogicalLogLocator(lsnValue, memBuffer, 0, this);
+                    } else {
+                        logicalLogLocator.setLsn(lsnValue);
+                        logicalLogLocator.setBuffer(memBuffer);
+                        logicalLogLocator.setMemoryOffset(0);
+                    }
+                    try {
+                        // validate the log record by comparing checksums
+                        if (!logRecordHelper.validateLogRecord(logicalLogLocator)) {
+                            throw new ACIDException(" invalid log record at lsn " + lsnValue);
+                        }
+                    } catch (Exception e) {
+                        throw new ACIDException("exception encoutered in validating log record at lsn " + lsnValue, e);
+                    }
+                    return;
                 }
             }
-        } catch (IOException ioe) {
-            throw new IllegalStateException("Failed to initialize the log anchor", ioe);
         }
+
+        // the log record is residing on the disk, read it from there.
+        readDiskLog(lsnValue, logicalLogLocator);
+    }
+
+    public void renewLogFiles() throws ACIDException {
+        List<String> logFileNames = LogUtil.getLogFiles(logManagerProperties);
+        for (String name : logFileNames) {
+            File file = new File(LogUtil.getLogFilePath(logManagerProperties, Long.parseLong(name)));
+            if (!file.delete()) {
+                throw new ACIDException("Failed to delete a file: " + name);
+            }
+        }
+        closeLogPages();
+        initLSN();
+        openLogPages();
+        logPageFlusher.renew();
+    }
+
+    private PhysicalLogLocator initLSN() throws ACIDException {
+        PhysicalLogLocator nextPhysicalLsn = LogUtil.initializeLogAnchor(this);
+        startingLSN = nextPhysicalLsn.getLsn();
+        lastFlushedLSN.set(startingLSN - 1);
         if (LOGGER.isLoggable(Level.INFO)) {
-            LOGGER.info("log file Id: " + fileId + ", offset: " + offset);
+            LOGGER.info(" Starting lsn is : " + startingLSN);
         }
-        return logFileSize * fileId + offset;
+        lsn.set(startingLSN);
+        return nextPhysicalLsn;
     }
 
-    public void renewLogFiles() {
-        terminateLogFlusher();
-        deleteAllLogFiles();
-        initializeLogManager();
+    private void closeLogPages() throws ACIDException {
+        for (int i = 0; i < numLogPages; i++) {
+            try {
+                logPages[i].close();
+            } catch (IOException e) {
+                throw new ACIDException(e);
+            }
+        }
     }
 
-    private void terminateLogFlusher() {
-        logFlusher.terminate();
+    private void openLogPages() throws ACIDException {
         try {
-            logFlusher.join();
-        } catch (InterruptedException e) {
-            throw new IllegalStateException(e);
+            String filePath = LogUtil.getLogFilePath(logManagerProperties, LogUtil.getFileId(this, startingLSN));
+            for (int i = 0; i < numLogPages; i++) {
+                logPages[i].open(filePath,
+                        LogUtil.getFileOffset(this, startingLSN) + i * logManagerProperties.getLogPageSize(),
+                        logManagerProperties.getLogPageSize());
+            }
+        } catch (Exception e) {
+            throw new ACIDException(Thread.currentThread().getName() + " unable to create log buffer", e);
         }
     }
 
-    private void deleteAllLogFiles() {
-        List<Long> logFileIds = getLogFileIds();
-        for (Long id : logFileIds) {
-            File file = new File(getLogFilePath(id));
-            if (!file.delete()) {
-                throw new IllegalStateException("Failed to delete a file: " + file.getAbsolutePath());
-            }
+    @Override
+    public ILogRecordHelper getLogRecordHelper() {
+        return logRecordHelper;
+    }
+
+    /*
+     * This method shall be called by the Buffer manager when it needs to evict
+     * a page from the cache. TODO: Change the implementation from a looping
+     * logic to event based when log manager support is integrated with the
+     * Buffer Manager.
+     */
+    @Override
+    public synchronized void flushLog(LogicalLogLocator logicalLogLocator) throws ACIDException {
+        if (logicalLogLocator.getLsn() > lsn.get()) {
+            throw new ACIDException(" invalid lsn " + logicalLogLocator.getLsn());
         }
+        while (lastFlushedLSN.get() < logicalLogLocator.getLsn());
     }
 
-    private List<Long> getLogFileIds() {
-        File fileLogDir = new File(logDir);
-        String[] logFileNames = null;
-        List<Long> logFileIds = null;
-        if (fileLogDir.exists()) {
-            logFileNames = fileLogDir.list(new FilenameFilter() {
-                public boolean accept(File dir, String name) {
-                    if (name.startsWith(logFilePrefix)) {
-                        return true;
-                    }
-                    return false;
-                }
-            });
-            if (logFileNames != null && logFileNames.length != 0) {
-                logFileIds = new ArrayList<Long>();
-                for (String fileName : logFileNames) {
-                    logFileIds.add(Long.parseLong(fileName.substring(logFilePrefix.length() + 1)));
-                }
-                Collections.sort(logFileIds, new Comparator<Long>() {
-                    @Override
-                    public int compare(Long arg0, Long arg1) {
-                        if (arg0 > arg1) {
-                            return 1;
-                        } else if (arg0 == arg1) {
-                            return 0;
-                        } else {
-                            return -1;
-                        }
-                    }
-                });
+    /*
+     * Map each log page to cover a physical byte range over a log file. When a
+     * page is flushed, the page contents are put to disk in the corresponding
+     * byte range.
+     */
+    private void initializeLogPages(PhysicalLogLocator physicalLogLocator) throws ACIDException {
+        try {
+            String filePath = LogUtil.getLogFilePath(logManagerProperties,
+                    LogUtil.getFileId(this, physicalLogLocator.getLsn()));
+            for (int i = 0; i < numLogPages; i++) {
+                logPages[i] = FileUtil.getFileBasedBuffer(
+                        filePath,
+                        LogUtil.getFileOffset(this, physicalLogLocator.getLsn()) + i
+                                * logManagerProperties.getLogPageSize(), logManagerProperties.getLogPageSize());
             }
+        } catch (Exception e) {
+            e.printStackTrace();
+            throw new ACIDException(Thread.currentThread().getName() + " unable to create log buffer", e);
         }
-        return logFileIds;
     }
 
-    public String getLogFilePath(long fileId) {
-        return logDir + File.separator + logFilePrefix + "_" + fileId;
+    /*
+     * Pages are sequenced starting with 0 going upto numLogPages-1.
+     */
+    public int getNextPageInSequence(int pageNo) {
+        return (pageNo + 1) % numLogPages;
     }
 
-    public long getLogFileOffset(long lsn) {
-        return lsn % logFileSize;
+    public int getPreviousPageInSequence(int pageNo) {
+        return pageNo == 0 ? numLogPages - 1 : pageNo - 1;
     }
 
-    public long getLogFileId(long lsn) {
-        return lsn / logFileSize;
+    @Override
+    public LogManagerProperties getLogManagerProperties() {
+        return logManagerProperties;
     }
 
-    private boolean createFileIfNotExists(String path) throws IOException {
-        File file = new File(path);
-        File parentFile = file.getParentFile();
-        if (parentFile != null) {
-            parentFile.mkdirs();
-        }
-        return file.createNewFile();
+    public IFileBasedBuffer getLogPage(int pageIndex) {
+        return logPages[pageIndex];
     }
 
-    private boolean createNewDirectory(String path) throws IOException {
-        return (new File(path)).mkdir();
+    public AtomicInteger getLogPageOwnershipCount(int pageIndex) {
+        return logPageOwnerCount[pageIndex];
     }
 
-    public FileChannel getFileChannel(long lsn, boolean create) {
-        FileChannel newFileChannel = null;
-        try {
-            long fileId = getLogFileId(lsn);
-            String logFilePath = getLogFilePath(fileId);
-            File file = new File(logFilePath);
-            if (create) {
-                if (!file.createNewFile()) {
-                    throw new IllegalStateException();
-                }
-            } else {
-                if (!file.exists()) {
-                    throw new IllegalStateException();
+    public IFileBasedBuffer[] getLogPages() {
+        return logPages;
+    }
+
+    @Override
+    public TransactionSubsystem getTransactionSubsystem() {
+        return provider;
+    }
+
+    public void decrementActiveTxnCountOnIndexes(int pageIndex) throws HyracksDataException {
+        TransactionContext ctx = null;
+        int count = 0;
+        int i = 0;
+
+        HashMap<TransactionContext, Integer> map = activeTxnCountMaps.get(pageIndex);
+        Set<Map.Entry<TransactionContext, Integer>> entrySet = map.entrySet();
+        if (entrySet != null) {
+            for (Map.Entry<TransactionContext, Integer> entry : entrySet) {
+                if (entry != null) {
+                    if (entry.getValue() != null) {
+                        count = entry.getValue();
+                    }
+                    if (count > 0) {
+                        ctx = entry.getKey();
+                        for (i = 0; i < count; i++) {
+                            ctx.decreaseActiveTransactionCountOnIndexes();
+                        }
+                    }
                 }
             }
-            RandomAccessFile raf = new RandomAccessFile(new File(logFilePath), "rw");
-            newFileChannel = raf.getChannel();
-            newFileChannel.position(getLogFileOffset(lsn));
-        } catch (IOException e) {
-            throw new IllegalStateException(e);
         }
-        return newFileChannel;
+
+        map.clear();
     }
 }
 
-class LogFlusher extends Thread {
-    private final LogManager logMgr;
-    private final LinkedBlockingQueue<LogPage> emptyQ;
-    private final LinkedBlockingQueue<LogPage> flushQ;
-    private LogPage flushPage;
-    private boolean stop;
+/*
+ * The thread responsible for putting log pages to disk in an ordered manner.
+ * The Log Flusher updates the bookkeeping data internal to the log manager and
+ * acquires appropriate locks. It also acquires finer level locks on the log
+ * page when it is in process of flushing the content to disk.
+ */
+class LogPageFlushThread extends Thread {
+
+    private LogManager logManager;
+    /*
+     * pendingFlushRequests is a map with key as Integer denoting the page
+     * index. When a (transaction) thread discovers the need to flush a page, it
+     * puts its Thread object into the corresponding value that is a
+     * LinkedBlockingQueue. The LogManager has a LogFlusher thread that scans
+     * this map in order of page index (and circling around). The flusher thread
+     * needs to flush pages in order and waits for a thread to deposit an object
+     * in the blocking queue corresponding to the next page in order. A request
+     * to flush a page is conveyed to the flush thread by simply depositing an
+     * object in to corresponding blocking queue. It is blocking in the sense
+     * that the flusher thread will continue to wait for an object to arrive in
+     * the queue. The object itself is ignored by the fliusher and just acts as
+     * a signal/event that a page needs to be flushed.
+     */
+    private final LinkedBlockingQueue<Object>[] flushRequestQueue;
+    private final Object[] flushRequests;
+    private int pageToFlush;
+    private final long groupCommitWaitPeriod;
+    private boolean isRenewRequest;
+
+    public LogPageFlushThread(LogManager logManager) {
+        this.logManager = logManager;
+        setName("Flusher");
+        int numLogPages = logManager.getLogManagerProperties().getNumLogPages();
+        this.flushRequestQueue = new LinkedBlockingQueue[numLogPages];
+        this.flushRequests = new Object[numLogPages];
+        for (int i = 0; i < numLogPages; i++) {
+            flushRequestQueue[i] = new LinkedBlockingQueue<Object>(1);
+            flushRequests[i] = new Object();
+        }
+        this.pageToFlush = -1;
+        groupCommitWaitPeriod = logManager.getLogManagerProperties().getGroupCommitWaitPeriod();
+        isRenewRequest = false;
+    }
 
-    public LogFlusher(LogManager logMgr, LinkedBlockingQueue<LogPage> emptyQ, LinkedBlockingQueue<LogPage> flushQ) {
-        this.logMgr = logMgr;
-        this.emptyQ = emptyQ;
-        this.flushQ = flushQ;
-        flushPage = null;
-        stop = false;
+    public void renew() {
+        isRenewRequest = true;
+        pageToFlush = -1;
+        this.interrupt();
+        isRenewRequest = false;
     }
 
-    public void terminate() {
-        if (flushPage != null) {
-            flushPage.isStop(true);
+    public void requestFlush(int pageIndex, long lsn, boolean isSynchronous) {
+        synchronized (logManager.getLogPage(pageIndex)) {
+            // return if flushedLSN >= lsn
+            if (logManager.getLastFlushedLsn().get() >= lsn) {
+                return;
+            }
+
+            // put a new request to the queue only if the request on the page is
+            // not in the queue.
+            flushRequestQueue[pageIndex].offer(flushRequests[pageIndex]);
+
+            // return if the request is asynchronous
+            if (!isSynchronous) {
+                return;
+            }
+
+            // wait until there is flush.
+            boolean isNotified = false;
+            while (!isNotified) {
+                try {
+                    logManager.getLogPage(pageIndex).wait();
+                    isNotified = true;
+                } catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
         }
-        stop = true;
-        this.interrupt();
     }
 
     @Override
     public void run() {
         while (true) {
-            flushPage = null;
             try {
-                flushPage = flushQ.take();
-                flushPage.flush();
-            } catch (InterruptedException e) {
-                if (stop) {
-                    break;
-                } else {
-                    throw new IllegalStateException(e);
+                pageToFlush = logManager.getNextPageInSequence(pageToFlush);
+
+                // A wait call on the linkedBLockingQueue. The flusher thread is
+                // notified when an object is added to the queue. Please note
+                // that each page has an associated blocking queue.
+                try {
+                    flushRequestQueue[pageToFlush].take();
+                } catch (InterruptedException ie) {
+                    while (isRenewRequest) {
+                        sleep(1);
+                    }
+                    continue;
                 }
+
+                synchronized (logManager.getLogPage(pageToFlush)) {
+
+                    // lock the internal state of the log manager and create a
+                    // log file if necessary.
+                    int prevLogFileId = logManager.getLogFileId(logManager.getLastFlushedLsn().get());
+                    int nextLogFileId = logManager.getLogFileId(logManager.getLastFlushedLsn().get()
+                            + logManager.getLogManagerProperties().getLogPageSize());
+                    if (prevLogFileId != nextLogFileId) {
+                        String filePath = LogUtil.getLogFilePath(logManager.getLogManagerProperties(), nextLogFileId);
+                        FileUtil.createFileIfNotExists(filePath);
+                        logManager.getLogPage(pageToFlush).reset(
+                                LogUtil.getLogFilePath(logManager.getLogManagerProperties(), nextLogFileId), 0,
+                                logManager.getLogManagerProperties().getLogPageSize());
+                    }
+
+                    // #. sleep during the groupCommitWaitTime
+                    sleep(groupCommitWaitPeriod);
+
+                    // #. set the logPageStatus to INACTIVE in order to prevent
+                    // other txns from writing on this page.
+                    logManager.getLogPageStatus(pageToFlush).set(PageState.INACTIVE);
+
+                    // #. need to wait until the logPageOwnerCount reaches 1
+                    // (LOG_WRITER)
+                    // meaning every one has finished writing logs on this page.
+                    while (logManager.getLogPageOwnershipCount(pageToFlush).get() != PageOwnershipStatus.LOG_WRITER) {
+                        sleep(0);
+                    }
+
+                    // #. set the logPageOwnerCount to 0 (LOG_FLUSHER)
+                    // meaning it is flushing.
+                    logManager.getLogPageOwnershipCount(pageToFlush).set(PageOwnershipStatus.LOG_FLUSHER);
+
+                    // put the content to disk (the thread still has a lock on
+                    // the log page)
+                    logManager.getLogPage(pageToFlush).flush();
+
+                    // increment the last flushed lsn and lastFlushedPage
+                    logManager.incrementLastFlushedLsn(logManager.getLogManagerProperties().getLogPageSize());
+
+                    // decrement activeTxnCountOnIndexes
+                    logManager.decrementActiveTxnCountOnIndexes(pageToFlush);
+
+                    // reset the count to 1
+                    logManager.getLogPageOwnershipCount(pageToFlush).set(PageOwnershipStatus.LOG_WRITER);
+
+                    // Map the log page to a new region in the log file.
+                    long nextWritePosition = logManager.getLogPages()[pageToFlush].getNextWritePosition()
+                            + logManager.getLogManagerProperties().getLogBufferSize();
+
+                    logManager.resetLogPage(nextWritePosition, pageToFlush);
+
+                    // mark the page as ACTIVE
+                    logManager.getLogPageStatus(pageToFlush).set(LogManager.PageState.ACTIVE);
+
+                    // #. checks the queue whether there is another flush
+                    // request on the same log buffer
+                    // If there is another request, then simply remove it.
+                    if (flushRequestQueue[pageToFlush].peek() != null) {
+                        flushRequestQueue[pageToFlush].take();
+                    }
+
+                    // notify all waiting (transaction) threads.
+                    logManager.getLogPage(pageToFlush).notifyAll();
+                }
+            } catch (IOException ioe) {
+                ioe.printStackTrace();
+                throw new Error(" exception in flushing log page", ioe);
+            } catch (InterruptedException e) {
+                e.printStackTrace();
+                break;
             }
-            emptyQ.offer(flushPage);
         }
     }
 }
\ No newline at end of file