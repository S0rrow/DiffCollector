diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java
index 14463730a6..0758714837 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/ProtonServerReceiverContext.java
@@ -19,15 +19,11 @@ package org.apache.activemq.artemis.protocol.amqp.proton;
 import java.util.Arrays;
 import java.util.List;
 
-import org.apache.activemq.artemis.api.config.ActiveMQDefaultConfiguration;
 import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
 import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.core.security.CheckType;
 import org.apache.activemq.artemis.core.security.SecurityAuth;
-import org.apache.activemq.artemis.core.server.RoutingContext;
-import org.apache.activemq.artemis.core.server.impl.AddressInfo;
-import org.apache.activemq.artemis.core.server.impl.RoutingContextImpl;
 import org.apache.activemq.artemis.core.transaction.Transaction;
 import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPException;
@@ -51,9 +47,6 @@ import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.Receiver;
 import org.jboss.logging.Logger;
 
-/**
- * This is the equivalent for the ServerProducer
- */
 public class ProtonServerReceiverContext extends ProtonInitializable implements ProtonDeliveryHandler {
 
    private static final Logger log = Logger.getLogger(ProtonServerReceiverContext.class);
@@ -68,43 +61,35 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
 
    protected final AMQPSessionCallback sessionSPI;
 
-   RoutingContext routingContext = new RoutingContextImpl(null);
-
-   /**
-    * We create this AtomicRunnable with setRan.
-    * This is because we always reuse the same instance.
-    * In case the creditRunnable was run, we reset and send it over.
-    * We set it as ran as the first one should always go through
-    */
+   /** We create this AtomicRunnable with setRan.
+    *  This is because we always reuse the same instance.
+    *  In case the creditRunnable was run, we reset and send it over.
+    *  We set it as ran as the first one should always go through */
    protected final AtomicRunnable creditRunnable;
 
-   /**
-    * This Credit Runnable may be used in Mock tests to simulate the credit semantic here
-    */
-   public static AtomicRunnable createCreditRunnable(int refill,
-                                                     int threshold,
-                                                     Receiver receiver,
-                                                     AMQPConnectionContext connection) {
-      Runnable creditRunnable = () -> {
-
-         connection.requireInHandler();
-         if (receiver.getCredit() <= threshold) {
-            int topUp = refill - receiver.getCredit();
-            if (topUp > 0) {
-               // System.out.println("Sending " + topUp + " towards client");
-               receiver.flow(topUp);
-               connection.flush();
-            }
-         }
-      };
+
+   /** This Credit Runnable may be used in Mock tests to simulate the credit semantic here */
+   public static AtomicRunnable createCreditRunnable(int refill, int threshold, Receiver receiver, AMQPConnectionContext connection) {
       return new AtomicRunnable() {
          @Override
          public void atomicRun() {
-            connection.runNow(creditRunnable);
+            connection.lock();
+            try {
+               if (receiver.getCredit() <= threshold) {
+                  int topUp = refill - receiver.getCredit();
+                  if (topUp > 0) {
+                     receiver.flow(topUp);
+                  }
+               }
+            } finally {
+               connection.unlock();
+            }
+            connection.flush();
          }
       };
    }
 
+
    /*
     The maximum number of credits we will allocate to clients.
     This number is also used by the broker when refresh client credits.
@@ -244,15 +229,8 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
             }
          }
       }
-      final AddressInfo addressInfo = sessionSPI.getAddress(address);
-      if (addressInfo != null && !addressInfo.getRoutingTypes().isEmpty()) {
-         if (addressInfo.getRoutingTypes().size() == 1 && addressInfo.getRoutingType() == RoutingType.MULTICAST) {
-            return RoutingType.MULTICAST;
-         }
-      }
-      RoutingType defaultRoutingType = sessionSPI.getDefaultRoutingType(address);
-      defaultRoutingType = defaultRoutingType == null ? ActiveMQDefaultConfiguration.getDefaultRoutingType() : defaultRoutingType;
-      return defaultRoutingType;
+
+      return sessionSPI.getDefaultRoutingType(address);
    }
 
    /*
@@ -262,46 +240,41 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
     */
    @Override
    public void onMessage(Delivery delivery) throws ActiveMQAMQPException {
-      connection.requireInHandler();
-      Receiver receiver = ((Receiver) delivery.getLink());
-
-      if (receiver.current() != delivery) {
-         return;
-      }
-
-      if (delivery.isAborted()) {
-         // Aborting implicitly remotely settles, so advance
-         // receiver to the next delivery and settle locally.
-         receiver.advance();
-         delivery.settle();
+      try {
+         Receiver receiver = ((Receiver) delivery.getLink());
 
-         // Replenish the credit if not doing a drain
-         if (!receiver.getDrain()) {
-            receiver.flow(1);
+         if (receiver.current() != delivery) {
+            return;
          }
 
-         return;
-      } else if (delivery.isPartial()) {
-         return;
-      }
+         if (delivery.isAborted()) {
+            // Aborting implicitly remotely settles, so advance
+            // receiver to the next delivery and settle locally.
+            receiver.advance();
+            delivery.settle();
 
-      ReadableBuffer data = receiver.recv();
-      receiver.advance();
-      Transaction tx = null;
+            // Replenish the credit if not doing a drain
+            if (!receiver.getDrain()) {
+               receiver.flow(1);
+            }
 
-      if (delivery.getRemoteState() instanceof TransactionalState) {
-         TransactionalState txState = (TransactionalState) delivery.getRemoteState();
-         tx = this.sessionSPI.getTransaction(txState.getTxnId(), false);
-      }
+            return;
+         } else if (delivery.isPartial()) {
+            return;
+         }
 
-      final Transaction txUsed = tx;
+         Transaction tx = null;
+         ReadableBuffer data = receiver.recv();
+         receiver.advance();
 
-      actualDelivery(delivery, receiver, data, txUsed);
-   }
+         if (delivery.getRemoteState() instanceof TransactionalState) {
+            TransactionalState txState = (TransactionalState) delivery.getRemoteState();
+            tx = this.sessionSPI.getTransaction(txState.getTxnId(), false);
+         }
 
-   private void actualDelivery(Delivery delivery, Receiver receiver, ReadableBuffer data, Transaction tx) {
-      try {
-         sessionSPI.serverSend(this, tx, receiver, delivery, address, delivery.getMessageFormat(), data, routingContext);
+         sessionSPI.serverSend(this, tx, receiver, delivery, address, delivery.getMessageFormat(), data);
+
+         flow();
       } catch (Exception e) {
          log.warn(e.getMessage(), e);
          Rejected rejected = new Rejected();
@@ -312,17 +285,13 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
          } else {
             condition.setCondition(Symbol.valueOf("failed"));
          }
-         connection.runLater(() -> {
 
-            condition.setDescription(e.getMessage());
-            rejected.setError(condition);
-
-            delivery.disposition(rejected);
-            delivery.settle();
-            flow();
-            connection.flush();
-         });
+         condition.setDescription(e.getMessage());
+         rejected.setError(condition);
 
+         delivery.disposition(rejected);
+         delivery.settle();
+         flow();
       }
    }
 
@@ -346,7 +315,6 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
    }
 
    public void flow() {
-      connection.requireInHandler();
       if (!creditRunnable.isRun()) {
          return; // nothing to be done as the previous one did not run yet
       }
@@ -362,10 +330,13 @@ public class ProtonServerReceiverContext extends ProtonInitializable implements
    }
 
    public void drain(int credits) {
-      connection.runNow(() -> {
+      connection.lock();
+      try {
          receiver.drain(credits);
-         connection.flush();
-      });
+      } finally {
+         connection.unlock();
+      }
+      connection.flush();
    }
 
    public int drained() {