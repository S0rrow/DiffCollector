diff --git a/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java b/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java
index e8259c32b0..e7582f2754 100644
--- a/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java
+++ b/artemis-protocols/artemis-openwire-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/openwire/OpenWireConnection.java
@@ -16,54 +16,35 @@
  */
 package org.apache.activemq.artemis.core.protocol.openwire;
 
-import javax.jms.InvalidClientIDException;
 import javax.jms.InvalidDestinationException;
 import javax.jms.JMSSecurityException;
-import javax.transaction.xa.XAResource;
+import javax.jms.ResourceAllocationException;
 import java.io.IOException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 
-import org.apache.activemq.advisory.AdvisorySupport;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
+import org.apache.activemq.artemis.api.core.ActiveMQBuffers;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.api.core.ActiveMQNonExistentQueueException;
 import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
 import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.core.postoffice.Binding;
-import org.apache.activemq.artemis.core.postoffice.Bindings;
-import org.apache.activemq.artemis.core.postoffice.QueueBinding;
 import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQCompositeConsumerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConnectionContext;
 import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumer;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQProducerBrokerExchange;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQServerConsumer;
-import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession;
 import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSingleConsumerBrokerExchange;
-import org.apache.activemq.artemis.core.remoting.FailureListener;
-import org.apache.activemq.artemis.core.security.CheckType;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
-import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
-import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
-import org.apache.activemq.artemis.core.server.BindingQueryResult;
-import org.apache.activemq.artemis.core.server.Queue;
-import org.apache.activemq.artemis.core.server.ServerConsumer;
-import org.apache.activemq.artemis.core.server.SlowConsumerDetectionListener;
-import org.apache.activemq.artemis.spi.core.protocol.AbstractRemotingConnection;
-import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
-import org.apache.activemq.artemis.spi.core.remoting.Connection;
-import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.command.ActiveMQDestination;
 import org.apache.activemq.command.ActiveMQMessage;
-import org.apache.activemq.command.ActiveMQTopic;
 import org.apache.activemq.command.BrokerInfo;
 import org.apache.activemq.command.Command;
 import org.apache.activemq.command.ConnectionControl;
@@ -78,7 +59,6 @@ import org.apache.activemq.command.DataArrayResponse;
 import org.apache.activemq.command.DestinationInfo;
 import org.apache.activemq.command.ExceptionResponse;
 import org.apache.activemq.command.FlushCommand;
-import org.apache.activemq.command.IntegerResponse;
 import org.apache.activemq.command.KeepAliveInfo;
 import org.apache.activemq.command.Message;
 import org.apache.activemq.command.MessageAck;
@@ -88,6 +68,7 @@ import org.apache.activemq.command.MessagePull;
 import org.apache.activemq.command.ProducerAck;
 import org.apache.activemq.command.ProducerId;
 import org.apache.activemq.command.ProducerInfo;
+import org.apache.activemq.command.RemoveInfo;
 import org.apache.activemq.command.RemoveSubscriptionInfo;
 import org.apache.activemq.command.Response;
 import org.apache.activemq.command.SessionId;
@@ -96,213 +77,361 @@ import org.apache.activemq.command.ShutdownInfo;
 import org.apache.activemq.command.TransactionId;
 import org.apache.activemq.command.TransactionInfo;
 import org.apache.activemq.command.WireFormatInfo;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQBrokerStoppedException;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConnectionContext;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQConsumerBrokerExchange;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQMessageAuthorizationPolicy;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQProducerBrokerExchange;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQSession;
+import org.apache.activemq.artemis.core.protocol.openwire.amq.AMQTransaction;
+import org.apache.activemq.artemis.core.remoting.CloseListener;
+import org.apache.activemq.artemis.core.remoting.FailureListener;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.openwire.OpenWireFormat;
+import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
+import org.apache.activemq.artemis.spi.core.remoting.Acceptor;
+import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.state.CommandVisitor;
 import org.apache.activemq.state.ConnectionState;
 import org.apache.activemq.state.ConsumerState;
 import org.apache.activemq.state.ProducerState;
 import org.apache.activemq.state.SessionState;
+import org.apache.activemq.thread.TaskRunner;
+import org.apache.activemq.thread.TaskRunnerFactory;
 import org.apache.activemq.transport.TransmitCallback;
 import org.apache.activemq.util.ByteSequence;
+import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.wireformat.WireFormat;
 
 /**
  * Represents an activemq connection.
  */
-public class OpenWireConnection extends AbstractRemotingConnection implements SecurityAuth {
+public class OpenWireConnection implements RemotingConnection, CommandVisitor {
 
    private final OpenWireProtocolManager protocolManager;
 
+   private final Connection transportConnection;
+
+   private final AMQConnectorImpl acceptorUsed;
+
+   private final long creationTime;
+
+   private final List<FailureListener> failureListeners = new CopyOnWriteArrayList<FailureListener>();
+
+   private final List<CloseListener> closeListeners = new CopyOnWriteArrayList<CloseListener>();
+
    private boolean destroyed = false;
 
    private final Object sendLock = new Object();
 
-   private final OpenWireFormat wireFormat;
+   private boolean dataReceived;
+
+   private OpenWireFormat wireFormat;
+
+   private boolean faultTolerantConnection;
 
    private AMQConnectionContext context;
 
+   private AMQMessageAuthorizationPolicy messageAuthorizationPolicy;
+
+   private boolean networkConnection;
+
+   private boolean manageable;
+
+   private boolean pendingStop;
+
+   private Throwable stopError = null;
+
+   // should come from activemq server
+   private final TaskRunnerFactory stopTaskRunnerFactory = null;
+
+   private boolean starting;
+
    private final AtomicBoolean stopping = new AtomicBoolean(false);
 
-   private boolean inServiceException;
+   private final ReentrantReadWriteLock serviceLock = new ReentrantReadWriteLock();
 
-   private final AtomicBoolean asyncException = new AtomicBoolean(false);
+   private final CountDownLatch stopped = new CountDownLatch(1);
+
+   protected TaskRunner taskRunner;
+
+   private boolean active;
 
-   // Clebert: Artemis session has meta-data support, perhaps we could reuse it here
-   private Map<String, SessionId> sessionIdMap = new ConcurrentHashMap<>();
+   protected final List<Command> dispatchQueue = new LinkedList<Command>();
 
+   private boolean markedCandidate;
 
-   private final Map<ConsumerId, AMQConsumerBrokerExchange> consumerExchanges = new HashMap<>();
-   private final Map<ProducerId, AMQProducerBrokerExchange> producerExchanges = new HashMap<>();
+   private boolean blockedCandidate;
 
-   // Clebert TODO: Artemis already stores the Session. Why do we need a different one here
-   private Map<SessionId, AMQSession> sessions = new ConcurrentHashMap<>();
+   private long timeStamp;
 
+   private boolean inServiceException;
+
+   private final AtomicBoolean asyncException = new AtomicBoolean(false);
 
+   private final Map<ConsumerId, AMQConsumerBrokerExchange> consumerExchanges = new HashMap<ConsumerId, AMQConsumerBrokerExchange>();
+   private final Map<ProducerId, AMQProducerBrokerExchange> producerExchanges = new HashMap<ProducerId, AMQProducerBrokerExchange>();
 
    private ConnectionState state;
 
-   private final Set<ActiveMQDestination> tempQueues = new ConcurrentHashSet<>();
+   private final Set<String> tempQueues = new ConcurrentHashSet<String>();
+
+   private DataInputWrapper dataInput = new DataInputWrapper();
 
-   private Map<TransactionId, TransactionInfo> txMap = new ConcurrentHashMap<>();
+   private Map<TransactionId, TransactionInfo> txMap = new ConcurrentHashMap<TransactionId, TransactionInfo>();
 
    private volatile AMQSession advisorySession;
 
-   // TODO-NOW: check on why there are two connections created for every createConnection on the client.
-   public OpenWireConnection(Connection connection,
-                             Executor executor,
+   public OpenWireConnection(Acceptor acceptorUsed,
+                             Connection connection,
                              OpenWireProtocolManager openWireProtocolManager,
                              OpenWireFormat wf) {
-      super(connection, executor);
       this.protocolManager = openWireProtocolManager;
+      this.transportConnection = connection;
+      this.acceptorUsed = new AMQConnectorImpl(acceptorUsed);
       this.wireFormat = wf;
+      this.creationTime = System.currentTimeMillis();
    }
 
-   // SecurityAuth implementation
    @Override
-   public String getUsername() {
-      ConnectionInfo info = getConnectionInfo();
-      if (info == null) {
-         return null;
+   public void bufferReceived(Object connectionID, ActiveMQBuffer buffer) {
+      try {
+         dataInput.receiveData(buffer);
+      }
+      catch (Throwable t) {
+         ActiveMQServerLogger.LOGGER.error("decoding error", t);
+         return;
+      }
+
+      // this.setDataReceived();
+      while (dataInput.readable()) {
+         try {
+            Object object = null;
+            try {
+               object = wireFormat.unmarshal(dataInput);
+               dataInput.mark();
+            }
+            catch (NotEnoughBytesException e) {
+               //meaning the dataInput hasn't enough bytes for a command.
+               //in that case we just return and waiting for the next
+               //call of bufferReceived()
+               return;
+            }
+
+            Command command = (Command) object;
+            boolean responseRequired = command.isResponseRequired();
+            int commandId = command.getCommandId();
+            // the connection handles pings, negotiations directly.
+            // and delegate all other commands to manager.
+            if (command.getClass() == KeepAliveInfo.class) {
+               KeepAliveInfo info = (KeepAliveInfo) command;
+               if (info.isResponseRequired()) {
+                  info.setResponseRequired(false);
+                  protocolManager.sendReply(this, info);
+               }
+            }
+            else if (command.getClass() == WireFormatInfo.class) {
+               // amq here starts a read/write monitor thread (detect ttl?)
+               negotiate((WireFormatInfo) command);
+            }
+            else if (command.getClass() == ConnectionInfo.class || command.getClass() == ConsumerInfo.class || command.getClass() == RemoveInfo.class || command.getClass() == SessionInfo.class || command.getClass() == ProducerInfo.class || ActiveMQMessage.class.isAssignableFrom(command.getClass()) || command.getClass() == MessageAck.class || command.getClass() == TransactionInfo.class || command.getClass() == DestinationInfo.class || command.getClass() == ShutdownInfo.class || command.getClass() == RemoveSubscriptionInfo.class) {
+               Response response = null;
+
+               if (pendingStop) {
+                  response = new ExceptionResponse(this.stopError);
+               }
+               else {
+                  response = ((Command) command).visit(this);
+
+                  if (response instanceof ExceptionResponse) {
+                     if (!responseRequired) {
+                        Throwable cause = ((ExceptionResponse) response).getException();
+                        serviceException(cause);
+                        response = null;
+                     }
+                  }
+               }
+
+               if (responseRequired) {
+                  if (response == null) {
+                     response = new Response();
+                  }
+               }
+
+               // The context may have been flagged so that the response is not
+               // sent.
+               if (context != null) {
+                  if (context.isDontSendReponse()) {
+                     context.setDontSendReponse(false);
+                     response = null;
+                  }
+               }
+
+               if (response != null && !protocolManager.isStopping()) {
+                  response.setCorrelationId(commandId);
+                  dispatchSync(response);
+               }
+
+            }
+            else {
+               // note!!! wait for negotiation (e.g. use a countdown latch)
+               // before handling any other commands
+               this.protocolManager.handleCommand(this, command);
+            }
+         }
+         catch (IOException e) {
+            ActiveMQServerLogger.LOGGER.error("error decoding", e);
+         }
+         catch (Throwable t) {
+            ActiveMQServerLogger.LOGGER.error("error decoding", t);
+         }
       }
-      return info.getUserName();
    }
 
-   // SecurityAuth implementation
+   private void negotiate(WireFormatInfo command) throws IOException {
+      this.wireFormat.renegotiateWireFormat(command);
+   }
+
+   @Override
+   public Object getID() {
+      return transportConnection.getID();
+   }
+
+   @Override
+   public long getCreationTime() {
+      return creationTime;
+   }
+
    @Override
-   public RemotingConnection getRemotingConnection() {
-      return this;
+   public String getRemoteAddress() {
+      return transportConnection.getRemoteAddress();
    }
 
-   // SecurityAuth implementation
    @Override
-   public String getPassword() {
-      ConnectionInfo info = getConnectionInfo();
-      if (info == null) {
-         return null;
+   public void addFailureListener(FailureListener listener) {
+      if (listener == null) {
+         throw new IllegalStateException("FailureListener cannot be null");
       }
-      return info.getPassword();
+
+      failureListeners.add(listener);
    }
 
-   private ConnectionInfo getConnectionInfo() {
-      if (state == null) {
-         return null;
+   @Override
+   public boolean removeFailureListener(FailureListener listener) {
+      if (listener == null) {
+         throw new IllegalStateException("FailureListener cannot be null");
       }
-      ConnectionInfo info = state.getInfo();
-      if (info == null) {
-         return null;
+
+      return failureListeners.remove(listener);
+   }
+
+   @Override
+   public void addCloseListener(CloseListener listener) {
+      if (listener == null) {
+         throw new IllegalStateException("CloseListener cannot be null");
       }
-      return info;
+
+      closeListeners.add(listener);
    }
 
    @Override
-   public void bufferReceived(Object connectionID, ActiveMQBuffer buffer) {
-      super.bufferReceived(connectionID, buffer);
-      try {
+   public boolean removeCloseListener(CloseListener listener) {
+      if (listener == null) {
+         throw new IllegalStateException("CloseListener cannot be null");
+      }
 
-         // TODO-NOW: set OperationContext
+      return closeListeners.remove(listener);
+   }
 
-         Command command = (Command) wireFormat.unmarshal(buffer);
+   @Override
+   public List<CloseListener> removeCloseListeners() {
+      List<CloseListener> ret = new ArrayList<CloseListener>(closeListeners);
 
-         boolean responseRequired = command.isResponseRequired();
-         int commandId = command.getCommandId();
+      closeListeners.clear();
 
+      return ret;
+   }
 
-         // TODO-NOW: the server should send packets to the client based on the requested times
-         //           need to look at what Andy did on AMQP
+   @Override
+   public void setCloseListeners(List<CloseListener> listeners) {
+      closeListeners.clear();
 
-         // the connection handles pings, negotiations directly.
-         // and delegate all other commands to manager.
-         if (command.getClass() == KeepAliveInfo.class) {
-            KeepAliveInfo info = (KeepAliveInfo) command;
-            info.setResponseRequired(false);
-            // if we don't respond to KeepAlive commands then the client will think the server is dead and timeout
-            // for some reason KeepAliveInfo.isResponseRequired() is always false
-            sendCommand(info);
-         }
-         else {
-            Response response = null;
+      closeListeners.addAll(listeners);
+   }
 
-            try {
-               setLastCommand(command);
-               response = command.visit(commandProcessorInstance);
-            }
-            catch (Exception e) {
-               if (responseRequired) {
-                  response = new ExceptionResponse(e);
-               }
-            }
-            finally {
-               setLastCommand(null);
-            }
+   @Override
+   public List<FailureListener> getFailureListeners() {
+      // we do not return the listeners otherwise the remoting service
+      // would NOT destroy the connection.
+      return Collections.emptyList();
+   }
 
-            if (response instanceof ExceptionResponse) {
-               if (!responseRequired) {
-                  Throwable cause = ((ExceptionResponse) response).getException();
-                  serviceException(cause);
-                  response = null;
-               }
-            }
+   @Override
+   public List<FailureListener> removeFailureListeners() {
+      List<FailureListener> ret = new ArrayList<FailureListener>(failureListeners);
 
-            if (responseRequired) {
-               if (response == null) {
-                  response = new Response();
-                  response.setCorrelationId(command.getCommandId());
-               }
-            }
+      failureListeners.clear();
 
-            // The context may have been flagged so that the response is not
-            // sent.
-            if (context != null) {
-               if (context.isDontSendReponse()) {
-                  context.setDontSendReponse(false);
-                  response = null;
-               }
-            }
+      return ret;
+   }
 
-            // TODO-NOW: response through operation-context
+   @Override
+   public void setFailureListeners(List<FailureListener> listeners) {
+      failureListeners.clear();
 
-            if (response != null && !protocolManager.isStopping()) {
-               response.setCorrelationId(commandId);
-               dispatchSync(response);
-            }
+      failureListeners.addAll(listeners);
+   }
 
-         }
-      }
-      catch (Exception e) {
-         ActiveMQServerLogger.LOGGER.debug(e);
+   @Override
+   public ActiveMQBuffer createTransportBuffer(int size) {
+      return ActiveMQBuffers.dynamicBuffer(size);
+   }
 
-         sendException(e);
+   @Override
+   public void fail(ActiveMQException me) {
+      if (me != null) {
+         ActiveMQServerLogger.LOGGER.connectionFailureDetected(me.getMessage(), me.getType());
       }
+
+      // Then call the listeners
+      callFailureListeners(me);
+
+      callClosingListeners();
+
+      destroyed = true;
+
+      transportConnection.close();
    }
 
-   public void sendException(Exception e) {
-      Response resp;
-      if (e instanceof ActiveMQSecurityException) {
-         resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
-      }
-      else if (e instanceof ActiveMQNonExistentQueueException) {
-         resp = new ExceptionResponse(new InvalidDestinationException(e.getMessage()));
-      }
-      else {
-         resp = new ExceptionResponse(e);
-      }
+   @Override
+   public void destroy() {
+      destroyed = true;
+
+      transportConnection.close();
+
       try {
-         dispatch(resp);
+         deleteTempQueues();
       }
-      catch (IOException e2) {
-         ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e2);
+      catch (Exception e) {
+         //log warning
+      }
+
+      synchronized (sendLock) {
+         callClosingListeners();
       }
    }
 
-   private void setLastCommand(Command command) {
-      if (context != null) {
-         context.setLastCommand(command);
+   private void deleteTempQueues() throws Exception {
+      Iterator<String> queueNames = tempQueues.iterator();
+      while (queueNames.hasNext()) {
+         String q = queueNames.next();
+         protocolManager.deleteQueue(q);
       }
    }
 
    @Override
-   public void destroy() {
-      fail(null, null);
+   public Connection getTransportConnection() {
+      return this.transportConnection;
    }
 
    @Override
@@ -317,7 +446,7 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
 
    @Override
    public void disconnect(boolean criticalError) {
-      this.disconnect(null, null, criticalError);
+      fail(null);
    }
 
    @Override
@@ -334,7 +463,7 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
    }
 
    private void callFailureListeners(final ActiveMQException me) {
-      final List<FailureListener> listenersClone = new ArrayList<>(failureListeners);
+      final List<FailureListener> listenersClone = new ArrayList<FailureListener>(failureListeners);
 
       for (final FailureListener listener : listenersClone) {
          try {
@@ -349,10 +478,26 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
       }
    }
 
-   // send a WireFormatInfo to the peer
-   public void sendHandshake() {
+   private void callClosingListeners() {
+      final List<CloseListener> listenersClone = new ArrayList<CloseListener>(closeListeners);
+
+      for (final CloseListener listener : listenersClone) {
+         try {
+            listener.connectionClosed();
+         }
+         catch (final Throwable t) {
+            // Failure of one listener to execute shouldn't prevent others
+            // from
+            // executing
+            ActiveMQServerLogger.LOGGER.errorCallingFailureListener(t);
+         }
+      }
+   }
+
+   // throw a WireFormatInfo to the peer
+   public void init() {
       WireFormatInfo info = wireFormat.getPreferedWireFormatInfo();
-      sendCommand(info);
+      protocolManager.send(this, info);
    }
 
    public ConnectionState getState() {
@@ -376,22 +521,195 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
 
    }
 
-   public void dispatchAsync(Command message) throws Exception {
-      dispatchSync(message);
+   @Override
+   public Response processAddConnection(ConnectionInfo info) throws Exception {
+      WireFormatInfo wireFormatInfo = wireFormat.getPreferedWireFormatInfo();
+      // Older clients should have been defaulting this field to true.. but
+      // they were not.
+      if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
+         info.setClientMaster(true);
+      }
+
+      state = new ConnectionState(info);
+
+      context = new AMQConnectionContext();
+
+      state.reset(info);
+
+      this.faultTolerantConnection = info.isFaultTolerant();
+      // Setup the context.
+      String clientId = info.getClientId();
+      context.setBroker(protocolManager);
+      context.setClientId(clientId);
+      context.setClientMaster(info.isClientMaster());
+      context.setConnection(this);
+      context.setConnectionId(info.getConnectionId());
+      // for now we pass the manager as the connector and see what happens
+      // it should be related to activemq's Acceptor
+      context.setConnector(this.acceptorUsed);
+      context.setMessageAuthorizationPolicy(getMessageAuthorizationPolicy());
+      context.setNetworkConnection(networkConnection);
+      context.setFaultTolerant(faultTolerantConnection);
+      context.setTransactions(new ConcurrentHashMap<TransactionId, AMQTransaction>());
+      context.setUserName(info.getUserName());
+      context.setWireFormatInfo(wireFormatInfo);
+      context.setReconnect(info.isFailoverReconnect());
+      this.manageable = info.isManageable();
+      context.setConnectionState(state);
+      if (info.getClientIp() == null) {
+         info.setClientIp(getRemoteAddress());
+      }
+
+      try {
+         protocolManager.addConnection(context, info);
+      }
+      catch (Exception e) {
+         if (e instanceof SecurityException) {
+            // close this down - in case the peer of this transport doesn't play
+            // nice
+            delayedStop(2000, "Failed with SecurityException: " + e.getLocalizedMessage(), e);
+         }
+         Response resp = new ExceptionResponse(e);
+         return resp;
+      }
+      if (info.isManageable()) {
+         // send ConnectionCommand
+         ConnectionControl command = this.acceptorUsed.getConnectionControl();
+         command.setFaultTolerant(protocolManager.isFaultTolerantConfiguration());
+         if (info.isFailoverReconnect()) {
+            command.setRebalanceConnection(false);
+         }
+         dispatchAsync(command);
+      }
+      return null;
+   }
+
+   public void dispatchAsync(Command message) {
+      if (!stopping.get()) {
+         if (taskRunner == null) {
+            dispatchSync(message);
+         }
+         else {
+            synchronized (dispatchQueue) {
+               dispatchQueue.add(message);
+            }
+            try {
+               taskRunner.wakeup();
+            }
+            catch (InterruptedException e) {
+               Thread.currentThread().interrupt();
+            }
+         }
+      }
+      else {
+         if (message.isMessageDispatch()) {
+            MessageDispatch md = (MessageDispatch) message;
+            TransmitCallback sub = md.getTransmitCallback();
+            protocolManager.postProcessDispatch(md);
+            if (sub != null) {
+               sub.onFailure();
+            }
+         }
+      }
+   }
+
+   public void dispatchSync(Command message) {
+      try {
+         processDispatch(message);
+      }
+      catch (IOException e) {
+         serviceExceptionAsync(e);
+      }
+   }
+
+   public void serviceExceptionAsync(final IOException e) {
+      if (asyncException.compareAndSet(false, true)) {
+         new Thread("Async Exception Handler") {
+            @Override
+            public void run() {
+               serviceException(e);
+            }
+         }.start();
+      }
+   }
+
+   public void serviceException(Throwable e) {
+      // are we a transport exception such as not being able to dispatch
+      // synchronously to a transport
+      if (e instanceof IOException) {
+         serviceTransportException((IOException) e);
+      }
+      else if (e.getClass() == AMQBrokerStoppedException.class) {
+         // Handle the case where the broker is stopped
+         // But the client is still connected.
+         if (!stopping.get()) {
+            ConnectionError ce = new ConnectionError();
+            ce.setException(e);
+            dispatchSync(ce);
+            // Record the error that caused the transport to stop
+            this.stopError = e;
+            // Wait a little bit to try to get the output buffer to flush
+            // the exception notification to the client.
+            try {
+               Thread.sleep(500);
+            }
+            catch (InterruptedException ie) {
+               Thread.currentThread().interrupt();
+            }
+            // Worst case is we just kill the connection before the
+            // notification gets to him.
+            stopAsync();
+         }
+      }
+      else if (!stopping.get() && !inServiceException) {
+         inServiceException = true;
+         try {
+            ConnectionError ce = new ConnectionError();
+            ce.setException(e);
+            if (pendingStop) {
+               dispatchSync(ce);
+            }
+            else {
+               dispatchAsync(ce);
+            }
+         }
+         finally {
+            inServiceException = false;
+         }
+      }
    }
 
-   public void dispatchSync(Command message) throws Exception {
-      processDispatch(message);
+   public void serviceTransportException(IOException e) {
+      /*
+       * deal with it later BrokerService bService =
+       * connector.getBrokerService(); if (bService.isShutdownOnSlaveFailure())
+       * { if (brokerInfo != null) { if (brokerInfo.isSlaveBroker()) {
+       * LOG.error("Slave has exception: {} shutting down master now.",
+       * e.getMessage(), e); try { doStop(); bService.stop(); } catch (Exception
+       * ex) { LOG.warn("Failed to stop the master", ex); } } } } if
+       * (!stopping.get() && !pendingStop) { transportException.set(e); if
+       * (TRANSPORTLOG.isDebugEnabled()) { TRANSPORTLOG.debug(this + " failed: "
+       * + e, e); } else if (TRANSPORTLOG.isWarnEnabled() && !expected(e)) {
+       * TRANSPORTLOG.warn(this + " failed: " + e); } stopAsync(); }
+       */
    }
 
-   public void serviceException(Throwable e) throws Exception {
-      ConnectionError ce = new ConnectionError();
-      ce.setException(e);
-      dispatchAsync(ce);
+   public void setMarkedCandidate(boolean markedCandidate) {
+      this.markedCandidate = markedCandidate;
+      if (!markedCandidate) {
+         timeStamp = 0;
+         blockedCandidate = false;
+      }
    }
 
-   public void dispatch(Command command) throws IOException {
-      this.physicalSend(command);
+   protected void dispatch(Command command) throws IOException {
+      try {
+         setMarkedCandidate(true);
+         this.physicalSend(command);
+      }
+      finally {
+         setMarkedCandidate(false);
+      }
    }
 
    protected void processDispatch(Command command) throws IOException {
@@ -426,775 +744,618 @@ public class OpenWireConnection extends AbstractRemotingConnection implements Se
       }
    }
 
-   private void addConsumerBrokerExchange(ConsumerId id,
-                                         AMQSession amqSession,
-                                         List<AMQConsumer> consumerList) {
-      AMQConsumerBrokerExchange result = consumerExchanges.get(id);
-      if (result == null) {
-         if (consumerList.size() == 1) {
-            result = new AMQSingleConsumerBrokerExchange(amqSession, consumerList.get(0));
+   private AMQMessageAuthorizationPolicy getMessageAuthorizationPolicy() {
+      return this.messageAuthorizationPolicy;
+   }
+
+   public void delayedStop(final int waitTime, final String reason, Throwable cause) {
+      if (waitTime > 0) {
+         synchronized (this) {
+            pendingStop = true;
+            stopError = cause;
          }
-         else {
-            result = new AMQCompositeConsumerBrokerExchange(amqSession, consumerList);
+         try {
+            stopTaskRunnerFactory.execute(new Runnable() {
+               @Override
+               public void run() {
+                  try {
+                     Thread.sleep(waitTime);
+                     stopAsync();
+                  }
+                  catch (InterruptedException e) {
+                  }
+               }
+            });
          }
-         synchronized (consumerExchanges) {
-            consumerExchanges.put(id, result);
+         catch (Throwable t) {
+            // log error
          }
       }
    }
 
-   private AMQProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {
-      AMQProducerBrokerExchange result = producerExchanges.get(id);
-      if (result == null) {
-         synchronized (producerExchanges) {
-            result = new AMQProducerBrokerExchange();
-            result.setConnectionContext(context);
-            //todo implement reconnect https://issues.apache.org/jira/browse/ARTEMIS-194
-            //todo: this used to check for  && this.acceptorUsed.isAuditNetworkProducers()
-            if (context.isReconnect() || (context.isNetworkConnection())) {
-               // once implemented ARTEMIS-194, we need to set the storedSequenceID here somehow
-               // We have different semantics on Artemis Journal, but we could adapt something for this
-               // TBD during the implemetnation of ARTEMIS-194
-               result.setLastStoredSequenceId(0);
-            }
-            SessionState ss = state.getSessionState(id.getParentId());
-            if (ss != null) {
-               result.setProducerState(ss.getProducerState(id));
-               ProducerState producerState = ss.getProducerState(id);
-               if (producerState != null && producerState.getInfo() != null) {
-                  ProducerInfo info = producerState.getInfo();
-               }
-            }
-            producerExchanges.put(id, result);
+   public void stopAsync() {
+      // If we're in the middle of starting then go no further... for now.
+      synchronized (this) {
+         pendingStop = true;
+         if (starting) {
+            // log
+            return;
          }
       }
-      return result;
-   }
-
-   private void removeConsumerBrokerExchange(ConsumerId id) {
-      synchronized (consumerExchanges) {
-         consumerExchanges.remove(id);
-      }
-   }
-
-   public void deliverMessage(MessageDispatch dispatch) {
-      Message m = dispatch.getMessage();
-      if (m != null) {
-         long endTime = System.currentTimeMillis();
-         m.setBrokerOutTime(endTime);
-      }
-
-      sendCommand(dispatch);
-   }
-
-   public WireFormat getMarshaller() {
-      return this.wireFormat;
-   }
-
-   public void registerTempQueue(ActiveMQDestination queue) {
-      tempQueues.add(queue);
-   }
-
-   private void shutdown(boolean fail) {
-      if (fail) {
-         transportConnection.forceClose();
-      }
-      else {
-         transportConnection.close();
+      if (stopping.compareAndSet(false, true)) {
+         if (context != null) {
+            context.getStopping().set(true);
+         }
+         try {
+            stopTaskRunnerFactory.execute(new Runnable() {
+               @Override
+               public void run() {
+                  serviceLock.writeLock().lock();
+                  try {
+                     doStop();
+                  }
+                  catch (Throwable e) {
+                     // LOG
+                  }
+                  finally {
+                     stopped.countDown();
+                     serviceLock.writeLock().unlock();
+                  }
+               }
+            });
+         }
+         catch (Throwable t) {
+            // LOG
+            stopped.countDown();
+         }
       }
    }
 
-   private void disconnect(ActiveMQException me, String reason, boolean fail)  {
-
-      if (context == null || destroyed) {
-         return;
+   protected void doStop() throws Exception {
+      this.acceptorUsed.onStopped(this);
+      /*
+       * What's a duplex bridge? try { synchronized (this) { if (duplexBridge !=
+       * null) { duplexBridge.stop(); } } } catch (Exception ignore) {
+       * LOG.trace("Exception caught stopping. This exception is ignored.",
+       * ignore); }
+       */
+      try {
+         getTransportConnection().close();
       }
-      // Don't allow things to be added to the connection state while we
-      // are shutting down.
-      // is it necessary? even, do we need state at all?
-      state.shutdown();
-
-      // Then call the listeners
-      // this should closes underlying sessions
-      callFailureListeners(me);
-
-      // this should clean up temp dests
-      synchronized (sendLock) {
-         callClosingListeners();
+      catch (Exception e) {
+         // log
+      }
+
+      if (taskRunner != null) {
+         taskRunner.shutdown(1);
+         taskRunner = null;
+      }
+
+      active = false;
+      // Run the MessageDispatch callbacks so that message references get
+      // cleaned up.
+      synchronized (dispatchQueue) {
+         for (Iterator<Command> iter = dispatchQueue.iterator(); iter.hasNext(); ) {
+            Command command = iter.next();
+            if (command.isMessageDispatch()) {
+               MessageDispatch md = (MessageDispatch) command;
+               TransmitCallback sub = md.getTransmitCallback();
+               protocolManager.postProcessDispatch(md);
+               if (sub != null) {
+                  sub.onFailure();
+               }
+            }
+         }
+         dispatchQueue.clear();
       }
-
-      destroyed = true;
-
-      //before closing transport, sendCommand the last response if any
-      Command command = context.getLastCommand();
-      if (command != null && command.isResponseRequired()) {
-         Response lastResponse = new Response();
-         lastResponse.setCorrelationId(command.getCommandId());
+      //
+      // Remove all logical connection associated with this connection
+      // from the broker.
+      if (!protocolManager.isStopped()) {
+         context.getStopping().set(true);
          try {
-            dispatchSync(lastResponse);
+            processRemoveConnection(state.getInfo().getConnectionId(), 0L);
          }
-         catch (Throwable e) {
-            ActiveMQServerLogger.LOGGER.warn(e.getMessage(), e);
+         catch (Throwable ignore) {
+            ignore.printStackTrace();
          }
       }
    }
 
    @Override
-   public void disconnect(String reason, boolean fail) {
-      this.disconnect(null, reason, fail);
-   }
-
-   @Override
-   public void fail(ActiveMQException me, String message) {
-      if (me != null) {
-         ActiveMQServerLogger.LOGGER.connectionFailureDetected(me.getMessage(), me.getType());
-      }
+   public Response processAddConsumer(ConsumerInfo info) {
+      Response resp = null;
       try {
-         protocolManager.removeConnection(this.getConnectionInfo(), me);
+         protocolManager.addConsumer(this, info);
       }
-      catch (InvalidClientIDException e) {
-         ActiveMQServerLogger.LOGGER.warn("Couldn't close connection because invalid clientID", e);
+      catch (Exception e) {
+         if (e instanceof ActiveMQSecurityException) {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+         }
+         else {
+            resp = new ExceptionResponse(e);
+         }
       }
-      shutdown(true);
+      return resp;
    }
 
-   public void setAdvisorySession(AMQSession amqSession) {
-      this.advisorySession = amqSession;
-   }
-
-   public AMQSession getAdvisorySession() {
-      return this.advisorySession;
-   }
-
-   public AMQConnectionContext getContext() {
-      return this.context;
-   }
-
-   public void updateClient(ConnectionControl control) throws Exception {
-      if (protocolManager.isUpdateClusterClients()) {
-         dispatchAsync(control);
+   public void addConsumerBrokerExchange(ConsumerId id,
+                                         AMQSession amqSession,
+                                         Map<ActiveMQDestination, AMQConsumer> consumerMap) {
+      AMQConsumerBrokerExchange result = consumerExchanges.get(id);
+      if (result == null) {
+         if (consumerMap.size() == 1) {
+            result = new AMQSingleConsumerBrokerExchange(amqSession, consumerMap.values().iterator().next());
+         }
+         else {
+            result = new AMQCompositeConsumerBrokerExchange(amqSession, consumerMap);
+         }
+         synchronized (consumerExchanges) {
+            result.setConnectionContext(context);
+            SessionState ss = state.getSessionState(id.getParentId());
+            if (ss != null) {
+               ConsumerState cs = ss.getConsumerState(id);
+               if (cs != null) {
+                  ConsumerInfo info = cs.getInfo();
+                  if (info != null) {
+                     if (info.getDestination() != null && info.getDestination().isPattern()) {
+                        result.setWildcard(true);
+                     }
+                  }
+               }
+            }
+            consumerExchanges.put(id, result);
+         }
       }
    }
 
-   public AMQConnectionContext initContext(ConnectionInfo info) {
-      WireFormatInfo wireFormatInfo = wireFormat.getPreferedWireFormatInfo();
-      // Older clients should have been defaulting this field to true.. but
-      // they were not.
-      if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
-         info.setClientMaster(true);
-      }
-
-      state = new ConnectionState(info);
-
-      context = new AMQConnectionContext();
-
-      state.reset(info);
-
-      // Setup the context.
-      String clientId = info.getClientId();
-      context.setBroker(protocolManager);
-      context.setClientId(clientId);
-      context.setClientMaster(info.isClientMaster());
-      context.setConnection(this);
-      context.setConnectionId(info.getConnectionId());
-      // for now we pass the manager as the connector and see what happens
-      // it should be related to activemq's Acceptor
-      context.setFaultTolerant(info.isFaultTolerant());
-      context.setUserName(info.getUserName());
-      context.setWireFormatInfo(wireFormatInfo);
-      context.setReconnect(info.isFailoverReconnect());
-      context.setConnectionState(state);
-      if (info.getClientIp() == null) {
-         info.setClientIp(getRemoteAddress());
+   public int getConsumerCount() {
+      int result = 0;
+      for (SessionId sessionId : state.getSessionIds()) {
+         SessionState sessionState = state.getSessionState(sessionId);
+         if (sessionState != null) {
+            result += sessionState.getConsumerIds().size();
+         }
       }
-
-      return context;
+      return result;
    }
 
-   //raise the refCount of context
-   public void reconnect(AMQConnectionContext existingContext, ConnectionInfo info) {
-      this.context = existingContext;
-      WireFormatInfo wireFormatInfo = wireFormat.getPreferedWireFormatInfo();
-      // Older clients should have been defaulting this field to true.. but
-      // they were not.
-      if (wireFormatInfo != null && wireFormatInfo.getVersion() <= 2) {
-         info.setClientMaster(true);
-      }
-      if (info.getClientIp() == null) {
-         info.setClientIp(getRemoteAddress());
+   public int getProducerCount() {
+      int result = 0;
+      for (SessionId sessionId : state.getSessionIds()) {
+         SessionState sessionState = state.getSessionState(sessionId);
+         if (sessionState != null) {
+            result += sessionState.getProducerIds().size();
+         }
       }
-
-      state = new ConnectionState(info);
-      state.reset(info);
-
-      context.setConnection(this);
-      context.setConnectionState(state);
-      context.setClientMaster(info.isClientMaster());
-      context.setFaultTolerant(info.isFaultTolerant());
-      context.setReconnect(true);
-      context.incRefCount();
+      return result;
    }
 
-   /**
-    * This will answer with commands to the client
-    */
-   public boolean sendCommand(final Command command) {
-      if (ActiveMQServerLogger.LOGGER.isTraceEnabled()) {
-         ActiveMQServerLogger.LOGGER.trace("sending " + command);
+   @Override
+   public Response processAddDestination(DestinationInfo dest) throws Exception {
+      Response resp = null;
+      try {
+         protocolManager.addDestination(this, dest);
       }
-
-      if (isDestroyed()) {
-         return false;
+      catch (Exception e) {
+         if (e instanceof ActiveMQSecurityException) {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+         }
+         else {
+            resp = new ExceptionResponse(e);
+         }
       }
+      return resp;
+   }
 
+   @Override
+   public Response processAddProducer(ProducerInfo info) throws Exception {
+      Response resp = null;
       try {
-         physicalSend(command);
+         protocolManager.addProducer(this, info);
       }
       catch (Exception e) {
-         return false;
-      }
-      catch (Throwable t) {
-         return false;
+         if (e instanceof ActiveMQSecurityException) {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
+         }
+         else if (e instanceof ActiveMQNonExistentQueueException) {
+            resp = new ExceptionResponse(new InvalidDestinationException(e.getMessage()));
+         }
+         else {
+            resp = new ExceptionResponse(e);
+         }
       }
-      return true;
+      return resp;
    }
 
-   public void addDestination(DestinationInfo info) throws Exception {
-      ActiveMQDestination dest = info.getDestination();
-      if (dest.isQueue()) {
-         SimpleString qName = OpenWireUtil.toCoreAddress(dest);
-         QueueBinding binding = (QueueBinding) protocolManager.getServer().getPostOffice().getBinding(qName);
-         if (binding == null) {
-            if (getState().getInfo() != null) {
-
-               CheckType checkType = dest.isTemporary() ? CheckType.CREATE_NON_DURABLE_QUEUE : CheckType.CREATE_DURABLE_QUEUE;
-               protocolManager.getServer().getSecurityStore().check(qName, checkType, this);
-
-               protocolManager.getServer().checkQueueCreationLimit(getUsername());
-            }
-            ConnectionInfo connInfo = getState().getInfo();
-            protocolManager.getServer().createQueue(qName, qName, null, connInfo == null ? null : SimpleString.toSimpleString(connInfo.getUserName()), false, dest.isTemporary());
+   @Override
+   public Response processAddSession(SessionInfo info) throws Exception {
+      // Avoid replaying dup commands
+      if (!state.getSessionIds().contains(info.getSessionId())) {
+         protocolManager.addSession(this, info);
+         try {
+            state.addSession(info);
          }
-
-         if (dest.isTemporary()) {
-            registerTempQueue(dest);
+         catch (IllegalStateException e) {
+            e.printStackTrace();
+            protocolManager.removeSession(context, info);
          }
       }
+      return null;
+   }
 
-      if (!AdvisorySupport.isAdvisoryTopic(dest)) {
-         AMQConnectionContext context = getContext();
-         DestinationInfo advInfo = new DestinationInfo(context.getConnectionId(), DestinationInfo.ADD_OPERATION_TYPE, dest);
+   @Override
+   public Response processBeginTransaction(TransactionInfo info) throws Exception {
+      TransactionId txId = info.getTransactionId();
 
-         ActiveMQTopic topic = AdvisorySupport.getDestinationAdvisoryTopic(dest);
-         protocolManager.fireAdvisory(context, topic, advInfo);
+      if (!txMap.containsKey(txId)) {
+         txMap.put(txId, info);
       }
+      return null;
    }
 
-
-   public void updateConsumer(ConsumerControl consumerControl) {
-      SessionId sessionId = consumerControl.getConsumerId().getParentId();
-      AMQSession amqSession = sessions.get(sessionId);
-      amqSession.updateConsumerPrefetchSize(consumerControl.getConsumerId(), consumerControl.getPrefetch());
+   @Override
+   public Response processBrokerInfo(BrokerInfo arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
    }
 
-   public void addConsumer(ConsumerInfo info) throws Exception {
-      // Todo: add a destination interceptors holder here (amq supports this)
-      SessionId sessionId = info.getConsumerId().getParentId();
-      ConnectionId connectionId = sessionId.getParentId();
-      ConnectionState cs = getState();
-      if (cs == null) {
-         throw new IllegalStateException("Cannot add a consumer to a connection that had not been registered: " + connectionId);
-      }
-      SessionState ss = cs.getSessionState(sessionId);
-      if (ss == null) {
-         throw new IllegalStateException(protocolManager.getServer() + " Cannot add a consumer to a session that had not been registered: " + sessionId);
-      }
-      // Avoid replaying dup commands
-      if (!ss.getConsumerIds().contains(info.getConsumerId())) {
-
-         AMQSession amqSession = sessions.get(sessionId);
-         if (amqSession == null) {
-            throw new IllegalStateException("Session not exist! : " + sessionId);
-         }
-
-         List<AMQConsumer> consumersList = amqSession.createConsumer(info, amqSession, new SlowConsumerDetection());
+   @Override
+   public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
+      protocolManager.commitTransactionOnePhase(info);
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
 
-         this.addConsumerBrokerExchange(info.getConsumerId(), amqSession, consumersList);
-         ss.addConsumer(info);
-         amqSession.start();
-      }
+      return null;
    }
 
-   class SlowConsumerDetection implements SlowConsumerDetectionListener {
+   @Override
+   public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
+      protocolManager.commitTransactionTwoPhase(info);
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
 
-      @Override
-      public void onSlowConsumer(ServerConsumer consumer) {
-         if (consumer instanceof AMQServerConsumer) {
-            AMQServerConsumer serverConsumer = (AMQServerConsumer)consumer;
-            ActiveMQTopic topic = AdvisorySupport.getSlowConsumerAdvisoryTopic(serverConsumer.getAmqConsumer().getOpenwireDestination());
-            ActiveMQMessage advisoryMessage = new ActiveMQMessage();
-            try {
-               advisoryMessage.setStringProperty(AdvisorySupport.MSG_PROPERTY_CONSUMER_ID, serverConsumer.getAmqConsumer().getId().toString());
-               protocolManager.fireAdvisory(context, topic, advisoryMessage, serverConsumer.getAmqConsumer().getId());
-            }
-            catch (Exception e) {
-               // TODO-NOW: LOGGING
-               e.printStackTrace();
-            }
-         }
-      }
+      return null;
    }
 
-   public void addSessions(Set<SessionId> sessionSet) {
-      Iterator<SessionId> iter = sessionSet.iterator();
-      while (iter.hasNext()) {
-         SessionId sid = iter.next();
-         addSession(getState().getSessionState(sid).getInfo(), true);
-      }
+   @Override
+   public Response processConnectionControl(ConnectionControl arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
    }
 
-   public AMQSession addSession(SessionInfo ss) {
-      return addSession(ss, false);
+   @Override
+   public Response processConnectionError(ConnectionError arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
    }
 
-   public AMQSession addSession(SessionInfo ss, boolean internal) {
-      AMQSession amqSession = new AMQSession(getState().getInfo(), ss, protocolManager.getServer(), this, protocolManager.getScheduledPool(), protocolManager);
-      amqSession.initialize();
-      amqSession.setInternal(internal);
-      sessions.put(ss.getSessionId(), amqSession);
-      sessionIdMap.put(amqSession.getCoreSession().getName(), ss.getSessionId());
-      return amqSession;
+   @Override
+   public Response processConsumerControl(ConsumerControl arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
    }
 
-   public void removeSession(AMQConnectionContext context, SessionInfo info) throws Exception {
-      AMQSession session = sessions.remove(info.getSessionId());
-      if (session != null) {
-         session.close();
-      }
+   @Override
+   public Response processControlCommand(ControlCommand arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
    }
 
-   public AMQSession getSession(SessionId sessionId) {
-      return sessions.get(sessionId);
-   }
+   @Override
+   public Response processEndTransaction(TransactionInfo info) throws Exception {
+      protocolManager.endTransaction(info);
+      TransactionId txId = info.getTransactionId();
 
-   public void removeDestination(ActiveMQDestination dest) throws Exception {
-      if (dest.isQueue()) {
-         SimpleString qName = new SimpleString("jms.queue." + dest.getPhysicalName());
-         protocolManager.getServer().destroyQueue(qName);
+      if (!txMap.containsKey(txId)) {
+         txMap.put(txId, info);
       }
-      else {
-         Bindings bindings = protocolManager.getServer().getPostOffice().getBindingsForAddress(SimpleString.toSimpleString("jms.topic." + dest.getPhysicalName()));
-         Iterator<Binding> iterator = bindings.getBindings().iterator();
+      return null;
+   }
 
-         while (iterator.hasNext()) {
-            Queue b = (Queue) iterator.next().getBindable();
-            if (b.getConsumerCount() > 0) {
-               throw new Exception("Destination still has an active subscription: " + dest.getPhysicalName());
-            }
-            if (b.isDurable()) {
-               throw new Exception("Destination still has durable subscription: " + dest.getPhysicalName());
-            }
-            b.deleteQueue();
-         }
-      }
+   @Override
+   public Response processFlush(FlushCommand arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      if (!AdvisorySupport.isAdvisoryTopic(dest)) {
-         AMQConnectionContext context = getContext();
-         DestinationInfo advInfo = new DestinationInfo(context.getConnectionId(), DestinationInfo.REMOVE_OPERATION_TYPE, dest);
+   @Override
+   public Response processForgetTransaction(TransactionInfo info) throws Exception {
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
 
-         ActiveMQTopic topic = AdvisorySupport.getDestinationAdvisoryTopic(dest);
-         protocolManager.fireAdvisory(context, topic, advInfo);
-      }
+      protocolManager.forgetTransaction(info.getTransactionId());
+      return null;
    }
 
-   /**
-    * Checks to see if this destination exists.  If it does not throw an invalid destination exception.
-    *
-    * @param destination
-    */
-   private void validateDestination(ActiveMQDestination destination) throws Exception {
-      if (destination.isQueue()) {
-         SimpleString physicalName = OpenWireUtil.toCoreAddress(destination);
-         BindingQueryResult result = protocolManager.getServer().bindingQuery(physicalName);
-         if (!result.isExists() && !result.isAutoCreateJmsQueues()) {
-            throw ActiveMQMessageBundle.BUNDLE.noSuchQueue(physicalName);
-         }
-      }
+   @Override
+   public Response processKeepAlive(KeepAliveInfo arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
    }
 
+   @Override
+   public Response processMessage(Message messageSend) {
+      Response resp = null;
+      try {
+         ProducerId producerId = messageSend.getProducerId();
+         AMQProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
+         final AMQConnectionContext pcontext = producerExchange.getConnectionContext();
+         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
+         boolean sendProducerAck = !messageSend.isResponseRequired() && producerInfo.getWindowSize() > 0 && !pcontext.isInRecoveryMode();
 
-   CommandProcessor commandProcessorInstance = new CommandProcessor();
-
-
-   // This will listen for commands throught the protocolmanager
-   public class CommandProcessor implements CommandVisitor {
+         AMQSession session = protocolManager.getSession(producerId.getParentId());
 
-      public AMQConnectionContext getContext() {
-         return OpenWireConnection.this.getContext();
-      }
+         if (producerExchange.canDispatch(messageSend)) {
+            SendingResult result = session.send(producerExchange, messageSend, sendProducerAck);
+            if (result.isBlockNextSend()) {
+               if (!context.isNetworkConnection() && result.isSendFailIfNoSpace()) {
+                  throw new ResourceAllocationException("Usage Manager Memory Limit reached. Stopping producer (" + producerId + ") to prevent flooding " + result.getBlockingAddress() + "." + " See http://activemq.apache.org/producer-flow-control.html for more info");
+               }
 
-      @Override
-      public Response processAddConnection(ConnectionInfo info) throws Exception {
-         try {
-            protocolManager.addConnection(OpenWireConnection.this, info);
-         }
-         catch (Exception e) {
-            Response resp = new ExceptionResponse(e);
-            return resp;
-         }
-         if (info.isManageable() && protocolManager.isUpdateClusterClients()) {
-            // send ConnectionCommand
-            ConnectionControl command = protocolManager.newConnectionControl();
-            command.setFaultTolerant(protocolManager.isFaultTolerantConfiguration());
-            if (info.isFailoverReconnect()) {
-               command.setRebalanceConnection(false);
+               if (producerInfo.getWindowSize() > 0 || messageSend.isResponseRequired()) {
+                  //in that case don't send the response
+                  //this will force the client to wait until
+                  //the response is got.
+                  context.setDontSendReponse(true);
+               }
+               else {
+                  //hang the connection until the space is available
+                  session.blockingWaitForSpace(producerExchange, result);
+               }
+            }
+            else if (sendProducerAck) {
+               ProducerAck ack = new ProducerAck(producerInfo.getProducerId(), messageSend.getSize());
+               this.dispatchAsync(ack);
             }
-            dispatchAsync(command);
          }
-         return null;
-
       }
-
-      @Override
-      public Response processAddProducer(ProducerInfo info) throws Exception {
-         SessionId sessionId = info.getProducerId().getParentId();
-         ConnectionState cs = getState();
-
-         if (cs == null) {
-            throw new IllegalStateException("Cannot add a producer to a connection that had not been registered: " + sessionId.getParentId());
+      catch (Exception e) {
+         if (e instanceof ActiveMQSecurityException) {
+            resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
          }
-
-         SessionState ss = cs.getSessionState(sessionId);
-         if (ss == null) {
-            throw new IllegalStateException("Cannot add a producer to a session that had not been registered: " + sessionId);
+         else {
+            resp = new ExceptionResponse(e);
          }
+      }
+      return resp;
+   }
 
-         // Avoid replaying dup commands
-         if (!ss.getProducerIds().contains(info.getProducerId())) {
-            ActiveMQDestination destination = info.getDestination();
-
-            if (destination != null && !AdvisorySupport.isAdvisoryTopic(destination)) {
-               if (destination.isQueue()) {
-                  OpenWireConnection.this.validateDestination(destination);
+   private AMQProducerBrokerExchange getProducerBrokerExchange(ProducerId id) throws IOException {
+      AMQProducerBrokerExchange result = producerExchanges.get(id);
+      if (result == null) {
+         synchronized (producerExchanges) {
+            result = new AMQProducerBrokerExchange();
+            result.setConnectionContext(context);
+            //todo implement reconnect https://issues.apache.org/jira/browse/ARTEMIS-194
+            if (context.isReconnect() || (context.isNetworkConnection() && this.acceptorUsed.isAuditNetworkProducers())) {
+               if (protocolManager.getPersistenceAdapter() != null) {
+                  result.setLastStoredSequenceId(protocolManager.getPersistenceAdapter().getLastProducerSequenceId(id));
                }
-               DestinationInfo destInfo = new DestinationInfo(getContext().getConnectionId(), DestinationInfo.ADD_OPERATION_TYPE, destination);
-               OpenWireConnection.this.addDestination(destInfo);
             }
-
-            ss.addProducer(info);
-
+            SessionState ss = state.getSessionState(id.getParentId());
+            if (ss != null) {
+               result.setProducerState(ss.getProducerState(id));
+               ProducerState producerState = ss.getProducerState(id);
+               if (producerState != null && producerState.getInfo() != null) {
+                  ProducerInfo info = producerState.getInfo();
+                  result.setMutable(info.getDestination() == null || info.getDestination().isComposite());
+               }
+            }
+            producerExchanges.put(id, result);
          }
-         return null;
-      }
-
-      @Override
-      public Response processAddConsumer(ConsumerInfo info) throws Exception {
-         addConsumer(info);
-         return null;
-      }
-
-      @Override
-      public Response processRemoveDestination(DestinationInfo info) throws Exception {
-         ActiveMQDestination dest = info.getDestination();
-         removeDestination(dest);
-         return null;
       }
+      return result;
+   }
 
-      @Override
-      public Response processRemoveProducer(ProducerId id) throws Exception {
+   @Override
+   public Response processMessageAck(MessageAck ack) throws Exception {
+      AMQConsumerBrokerExchange consumerBrokerExchange = consumerExchanges.get(ack.getConsumerId());
+      consumerBrokerExchange.acknowledge(ack);
+      return null;
+   }
 
-         // TODO-now: proper implement this method
-         return null;
-      }
+   @Override
+   public Response processMessageDispatch(MessageDispatch arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      @Override
-      public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) throws Exception {
-         SessionState session = state.getSessionState(id);
-         if (session == null) {
-            throw new IllegalStateException("Cannot remove session that had not been registered: " + id);
-         }
-         // Don't let new consumers or producers get added while we are closing
-         // this down.
-         session.shutdown();
-         // Cascade the connection stop producers.
-         // we don't stop consumer because in core
-         // closing the session will do the job
-         for (ProducerId producerId : session.getProducerIds()) {
-            try {
-               processRemoveProducer(producerId);
-            }
-            catch (Throwable e) {
-               // LOG.warn("Failed to remove producer: {}", producerId, e);
-            }
-         }
-         state.removeSession(id);
-         removeSession(context, session.getInfo());
-         return null;
-      }
+   @Override
+   public Response processMessageDispatchNotification(MessageDispatchNotification arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      @Override
-      public Response processRemoveSubscription(RemoveSubscriptionInfo subInfo) throws Exception {
-         protocolManager.removeSubscription(subInfo);
-         return null;
+   @Override
+   public Response processMessagePull(MessagePull arg0) throws Exception {
+      AMQConsumerBrokerExchange amqConsumerBrokerExchange = consumerExchanges.get(arg0.getConsumerId());
+      if (amqConsumerBrokerExchange == null) {
+         throw new IllegalStateException("Consumer does not exist");
       }
+      amqConsumerBrokerExchange.processMessagePull(arg0);
+      return null;
+   }
 
-      @Override
-      public Response processRollbackTransaction(TransactionInfo info) throws Exception {
-         protocolManager.rollbackTransaction(info);
-         TransactionId txId = info.getTransactionId();
-         txMap.remove(txId);
-         return null;
-      }
+   @Override
+   public Response processPrepareTransaction(TransactionInfo info) throws Exception {
+      protocolManager.prepareTransaction(info);
+      return null;
+   }
 
-      @Override
-      public Response processShutdown(ShutdownInfo info) throws Exception {
-         OpenWireConnection.this.shutdown(false);
-         return null;
-      }
+   @Override
+   public Response processProducerAck(ProducerAck arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      @Override
-      public Response processWireFormat(WireFormatInfo command) throws Exception {
-         wireFormat.renegotiateWireFormat(command);
-         //throw back a brokerInfo here
-         protocolManager.sendBrokerInfo(OpenWireConnection.this);
-         return null;
-      }
+   @Override
+   public Response processRecoverTransactions(TransactionInfo info) throws Exception {
+      Set<SessionId> sIds = state.getSessionIds();
+      TransactionId[] recovered = protocolManager.recoverTransactions(sIds);
+      return new DataArrayResponse(recovered);
+   }
 
-      @Override
-      public Response processAddDestination(DestinationInfo dest) throws Exception {
-         Response resp = null;
+   @Override
+   public Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws Exception {
+      // Don't allow things to be added to the connection state while we
+      // are shutting down.
+      state.shutdown();
+      // Cascade the connection stop to the sessions.
+      for (SessionId sessionId : state.getSessionIds()) {
          try {
-            addDestination(dest);
+            processRemoveSession(sessionId, lastDeliveredSequenceId);
          }
-         catch (Exception e) {
-            if (e instanceof ActiveMQSecurityException) {
-               resp = new ExceptionResponse(new JMSSecurityException(e.getMessage()));
-            }
-            else {
-               resp = new ExceptionResponse(e);
-            }
+         catch (Throwable e) {
+            // LOG
          }
-         return resp;
       }
 
-      @Override
-      public Response processAddSession(SessionInfo info) throws Exception {
-         // Avoid replaying dup commands
-         if (!state.getSessionIds().contains(info.getSessionId())) {
-            addSession(info);
-            state.addSession(info);
-         }
-         return null;
+      try {
+         protocolManager.removeConnection(context, state.getInfo(), null);
       }
-
-      @Override
-      public Response processBeginTransaction(TransactionInfo info) throws Exception {
-         TransactionId txId = info.getTransactionId();
-
-         if (!txMap.containsKey(txId)) {
-            txMap.put(txId, info);
-         }
-         return null;
+      catch (Throwable e) {
+         // log
       }
+      return null;
+   }
 
-      @Override
-      public Response processBrokerInfo(BrokerInfo arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
+   @Override
+   public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {
+      SessionId sessionId = id.getParentId();
+      SessionState ss = state.getSessionState(sessionId);
+      if (ss == null) {
+         throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: " + sessionId);
       }
+      ConsumerState consumerState = ss.removeConsumer(id);
+      if (consumerState == null) {
+         throw new IllegalStateException("Cannot remove a consumer that had not been registered: " + id);
+      }
+      ConsumerInfo info = consumerState.getInfo();
+      info.setLastDeliveredSequenceId(lastDeliveredSequenceId);
 
-      @Override
-      public Response processCommitTransactionOnePhase(TransactionInfo info) throws Exception {
-         try {
-            protocolManager.commitTransactionOnePhase(info);
-            TransactionId txId = info.getTransactionId();
-            txMap.remove(txId);
-         }
-         catch (Exception e) {
-            e.printStackTrace();
-            throw e;
-         }
+      AMQConsumerBrokerExchange consumerBrokerExchange = consumerExchanges.get(id);
 
-         return null;
-      }
+      consumerBrokerExchange.removeConsumer();
 
-      @Override
-      public Response processCommitTransactionTwoPhase(TransactionInfo info) throws Exception {
-         protocolManager.commitTransactionTwoPhase(info);
-         TransactionId txId = info.getTransactionId();
-         txMap.remove(txId);
+      removeConsumerBrokerExchange(id);
 
-         return null;
-      }
+      return null;
+   }
 
-      @Override
-      public Response processConnectionControl(ConnectionControl connectionControl) throws Exception {
-         //activemq5 keeps a var to remember only the faultTolerant flag
-         //this can be sent over a reconnected transport as the first command
-         //before restoring the connection.
-         return null;
+   private void removeConsumerBrokerExchange(ConsumerId id) {
+      synchronized (consumerExchanges) {
+         consumerExchanges.remove(id);
       }
+   }
 
-      @Override
-      public Response processConnectionError(ConnectionError arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
+   @Override
+   public Response processRemoveDestination(DestinationInfo info) throws Exception {
+      ActiveMQDestination dest = info.getDestination();
+      if (dest.isQueue()) {
+         String qName = "jms.queue." + dest.getPhysicalName();
+         protocolManager.deleteQueue(qName);
       }
+      return null;
+   }
 
-      @Override
-      public Response processConsumerControl(ConsumerControl consumerControl) throws Exception {
-         //amq5 clients send this command to restore prefetchSize
-         //after successful reconnect
+   @Override
+   public Response processRemoveProducer(ProducerId id) throws Exception {
+      protocolManager.removeProducer(id);
+      return null;
+   }
+
+   @Override
+   public Response processRemoveSession(SessionId id, long lastDeliveredSequenceId) throws Exception {
+      SessionState session = state.getSessionState(id);
+      if (session == null) {
+         throw new IllegalStateException("Cannot remove session that had not been registered: " + id);
+      }
+      // Don't let new consumers or producers get added while we are closing
+      // this down.
+      session.shutdown();
+      // Cascade the connection stop to the consumers and producers.
+      for (ConsumerId consumerId : session.getConsumerIds()) {
          try {
-            updateConsumer(consumerControl);
+            processRemoveConsumer(consumerId, lastDeliveredSequenceId);
          }
-         catch (Exception e) {
-            //log error
+         catch (Throwable e) {
+            // LOG.warn("Failed to remove consumer: {}", consumerId, e);
          }
-         return null;
-      }
-
-      @Override
-      public Response processControlCommand(ControlCommand arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
       }
-
-      @Override
-      public Response processEndTransaction(TransactionInfo info) throws Exception {
-         protocolManager.endTransaction(info);
-         TransactionId txId = info.getTransactionId();
-
-         if (!txMap.containsKey(txId)) {
-            txMap.put(txId, info);
+      for (ProducerId producerId : session.getProducerIds()) {
+         try {
+            processRemoveProducer(producerId);
+         }
+         catch (Throwable e) {
+            // LOG.warn("Failed to remove producer: {}", producerId, e);
          }
-         return null;
-      }
-
-      @Override
-      public Response processFlush(FlushCommand arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
-      }
-
-      @Override
-      public Response processForgetTransaction(TransactionInfo info) throws Exception {
-         TransactionId txId = info.getTransactionId();
-         txMap.remove(txId);
-
-         protocolManager.forgetTransaction(info.getTransactionId());
-         return null;
-      }
-
-      @Override
-      public Response processKeepAlive(KeepAliveInfo arg0) throws Exception {
-         throw new IllegalStateException("not implemented! ");
-      }
-
-      @Override
-      public Response processMessage(Message messageSend) throws Exception {
-         ProducerId producerId = messageSend.getProducerId();
-         AMQProducerBrokerExchange producerExchange = getProducerBrokerExchange(producerId);
-         final AMQConnectionContext pcontext = producerExchange.getConnectionContext();
-         final ProducerInfo producerInfo = producerExchange.getProducerState().getInfo();
-         boolean sendProducerAck = !messageSend.isResponseRequired() && producerInfo.getWindowSize() > 0 && !pcontext.isInRecoveryMode();
-
-         AMQSession session = getSession(producerId.getParentId());
-
-         session.send(producerInfo, messageSend, sendProducerAck);
-         return null;
       }
+      state.removeSession(id);
+      protocolManager.removeSession(context, session.getInfo());
+      return null;
+   }
 
+   @Override
+   public Response processRemoveSubscription(RemoveSubscriptionInfo subInfo) throws Exception {
+      protocolManager.removeSubscription(subInfo);
+      return null;
+   }
 
-      @Override
-      public Response processMessageAck(MessageAck ack) throws Exception {
-         AMQConsumerBrokerExchange consumerBrokerExchange = consumerExchanges.get(ack.getConsumerId());
-         consumerBrokerExchange.acknowledge(ack);
-         return null;
-      }
+   @Override
+   public Response processRollbackTransaction(TransactionInfo info) throws Exception {
+      protocolManager.rollbackTransaction(info);
+      TransactionId txId = info.getTransactionId();
+      txMap.remove(txId);
+      return null;
+   }
 
-      @Override
-      public Response processMessageDispatch(MessageDispatch arg0) throws Exception {
-         return null;
-      }
+   @Override
+   public Response processShutdown(ShutdownInfo info) throws Exception {
+      return null;
+   }
 
-      @Override
-      public Response processMessageDispatchNotification(MessageDispatchNotification arg0) throws Exception {
-         return null;
-      }
+   @Override
+   public Response processWireFormat(WireFormatInfo arg0) throws Exception {
+      throw new IllegalStateException("not implemented! ");
+   }
 
-      @Override
-      public Response processMessagePull(MessagePull arg0) throws Exception {
-         AMQConsumerBrokerExchange amqConsumerBrokerExchange = consumerExchanges.get(arg0.getConsumerId());
-         if (amqConsumerBrokerExchange == null) {
-            throw new IllegalStateException("Consumer does not exist");
-         }
-         amqConsumerBrokerExchange.processMessagePull(arg0);
-         return null;
-      }
+   public int getMaximumConsumersAllowedPerConnection() {
+      return this.acceptorUsed.getMaximumConsumersAllowedPerConnection();
+   }
 
-      @Override
-      public Response processPrepareTransaction(TransactionInfo info) throws Exception {
-         protocolManager.prepareTransaction(info);
-         //activemq needs a rdonly response
-         return new IntegerResponse(XAResource.XA_RDONLY);
-      }
+   public int getMaximumProducersAllowedPerConnection() {
+      return this.acceptorUsed.getMaximumProducersAllowedPerConnection();
+   }
 
-      @Override
-      public Response processProducerAck(ProducerAck arg0) throws Exception {
-         // a broker doesn't do producers.. this shouldn't happen
-         return null;
+   public void deliverMessage(MessageDispatch dispatch) {
+      Message m = dispatch.getMessage();
+      if (m != null) {
+         long endTime = System.currentTimeMillis();
+         m.setBrokerOutTime(endTime);
       }
 
-      @Override
-      public Response processRecoverTransactions(TransactionInfo info) throws Exception {
-         Set<SessionId> sIds = state.getSessionIds();
-
-
-         List<TransactionId> recovered = new ArrayList<>();
-         if (sIds != null) {
-            for (SessionId sid : sIds) {
-               AMQSession s = sessions.get(sid);
-               if (s != null) {
-                  s.recover(recovered);
-               }
-            }
-         }
-
-         return new DataArrayResponse(recovered.toArray(new TransactionId[0]));
-      }
+      protocolManager.send(this, dispatch);
+   }
 
-      @Override
-      public Response processRemoveConnection(ConnectionId id, long lastDeliveredSequenceId) throws Exception {
-         //we let protocol manager to handle connection add/remove
-         try {
-            protocolManager.removeConnection(state.getInfo(), null);
-         }
-         catch (Throwable e) {
-            // log
-         }
-         return null;
-      }
+   public WireFormat getMarshaller() {
+      return this.wireFormat;
+   }
 
-      @Override
-      public Response processRemoveConsumer(ConsumerId id, long lastDeliveredSequenceId) throws Exception {
-         SessionId sessionId = id.getParentId();
-         SessionState ss = state.getSessionState(sessionId);
-         if (ss == null) {
-            throw new IllegalStateException("Cannot remove a consumer from a session that had not been registered: " + sessionId);
-         }
-         ConsumerState consumerState = ss.removeConsumer(id);
-         if (consumerState == null) {
-            throw new IllegalStateException("Cannot remove a consumer that had not been registered: " + id);
-         }
-         ConsumerInfo info = consumerState.getInfo();
-         info.setLastDeliveredSequenceId(lastDeliveredSequenceId);
+   public void registerTempQueue(SimpleString qName) {
+      tempQueues.add(qName.toString());
+   }
 
-         AMQConsumerBrokerExchange consumerBrokerExchange = consumerExchanges.get(id);
+   @Override
+   public void disconnect(String reason, boolean fail) {
+      destroy();
+   }
 
-         consumerBrokerExchange.removeConsumer();
+   @Override
+   public void fail(ActiveMQException e, String message) {
+      destroy();
+   }
 
-         removeConsumerBrokerExchange(id);
+   public void setAdvisorySession(AMQSession amqSession) {
+      this.advisorySession = amqSession;
+   }
 
-         return null;
-      }
+   public AMQSession getAdvisorySession() {
+      return this.advisorySession;
+   }
 
+   public AMQConnectionContext getConext() {
+      return this.context;
    }
 
 }