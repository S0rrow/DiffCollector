diff --git a/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnector.java b/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnector.java
index b856421681..49c936bfd3 100644
--- a/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnector.java
+++ b/artemis-core-client/src/main/java/org/apache/activemq/artemis/core/remoting/impl/netty/NettyConnector.java
@@ -16,6 +16,9 @@
  */
 package org.apache.activemq.artemis.core.remoting.impl.netty;
 
+import javax.net.ssl.SSLContext;
+import javax.net.ssl.SSLEngine;
+import javax.net.ssl.SSLParameters;
 import java.io.IOException;
 import java.net.ConnectException;
 import java.net.Inet6Address;
@@ -26,12 +29,14 @@ import java.net.URI;
 import java.net.URISyntaxException;
 import java.net.UnknownHostException;
 import java.nio.charset.StandardCharsets;
+import java.security.AccessController;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.security.PrivilegedAction;
 import java.util.Collections;
 import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
+import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CountDownLatch;
@@ -40,10 +45,6 @@ import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.TimeUnit;
 
-import javax.net.ssl.SSLContext;
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLParameters;
-
 import io.netty.bootstrap.Bootstrap;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
@@ -57,20 +58,19 @@ import io.netty.channel.ChannelPipeline;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.SimpleChannelInboundHandler;
-import io.netty.channel.WriteBufferWaterMark;
-import io.netty.channel.epoll.EpollEventLoopGroup;
-import io.netty.channel.epoll.EpollSocketChannel;
 import io.netty.channel.group.ChannelGroup;
 import io.netty.channel.group.DefaultChannelGroup;
 import io.netty.channel.nio.NioEventLoopGroup;
 import io.netty.channel.socket.nio.NioSocketChannel;
 import io.netty.handler.codec.base64.Base64;
+import io.netty.handler.codec.http.Cookie;
+import io.netty.handler.codec.http.CookieDecoder;
 import io.netty.handler.codec.http.DefaultFullHttpRequest;
 import io.netty.handler.codec.http.DefaultHttpRequest;
 import io.netty.handler.codec.http.FullHttpRequest;
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpClientCodec;
-import io.netty.handler.codec.http.HttpHeaderNames;
+import io.netty.handler.codec.http.HttpHeaders;
 import io.netty.handler.codec.http.HttpMethod;
 import io.netty.handler.codec.http.HttpObject;
 import io.netty.handler.codec.http.HttpObjectAggregator;
@@ -80,20 +80,17 @@ import io.netty.handler.codec.http.HttpResponse;
 import io.netty.handler.codec.http.HttpResponseDecoder;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpVersion;
-import io.netty.handler.codec.http.LastHttpContent;
-import io.netty.handler.codec.http.cookie.ClientCookieDecoder;
-import io.netty.handler.codec.http.cookie.Cookie;
+import io.netty.handler.codec.http.cookie.ClientCookieEncoder;
 import io.netty.handler.ssl.SslHandler;
 import io.netty.util.AttributeKey;
 import io.netty.util.ResourceLeakDetector;
-import io.netty.util.ResourceLeakDetector.Level;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GlobalEventExecutor;
-
-import org.apache.activemq.artemis.api.config.ActiveMQDefaultConfiguration;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
+import org.apache.activemq.artemis.api.config.ActiveMQDefaultConfiguration;
 import org.apache.activemq.artemis.core.client.ActiveMQClientLogger;
 import org.apache.activemq.artemis.core.client.ActiveMQClientMessageBundle;
+import org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryImpl;
 import org.apache.activemq.artemis.core.protocol.core.impl.ActiveMQClientProtocolManager;
 import org.apache.activemq.artemis.core.remoting.impl.ssl.SSLSupport;
 import org.apache.activemq.artemis.core.server.ActiveMQComponent;
@@ -105,13 +102,11 @@ import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;
 import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.artemis.utils.ConfigurationHelper;
 import org.apache.activemq.artemis.utils.FutureLatch;
-import org.apache.activemq.artemis.utils.IPV6Util;
 import org.jboss.logging.Logger;
 
 import static org.apache.activemq.artemis.utils.Base64.encodeBytes;
 
 public class NettyConnector extends AbstractConnector {
-
    private static final Logger logger = Logger.getLogger(NettyConnector.class);
 
    // Constants -----------------------------------------------------
@@ -141,7 +136,7 @@ public class NettyConnector extends AbstractConnector {
 
    static {
       // Disable resource leak detection for performance reasons by default
-      ResourceLeakDetector.setLevel(Level.DISABLED);
+      ResourceLeakDetector.setEnabled(false);
 
       // Set default Configuration
       Map<String, Object> config = new HashMap<>();
@@ -160,7 +155,7 @@ public class NettyConnector extends AbstractConnector {
 
    private final BufferHandler handler;
 
-   private final BaseConnectionLifeCycleListener<?> listener;
+   private final BaseConnectionLifeCycleListener listener;
 
    private boolean sslEnabled = TransportConstants.DEFAULT_SSL_ENABLED;
 
@@ -205,29 +200,21 @@ public class NettyConnector extends AbstractConnector {
 
    private boolean verifyHost;
 
-   private boolean useDefaultSslContext;
-
    private boolean tcpNoDelay;
 
    private int tcpSendBufferSize;
 
    private int tcpReceiveBufferSize;
 
-   private final int writeBufferLowWaterMark;
-
-   private final int writeBufferHighWaterMark;
-
    private long batchDelay;
 
    private ConcurrentMap<Object, Connection> connections = new ConcurrentHashMap<>();
 
    private String servletPath;
 
-   private boolean useEpoll;
+   private int nioRemotingThreads;
 
-   private int remotingThreads;
-
-   private boolean useGlobalWorkerPool;
+   private boolean useNioGlobalWorkerPool;
 
    private ScheduledExecutorService scheduledThreadPool;
 
@@ -250,7 +237,7 @@ public class NettyConnector extends AbstractConnector {
    // Public --------------------------------------------------------
    public NettyConnector(final Map<String, Object> configuration,
                          final BufferHandler handler,
-                         final BaseConnectionLifeCycleListener<?> listener,
+                         final BaseConnectionLifeCycleListener listener,
                          final Executor closeExecutor,
                          final Executor threadPool,
                          final ScheduledExecutorService scheduledThreadPool) {
@@ -259,7 +246,7 @@ public class NettyConnector extends AbstractConnector {
 
    public NettyConnector(final Map<String, Object> configuration,
                          final BufferHandler handler,
-                         final BaseConnectionLifeCycleListener<?> listener,
+                         final BaseConnectionLifeCycleListener listener,
                          final Executor closeExecutor,
                          final Executor threadPool,
                          final ScheduledExecutorService scheduledThreadPool,
@@ -287,7 +274,8 @@ public class NettyConnector extends AbstractConnector {
          httpMaxClientIdleTime = ConfigurationHelper.getLongProperty(TransportConstants.HTTP_CLIENT_IDLE_PROP_NAME, TransportConstants.DEFAULT_HTTP_CLIENT_IDLE_TIME, configuration);
          httpClientIdleScanPeriod = ConfigurationHelper.getLongProperty(TransportConstants.HTTP_CLIENT_IDLE_SCAN_PERIOD, TransportConstants.DEFAULT_HTTP_CLIENT_SCAN_PERIOD, configuration);
          httpRequiresSessionId = ConfigurationHelper.getBooleanProperty(TransportConstants.HTTP_REQUIRES_SESSION_ID, TransportConstants.DEFAULT_HTTP_REQUIRES_SESSION_ID, configuration);
-      } else {
+      }
+      else {
          httpMaxClientIdleTime = 0;
          httpClientIdleScanPeriod = -1;
          httpRequiresSessionId = false;
@@ -295,13 +283,9 @@ public class NettyConnector extends AbstractConnector {
 
       httpUpgradeEnabled = ConfigurationHelper.getBooleanProperty(TransportConstants.HTTP_UPGRADE_ENABLED_PROP_NAME, TransportConstants.DEFAULT_HTTP_UPGRADE_ENABLED, configuration);
 
-      remotingThreads = ConfigurationHelper.getIntProperty(TransportConstants.NIO_REMOTING_THREADS_PROPNAME, -1, configuration);
-      remotingThreads = ConfigurationHelper.getIntProperty(TransportConstants.REMOTING_THREADS_PROPNAME, remotingThreads, configuration);
-
-      useGlobalWorkerPool = ConfigurationHelper.getBooleanProperty(TransportConstants.USE_NIO_GLOBAL_WORKER_POOL_PROP_NAME, TransportConstants.DEFAULT_USE_GLOBAL_WORKER_POOL, configuration);
-      useGlobalWorkerPool = ConfigurationHelper.getBooleanProperty(TransportConstants.USE_GLOBAL_WORKER_POOL_PROP_NAME, useGlobalWorkerPool, configuration);
+      nioRemotingThreads = ConfigurationHelper.getIntProperty(TransportConstants.NIO_REMOTING_THREADS_PROPNAME, -1, configuration);
 
-      useEpoll = ConfigurationHelper.getBooleanProperty(TransportConstants.USE_EPOLL_PROP_NAME, TransportConstants.DEFAULT_USE_EPOLL, configuration);
+      useNioGlobalWorkerPool = ConfigurationHelper.getBooleanProperty(TransportConstants.USE_NIO_GLOBAL_WORKER_POOL_PROP_NAME, TransportConstants.DEFAULT_USE_NIO_GLOBAL_WORKER_POOL, configuration);
 
       useServlet = ConfigurationHelper.getBooleanProperty(TransportConstants.USE_SERVLET_PROP_NAME, TransportConstants.DEFAULT_USE_SERVLET, configuration);
       host = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, configuration);
@@ -314,22 +298,21 @@ public class NettyConnector extends AbstractConnector {
 
          keyStorePath = ConfigurationHelper.getStringProperty(TransportConstants.KEYSTORE_PATH_PROP_NAME, TransportConstants.DEFAULT_KEYSTORE_PATH, configuration);
 
-         keyStorePassword = ConfigurationHelper.getPasswordProperty(TransportConstants.KEYSTORE_PASSWORD_PROP_NAME, TransportConstants.DEFAULT_KEYSTORE_PASSWORD, configuration, ActiveMQDefaultConfiguration.getPropMaskPassword(), ActiveMQDefaultConfiguration.getPropPasswordCodec());
+         keyStorePassword = ConfigurationHelper.getPasswordProperty(TransportConstants.KEYSTORE_PASSWORD_PROP_NAME, TransportConstants.DEFAULT_KEYSTORE_PASSWORD, configuration, ActiveMQDefaultConfiguration.getPropMaskPassword(), ActiveMQDefaultConfiguration.getPropMaskPassword());
 
          trustStoreProvider = ConfigurationHelper.getStringProperty(TransportConstants.TRUSTSTORE_PROVIDER_PROP_NAME, TransportConstants.DEFAULT_TRUSTSTORE_PROVIDER, configuration);
 
          trustStorePath = ConfigurationHelper.getStringProperty(TransportConstants.TRUSTSTORE_PATH_PROP_NAME, TransportConstants.DEFAULT_TRUSTSTORE_PATH, configuration);
 
-         trustStorePassword = ConfigurationHelper.getPasswordProperty(TransportConstants.TRUSTSTORE_PASSWORD_PROP_NAME, TransportConstants.DEFAULT_TRUSTSTORE_PASSWORD, configuration, ActiveMQDefaultConfiguration.getPropMaskPassword(), ActiveMQDefaultConfiguration.getPropPasswordCodec());
+         trustStorePassword = ConfigurationHelper.getPasswordProperty(TransportConstants.TRUSTSTORE_PASSWORD_PROP_NAME, TransportConstants.DEFAULT_TRUSTSTORE_PASSWORD, configuration, ActiveMQDefaultConfiguration.getPropMaskPassword(), ActiveMQDefaultConfiguration.getPropMaskPassword());
 
          enabledCipherSuites = ConfigurationHelper.getStringProperty(TransportConstants.ENABLED_CIPHER_SUITES_PROP_NAME, TransportConstants.DEFAULT_ENABLED_CIPHER_SUITES, configuration);
 
          enabledProtocols = ConfigurationHelper.getStringProperty(TransportConstants.ENABLED_PROTOCOLS_PROP_NAME, TransportConstants.DEFAULT_ENABLED_PROTOCOLS, configuration);
 
          verifyHost = ConfigurationHelper.getBooleanProperty(TransportConstants.VERIFY_HOST_PROP_NAME, TransportConstants.DEFAULT_VERIFY_HOST, configuration);
-
-         useDefaultSslContext = ConfigurationHelper.getBooleanProperty(TransportConstants.USE_DEFAULT_SSL_CONTEXT_PROP_NAME, TransportConstants.DEFAULT_USE_DEFAULT_SSL_CONTEXT, configuration);
-      } else {
+      }
+      else {
          keyStoreProvider = TransportConstants.DEFAULT_KEYSTORE_PROVIDER;
          keyStorePath = TransportConstants.DEFAULT_KEYSTORE_PATH;
          keyStorePassword = TransportConstants.DEFAULT_KEYSTORE_PASSWORD;
@@ -339,14 +322,12 @@ public class NettyConnector extends AbstractConnector {
          enabledCipherSuites = TransportConstants.DEFAULT_ENABLED_CIPHER_SUITES;
          enabledProtocols = TransportConstants.DEFAULT_ENABLED_PROTOCOLS;
          verifyHost = TransportConstants.DEFAULT_VERIFY_HOST;
-         useDefaultSslContext = TransportConstants.DEFAULT_USE_DEFAULT_SSL_CONTEXT;
       }
 
       tcpNoDelay = ConfigurationHelper.getBooleanProperty(TransportConstants.TCP_NODELAY_PROPNAME, TransportConstants.DEFAULT_TCP_NODELAY, configuration);
       tcpSendBufferSize = ConfigurationHelper.getIntProperty(TransportConstants.TCP_SENDBUFFER_SIZE_PROPNAME, TransportConstants.DEFAULT_TCP_SENDBUFFER_SIZE, configuration);
       tcpReceiveBufferSize = ConfigurationHelper.getIntProperty(TransportConstants.TCP_RECEIVEBUFFER_SIZE_PROPNAME, TransportConstants.DEFAULT_TCP_RECEIVEBUFFER_SIZE, configuration);
-      this.writeBufferLowWaterMark = ConfigurationHelper.getIntProperty(TransportConstants.WRITE_BUFFER_LOW_WATER_MARK_PROPNAME, TransportConstants.DEFAULT_WRITE_BUFFER_LOW_WATER_MARK, configuration);
-      this.writeBufferHighWaterMark = ConfigurationHelper.getIntProperty(TransportConstants.WRITE_BUFFER_HIGH_WATER_MARK_PROPNAME, TransportConstants.DEFAULT_WRITE_BUFFER_HIGH_WATER_MARK, configuration);
+
       batchDelay = ConfigurationHelper.getLongProperty(TransportConstants.BATCH_DELAY, TransportConstants.DEFAULT_BATCH_DELAY, configuration);
 
       connectTimeoutMillis = ConfigurationHelper.getIntProperty(TransportConstants.NETTY_CONNECT_TIMEOUT, TransportConstants.DEFAULT_NETTY_CONNECT_TIMEOUT, configuration);
@@ -371,50 +352,33 @@ public class NettyConnector extends AbstractConnector {
          sslEnabled +
          ", useNio=" +
          true +
-         getHttpUpgradeInfo() +
          "]";
    }
 
-   private String getHttpUpgradeInfo() {
-      if (!httpUpgradeEnabled) {
-         return "";
-      }
-      String serverName = ConfigurationHelper.getStringProperty(TransportConstants.ACTIVEMQ_SERVER_NAME, null, configuration);
-      String acceptor = ConfigurationHelper.getStringProperty(TransportConstants.HTTP_UPGRADE_ENDPOINT_PROP_NAME, null, configuration);
-      return ", activemqServerName=" + serverName + ", httpUpgradeEndpoint=" + acceptor;
-   }
-
    @Override
    public synchronized void start() {
       if (channelClazz != null) {
          return;
       }
 
-      if (remotingThreads == -1) {
-         // Default to number of cores * 3
-         remotingThreads = Runtime.getRuntime().availableProcessors() * 3;
-      }
+      int threadsToUse;
 
-      if (useEpoll && Epoll.isAvailable()) {
-         if (useGlobalWorkerPool) {
-            group = SharedEventLoopGroup.getInstance((threadFactory -> new EpollEventLoopGroup(remotingThreads, threadFactory)));
-         } else {
-            group = new EpollEventLoopGroup(remotingThreads);
-         }
+      if (nioRemotingThreads == -1) {
+         // Default to number of cores * 3
 
-         channelClazz = EpollSocketChannel.class;
-         logger.debug("Connector " + this + " using native epoll");
-      } else {
-         if (useGlobalWorkerPool) {
-            channelClazz = NioSocketChannel.class;
-            group = SharedEventLoopGroup.getInstance((threadFactory -> new NioEventLoopGroup(remotingThreads, threadFactory)));
-         } else {
-            channelClazz = NioSocketChannel.class;
-            group = new NioEventLoopGroup(remotingThreads);
-         }
+         threadsToUse = Runtime.getRuntime().availableProcessors() * 3;
+      }
+      else {
+         threadsToUse = this.nioRemotingThreads;
+      }
 
+      if (useNioGlobalWorkerPool) {
          channelClazz = NioSocketChannel.class;
-         logger.debug("Connector + " + this + " using nio");
+         group = SharedNioEventLoopGroup.getInstance(threadsToUse);
+      }
+      else {
+         channelClazz = NioSocketChannel.class;
+         group = new NioEventLoopGroup(threadsToUse);
       }
       // if we are a servlet wrap the socketChannelFactory
 
@@ -433,69 +397,64 @@ public class NettyConnector extends AbstractConnector {
       if (tcpSendBufferSize != -1) {
          bootstrap.option(ChannelOption.SO_SNDBUF, tcpSendBufferSize);
       }
-      final int writeBufferLowWaterMark = this.writeBufferLowWaterMark != -1 ? this.writeBufferLowWaterMark : WriteBufferWaterMark.DEFAULT.low();
-      final int writeBufferHighWaterMark = this.writeBufferHighWaterMark != -1 ? this.writeBufferHighWaterMark : WriteBufferWaterMark.DEFAULT.high();
-      final WriteBufferWaterMark writeBufferWaterMark = new WriteBufferWaterMark(writeBufferLowWaterMark, writeBufferHighWaterMark);
-      bootstrap.option(ChannelOption.WRITE_BUFFER_WATER_MARK, writeBufferWaterMark);
       bootstrap.option(ChannelOption.SO_KEEPALIVE, true);
       bootstrap.option(ChannelOption.SO_REUSEADDR, true);
+      bootstrap.option(ChannelOption.ALLOCATOR, PartialPooledByteBufAllocator.INSTANCE);
       channelGroup = new DefaultChannelGroup("activemq-connector", GlobalEventExecutor.INSTANCE);
 
       final SSLContext context;
       if (sslEnabled) {
          try {
-            if (useDefaultSslContext) {
-               context = SSLContext.getDefault();
-            } else {
-               // HORNETQ-680 - override the server-side config if client-side system properties are set
-               String realKeyStorePath = keyStorePath;
-               String realKeyStoreProvider = keyStoreProvider;
-               String realKeyStorePassword = keyStorePassword;
-               if (System.getProperty(JAVAX_KEYSTORE_PATH_PROP_NAME) != null) {
-                  realKeyStorePath = System.getProperty(JAVAX_KEYSTORE_PATH_PROP_NAME);
-               }
-               if (System.getProperty(JAVAX_KEYSTORE_PASSWORD_PROP_NAME) != null) {
-                  realKeyStorePassword = System.getProperty(JAVAX_KEYSTORE_PASSWORD_PROP_NAME);
-               }
+            // HORNETQ-680 - override the server-side config if client-side system properties are set
+            String realKeyStorePath = keyStorePath;
+            String realKeyStoreProvider = keyStoreProvider;
+            String realKeyStorePassword = keyStorePassword;
+            if (System.getProperty(JAVAX_KEYSTORE_PATH_PROP_NAME) != null) {
+               realKeyStorePath = System.getProperty(JAVAX_KEYSTORE_PATH_PROP_NAME);
+            }
+            if (System.getProperty(JAVAX_KEYSTORE_PASSWORD_PROP_NAME) != null) {
+               realKeyStorePassword = System.getProperty(JAVAX_KEYSTORE_PASSWORD_PROP_NAME);
+            }
 
-               if (System.getProperty(ACTIVEMQ_KEYSTORE_PROVIDER_PROP_NAME) != null) {
-                  realKeyStoreProvider = System.getProperty(ACTIVEMQ_KEYSTORE_PROVIDER_PROP_NAME);
-               }
-               if (System.getProperty(ACTIVEMQ_KEYSTORE_PATH_PROP_NAME) != null) {
-                  realKeyStorePath = System.getProperty(ACTIVEMQ_KEYSTORE_PATH_PROP_NAME);
-               }
-               if (System.getProperty(ACTIVEMQ_KEYSTORE_PASSWORD_PROP_NAME) != null) {
-                  realKeyStorePassword = System.getProperty(ACTIVEMQ_KEYSTORE_PASSWORD_PROP_NAME);
-               }
+            if (System.getProperty(ACTIVEMQ_KEYSTORE_PROVIDER_PROP_NAME) != null) {
+               realKeyStoreProvider = System.getProperty(ACTIVEMQ_KEYSTORE_PROVIDER_PROP_NAME);
+            }
+            if (System.getProperty(ACTIVEMQ_KEYSTORE_PATH_PROP_NAME) != null) {
+               realKeyStorePath = System.getProperty(ACTIVEMQ_KEYSTORE_PATH_PROP_NAME);
+            }
+            if (System.getProperty(ACTIVEMQ_KEYSTORE_PASSWORD_PROP_NAME) != null) {
+               realKeyStorePassword = System.getProperty(ACTIVEMQ_KEYSTORE_PASSWORD_PROP_NAME);
+            }
 
-               String realTrustStorePath = trustStorePath;
-               String realTrustStoreProvider = trustStoreProvider;
-               String realTrustStorePassword = trustStorePassword;
-               if (System.getProperty(JAVAX_TRUSTSTORE_PATH_PROP_NAME) != null) {
-                  realTrustStorePath = System.getProperty(JAVAX_TRUSTSTORE_PATH_PROP_NAME);
-               }
-               if (System.getProperty(JAVAX_TRUSTSTORE_PASSWORD_PROP_NAME) != null) {
-                  realTrustStorePassword = System.getProperty(JAVAX_TRUSTSTORE_PASSWORD_PROP_NAME);
-               }
+            String realTrustStorePath = trustStorePath;
+            String realTrustStoreProvider = trustStoreProvider;
+            String realTrustStorePassword = trustStorePassword;
+            if (System.getProperty(JAVAX_TRUSTSTORE_PATH_PROP_NAME) != null) {
+               realTrustStorePath = System.getProperty(JAVAX_TRUSTSTORE_PATH_PROP_NAME);
+            }
+            if (System.getProperty(JAVAX_TRUSTSTORE_PASSWORD_PROP_NAME) != null) {
+               realTrustStorePassword = System.getProperty(JAVAX_TRUSTSTORE_PASSWORD_PROP_NAME);
+            }
 
-               if (System.getProperty(ACTIVEMQ_TRUSTSTORE_PROVIDER_PROP_NAME) != null) {
-                  realTrustStoreProvider = System.getProperty(ACTIVEMQ_TRUSTSTORE_PROVIDER_PROP_NAME);
-               }
-               if (System.getProperty(ACTIVEMQ_TRUSTSTORE_PATH_PROP_NAME) != null) {
-                  realTrustStorePath = System.getProperty(ACTIVEMQ_TRUSTSTORE_PATH_PROP_NAME);
-               }
-               if (System.getProperty(ACTIVEMQ_TRUSTSTORE_PASSWORD_PROP_NAME) != null) {
-                  realTrustStorePassword = System.getProperty(ACTIVEMQ_TRUSTSTORE_PASSWORD_PROP_NAME);
-               }
-               context = SSLSupport.createContext(realKeyStoreProvider, realKeyStorePath, realKeyStorePassword, realTrustStoreProvider, realTrustStorePath, realTrustStorePassword);
+            if (System.getProperty(ACTIVEMQ_TRUSTSTORE_PROVIDER_PROP_NAME) != null) {
+               realTrustStoreProvider = System.getProperty(ACTIVEMQ_TRUSTSTORE_PROVIDER_PROP_NAME);
+            }
+            if (System.getProperty(ACTIVEMQ_TRUSTSTORE_PATH_PROP_NAME) != null) {
+               realTrustStorePath = System.getProperty(ACTIVEMQ_TRUSTSTORE_PATH_PROP_NAME);
             }
-         } catch (Exception e) {
+            if (System.getProperty(ACTIVEMQ_TRUSTSTORE_PASSWORD_PROP_NAME) != null) {
+               realTrustStorePassword = System.getProperty(ACTIVEMQ_TRUSTSTORE_PASSWORD_PROP_NAME);
+            }
+            context = SSLSupport.createContext(realKeyStoreProvider, realKeyStorePath, realKeyStorePassword, realTrustStoreProvider, realTrustStorePath, realTrustStorePassword);
+         }
+         catch (Exception e) {
             close();
             IllegalStateException ise = new IllegalStateException("Unable to create NettyConnector for " + host + ":" + port);
             ise.initCause(e);
             throw ise;
          }
-      } else {
+      }
+      else {
          context = null; // Unused
       }
 
@@ -512,7 +471,8 @@ public class NettyConnector extends AbstractConnector {
                SSLEngine engine;
                if (verifyHost) {
                   engine = context.createSSLEngine(host, port);
-               } else {
+               }
+               else {
                   engine = context.createSSLEngine();
                }
 
@@ -528,7 +488,8 @@ public class NettyConnector extends AbstractConnector {
                if (enabledCipherSuites != null) {
                   try {
                      engine.setEnabledCipherSuites(SSLSupport.parseCommaSeparatedListIntoArray(enabledCipherSuites));
-                  } catch (IllegalArgumentException e) {
+                  }
+                  catch (IllegalArgumentException e) {
                      ActiveMQClientLogger.LOGGER.invalidCipherSuite(SSLSupport.parseArrayIntoCommandSeparatedList(engine.getSupportedCipherSuites()));
                      throw e;
                   }
@@ -537,11 +498,13 @@ public class NettyConnector extends AbstractConnector {
                if (enabledProtocols != null) {
                   try {
                      engine.setEnabledProtocols(SSLSupport.parseCommaSeparatedListIntoArray(enabledProtocols));
-                  } catch (IllegalArgumentException e) {
+                  }
+                  catch (IllegalArgumentException e) {
                      ActiveMQClientLogger.LOGGER.invalidProtocol(SSLSupport.parseArrayIntoCommandSeparatedList(engine.getSupportedProtocols()));
                      throw e;
                   }
-               } else {
+               }
+               else {
                   engine.setEnabledProtocols(originalProtocols);
                }
 
@@ -639,7 +602,8 @@ public class NettyConnector extends AbstractConnector {
          if (inet6Address.getScopeId() != 0) {
             try {
                remoteDestination = new InetSocketAddress(InetAddress.getByAddress(inet6Address.getAddress()), ((InetSocketAddress) remoteDestination).getPort());
-            } catch (UnknownHostException e) {
+            }
+            catch (UnknownHostException e) {
                throw new IllegalArgumentException(e.getMessage());
             }
          }
@@ -653,11 +617,13 @@ public class NettyConnector extends AbstractConnector {
          SocketAddress localDestination;
          if (localAddress != null) {
             localDestination = new InetSocketAddress(localAddress, localPort);
-         } else {
+         }
+         else {
             localDestination = new InetSocketAddress(localPort);
          }
          future = bootstrap.connect(remoteDestination, localDestination);
-      } else {
+      }
+      else {
          future = bootstrap.connect(remoteDestination);
       }
 
@@ -673,12 +639,14 @@ public class NettyConnector extends AbstractConnector {
                   ChannelPipeline channelPipeline = ch.pipeline();
                   ActiveMQChannelHandler channelHandler = channelPipeline.get(ActiveMQChannelHandler.class);
                   channelHandler.active = true;
-               } else {
+               }
+               else {
                   ch.close().awaitUninterruptibly();
                   ActiveMQClientLogger.LOGGER.errorCreatingNettyConnection(handshakeFuture.cause());
                   return null;
                }
-            } else {
+            }
+            else {
                //handshakeFuture.setFailure(new SSLException("Handshake was not completed in 30 seconds"));
                ch.close().awaitUninterruptibly();
                return null;
@@ -694,15 +662,11 @@ public class NettyConnector extends AbstractConnector {
                if (sslEnabled) {
                   scheme = "https";
                }
-               URI uri = new URI(scheme, null, IPV6Util.encloseHost(host), port, null, null, null);
+               URI uri = new URI(scheme, null, host, port, null, null, null);
                HttpRequest request = new DefaultHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri.getRawPath());
-               request.headers().set(HttpHeaderNames.HOST, host);
-               request.headers().set(HttpHeaderNames.UPGRADE, ACTIVEMQ_REMOTING);
-               request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderNames.UPGRADE);
-               final String serverName = ConfigurationHelper.getStringProperty(TransportConstants.ACTIVEMQ_SERVER_NAME, null, configuration);
-               if (serverName != null) {
-                  request.headers().set(TransportConstants.ACTIVEMQ_SERVER_NAME, serverName);
-               }
+               request.headers().set(HttpHeaders.Names.HOST, host);
+               request.headers().set(HttpHeaders.Names.UPGRADE, ACTIVEMQ_REMOTING);
+               request.headers().set(HttpHeaders.Names.CONNECTION, HttpHeaders.Values.UPGRADE);
 
                final String endpoint = ConfigurationHelper.getStringProperty(TransportConstants.HTTP_UPGRADE_ENDPOINT_PROP_NAME, null, configuration);
                if (endpoint != null) {
@@ -724,11 +688,13 @@ public class NettyConnector extends AbstractConnector {
                   ch.close().awaitUninterruptibly();
                   return null;
                }
-            } catch (URISyntaxException e) {
+            }
+            catch (URISyntaxException e) {
                ActiveMQClientLogger.LOGGER.errorCreatingNettyConnection(e);
                return null;
             }
-         } else {
+         }
+         else {
             ChannelPipeline channelPipeline = ch.pipeline();
             ActiveMQChannelHandler channelHandler = channelPipeline.get(ActiveMQChannelHandler.class);
             channelHandler.active = true;
@@ -739,7 +705,8 @@ public class NettyConnector extends AbstractConnector {
          NettyConnection conn = new NettyConnection(configuration, ch, connectionListener, !httpEnabled && batchDelay > 0, false);
          connectionListener.connectionCreated(null, conn, protocolManager);
          return conn;
-      } else {
+      }
+      else {
          Throwable t = future.cause();
 
          if (t != null && !(t instanceof ConnectException)) {
@@ -781,50 +748,33 @@ public class NettyConnector extends AbstractConnector {
          this.httpClientCodec = httpClientCodec;
       }
 
-      /**
-       * HTTP upgrade response will be decode by Netty as 2 objects:
-       * - 1 HttpObject corresponding to the 101 SWITCHING PROTOCOL headers
-       * - 1 EMPTY_LAST_CONTENT
-       *
-       * The HTTP upgrade is successful whne the 101 SWITCHING PROTOCOL has been received (handshakeComplete = true)
-       * but the latch is count down only when the following EMPTY_LAST_CONTENT is also received.
-       * Otherwise this ChannelHandler would be removed too soon and the ActiveMQChannelHandler would handle the
-       * EMPTY_LAST_CONTENT (while it is expecitng only ByteBuf).
-       */
       @Override
       public void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception {
-         if (logger.isDebugEnabled()) {
-            logger.debug("Received msg=" + msg);
-         }
          if (msg instanceof HttpResponse) {
             HttpResponse response = (HttpResponse) msg;
-            if (response.status().code() == HttpResponseStatus.SWITCHING_PROTOCOLS.code() && response.headers().get(HttpHeaderNames.UPGRADE).equals(ACTIVEMQ_REMOTING)) {
+            if (response.getStatus().code() == HttpResponseStatus.SWITCHING_PROTOCOLS.code() && response.headers().get(HttpHeaders.Names.UPGRADE).equals(ACTIVEMQ_REMOTING)) {
                String accept = response.headers().get(SEC_ACTIVEMQ_REMOTING_ACCEPT);
                String expectedResponse = createExpectedResponse(MAGIC_NUMBER, ctx.channel().attr(REMOTING_KEY).get());
 
                if (expectedResponse.equals(accept)) {
-                  // HTTP upgrade is successful but let's wait to receive the EMPTY_LAST_CONTENT to count down the latch
+                  // remove the http handlers and flag the activemq channel handler as active
+                  pipeline.remove(httpClientCodec);
+                  pipeline.remove(this);
                   handshakeComplete = true;
-               } else {
-                  // HTTP upgrade failed
-                  ActiveMQClientLogger.LOGGER.httpHandshakeFailed(msg);
+                  ActiveMQChannelHandler channelHandler = pipeline.get(ActiveMQChannelHandler.class);
+                  channelHandler.active = true;
+               }
+               else {
+                  ActiveMQClientLogger.LOGGER.httpHandshakeFailed(accept, expectedResponse);
                   ctx.close();
-                  latch.countDown();
                }
-               return;
             }
-         } else if (msg == LastHttpContent.EMPTY_LAST_CONTENT && handshakeComplete) {
-            // remove the http handlers and flag the activemq channel handler as active
-            pipeline.remove(httpClientCodec);
-            pipeline.remove(this);
-            ActiveMQChannelHandler channelHandler = pipeline.get(ActiveMQChannelHandler.class);
-            channelHandler.active = true;
-         }
-         if (!handshakeComplete) {
-            ActiveMQClientLogger.LOGGER.httpHandshakeFailed(msg);
-            ctx.close();
+            else if (response.getStatus().code() == HttpResponseStatus.FORBIDDEN.code()) {
+               ActiveMQClientLogger.LOGGER.httpUpgradeNotSupportedByRemoteAcceptor();
+               ctx.close();
+            }
+            latch.countDown();
          }
-         latch.countDown();
       }
 
       @Override
@@ -838,7 +788,8 @@ public class NettyConnector extends AbstractConnector {
             if (!latch.await(30000, TimeUnit.MILLISECONDS)) {
                return false;
             }
-         } catch (InterruptedException e) {
+         }
+         catch (InterruptedException e) {
             return false;
          }
          return handshakeComplete;
@@ -893,12 +844,10 @@ public class NettyConnector extends AbstractConnector {
       public void channelRead(final ChannelHandlerContext ctx, final Object msg) throws Exception {
          FullHttpResponse response = (FullHttpResponse) msg;
          if (httpRequiresSessionId && !active) {
-            final List<String> setCookieHeaderValues = response.headers().getAll(HttpHeaderNames.SET_COOKIE);
-            for (String setCookieHeaderValue : setCookieHeaderValues) {
-               final Cookie cookie = ClientCookieDecoder.LAX.decode(setCookieHeaderValue);
-               if ("JSESSIONID".equals(cookie.name())) {
-                  this.cookie = setCookieHeaderValue;
-                  break;
+            Set<Cookie> cookieMap = CookieDecoder.decode(response.headers().get(HttpHeaders.Names.SET_COOKIE));
+            for (Cookie cookie : cookieMap) {
+               if (cookie.getName().equals("JSESSIONID")) {
+                  this.cookie = ClientCookieEncoder.LAX.encode(cookie);
                }
             }
             active = true;
@@ -914,7 +863,8 @@ public class NettyConnector extends AbstractConnector {
             if (httpRequiresSessionId && !active) {
                if (handshaking) {
                   handshaking = true;
-               } else {
+               }
+               else {
                   if (!handShakeFuture.await(5000)) {
                      throw new RuntimeException("Handshake failed after timeout");
                   }
@@ -923,14 +873,15 @@ public class NettyConnector extends AbstractConnector {
 
             ByteBuf buf = (ByteBuf) msg;
             FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, url, buf);
-            httpRequest.headers().add(HttpHeaderNames.HOST, NettyConnector.this.host);
+            httpRequest.headers().add(HttpHeaders.Names.HOST, NettyConnector.this.host);
             if (cookie != null) {
-               httpRequest.headers().add(HttpHeaderNames.COOKIE, cookie);
+               httpRequest.headers().add(HttpHeaders.Names.COOKIE, cookie);
             }
-            httpRequest.headers().add(HttpHeaderNames.CONTENT_LENGTH, String.valueOf(buf.readableBytes()));
+            httpRequest.headers().add(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buf.readableBytes()));
             ctx.write(httpRequest, promise);
             lastSendTime = System.currentTimeMillis();
-         } else {
+         }
+         else {
             ctx.write(msg, promise);
             lastSendTime = System.currentTimeMillis();
          }
@@ -950,7 +901,7 @@ public class NettyConnector extends AbstractConnector {
 
             if (!waitingGet && System.currentTimeMillis() > lastSendTime + httpMaxClientIdleTime) {
                FullHttpRequest httpRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url);
-               httpRequest.headers().add(HttpHeaderNames.HOST, NettyConnector.this.host);
+               httpRequest.headers().add(HttpHeaders.Names.HOST, NettyConnector.this.host);
                waitingGet = true;
                channel.writeAndFlush(httpRequest);
             }
@@ -979,9 +930,6 @@ public class NettyConnector extends AbstractConnector {
          if (connections.putIfAbsent(connection.getID(), connection) != null) {
             throw ActiveMQClientMessageBundle.BUNDLE.connectionExists(connection.getID());
          }
-         @SuppressWarnings("unchecked")
-         final BaseConnectionLifeCycleListener<ClientProtocolManager> clientListener = (BaseConnectionLifeCycleListener<ClientProtocolManager>) listener;
-         clientListener.connectionCreated(component, connection, protocol);
       }
 
       @Override
@@ -1010,7 +958,7 @@ public class NettyConnector extends AbstractConnector {
 
       @Override
       public void connectionReadyForWrites(Object connectionID, boolean ready) {
-         NettyConnection connection = (NettyConnection) connections.get(connectionID);
+         NettyConnection connection = (NettyConnection)connections.get(connectionID);
          if (connection != null) {
             connection.fireReady(ready);
          }
@@ -1039,20 +987,6 @@ public class NettyConnector extends AbstractConnector {
 
    @Override
    public boolean isEquivalent(Map<String, Object> configuration) {
-      Boolean httpUpgradeEnabled = ConfigurationHelper.getBooleanProperty(TransportConstants.HTTP_UPGRADE_ENABLED_PROP_NAME, TransportConstants.DEFAULT_HTTP_UPGRADE_ENABLED, configuration);
-      if (httpUpgradeEnabled) {
-         // we need to look at the activemqServerName to distinguish between ActiveMQ servers that could be proxied behind the same
-         // HTTP upgrade handler in the Web server
-         String otherActiveMQServerName = ConfigurationHelper.getStringProperty(TransportConstants.ACTIVEMQ_SERVER_NAME, null, configuration);
-         String activeMQServerName = ConfigurationHelper.getStringProperty(TransportConstants.ACTIVEMQ_SERVER_NAME, null, this.configuration);
-         boolean equivalent = isSameHostAndPort(configuration) && otherActiveMQServerName != null && otherActiveMQServerName.equals(activeMQServerName);
-         return equivalent;
-      } else {
-         return isSameHostAndPort(configuration);
-      }
-   }
-
-   private boolean isSameHostAndPort(Map<String, Object> configuration) {
       //here we only check host and port because these two parameters
       //is sufficient to determine the target host
       String host = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, configuration);
@@ -1074,7 +1008,8 @@ public class NettyConnector extends AbstractConnector {
          logger.debug(this + " host 1: " + host + " ip address: " + ip1 + " host 2: " + this.host + " ip address: " + ip2);
 
          result = ip1.equals(ip2);
-      } catch (UnknownHostException e) {
+      }
+      catch (UnknownHostException e) {
          ActiveMQClientLogger.LOGGER.error("Cannot resolve host", e);
       }
 
@@ -1093,7 +1028,17 @@ public class NettyConnector extends AbstractConnector {
    }
 
    public static void clearThreadPools() {
-      SharedEventLoopGroup.forceShutdown();
+      SharedNioEventLoopGroup.forceShutdown();
+   }
+
+   private static ClassLoader getThisClassLoader() {
+      return AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
+         @Override
+         public ClassLoader run() {
+            return ClientSessionFactoryImpl.class.getClassLoader();
+         }
+      });
+
    }
 
    private static String base64(byte[] data) {
@@ -1132,7 +1077,8 @@ public class NettyConnector extends AbstractConnector {
          digest.update(concat.getBytes(StandardCharsets.UTF_8));
          final byte[] bytes = digest.digest();
          return encodeBytes(bytes);
-      } catch (NoSuchAlgorithmException e) {
+      }
+      catch (NoSuchAlgorithmException e) {
          throw new IOException(e);
       }
    }