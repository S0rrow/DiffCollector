diff --git a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPSessionCallback.java b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPSessionCallback.java
index 7fef3dbc68..18c6b05f17 100644
--- a/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPSessionCallback.java
+++ b/artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPSessionCallback.java
@@ -21,32 +21,27 @@ import java.util.concurrent.Executor;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
-import org.apache.activemq.artemis.api.core.ActiveMQAddressExistsException;
 import org.apache.activemq.artemis.api.core.ActiveMQException;
 import org.apache.activemq.artemis.api.core.ActiveMQQueueExistsException;
-import org.apache.activemq.artemis.api.core.ActiveMQSecurityException;
-import org.apache.activemq.artemis.api.core.Message;
-import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.api.core.client.ActiveMQClient;
 import org.apache.activemq.artemis.core.io.IOCallback;
-import org.apache.activemq.artemis.core.message.impl.CoreMessageObjectPools;
-import org.apache.activemq.artemis.core.paging.PagingManager;
 import org.apache.activemq.artemis.core.paging.PagingStore;
 import org.apache.activemq.artemis.core.persistence.OperationContext;
-import org.apache.activemq.artemis.core.persistence.StorageManager;
-import org.apache.activemq.artemis.core.security.CheckType;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
 import org.apache.activemq.artemis.core.server.AddressQueryResult;
+import org.apache.activemq.artemis.core.server.BindingQueryResult;
 import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
+import org.apache.activemq.artemis.api.core.RoutingType;
 import org.apache.activemq.artemis.core.server.ServerConsumer;
-import org.apache.activemq.artemis.core.server.ServerProducer;
+import org.apache.activemq.artemis.core.server.ServerMessage;
 import org.apache.activemq.artemis.core.server.ServerSession;
 import org.apache.activemq.artemis.core.server.impl.AddressInfo;
 import org.apache.activemq.artemis.core.server.impl.ServerConsumerImpl;
-import org.apache.activemq.artemis.core.settings.impl.AddressSettings;
 import org.apache.activemq.artemis.core.transaction.Transaction;
+import org.apache.activemq.artemis.jms.client.ActiveMQConnection;
+import org.apache.activemq.artemis.protocol.amqp.converter.ProtonMessageConverter;
+import org.apache.activemq.artemis.protocol.amqp.converter.message.EncodedMessage;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPInternalErrorException;
 import org.apache.activemq.artemis.protocol.amqp.exceptions.ActiveMQAMQPResourceLimitExceededException;
@@ -54,7 +49,6 @@ import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolMess
 import org.apache.activemq.artemis.protocol.amqp.proton.AMQPConnectionContext;
 import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;
 import org.apache.activemq.artemis.protocol.amqp.proton.AmqpSupport;
-import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerReceiverContext;
 import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;
 import org.apache.activemq.artemis.protocol.amqp.sasl.PlainSASLResult;
 import org.apache.activemq.artemis.protocol.amqp.sasl.SASLResult;
@@ -62,7 +56,6 @@ import org.apache.activemq.artemis.spi.core.protocol.SessionCallback;
 import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
 import org.apache.activemq.artemis.utils.IDGenerator;
-import org.apache.activemq.artemis.utils.RunnableEx;
 import org.apache.activemq.artemis.utils.SelectorTranslator;
 import org.apache.activemq.artemis.utils.SimpleIDGenerator;
 import org.apache.activemq.artemis.utils.UUIDGenerator;
@@ -70,13 +63,13 @@ import org.apache.qpid.proton.amqp.Binary;
 import org.apache.qpid.proton.amqp.Symbol;
 import org.apache.qpid.proton.amqp.messaging.Accepted;
 import org.apache.qpid.proton.amqp.messaging.Rejected;
-import org.apache.qpid.proton.amqp.transaction.TransactionalState;
 import org.apache.qpid.proton.amqp.transport.AmqpError;
 import org.apache.qpid.proton.amqp.transport.ErrorCondition;
-import org.apache.qpid.proton.codec.ReadableBuffer;
+import org.apache.qpid.proton.codec.WritableBuffer;
 import org.apache.qpid.proton.engine.Delivery;
 import org.apache.qpid.proton.engine.EndpointState;
 import org.apache.qpid.proton.engine.Receiver;
+import io.netty.buffer.ByteBuf;
 import org.jboss.logging.Logger;
 
 public class AMQPSessionCallback implements SessionCallback {
@@ -89,8 +82,6 @@ public class AMQPSessionCallback implements SessionCallback {
 
    private final ProtonProtocolManager manager;
 
-   private final StorageManager storageManager;
-
    private final AMQPConnectionContext connection;
 
    private final Connection transportConnection;
@@ -101,16 +92,10 @@ public class AMQPSessionCallback implements SessionCallback {
 
    private AMQPSessionContext protonSession;
 
-   private final Executor sessionExecutor;
+   private final Executor closeExecutor;
 
    private final AtomicBoolean draining = new AtomicBoolean(false);
 
-   private CoreMessageObjectPools coreMessageObjectPools = new CoreMessageObjectPools();
-
-   private final AddressQueryCache<AddressQueryResult> addressQueryCache = new AddressQueryCache<>();
-
-   private CreditRunnable creditRunnable;
-
    public AMQPSessionCallback(AMQPConnectionCallback protonSPI,
                               ProtonProtocolManager manager,
                               AMQPConnectionContext connection,
@@ -119,10 +104,9 @@ public class AMQPSessionCallback implements SessionCallback {
                               OperationContext operationContext) {
       this.protonSPI = protonSPI;
       this.manager = manager;
-      this.storageManager = manager.getServer().getStorageManager();
       this.connection = connection;
       this.transportConnection = transportConnection;
-      this.sessionExecutor = executor;
+      this.closeExecutor = executor;
       this.operationContext = operationContext;
    }
 
@@ -142,7 +126,7 @@ public class AMQPSessionCallback implements SessionCallback {
                @Override
                public void run() {
                   try {
-                     plugSender.reportDrained();
+                     plugSender.getSender().drained();
                   } finally {
                      draining.set(false);
                   }
@@ -154,34 +138,11 @@ public class AMQPSessionCallback implements SessionCallback {
       }
    }
 
-   public void withinContext(RunnableEx run) throws Exception {
-      OperationContext context = recoverContext();
-      try {
-         run.run();
-      } finally {
-         resetContext(context);
-      }
-   }
-
-   public void afterIO(IOCallback ioCallback) {
-      OperationContext context = recoverContext();
-      try {
-         manager.getServer().getStorageManager().afterCompleteOperations(ioCallback);
-      } finally {
-         resetContext(context);
-      }
-   }
-
    @Override
    public void browserFinished(ServerConsumer consumer) {
 
    }
 
-   @Override
-   public boolean supportsDirectDelivery() {
-      return false;
-   }
-
    public void init(AMQPSessionContext protonSession, SASLResult saslResult) throws Exception {
 
       this.protonSession = protonSession;
@@ -215,14 +176,14 @@ public class AMQPSessionCallback implements SessionCallback {
    }
 
    public Object createSender(ProtonServerSenderContext protonSender,
-                              SimpleString queue,
+                              String queue,
                               String filter,
                               boolean browserOnly) throws Exception {
       long consumerID = consumerIDGenerator.generateID();
 
       filter = SelectorTranslator.convertToActiveMQFilterString(filter);
 
-      ServerConsumer consumer = serverSession.createConsumer(consumerID, queue, SimpleString.toSimpleString(filter), browserOnly, false, null);
+      ServerConsumer consumer = serverSession.createConsumer(consumerID, SimpleString.toSimpleString(queue), SimpleString.toSimpleString(filter), browserOnly);
 
       // AMQP handles its own flow control for when it's started
       consumer.setStarted(true);
@@ -238,134 +199,68 @@ public class AMQPSessionCallback implements SessionCallback {
       serverConsumer.receiveCredits(-1);
    }
 
-   public void createTemporaryQueue(SimpleString queueName, RoutingType routingType) throws Exception {
-      createTemporaryQueue(queueName, queueName, routingType, null);
+   public void createTemporaryQueue(String queueName, RoutingType routingType) throws Exception {
+      serverSession.createQueue(SimpleString.toSimpleString(queueName), SimpleString.toSimpleString(queueName), routingType, null, true, false);
    }
 
-   public void createTemporaryQueue(SimpleString address,
-                                    SimpleString queueName,
-                                    RoutingType routingType,
-                                    SimpleString filter) throws Exception {
-      try {
-         serverSession.createQueue(address, queueName, routingType, filter, true, false);
-      } catch (ActiveMQSecurityException se) {
-         throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingTempDestination(se.getMessage());
-      }
+   public void createTemporaryQueue(String address, String queueName, RoutingType routingType, String filter) throws Exception {
+      serverSession.createQueue(SimpleString.toSimpleString(address), SimpleString.toSimpleString(queueName),  routingType, SimpleString.toSimpleString(filter), true, false);
    }
 
-   public void createUnsharedDurableQueue(SimpleString address,
-                                          RoutingType routingType,
-                                          SimpleString queueName,
-                                          SimpleString filter) throws Exception {
-      try {
-         serverSession.createQueue(address, queueName, routingType, filter, false, true, 1, false, false);
-      } catch (ActiveMQSecurityException se) {
-         throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(se.getMessage());
-      }
+   public void createUnsharedDurableQueue(String address, RoutingType routingType, String queueName, String filter) throws Exception {
+      serverSession.createQueue(SimpleString.toSimpleString(address), SimpleString.toSimpleString(queueName), routingType, SimpleString.toSimpleString(filter), false, true, 1, false, false);
    }
 
-   public void createSharedDurableQueue(SimpleString address,
-                                        RoutingType routingType,
-                                        SimpleString queueName,
-                                        SimpleString filter) throws Exception {
-      try {
-         serverSession.createQueue(address, queueName, routingType, filter, false, true, -1, false, false);
-      } catch (ActiveMQSecurityException se) {
-         throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(se.getMessage());
-      }
+   public void createSharedDurableQueue(String address, RoutingType routingType, String queueName, String filter) throws Exception {
+      serverSession.createQueue(SimpleString.toSimpleString(address), SimpleString.toSimpleString(queueName), routingType, SimpleString.toSimpleString(filter), false, true, -1, false, false);
    }
 
-   public void createSharedVolatileQueue(SimpleString address,
-                                         RoutingType routingType,
-                                         SimpleString queueName,
-                                         SimpleString filter) throws Exception {
-      try {
-         serverSession.createQueue(address, queueName, routingType, filter, false, false, -1, true, true);
-      } catch (ActiveMQSecurityException se) {
-         throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.securityErrorCreatingConsumer(se.getMessage());
-      }
+   public void createSharedVolatileQueue(String address, RoutingType routingType, String queueName, String filter) throws Exception {
+      serverSession.createQueue(SimpleString.toSimpleString(address), SimpleString.toSimpleString(queueName), routingType, SimpleString.toSimpleString(filter), false, false, -1, true, true);
    }
 
-   public QueueQueryResult queueQuery(SimpleString queueName, RoutingType routingType, boolean autoCreate) throws Exception {
-      QueueQueryResult queueQueryResult = serverSession.executeQueueQuery(queueName);
+   public QueueQueryResult queueQuery(String queueName, RoutingType routingType, boolean autoCreate) throws Exception {
+      QueueQueryResult queueQueryResult = serverSession.executeQueueQuery(SimpleString.toSimpleString(queueName));
 
       if (!queueQueryResult.isExists() && queueQueryResult.isAutoCreateQueues() && autoCreate) {
          try {
-            serverSession.createQueue(queueName, queueName, routingType, null, false, true, true);
+            serverSession.createQueue(new SimpleString(queueName), new SimpleString(queueName), routingType, null, false, true);
          } catch (ActiveMQQueueExistsException e) {
             // The queue may have been created by another thread in the mean time.  Catch and do nothing.
          }
-         queueQueryResult = serverSession.executeQueueQuery(queueName);
+         queueQueryResult = serverSession.executeQueueQuery(SimpleString.toSimpleString(queueName));
       }
 
-      // if auto-create we will return whatever type was used before
-      if (queueQueryResult.isExists() && !queueQueryResult.isAutoCreated() && queueQueryResult.getRoutingType() != routingType) {
+      if (queueQueryResult.getRoutingType() != routingType) {
          throw new IllegalStateException("Incorrect Routing Type for queue, expecting: " + routingType);
       }
-
       return queueQueryResult;
    }
 
-
-
-   public boolean checkAddressAndAutocreateIfPossible(SimpleString address, RoutingType routingType) throws Exception {
-      boolean result = false;
-      SimpleString unPrefixedAddress = serverSession.removePrefix(address);
-      AddressSettings addressSettings = manager.getServer().getAddressSettingsRepository().getMatch(unPrefixedAddress.toString());
-
-      if (routingType == RoutingType.MULTICAST) {
-         if (manager.getServer().getAddressInfo(unPrefixedAddress) == null) {
-            if (addressSettings.isAutoCreateAddresses()) {
-               try {
-                  serverSession.createAddress(address, routingType, true);
-               } catch (ActiveMQAddressExistsException e) {
-                  // The address may have been created by another thread in the mean time.  Catch and do nothing.
-               }
-               result = true;
-            }
-         } else {
-            result = true;
-         }
-      } else if (routingType == RoutingType.ANYCAST) {
-         if (manager.getServer().locateQueue(unPrefixedAddress) == null) {
-            if (addressSettings.isAutoCreateQueues()) {
-               try {
-                  serverSession.createQueue(address, address, routingType, null, false, true, true);
-               } catch (ActiveMQQueueExistsException e) {
-                  // The queue may have been created by another thread in the mean time.  Catch and do nothing.
-               }
-               result = true;
-            }
-         } else {
-            result = true;
+   public boolean bindingQuery(String address) throws Exception {
+      BindingQueryResult bindingQueryResult = serverSession.executeBindingQuery(SimpleString.toSimpleString(address));
+      if (!bindingQueryResult.isExists() && bindingQueryResult.isAutoCreateQueues()) {
+         try {
+            serverSession.createQueue(new SimpleString(address), new SimpleString(address), RoutingType.ANYCAST, null, false, true);
+         } catch (ActiveMQQueueExistsException e) {
+            // The queue may have been created by another thread in the mean time.  Catch and do nothing.
          }
+         bindingQueryResult = serverSession.executeBindingQuery(SimpleString.toSimpleString(address));
       }
-
-      return result;
+      return bindingQueryResult.isExists();
    }
 
-
-   public AddressQueryResult addressQuery(SimpleString addressName,
-                                          RoutingType routingType,
-                                          boolean autoCreate) throws Exception {
-
-      AddressQueryResult addressQueryResult = addressQueryCache.getResult(addressName);
-      if (addressQueryResult != null) {
-         return addressQueryResult;
-      }
-
-      addressQueryResult = serverSession.executeAddressQuery(addressName);
+   public AddressQueryResult addressQuery(String addressName, RoutingType routingType, boolean autoCreate) throws Exception {
+      AddressQueryResult addressQueryResult = serverSession.executeAddressQuery(SimpleString.toSimpleString(addressName));
 
       if (!addressQueryResult.isExists() && addressQueryResult.isAutoCreateAddresses() && autoCreate) {
          try {
-            serverSession.createAddress(addressName, routingType, true);
+            serverSession.createAddress(SimpleString.toSimpleString(addressName), routingType, true);
          } catch (ActiveMQQueueExistsException e) {
             // The queue may have been created by another thread in the mean time.  Catch and do nothing.
          }
-         addressQueryResult = serverSession.executeAddressQuery(addressName);
+         addressQueryResult = serverSession.executeAddressQuery(SimpleString.toSimpleString(addressName));
       }
-
-      addressQueryCache.setResult(addressName, addressQueryResult);
       return addressQueryResult;
    }
 
@@ -397,15 +292,17 @@ public class AMQPSessionCallback implements SessionCallback {
       }
 
       try {
-         // a short timeout will do.. 1 second is already long enough
-         if (!latch.await(1, TimeUnit.SECONDS)) {
-            logger.debug("Could not close consumer on time");
-         }
+         latch.await(10, TimeUnit.SECONDS);
       } catch (InterruptedException e) {
          throw new ActiveMQAMQPInternalErrorException("Unable to close consumers for queue: " + consumer.getQueue());
       }
+   }
+
+   public long encodeMessage(Object message, int deliveryCount, WritableBuffer buffer) throws Exception {
+      ProtonMessageConverter converter = (ProtonMessageConverter) manager.getConverter();
 
-      consumer.getQueue().recheckRefCount(serverSession.getSessionContext());
+      // The Proton variant accepts a WritableBuffer to allow for a faster more direct encode.
+      return (long) converter.outbound((ServerMessage) message, deliveryCount, buffer);
    }
 
    public String tempQueueName() {
@@ -415,43 +312,33 @@ public class AMQPSessionCallback implements SessionCallback {
    public void close() throws Exception {
       //need to check here as this can be called if init fails
       if (serverSession != null) {
-         OperationContext context = recoverContext();
+         recoverContext();
          try {
             serverSession.close(false);
          } finally {
-            resetContext(context);
+            resetContext();
          }
       }
    }
 
-   public void ack(Transaction transaction, Object brokerConsumer, Message message) throws Exception {
+   public void ack(Transaction transaction, Object brokerConsumer, Object message) throws Exception {
       if (transaction == null) {
          transaction = serverSession.getCurrentTransaction();
       }
-      OperationContext oldContext = recoverContext();
+      recoverContext();
       try {
-         ((ServerConsumer) brokerConsumer).individualAcknowledge(transaction, message.getMessageID());
+         ((ServerConsumer) brokerConsumer).individualAcknowledge(transaction, ((ServerMessage) message).getMessageID());
       } finally {
-         resetContext(oldContext);
+         resetContext();
       }
    }
 
-   public void cancel(Object brokerConsumer, Message message, boolean updateCounts) throws Exception {
-      OperationContext oldContext = recoverContext();
+   public void cancel(Object brokerConsumer, Object message, boolean updateCounts) throws Exception {
+      recoverContext();
       try {
-         ((ServerConsumer) brokerConsumer).individualCancel(message.getMessageID(), updateCounts);
-         ((ServerConsumer) brokerConsumer).getQueue().forceDelivery();
+         ((ServerConsumer) brokerConsumer).individualCancel(((ServerMessage) message).getMessageID(), updateCounts);
       } finally {
-         resetContext(oldContext);
-      }
-   }
-
-   public void reject(Object brokerConsumer, Message message) throws Exception {
-      OperationContext oldContext = recoverContext();
-      try {
-         ((ServerConsumer) brokerConsumer).reject(message.getMessageID());
-      } finally {
-         resetContext(oldContext);
+         resetContext();
       }
    }
 
@@ -459,51 +346,46 @@ public class AMQPSessionCallback implements SessionCallback {
       ((ServerConsumer) consumer).receiveCredits(-1);
    }
 
-   public void serverSend(final ProtonServerReceiverContext context,
-                          final Transaction transaction,
+   public void serverSend(final Transaction transaction,
                           final Receiver receiver,
                           final Delivery delivery,
-                          SimpleString address,
+                          String address,
                           int messageFormat,
-                          ReadableBuffer data) throws Exception {
-      AMQPMessage message = new AMQPMessage(messageFormat, data, null, coreMessageObjectPools);
+                          ByteBuf messageEncoded) throws Exception {
+      EncodedMessage encodedMessage = new EncodedMessage(messageFormat, messageEncoded.array(), messageEncoded.arrayOffset(), messageEncoded.writerIndex());
+
+      ServerMessage message = manager.getConverter().inbound(encodedMessage);
+      //use the address on the receiver if not null, if null let's hope it was set correctly on the message
       if (address != null) {
-         message.setAddress(address);
+         message.setAddress(new SimpleString(address));
       } else {
          // Anonymous relay must set a To value
-         address = message.getAddressSimpleString();
-         if (address == null) {
+         if (message.getAddress() == null) {
             rejectMessage(delivery, Symbol.valueOf("failed"), "Missing 'to' field for message sent to an anonymous producer");
             return;
          }
-      }
 
-      //here check queue-autocreation
-      RoutingType routingType = context.getRoutingType(receiver, address);
-      if (!checkAddressAndAutocreateIfPossible(address, routingType)) {
-         throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.addressDoesntExist();
+         if (!bindingQuery(message.getAddress().toString())) {
+            throw ActiveMQAMQPProtocolMessageBundle.BUNDLE.addressDoesntExist();
+         }
       }
 
-      OperationContext oldcontext = recoverContext();
+      recoverContext();
 
-      try {
-         PagingStore store = manager.getServer().getPagingManager().getPageStore(message.getAddressSimpleString());
-         if (store.isRejectingMessages()) {
-            // We drop pre-settled messages (and abort any associated Tx)
-            if (delivery.remotelySettled()) {
-               if (transaction != null) {
-                  String amqpAddress = delivery.getLink().getTarget().getAddress();
-                  ActiveMQException e = new ActiveMQAMQPResourceLimitExceededException("Address is full: " + amqpAddress);
-                  transaction.markAsRollbackOnly(e);
-               }
-            } else {
-               rejectMessage(delivery, AmqpError.RESOURCE_LIMIT_EXCEEDED, "Address is full: " + address);
+      PagingStore store = manager.getServer().getPagingManager().getPageStore(message.getAddress());
+      if (store.isRejectingMessages()) {
+         // We drop pre-settled messages (and abort any associated Tx)
+         if (delivery.remotelySettled()) {
+            if (transaction != null) {
+               String amqpAddress = delivery.getLink().getTarget().getAddress();
+               ActiveMQException e = new ActiveMQAMQPResourceLimitExceededException("Address is full: " + amqpAddress);
+               transaction.markAsRollbackOnly(e);
             }
          } else {
-            serverSend(transaction, message, delivery, receiver);
+            rejectMessage(delivery, AmqpError.RESOURCE_LIMIT_EXCEEDED, "Address is full: " + address);
          }
-      } finally {
-         resetContext(oldcontext);
+      } else {
+         serverSend(transaction, message, delivery, receiver);
       }
    }
 
@@ -513,132 +395,87 @@ public class AMQPSessionCallback implements SessionCallback {
       condition.setDescription(errorMessage);
       Rejected rejected = new Rejected();
       rejected.setError(condition);
-
-      afterIO(new IOCallback() {
-         @Override
-         public void done() {
-            connection.lock();
-            try {
-               delivery.disposition(rejected);
-               delivery.settle();
-            } finally {
-               connection.unlock();
-            }
-            connection.flush();
-         }
-
-         @Override
-         public void onError(int errorCode, String errorMessage) {
-
-         }
-      });
-
+      delivery.disposition(rejected);
+      delivery.settle();
+      connection.flush();
    }
 
    private void serverSend(final Transaction transaction,
-                           final Message message,
+                           final ServerMessage message,
                            final Delivery delivery,
                            final Receiver receiver) throws Exception {
-      message.setConnectionID(receiver.getSession().getConnection().getRemoteContainer());
-      invokeIncoming((AMQPMessage) message, (ActiveMQProtonRemotingConnection) transportConnection.getProtocolConnection());
-      serverSession.send(transaction, message, false, false);
+      try {
 
-      afterIO(new IOCallback() {
-         @Override
-         public void done() {
-            connection.lock();
-            try {
-               if (delivery.getRemoteState() instanceof TransactionalState) {
-                  TransactionalState txAccepted = new TransactionalState();
-                  txAccepted.setOutcome(Accepted.getInstance());
-                  txAccepted.setTxnId(((TransactionalState) delivery.getRemoteState()).getTxnId());
+         message.putStringProperty(ActiveMQConnection.CONNECTION_ID_PROPERTY_NAME.toString(), receiver.getSession().getConnection().getRemoteContainer());
+         serverSession.send(transaction, message, false, false);
 
-                  delivery.disposition(txAccepted);
-               } else {
+         // FIXME Potential race here...
+         manager.getServer().getStorageManager().afterCompleteOperations(new IOCallback() {
+            @Override
+            public void done() {
+               synchronized (connection.getLock()) {
                   delivery.disposition(Accepted.getInstance());
+                  delivery.settle();
+                  connection.flush();
                }
-               delivery.settle();
-            } finally {
-               connection.unlock();
             }
-            connection.flush();
-         }
 
-         @Override
-         public void onError(int errorCode, String errorMessage) {
-            connection.lock();
-            try {
-               receiver.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, errorCode + ":" + errorMessage));
-               connection.flush();
-            } finally {
-               connection.unlock();
+            @Override
+            public void onError(int errorCode, String errorMessage) {
+               synchronized (connection.getLock()) {
+                  receiver.setCondition(new ErrorCondition(AmqpError.ILLEGAL_STATE, errorCode + ":" + errorMessage));
+                  connection.flush();
+               }
             }
-         }
-      });
+         });
+      } finally {
+         resetContext();
+      }
    }
 
-   public void offerProducerCredit(final SimpleString address,
+   public String getPubSubPrefix() {
+      return manager.getPubSubPrefix();
+   }
+
+   public void offerProducerCredit(final String address,
                                    final int credits,
                                    final int threshold,
                                    final Receiver receiver) {
       try {
-         /*
-         * The credit runnable will always be run in this thread unless the address or disc is full. If this is the case the
-         * runnable is run once the memory or disc is free, if this happens we don't want to keep adding runnables as this
-         * may cause a memory leak, one is enough.
-         * */
-         if (creditRunnable != null && !creditRunnable.isRun())
-            return;
-         PagingManager pagingManager = manager.getServer().getPagingManager();
-         creditRunnable = new CreditRunnable() {
-            boolean isRun = false;
-            @Override
-            public boolean isRun() {
-               return isRun;
+         if (address == null) {
+            synchronized (connection.getLock()) {
+               receiver.flow(credits);
+               connection.flush();
             }
-
+            return;
+         }
+         final PagingStore store = manager.getServer().getPagingManager().getPageStore(new SimpleString(address));
+         store.checkMemory(new Runnable() {
             @Override
             public void run() {
-               connection.lock();
-               try {
-                  if (receiver.getCredit() <= threshold) {
-                     int topUp = credits - receiver.getCredit();
-                     if (topUp > 0) {
-                        receiver.flow(topUp);
-                     }
+               synchronized (connection.getLock()) {
+                  if (receiver.getRemoteCredit() < threshold) {
+                     receiver.flow(credits);
+                     connection.flush();
                   }
-               } finally {
-                  isRun = true;
-                  connection.unlock();
                }
-               connection.flush();
             }
-         };
-
-         if (address == null) {
-            pagingManager.checkMemory(creditRunnable);
-         } else {
-            final PagingStore store = manager.getServer().getPagingManager().getPageStore(address);
-            store.checkMemory(creditRunnable);
-         }
+         });
       } catch (Exception e) {
          throw new RuntimeException(e);
       }
    }
 
-   public void deleteQueue(SimpleString queueName) throws Exception {
-      manager.getServer().destroyQueue(queueName);
+   public void deleteQueue(String queueName) throws Exception {
+      manager.getServer().destroyQueue(new SimpleString(queueName));
    }
 
-   public void resetContext(OperationContext oldContext) {
-      storageManager.setContext(oldContext);
+   private void resetContext() {
+      manager.getServer().getStorageManager().setContext(null);
    }
 
-   public OperationContext recoverContext() {
-
-      OperationContext oldContext = storageManager.getContext();
+   private void recoverContext() {
       manager.getServer().getStorageManager().setContext(serverSession.getSessionContext());
-      return oldContext;
    }
 
    @Override
@@ -655,19 +492,18 @@ public class AMQPSessionCallback implements SessionCallback {
    }
 
    @Override
-   public int sendMessage(MessageReference ref, Message message, ServerConsumer consumer, int deliveryCount) {
+   public int sendMessage(MessageReference ref, ServerMessage message, ServerConsumer consumer, int deliveryCount) {
+
+      message.removeProperty(ActiveMQConnection.CONNECTION_ID_PROPERTY_NAME.toString());
 
       ProtonServerSenderContext plugSender = (ProtonServerSenderContext) consumer.getProtocolContext();
 
       try {
-         return plugSender.deliverMessage(ref, deliveryCount, transportConnection);
+         return plugSender.deliverMessage(message, deliveryCount);
       } catch (Exception e) {
-         connection.lock();
-         try {
+         synchronized (connection.getLock()) {
             plugSender.getSender().setCondition(new ErrorCondition(AmqpError.INTERNAL_ERROR, e.getMessage()));
             connection.flush();
-         } finally {
-            connection.unlock();
          }
          throw new IllegalStateException("Can't deliver message " + e, e);
       }
@@ -676,7 +512,7 @@ public class AMQPSessionCallback implements SessionCallback {
 
    @Override
    public int sendLargeMessage(MessageReference ref,
-                               Message message,
+                               ServerMessage message,
                                ServerConsumer consumer,
                                long bodySize,
                                int deliveryCount) {
@@ -696,16 +532,15 @@ public class AMQPSessionCallback implements SessionCallback {
    }
 
    @Override
-   public void disconnect(ServerConsumer consumer, SimpleString queueName) {
+   public void disconnect(ServerConsumer consumer, String queueName) {
       ErrorCondition ec = new ErrorCondition(AmqpSupport.RESOURCE_DELETED, "Queue was deleted: " + queueName);
-      connection.lock();
       try {
-         ((ProtonServerSenderContext) consumer.getProtocolContext()).close(ec);
-         connection.flush();
+         synchronized (connection.getLock()) {
+            ((ProtonServerSenderContext) consumer.getProtocolContext()).close(ec);
+            connection.flush();
+         }
       } catch (ActiveMQAMQPException e) {
          logger.error("Error closing link for " + consumer.getQueue().getAddress());
-      } finally {
-         connection.unlock();
       }
    }
 
@@ -720,78 +555,41 @@ public class AMQPSessionCallback implements SessionCallback {
       }
    }
 
-   public Transaction getTransaction(Binary txid, boolean remove) throws ActiveMQAMQPException {
-      return protonSPI.getTransaction(txid, remove);
+   public Transaction getTransaction(Binary txid) throws ActiveMQAMQPException {
+      return protonSPI.getTransaction(txid);
    }
 
    public Binary newTransaction() {
       return protonSPI.newTransaction();
    }
 
-   public SimpleString getMatchingQueue(SimpleString address, RoutingType routingType) throws Exception {
-      return serverSession.getMatchingQueue(address, routingType);
-   }
-
-   public SimpleString getMatchingQueue(SimpleString address,
-                                        SimpleString queueName,
-                                        RoutingType routingType) throws Exception {
-      return serverSession.getMatchingQueue(address, queueName, routingType);
+   public void commitTX(Binary txid) throws Exception {
+      Transaction tx = protonSPI.getTransaction(txid);
+      tx.commit(true);
+      protonSPI.removeTransaction(txid);
    }
 
-   public AddressInfo getAddress(SimpleString address) {
-      return serverSession.getAddress(address);
-   }
-
-   public void removeTemporaryQueue(SimpleString address) throws Exception {
-      serverSession.deleteQueue(address);
-   }
+   public void rollbackTX(Binary txid, boolean lastMessageReceived) throws Exception {
+      Transaction tx = protonSPI.getTransaction(txid);
+      tx.rollback();
+      protonSPI.removeTransaction(txid);
 
-   public RoutingType getDefaultRoutingType(SimpleString address) {
-      return manager.getServer().getAddressSettingsRepository().getMatch(address.toString()).getDefaultAddressRoutingType();
    }
 
-   public void check(SimpleString address, CheckType checkType, SecurityAuth session) throws Exception {
-      manager.getServer().getSecurityStore().check(address, checkType, session);
-   }
-
-   public void invokeIncoming(AMQPMessage message, ActiveMQProtonRemotingConnection connection) {
-      protonSPI.invokeIncomingInterceptors(message, connection);
+   public SimpleString getMatchingQueue(SimpleString address, RoutingType routingType) throws Exception {
+      return serverSession.getMatchingQueue(address, routingType);
    }
 
-   public void invokeOutgoing(AMQPMessage message, ActiveMQProtonRemotingConnection connection) {
-      protonSPI.invokeOutgoingInterceptors(message, connection);
-   }
 
-   public void addProducer(ServerProducer serverProducer) {
-      serverSession.addProducer(serverProducer);
+   public SimpleString getMatchingQueue(SimpleString address, SimpleString queueName, RoutingType routingType) throws Exception {
+      return serverSession.getMatchingQueue(address, queueName, routingType);
    }
 
-   public void removeProducer(String name) {
-      serverSession.removeProducer(name);
+   public AddressInfo getAddress(SimpleString address) {
+      return  serverSession.getAddress(address);
    }
 
-
-   class AddressQueryCache<T> {
-      SimpleString address;
-      T result;
-
-      public synchronized T getResult(SimpleString parameterAddress) {
-         if (address != null && address.equals(parameterAddress)) {
-            return result;
-         } else {
-            result = null;
-            address = null;
-            return null;
-         }
-      }
-
-      public synchronized void setResult(SimpleString parameterAddress, T result) {
-         this.address = parameterAddress;
-         this.result = result;
-      }
-
-   }
-   interface CreditRunnable extends Runnable {
-      boolean isRun();
+   public void removeTemporaryQueue(String address) throws Exception {
+      serverSession.deleteQueue(SimpleString.toSimpleString(address));
    }
 }