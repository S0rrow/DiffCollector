diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
index 803881538..e960c2f67 100755
--- a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
@@ -18,16 +18,14 @@
 
 package org.apache.atlas.repository.graph;
 
-import java.math.BigDecimal;
-import java.math.BigInteger;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-import javax.inject.Inject;
-
+import com.thinkaurelius.titan.core.Cardinality;
+import com.thinkaurelius.titan.core.PropertyKey;
+import com.thinkaurelius.titan.core.TitanGraph;
+import com.thinkaurelius.titan.core.schema.Mapping;
+import com.thinkaurelius.titan.core.schema.TitanGraphIndex;
+import com.thinkaurelius.titan.core.schema.TitanManagement;
+import com.tinkerpop.blueprints.Edge;
+import com.tinkerpop.blueprints.Vertex;
 import org.apache.atlas.ApplicationProperties;
 import org.apache.atlas.AtlasException;
 import org.apache.atlas.discovery.SearchIndexer;
@@ -37,11 +35,6 @@ import org.apache.atlas.repository.Constants;
 import org.apache.atlas.repository.IndexCreationException;
 import org.apache.atlas.repository.IndexException;
 import org.apache.atlas.repository.RepositoryException;
-import org.apache.atlas.repository.graphdb.AtlasCardinality;
-import org.apache.atlas.repository.graphdb.AtlasGraph;
-import org.apache.atlas.repository.graphdb.AtlasGraphIndex;
-import org.apache.atlas.repository.graphdb.AtlasGraphManagement;
-import org.apache.atlas.repository.graphdb.AtlasPropertyKey;
 import org.apache.atlas.typesystem.types.AttributeInfo;
 import org.apache.atlas.typesystem.types.ClassType;
 import org.apache.atlas.typesystem.types.DataTypes;
@@ -53,8 +46,13 @@ import org.apache.commons.configuration.Configuration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.annotations.VisibleForTesting;
-
+import javax.inject.Inject;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
 
 /**
  * Adds index for properties of a given type when its added before any instances are added.
@@ -62,46 +60,33 @@ import com.google.common.annotations.VisibleForTesting;
 public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler {
 
     private static final Logger LOG = LoggerFactory.getLogger(GraphBackedSearchIndexer.class);
-    
-    private static final List<Class> VERTEX_INDEX_EXCLUSIONS = new ArrayList() {
-        {
+
+    private final TitanGraph titanGraph;
+
+    List<Class> MIXED_INDEX_EXCLUSIONS = new ArrayList() {{
             add(Boolean.class);
             add(BigDecimal.class);
             add(BigInteger.class);
-        }
-    };
-    
-    //allows injection of a dummy graph for testing
-    private IAtlasGraphProvider provider;
-    
+        }};
+
     @Inject
-    public GraphBackedSearchIndexer() throws RepositoryException, AtlasException {
-        this(new AtlasGraphProvider(), ApplicationProperties.get());
+    public GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider) throws AtlasException {
+        this(graphProvider, ApplicationProperties.get());
     }
 
-    @VisibleForTesting
-    GraphBackedSearchIndexer( IAtlasGraphProvider provider, Configuration configuration)
+    GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider, Configuration configuration)
             throws IndexException, RepositoryException {
-        this.provider = provider;
+        this.titanGraph = graphProvider.get();
         if (!HAConfiguration.isHAEnabled(configuration)) {
-            initialize(provider.get());
+            initialize();
         }
     }
 
     /**
-     * Initializes the indices for the graph - create indices for Global AtlasVertex Keys
+     * Initializes the indices for the graph - create indices for Global Vertex Keys
      */
     private void initialize() throws RepositoryException, IndexException {
-        
-        initialize(provider.get());    
-    }
-    
-    /**
-     * Initializes the indices for the graph - create indices for Global AtlasVertex Keys
-     */
-    private void initialize(AtlasGraph graph) throws RepositoryException, IndexException {
-        AtlasGraphManagement management = graph.getManagementSystem();
-
+        TitanManagement management = titanGraph.getManagementSystem();
         try {
             if (management.containsPropertyKey(Constants.VERTEX_TYPE_PROPERTY_KEY)) {
                 LOG.info("Global indexes already exist for graph");
@@ -109,49 +94,41 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                 return;
             }
 
-            /* This is called only once, which is the first time Atlas types are made indexable .*/
-            LOG.info("Indexes do not exist, Creating indexes for graph.");
-
-            
-            management.createVertexIndex(Constants.VERTEX_INDEX, Constants.BACKING_INDEX, Collections.<AtlasPropertyKey>emptyList());              
-            management.createEdgeIndex(Constants.EDGE_INDEX, Constants.BACKING_INDEX);
+        /* This is called only once, which is the first time Atlas types are made indexable .*/
+            LOG.info("Indexes do not exist, Creating indexes for titanGraph.");
+            management.buildIndex(Constants.VERTEX_INDEX, Vertex.class).buildMixedIndex(Constants.BACKING_INDEX);
+            management.buildIndex(Constants.EDGE_INDEX, Edge.class).buildMixedIndex(Constants.BACKING_INDEX);
 
             // create a composite index for guid as its unique
             createIndexes(management, Constants.GUID_PROPERTY_KEY, String.class, true,
-                    AtlasCardinality.SINGLE, true, true);
-
-            // create a composite index for entity creation timestamp
-            createIndexes(management, Constants.TIMESTAMP_PROPERTY_KEY, Long.class, false, AtlasCardinality.SINGLE, true, true);
+                    Cardinality.SINGLE, true);
 
-            // create a mixed index for entity state. Set systemProperty flag deliberately to false
-            // so that it doesnt create a composite index which has issues with
-            // titan 0.5.4 - Refer https://groups.google.com/forum/#!searchin/aureliusgraphs/hemanth/aureliusgraphs/bx7T843mzXU/fjAsclx7GAAJ
-            createIndexes(management, Constants.STATE_PROPERTY_KEY, String.class, false, AtlasCardinality.SINGLE, false, false);
+            // create a composite index for entity state
+            createIndexes(management, Constants.TIMESTAMP_PROPERTY_KEY, Long.class, false, Cardinality.SINGLE, true);
 
-            // create a composite index for entity modification timestamp
+            // create a composite index for entity state
             createIndexes(management, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY, Long.class, false,
-                    AtlasCardinality.SINGLE, false, false);
+                    Cardinality.SINGLE, true);
 
             // create a composite and mixed index for type since it can be combined with other keys
-            createIndexes(management, Constants.ENTITY_TYPE_PROPERTY_KEY, String.class, false, AtlasCardinality.SINGLE,
-                    true, true);
+            createIndexes(management, Constants.ENTITY_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE,
+                    true);
 
             // create a composite and mixed index for type since it can be combined with other keys
-            createIndexes(management, Constants.SUPER_TYPES_PROPERTY_KEY, String.class, false, AtlasCardinality.SET,
-                    true, true);
+            createIndexes(management, Constants.SUPER_TYPES_PROPERTY_KEY, String.class, false, Cardinality.SET,
+                    true);
 
             // create a composite and mixed index for traitNames since it can be combined with other
             // keys. Traits must be a set and not a list.
-            createIndexes(management, Constants.TRAIT_NAMES_PROPERTY_KEY, String.class, false, AtlasCardinality.SET,
-                    true, true);
+            createIndexes(management, Constants.TRAIT_NAMES_PROPERTY_KEY, String.class, false, Cardinality.SET,
+                    true);
 
             // Index for full text search
             createFullTextIndex(management);
 
             //Indexes for graph backed type system store
             createTypeStoreIndexes(management);
-      
-            
+
             commit(management);
             LOG.info("Index creation for global keys complete.");
         } catch (Throwable t) {
@@ -159,24 +136,25 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
             throw new RepositoryException(t);
         }
     }
-   
-
-    private void createFullTextIndex(AtlasGraphManagement management) {
-        AtlasPropertyKey fullText =
-                management.makePropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY, String.class, AtlasCardinality.SINGLE);
 
-        management.createFullTextIndex(Constants.FULLTEXT_INDEX, fullText, Constants.BACKING_INDEX);
+    private void createFullTextIndex(TitanManagement management) {
+        PropertyKey fullText =
+                management.makePropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY).dataType(String.class).make();
 
+        management.buildIndex(Constants.FULLTEXT_INDEX, Vertex.class)
+                .addKey(fullText, com.thinkaurelius.titan.core.schema.Parameter.of("mapping", Mapping.TEXT))
+                .buildMixedIndex(Constants.BACKING_INDEX);
+        LOG.info("Created mixed index for {}", Constants.ENTITY_TEXT_PROPERTY_KEY);
     }
 
-    private void createTypeStoreIndexes(AtlasGraphManagement management) {
+    private void createTypeStoreIndexes(TitanManagement management) {
         //Create unique index on typeName
-        createIndexes(management, Constants.TYPENAME_PROPERTY_KEY, String.class, true, AtlasCardinality.SINGLE,
-                true, true);
+        createIndexes(management, Constants.TYPENAME_PROPERTY_KEY, String.class, true, Cardinality.SINGLE,
+                true);
 
         //create index on vertex type
-        createIndexes(management, Constants.VERTEX_TYPE_PROPERTY_KEY, String.class, false, AtlasCardinality.SINGLE,
-                true, true);
+        createIndexes(management, Constants.VERTEX_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE,
+                true);
     }
 
     /**
@@ -187,13 +165,12 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
      */
     @Override
     public void onAdd(Collection<? extends IDataType> dataTypes) throws AtlasException {
-        AtlasGraphManagement management = provider.get().getManagementSystem();
-               
+        TitanManagement management = titanGraph.getManagementSystem();
         for (IDataType dataType : dataTypes) {
-            LOG.debug("Creating indexes for type name={}, definition={}", dataType.getName(), dataType.getClass());
+            LOG.info("Creating indexes for type name={}, definition={}", dataType.getName(), dataType.getClass());
             try {
                 addIndexForType(management, dataType);
-                LOG.info("Index creation for type {} complete", dataType.getName());
+                LOG.debug("Index creation for type {} complete", dataType.getName());
             } catch (Throwable throwable) {
                 LOG.error("Error creating index for type {}", dataType, throwable);
                 //Rollback indexes if any failure
@@ -211,7 +188,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         onAdd(dataTypes);
     }
 
-    private void addIndexForType(AtlasGraphManagement management, IDataType dataType) {
+    private void addIndexForType(TitanManagement management, IDataType dataType) {
         switch (dataType.getTypeCategory()) {
         case PRIMITIVE:
         case ENUM:
@@ -241,24 +218,26 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    private void createIndexForFields(AtlasGraphManagement management, IDataType dataType, Map<String, AttributeInfo> fields) {
+    private void createIndexForFields(TitanManagement management, IDataType dataType, Map<String, AttributeInfo> fields) {
         for (AttributeInfo field : fields.values()) {
-            createIndexForAttribute(management, dataType.getName(), field);
+            if (field.isIndexable) {
+                createIndexForAttribute(management, dataType.getName(), field);
+            }
         }
     }
 
-    private void createIndexForAttribute(AtlasGraphManagement management, String typeName, AttributeInfo field) {
+    private void createIndexForAttribute(TitanManagement management, String typeName, AttributeInfo field) {
         final String propertyName = GraphHelper.encodePropertyKey(typeName + "." + field.name);
         switch (field.dataType().getTypeCategory()) {
         case PRIMITIVE:
-            AtlasCardinality cardinality = getCardinality(field.multiplicity);
+            Cardinality cardinality = getCardinality(field.multiplicity);
             createIndexes(management, propertyName, getPrimitiveClass(field.dataType()), field.isUnique,
-                    cardinality, false, field.isIndexable);
+                    cardinality, false);
             break;
 
         case ENUM:
             cardinality = getCardinality(field.multiplicity);
-            createIndexes(management, propertyName, String.class, field.isUnique, cardinality, false, field.isIndexable);
+            createIndexes(management, propertyName, String.class, field.isUnique, cardinality, false);
             break;
 
         case ARRAY:
@@ -316,119 +295,72 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
         throw new IllegalArgumentException("unknown data type " + dataType);
     }
-  
 
-    private AtlasCardinality getCardinality(Multiplicity multiplicity) {
+
+    private Cardinality getCardinality(Multiplicity multiplicity) {
         if (multiplicity == Multiplicity.OPTIONAL || multiplicity == Multiplicity.REQUIRED) {
-            return AtlasCardinality.SINGLE;
+            return Cardinality.SINGLE;
         } else if (multiplicity == Multiplicity.COLLECTION) {
-            return AtlasCardinality.LIST;
+            return Cardinality.LIST;
         } else if (multiplicity == Multiplicity.SET) {
-            return AtlasCardinality.SET;
+            return Cardinality.SET;
         }
 
         // todo - default to LIST as this is the most forgiving
-        return AtlasCardinality.LIST;
+        return Cardinality.LIST;
     }
-    
-    private AtlasPropertyKey createIndexes(AtlasGraphManagement management, String propertyName, Class propertyClass,
-            boolean isUnique, AtlasCardinality cardinality, boolean createCompositeForAttribute,
-            boolean createCompositeWithTypeandSuperTypes) {
 
-        AtlasPropertyKey propertyKey = management.getPropertyKey(propertyName);
+    private PropertyKey createIndexes(TitanManagement management, String propertyName,
+                                      Class propertyClass, boolean isUnique, Cardinality cardinality,
+                                      boolean isSystemProperty) {
+        PropertyKey propertyKey = management.getPropertyKey(propertyName);
         if (propertyKey == null) {
-            propertyKey = management.makePropertyKey(propertyName, propertyClass, cardinality);
+            propertyKey = management.makePropertyKey(propertyName).dataType(propertyClass).cardinality(cardinality)
+                    .make();
 
-            updateVertexIndex(management, propertyName, propertyClass, cardinality, propertyKey);
+            enhanceMixedIndex(management, propertyName, propertyClass, cardinality, propertyKey);
 
-        }
-
-        if (createCompositeForAttribute) {
-            createExactMatchIndex(management, propertyClass, propertyKey, isUnique);
-        } else if (createCompositeWithTypeandSuperTypes) {
-            // Index with typename since typename+property key queries need to
-            // speed up
-            createExactMatchIndexWithTypeName(management, propertyClass, propertyKey);
-            createExactMatchIndexWithSuperTypeName(management, propertyClass, propertyKey);
-        }
-        return propertyKey;
-    }
-    
-    private void createExactMatchIndex(AtlasGraphManagement management, Class propertyClass,
-            AtlasPropertyKey propertyKey, boolean enforceUniqueness) {
-        
-        String propertyName = propertyKey.getName();
-        LOG.debug("Creating composite index for property {} of type {} ", propertyName, propertyClass.getName());
-
-        AtlasGraphIndex existingIndex = management.getGraphIndex(propertyName);
-        if (existingIndex == null) {
-            if (enforceUniqueness) {
-                LOG.debug("Enabling unique index for property {} of type {} ", propertyName, propertyClass.getName());
+            if (isSystemProperty) {
+                createCompositeIndex(management, propertyName, propertyClass, propertyKey, isUnique);
+            } else if (isUnique) {
+                // send uniqueness as false because there can be many vertexes with the same property value
+                // but state can be active / deleted.
+                createCompositeIndex(management, propertyName, propertyClass, propertyKey, false);
             }
-            management.createExactMatchIndex(propertyName, enforceUniqueness, Collections.singletonList(propertyKey));
-
         }
-        LOG.info("Created composite index for property {} of type {} ", propertyName, propertyClass.getName());
-    }
-    
-
-    private void createExactMatchIndexWithTypeName(AtlasGraphManagement management,
-            Class propertyClass, AtlasPropertyKey propertyKey) {
-        createExactMatchIndexWithSystemProperty(management, propertyClass, propertyKey,
-                Constants.ENTITY_TYPE_PROPERTY_KEY, AtlasCardinality.SINGLE);
-    }
-
-    private void createExactMatchIndexWithSuperTypeName(AtlasGraphManagement management,
-            Class propertyClass, AtlasPropertyKey propertyKey) {
-        createExactMatchIndexWithSystemProperty(management, propertyClass, propertyKey,
-                Constants.SUPER_TYPES_PROPERTY_KEY, AtlasCardinality.SET);
+        return propertyKey;
     }
 
-    private void createExactMatchIndexWithSystemProperty(AtlasGraphManagement management,
-            Class propertyClass, AtlasPropertyKey propertyKey, final String systemPropertyKey,
-            AtlasCardinality cardinality) {
-
-        LOG.debug("Creating composite index for property {} of type {} and {}", propertyKey.getName(), propertyClass.getName(),
-                systemPropertyKey);
-
-        AtlasPropertyKey typePropertyKey = management.getPropertyKey(systemPropertyKey);
-        if (typePropertyKey == null) {
-            typePropertyKey = management.makePropertyKey(systemPropertyKey, String.class, cardinality);
-        }
-
-        final String indexName = propertyKey.getName() + systemPropertyKey;
-        AtlasGraphIndex existingIndex = management.getGraphIndex(indexName);
-
-        if (existingIndex == null) {
-            
-            List<AtlasPropertyKey> keys = new ArrayList<AtlasPropertyKey>(2);
-            keys.add(propertyKey);
-            keys.add(typePropertyKey);
-            management.createExactMatchIndex(indexName, false, keys);
-
-            LOG.info("Created composite index for property {} of type {} and {}", propertyKey.getName(), propertyClass.getName(),
-                    systemPropertyKey);
+    private void createCompositeIndex(TitanManagement management, String propertyName, Class propertyClass,
+                                      PropertyKey propertyKey, boolean enforceUniqueness) {
+        LOG.debug("Creating composite index for property {} of type {} ", propertyName,
+                propertyClass.getName());
+        TitanManagement.IndexBuilder indexBuilder =
+                management.buildIndex(propertyName, Vertex.class).addKey(propertyKey);
+        if (enforceUniqueness) {
+            indexBuilder.unique();
         }
+        indexBuilder.buildCompositeIndex();
+        LOG.debug("Created composite index for property {} of type {} ", propertyName, propertyClass.getName());
     }
 
-    private void updateVertexIndex(AtlasGraphManagement management, String propertyName, Class propertyClass,
-            AtlasCardinality cardinality, AtlasPropertyKey propertyKey) {
-        if (checkIfVertexIndexApplicable(propertyClass, cardinality)) {
-            // Use backing index
-            management.addVertexIndexKey(Constants.VERTEX_INDEX, propertyKey);
+    private void enhanceMixedIndex(TitanManagement management, String propertyName, Class propertyClass,
+                                   Cardinality cardinality, PropertyKey propertyKey) {
+        if (checkIfMixedIndexApplicable(propertyClass, cardinality)) {
+            //Use backing index
             LOG.debug("Creating backing index for property {} of type {} ", propertyName, propertyClass.getName());
-
-            LOG.info("Created backing index for property {} of type {} ", propertyName, propertyClass.getName());
+            TitanGraphIndex vertexIndex = management.getGraphIndex(Constants.VERTEX_INDEX);
+            management.addIndexKey(vertexIndex, propertyKey);
+            LOG.debug("Created backing index for property {} of type {} ", propertyName, propertyClass.getName());
         }
     }
 
-    private boolean checkIfVertexIndexApplicable(Class propertyClass, AtlasCardinality cardinality) {
-        return !(VERTEX_INDEX_EXCLUSIONS.contains(propertyClass) || cardinality.isMany());
+    private boolean checkIfMixedIndexApplicable(Class propertyClass, Cardinality cardinality) {
+        return !(MIXED_INDEX_EXCLUSIONS.contains(propertyClass) || cardinality == Cardinality.LIST || cardinality ==
+                Cardinality.SET);
     }
-    
-
 
-    private void commit(AtlasGraphManagement management) throws IndexException {
+    public void commit(TitanManagement management) throws IndexException {
         try {
             management.commit();
         } catch (Exception e) {
@@ -437,7 +369,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    private void rollback(AtlasGraphManagement management) throws IndexException {
+    public void rollback(TitanManagement management) throws IndexException {
         try {
             management.rollback();
         } catch (Exception e) {
@@ -467,7 +399,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
     public void instanceIsPassive() {
         LOG.info("Reacting to passive state: No action right now.");
     }
-    
+
     /* Commenting this out since we do not need an index for edge label here
     private void createEdgeMixedIndex(String propertyName) {
         EdgeLabel edgeLabel = management.getEdgeLabel(propertyName);