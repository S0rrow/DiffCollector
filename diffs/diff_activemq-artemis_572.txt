diff --git a/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompSession.java b/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompSession.java
index 2a853a07a8..227b2337da 100644
--- a/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompSession.java
+++ b/artemis-protocols/artemis-stomp-protocol/src/main/java/org/apache/activemq/artemis/core/protocol/stomp/StompSession.java
@@ -19,9 +19,7 @@ package org.apache.activemq.artemis.core.protocol.stomp;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
-import java.util.concurrent.BlockingDeque;
 import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.LinkedBlockingDeque;
 import java.util.zip.Inflater;
 
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
@@ -35,7 +33,6 @@ import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.persistence.impl.journal.LargeServerMessageImpl;
 import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;
 import org.apache.activemq.artemis.core.server.LargeServerMessage;
-import org.apache.activemq.artemis.core.server.MessageReference;
 import org.apache.activemq.artemis.core.server.QueueQueryResult;
 import org.apache.activemq.artemis.core.server.ServerConsumer;
 import org.apache.activemq.artemis.core.server.ServerMessage;
@@ -46,7 +43,6 @@ import org.apache.activemq.artemis.spi.core.protocol.RemotingConnection;
 import org.apache.activemq.artemis.spi.core.protocol.SessionCallback;
 import org.apache.activemq.artemis.spi.core.remoting.ReadyListener;
 import org.apache.activemq.artemis.utils.ConfigurationHelper;
-import org.apache.activemq.artemis.utils.PendingTask;
 import org.apache.activemq.artemis.utils.UUIDGenerator;
 
 import static org.apache.activemq.artemis.core.protocol.stomp.ActiveMQStompProtocolMessageBundle.BUNDLE;
@@ -61,12 +57,10 @@ public class StompSession implements SessionCallback {
 
    private final OperationContext sessionContext;
 
-   private final BlockingDeque<PendingTask> afterDeliveryTasks = new LinkedBlockingDeque<>();
-
-   private final Map<Long, StompSubscription> subscriptions = new ConcurrentHashMap<>();
+   private final Map<Long, StompSubscription> subscriptions = new ConcurrentHashMap<Long, StompSubscription>();
 
    // key = message ID, value = consumer ID
-   private final Map<Long, Pair<Long, Integer>> messagesToAck = new ConcurrentHashMap<>();
+   private final Map<Long, Pair<Long, Integer>> messagesToAck = new ConcurrentHashMap<Long, Pair<Long, Integer>>();
 
    private volatile boolean noLocal = false;
 
@@ -79,11 +73,6 @@ public class StompSession implements SessionCallback {
       this.consumerCredits = ConfigurationHelper.getIntProperty(TransportConstants.STOMP_CONSUMERS_CREDIT, TransportConstants.STOMP_DEFAULT_CONSUMERS_CREDIT, connection.getAcceptorUsed().getConfiguration());
    }
 
-   @Override
-   public boolean isWritable(ReadyListener callback) {
-      return connection.isWritable(callback);
-   }
-
    void setServerSession(ServerSession session) {
       this.session = session;
    }
@@ -97,34 +86,13 @@ public class StompSession implements SessionCallback {
       return true;
    }
 
-   @Override
    public void sendProducerCreditsMessage(int credits, SimpleString address) {
    }
 
-   @Override
    public void sendProducerCreditsFailMessage(int credits, SimpleString address) {
    }
 
-   @Override
-   public void afterDelivery() throws Exception {
-      PendingTask task;
-      while ((task = afterDeliveryTasks.poll()) != null) {
-         task.run();
-      }
-   }
-
-   @Override
-   public void browserFinished(ServerConsumer consumer) {
-
-   }
-
-   @Override
-   public boolean updateDeliveryCountAfterCancel(ServerConsumer consumer, MessageReference ref, boolean failed) {
-      return false;
-   }
-
-   @Override
-   public int sendMessage(MessageReference ref, ServerMessage serverMessage, final ServerConsumer consumer, int deliveryCount) {
+   public int sendMessage(ServerMessage serverMessage, ServerConsumer consumer, int deliveryCount) {
       LargeServerMessageImpl largeMessage = null;
       ServerMessage newServerMessage = serverMessage;
       try {
@@ -168,24 +136,13 @@ public class StompSession implements SessionCallback {
 
          if (subscription.getAck().equals(Stomp.Headers.Subscribe.AckModeValues.AUTO)) {
             if (manager.send(connection, frame)) {
-               final long messageID = newServerMessage.getMessageID();
-               final long consumerID = consumer.getID();
-
-               // this will be called after the delivery is complete
-               // we can't call sesison.ack within the delivery
-               // as it could dead lock.
-               afterDeliveryTasks.offer(new PendingTask() {
-                  @Override
-                  public void run() throws Exception {
-                     //we ack and commit only if the send is successful
-                     session.acknowledge(consumerID, messageID);
-                     session.commit();
-                  }
-               });
+               //we ack and commit only if the send is successful
+               session.acknowledge(consumer.getID(), newServerMessage.getMessageID());
+               session.commit();
             }
          }
          else {
-            messagesToAck.put(newServerMessage.getMessageID(), new Pair<>(consumer.getID(), length));
+            messagesToAck.put(newServerMessage.getMessageID(), new Pair<Long, Integer>(consumer.getID(), length));
             // Must send AFTER adding to messagesToAck - or could get acked from client BEFORE it's been added!
             manager.send(connection, frame);
          }
@@ -204,7 +161,6 @@ public class StompSession implements SessionCallback {
 
    }
 
-   @Override
    public int sendLargeMessageContinuation(ServerConsumer consumer,
                                            byte[] body,
                                            boolean continues,
@@ -212,15 +168,21 @@ public class StompSession implements SessionCallback {
       return 0;
    }
 
-   @Override
-   public int sendLargeMessage(MessageReference ref, ServerMessage msg, ServerConsumer consumer, long bodySize, int deliveryCount) {
+   public int sendLargeMessage(ServerMessage msg, ServerConsumer consumer, long bodySize, int deliveryCount) {
       return 0;
    }
 
-   @Override
    public void closed() {
    }
 
+   public void addReadyListener(final ReadyListener listener) {
+      connection.getTransportConnection().addReadyListener(listener);
+   }
+
+   public void removeReadyListener(final ReadyListener listener) {
+      connection.getTransportConnection().removeReadyListener(listener);
+   }
+
    @Override
    public void disconnect(ServerConsumer consumerId, String queueName) {
       StompSubscription stompSubscription = subscriptions.remove(consumerId.getID());
@@ -306,10 +268,8 @@ public class StompSession implements SessionCallback {
       session.start();
    }
 
-   public boolean unsubscribe(String id, String durableSubscriptionName, String clientID) throws Exception {
-      boolean result = false;
+   public boolean unsubscribe(String id, String durableSubscriptionName) throws Exception {
       Iterator<Entry<Long, StompSubscription>> iterator = subscriptions.entrySet().iterator();
-
       while (iterator.hasNext()) {
          Map.Entry<Long, StompSubscription> entry = iterator.next();
          long consumerID = entry.getKey();
@@ -317,25 +277,21 @@ public class StompSession implements SessionCallback {
          if (id != null && id.equals(sub.getID())) {
             iterator.remove();
             session.closeConsumer(consumerID);
-            SimpleString queueName = SimpleString.toSimpleString(id);
+            SimpleString queueName;
+            if (durableSubscriptionName != null && durableSubscriptionName.trim().length() != 0) {
+               queueName = SimpleString.toSimpleString(id + "." + durableSubscriptionName);
+            }
+            else {
+               queueName = SimpleString.toSimpleString(id);
+            }
             QueueQueryResult query = session.executeQueueQuery(queueName);
             if (query.isExists()) {
                session.deleteQueue(queueName);
             }
-            result = true;
-         }
-      }
-
-      if (!result && durableSubscriptionName != null && clientID != null) {
-         SimpleString queueName = SimpleString.toSimpleString(clientID + "." + durableSubscriptionName);
-         QueueQueryResult query = session.executeQueueQuery(queueName);
-         if (query.isExists()) {
-            session.deleteQueue(queueName);
+            return true;
          }
-         result = true;
       }
-
-      return result;
+      return false;
    }
 
    boolean containsSubscription(String subscriptionID) {