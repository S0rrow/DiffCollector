diff --git a/archiva-modules/archiva-web/archiva-webdav/src/main/java/org/apache/maven/archiva/webdav/ArchivaDavResourceFactory.java b/archiva-modules/archiva-web/archiva-webdav/src/main/java/org/apache/maven/archiva/webdav/ArchivaDavResourceFactory.java
index 96effbba6..4c490ab93 100644
--- a/archiva-modules/archiva-web/archiva-webdav/src/main/java/org/apache/maven/archiva/webdav/ArchivaDavResourceFactory.java
+++ b/archiva-modules/archiva-web/archiva-webdav/src/main/java/org/apache/maven/archiva/webdav/ArchivaDavResourceFactory.java
@@ -19,84 +19,51 @@
  * under the License.
  */
 
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.List;
-
-import javax.servlet.http.HttpServletResponse;
-
-import org.apache.commons.io.FileUtils;
-import org.apache.commons.lang.StringUtils;
-import org.apache.jackrabbit.webdav.DavException;
-import org.apache.jackrabbit.webdav.DavResource;
-import org.apache.jackrabbit.webdav.DavResourceFactory;
-import org.apache.jackrabbit.webdav.DavResourceLocator;
-import org.apache.jackrabbit.webdav.DavServletRequest;
-import org.apache.jackrabbit.webdav.DavServletResponse;
-import org.apache.jackrabbit.webdav.DavSession;
-import org.apache.jackrabbit.webdav.lock.LockManager;
-import org.apache.jackrabbit.webdav.lock.SimpleLockManager;
-import org.apache.maven.archiva.common.utils.PathUtil;
-import org.apache.maven.archiva.configuration.ArchivaConfiguration;
-import org.apache.maven.archiva.configuration.RepositoryGroupConfiguration;
-import org.apache.maven.archiva.model.ArchivaRepositoryMetadata;
-import org.apache.maven.archiva.model.ArtifactReference;
-import org.apache.maven.archiva.policies.ProxyDownloadException;
-import org.apache.maven.archiva.proxy.RepositoryProxyConnectors;
+import com.opensymphony.xwork.ActionContext;
+import org.apache.jackrabbit.webdav.*;
 import org.apache.maven.archiva.repository.ManagedRepositoryContent;
-import org.apache.maven.archiva.repository.RepositoryContentFactory;
-import org.apache.maven.archiva.repository.RepositoryException;
 import org.apache.maven.archiva.repository.RepositoryNotFoundException;
-import org.apache.maven.archiva.repository.audit.AuditEvent;
+import org.apache.maven.archiva.repository.RepositoryException;
+import org.apache.maven.archiva.repository.RepositoryContentFactory;
+import org.apache.maven.archiva.repository.layout.LayoutException;
+import org.apache.maven.archiva.repository.content.RepositoryRequest;
 import org.apache.maven.archiva.repository.audit.AuditListener;
 import org.apache.maven.archiva.repository.audit.Auditable;
-import org.apache.maven.archiva.repository.content.RepositoryRequest;
-import org.apache.maven.archiva.repository.layout.LayoutException;
+import org.apache.maven.archiva.repository.audit.AuditEvent;
 import org.apache.maven.archiva.repository.metadata.MetadataTools;
 import org.apache.maven.archiva.repository.metadata.RepositoryMetadataException;
-import org.apache.maven.archiva.repository.metadata.RepositoryMetadataMerge;
-import org.apache.maven.archiva.repository.metadata.RepositoryMetadataReader;
-import org.apache.maven.archiva.repository.metadata.RepositoryMetadataWriter;
-import org.apache.maven.archiva.repository.scanner.RepositoryContentConsumers;
-import org.apache.maven.archiva.security.ServletAuthenticator;
+import org.apache.maven.archiva.webdav.util.WebdavMethodUtil;
 import org.apache.maven.archiva.webdav.util.MimeTypes;
 import org.apache.maven.archiva.webdav.util.RepositoryPathUtil;
-import org.apache.maven.archiva.webdav.util.WebdavMethodUtil;
+import org.apache.maven.archiva.proxy.RepositoryProxyConnectors;
+import org.apache.maven.archiva.common.utils.PathUtil;
+import org.apache.maven.archiva.configuration.ArchivaConfiguration;
+import org.apache.maven.archiva.configuration.RepositoryGroupConfiguration;
+import org.apache.maven.archiva.model.ArtifactReference;
+import org.apache.maven.archiva.model.ProjectReference;
+import org.apache.maven.archiva.model.VersionedReference;
+import org.apache.maven.archiva.policies.ProxyDownloadException;
+import org.apache.maven.archiva.security.ArchivaXworkUser;
 import org.apache.maven.model.DistributionManagement;
 import org.apache.maven.model.Model;
 import org.apache.maven.model.Relocation;
 import org.apache.maven.model.io.xpp3.MavenXpp3Reader;
-import org.codehaus.plexus.digest.ChecksumFile;
-import org.codehaus.plexus.digest.Digester;
-import org.codehaus.plexus.digest.DigesterException;
-import org.codehaus.plexus.redback.authentication.AuthenticationException;
-import org.codehaus.plexus.redback.authentication.AuthenticationResult;
-import org.codehaus.plexus.redback.authorization.AuthorizationException;
-import org.codehaus.plexus.redback.authorization.UnauthorizedException;
-import org.codehaus.plexus.redback.policy.AccountLockedException;
-import org.codehaus.plexus.redback.policy.MustChangePasswordException;
-import org.codehaus.plexus.redback.system.SecuritySession;
-import org.codehaus.plexus.redback.users.User;
-import org.codehaus.plexus.redback.users.UserManager;
 import org.codehaus.plexus.util.xml.pull.XmlPullParserException;
-import org.codehaus.redback.integration.filter.authentication.HttpAuthenticator;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import javax.servlet.http.HttpServletResponse;
+import java.util.ArrayList;
+import java.util.List;
+import java.io.*;
+
 /**
+ * @author <a href="mailto:james@atlassian.com">James William Dumay</a>
  * @plexus.component role="org.apache.maven.archiva.webdav.ArchivaDavResourceFactory"
  */
-public class ArchivaDavResourceFactory
-    implements DavResourceFactory, Auditable
+public class ArchivaDavResourceFactory implements DavResourceFactory, Auditable
 {
-    private static final String PROXIED_SUFFIX = " (proxied)";
-
-    private static final String HTTP_PUT_METHOD = "PUT";
-
-    private Logger log = LoggerFactory.getLogger( ArchivaDavResourceFactory.class );
+    private Logger log = LoggerFactory.getLogger(ArchivaDavResourceFactory.class);
 
     /**
      * @plexus.requirement role="org.apache.maven.archiva.repository.audit.AuditListener"
@@ -127,412 +94,205 @@
      * @plexus.requirement
      */
     private MimeTypes mimeTypes;
-
+    
+        
     /**
      * @plexus.requirement
      */
     private ArchivaConfiguration archivaConfiguration;
 
-    /**
-     * @plexus.requirement
-     */
-    private ServletAuthenticator servletAuth;
-
-    /**
-     * @plexus.requirement role-hint="basic"
-     */
-    private HttpAuthenticator httpAuth;
-
-    /**
-     * Lock Manager - use simple implementation from JackRabbit
-     */
-    private final LockManager lockManager = new SimpleLockManager();
-
-    /**
-     * @plexus.requirement
-     */
-    private RepositoryContentConsumers consumers;
-
-    /**
-     * @plexus.requirement
-     */
-    private ChecksumFile checksum;
-
-    /**
-     * @plexus.requirement role-hint="sha1"
-     */
-    private Digester digestSha1;
-
-    /**
-     * @plexus.requirement role-hint="md5";
-     */
-    private Digester digestMd5;
-
-    public DavResource createResource( final DavResourceLocator locator, final DavServletRequest request,
-                                       final DavServletResponse response )
-        throws DavException
-    {
-        ArchivaDavResourceLocator archivaLocator = checkLocatorIsInstanceOfRepositoryLocator( locator );
-
-        RepositoryGroupConfiguration repoGroupConfig =
-            archivaConfiguration.getConfiguration().getRepositoryGroupsAsMap().get( archivaLocator.getRepositoryId() );
-
-        String activePrincipal = getActivePrincipal( request );
-
-        List<String> resourcesInAbsolutePath = new ArrayList<String>();
-
-        boolean readMethod = WebdavMethodUtil.isReadMethod( request.getMethod() );
-        DavResource resource;
+    public DavResource createResource(final DavResourceLocator locator, final DavServletRequest request, final DavServletResponse response) throws DavException
+    {   
+        checkLocatorIsInstanceOfRepositoryLocator(locator);
+        ArchivaDavResourceLocator archivaLocator = (ArchivaDavResourceLocator)locator;
+        
+        RepositoryGroupConfiguration repoGroupConfig = archivaConfiguration.getConfiguration()
+                    .getRepositoryGroupsAsMap().get( ( (RepositoryLocator) locator).getRepositoryId() );
+                
+        List<String> repositories = new ArrayList<String>();
+        
         if ( repoGroupConfig != null )
         {
-            if ( !readMethod )
-            {
-                throw new DavException( HttpServletResponse.SC_METHOD_NOT_ALLOWED,
-                                        "Write method not allowed for repository groups." );
-            }
-
-            // handle browse requests for virtual repos
-            if ( RepositoryPathUtil.getLogicalResource( archivaLocator.getOrigResourcePath() ).endsWith( "/" ) )
-            {
-                return getResource( request, repoGroupConfig.getRepositories(), archivaLocator );
-            }
-            else
-            {
-                resource =
-                    processRepositoryGroup( locator, request, archivaLocator, repoGroupConfig.getRepositories(),
-                                            activePrincipal, readMethod, resourcesInAbsolutePath );
+            if ( RepositoryPathUtil.getLogicalResource( locator.getResourcePath() ).equals( "/" )
+                            || WebdavMethodUtil.isWriteMethod( request.getMethod() ) )
+            {                
+                throw new DavException( HttpServletResponse.SC_BAD_REQUEST, "Bad request to repository group <"
+                                        + repoGroupConfig.getId() + ">" );
             }
+            repositories.addAll( repoGroupConfig.getRepositories() );
         }
         else
-        {
-            ManagedRepositoryContent managedRepository = null;
+        {            
+            repositories.add( ( (RepositoryLocator) locator).getRepositoryId() );
+        }
 
+        DavResource resource = null;
+        DavException e = null;
+        
+        for ( String repositoryId : repositories )
+        {   
+            ManagedRepositoryContent managedRepository = null;
+            
             try
             {
-                managedRepository = repositoryFactory.getManagedRepositoryContent( archivaLocator.getRepositoryId() );
+                managedRepository = getManagedRepository( repositoryId );                
             }
-            catch ( RepositoryNotFoundException e )
-            {
-                throw new DavException( HttpServletResponse.SC_NOT_FOUND, "Invalid repository: "
-                    + archivaLocator.getRepositoryId() );
+            catch ( DavException de )
+            {                
+                throw new DavException( HttpServletResponse.SC_NOT_FOUND, "Invalid managed repository <" + repositoryId
+                        + ">" );
             }
-            catch ( RepositoryException e )
-            {
-                throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e );
-            }
-
-            resource =
-                processRepository( locator, request, archivaLocator, readMethod, activePrincipal,
-                                   archivaLocator.getRepositoryId(), managedRepository );
-
-            String logicalResource = RepositoryPathUtil.getLogicalResource( locator.getResourcePath() );
-            resourcesInAbsolutePath.add( managedRepository.getRepoRoot() + logicalResource );
-        }
-
-        String requestedResource = request.getRequestURI();
-
-        // MRM-872 : merge all available metadata
-        // merge metadata only when requested via the repo group
-        if ( ( repositoryRequest.isMetadata( requestedResource ) || ( requestedResource.endsWith( "metadata.xml.sha1" ) || requestedResource.endsWith( "metadata.xml.md5" ) ) )
-            && repoGroupConfig != null )
-        {
-            // this should only be at the project level not version level!
-            if ( isProjectReference( requestedResource ) )
-            {
-                String artifactId = StringUtils.substringBeforeLast( requestedResource.replace( '\\', '/' ), "/" );
-                artifactId = StringUtils.substringAfterLast( artifactId, "/" );
+             
+            if (!locator.getResourcePath().startsWith(ArchivaDavResource.HIDDEN_PATH_PREFIX))
+            {   
+                if (managedRepository != null)
+                {
+                    LogicalResource logicalResource = new LogicalResource(RepositoryPathUtil.getLogicalResource(locator.getResourcePath()));
+                    
+                    boolean isGet = WebdavMethodUtil.isReadMethod( request.getMethod() );
+                    boolean isPut = WebdavMethodUtil.isWriteMethod( request.getMethod() );
 
-                ArchivaDavResource res = (ArchivaDavResource) resource;
-                String filePath =
-                    StringUtils.substringBeforeLast( res.getLocalResource().getAbsolutePath().replace( '\\', '/' ), "/" );
-                filePath = filePath + "/maven-metadata-" + repoGroupConfig.getId() + ".xml";
+                    if (isGet)
+                    {
+                        resource = doGet(managedRepository, request, archivaLocator, logicalResource);
+                    }
 
-                // for MRM-872 handle checksums of the merged metadata files
-                if ( repositoryRequest.isSupportFile( requestedResource ) )
-                {
-                    File metadataChecksum =
-                        new File( filePath + "." + StringUtils.substringAfterLast( requestedResource, "." ) );
-                    if ( metadataChecksum.exists() )
+                    if (isPut)
                     {
-                        LogicalResource logicalResource =
-                            new LogicalResource( RepositoryPathUtil.getLogicalResource( locator.getResourcePath() ) );
-
-                        resource =
-                            new ArchivaDavResource( metadataChecksum.getAbsolutePath(), logicalResource.getPath(),
-                                                    null, request.getRemoteAddr(), activePrincipal,
-                                                    request.getDavSession(), archivaLocator, this, mimeTypes,
-                                                    auditListeners, consumers );
+                        resource = doPut(managedRepository, request, archivaLocator, logicalResource);
                     }
                 }
                 else
+                {                    
+                    e = new DavException(HttpServletResponse.SC_NOT_FOUND, "Repository does not exist");
+                }
+                
+                if (resource == null)
+                {                 
+                    e = new DavException(HttpServletResponse.SC_NOT_FOUND, "Repository does not exist");
+                }
+                else
                 {
-                    if ( resourcesInAbsolutePath != null && resourcesInAbsolutePath.size() > 1 )
-                    {
-                        // merge the metadata of all repos under group
-                        ArchivaRepositoryMetadata mergedMetadata = new ArchivaRepositoryMetadata();
-                        for ( String resourceAbsPath : resourcesInAbsolutePath )
-                        {
-                            try
-                            {
-                                File metadataFile = new File( resourceAbsPath );
-                                ArchivaRepositoryMetadata repoMetadata = RepositoryMetadataReader.read( metadataFile );
-                                mergedMetadata = RepositoryMetadataMerge.merge( mergedMetadata, repoMetadata );
-                            }
-                            catch ( RepositoryMetadataException r )
-                            {
-                                throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                                        "Error occurred while reading metadata file." );
-                            }
-                        }
-
-                        try
-                        {
-                            File resourceFile = writeMergedMetadataToFile( mergedMetadata, filePath );
-
-                            LogicalResource logicalResource =
-                                new LogicalResource( RepositoryPathUtil.getLogicalResource( locator.getResourcePath() ) );
-
-                            resource =
-                                new ArchivaDavResource( resourceFile.getAbsolutePath(), logicalResource.getPath(),
-                                                        null, request.getRemoteAddr(), activePrincipal,
-                                                        request.getDavSession(), archivaLocator, this, mimeTypes,
-                                                        auditListeners, consumers );
-                        }
-                        catch ( RepositoryMetadataException r )
-                        {
-                            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                                    "Error occurred while writing metadata file." );
-                        }
-                        catch ( IOException ie )
-                        {
-                            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                                    "Error occurred while generating checksum files." );
-                        }
-                        catch ( DigesterException de )
-                        {
-                            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                                    "Error occurred while generating checksum files." );
-                        }
+                    setHeaders(locator, response);
+                  
+                    //compatibility with MRM-440 to ensure browsing the repository works ok
+                    if (resource.isCollection() && !resource.getLocator().getResourcePath().endsWith("/"))
+                    {                        
+                        throw new BrowserRedirectException(resource.getHref());
                     }
-                }
+                    
+                    return resource;
+                }                
             }
-        }
+        }        
+        
+        throw e;
+    }
 
-        setHeaders( response, locator, resource );
+    public DavResource createResource(final DavResourceLocator locator, final DavSession davSession) throws DavException
+    {
+        checkLocatorIsInstanceOfRepositoryLocator(locator);
+        ArchivaDavResourceLocator archivaLocator = (ArchivaDavResourceLocator)locator;
 
-        // compatibility with MRM-440 to ensure browsing the repository works ok
-        if ( resource.isCollection() && !request.getRequestURI().endsWith( "/" ) )
+        DavResource resource = null;
+        if (!locator.getResourcePath().startsWith(ArchivaDavResource.HIDDEN_PATH_PREFIX))
         {
-            throw new BrowserRedirectException( resource.getHref() );
+            ManagedRepositoryContent managedRepository = getManagedRepository(archivaLocator.getRepositoryId());
+            String logicalResource = RepositoryPathUtil.getLogicalResource(locator.getResourcePath());
+            File resourceFile = new File ( managedRepository.getRepoRoot(), logicalResource);
+            resource = new ArchivaDavResource(resourceFile.getAbsolutePath(), logicalResource, mimeTypes, archivaLocator, this);                     
         }
-        resource.addLockManager( lockManager );
         return resource;
     }
 
-    private DavResource processRepositoryGroup( final DavResourceLocator locator, final DavServletRequest request,
-                                                ArchivaDavResourceLocator archivaLocator, List<String> repositories,
-                                                String activePrincipal, boolean readMethod,
-                                                List<String> resourcesInAbsolutePath )
-        throws DavException
+    private DavResource doGet(ManagedRepositoryContent managedRepository, DavServletRequest request, ArchivaDavResourceLocator locator, LogicalResource logicalResource) throws DavException
     {
-        DavResource resource = null;
-        DavException storedException = null;
+        File resourceFile = new File ( managedRepository.getRepoRoot(), logicalResource.getPath());
+        ArchivaDavResource resource = new ArchivaDavResource(resourceFile.getAbsolutePath(), logicalResource.getPath(), mimeTypes, locator, this);
 
-        for ( String repositoryId : repositories )
+        if ( !resource.isCollection() )
         {
-            ManagedRepositoryContent managedRepository = null;
+            // At this point the incoming request can either be in default or
+            // legacy layout format.
+            boolean fromProxy = fetchContentFromProxies(managedRepository, request, logicalResource );
+
+            boolean previouslyExisted = resourceFile.exists();
 
             try
             {
-                managedRepository = repositoryFactory.getManagedRepositoryContent( repositoryId );
-            }
-            catch ( RepositoryNotFoundException e )
-            {
-                throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e );
-            }
-            catch ( RepositoryException e )
-            {
-                throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e );
+                // Perform an adjustment of the resource to the managed
+                // repository expected path.
+                String localResourcePath = repositoryRequest.toNativePath( logicalResource.getPath(), managedRepository );
+                resourceFile = new File( managedRepository.getRepoRoot(), localResourcePath );
             }
-
-            try
+            catch ( LayoutException e )
             {
-                DavResource resource1 =
-                    processRepository( locator, request, archivaLocator, readMethod, activePrincipal, repositoryId,
-                                       managedRepository );
-                if ( resource == null )
+                if ( previouslyExisted )
                 {
-                    resource = resource1;
+                    return resource;
                 }
-
-                String logicalResource = RepositoryPathUtil.getLogicalResource( locator.getResourcePath() );
-                resourcesInAbsolutePath.add( managedRepository.getRepoRoot() + logicalResource );
-            }
-            catch ( DavException e )
-            {
-                storedException = e;
+                throw new DavException(HttpServletResponse.SC_NOT_FOUND, e);
             }
-        }
 
-        if ( resource == null )
-        {
-            if ( storedException != null )
+            // Attempt to fetch the resource from any defined proxy.
+            if ( fromProxy )
             {
-                throw storedException;
+                processAuditEvents(request, locator.getWorkspaceName(), logicalResource.getPath(), previouslyExisted, resourceFile, " (proxied)");
             }
-            else
+            resource = new ArchivaDavResource(resourceFile.getAbsolutePath(), logicalResource.getPath(), mimeTypes, locator, this);
+            
+            if ( !resourceFile.exists() )
             {
-                throw new DavException( HttpServletResponse.SC_NOT_FOUND );
+                resource = null;
             }
         }
         return resource;
     }
 
-    private DavResource processRepository( final DavResourceLocator locator, final DavServletRequest request,
-                                           ArchivaDavResourceLocator archivaLocator, boolean readMethod,
-                                           String activePrincipal, String repositoryId,
-                                           ManagedRepositoryContent managedRepository )
-        throws DavException
+    private DavResource doPut(ManagedRepositoryContent managedRepository, DavServletRequest request, ArchivaDavResourceLocator locator, LogicalResource logicalResource) throws DavException
     {
-        DavResource resource = null;
-        if ( isAuthorized( request, repositoryId ) )
-        {
-            LogicalResource logicalResource =
-                new LogicalResource( RepositoryPathUtil.getLogicalResource( locator.getResourcePath() ) );
-
-            File resourceFile = new File( managedRepository.getRepoRoot(), logicalResource.getPath() );
-            resource =
-                new ArchivaDavResource( resourceFile.getAbsolutePath(), logicalResource.getPath(),
-                                        managedRepository.getRepository(), request.getRemoteAddr(), activePrincipal,
-                                        request.getDavSession(), archivaLocator, this, mimeTypes, auditListeners,
-                                        consumers );
-
-            if ( readMethod )
-            {
-                if ( archivaLocator.getHref( false ).endsWith( "/" ) && !resourceFile.isDirectory() )
-                {
-                    // force a resource not found
-                    throw new DavException( HttpServletResponse.SC_NOT_FOUND, "Resource does not exist" );
-                }
-                else
-                {
-                    if ( !resource.isCollection() )
-                    {
-                        boolean previouslyExisted = resourceFile.exists();
-
-                        // Attempt to fetch the resource from any defined proxy.
-                        boolean fromProxy = fetchContentFromProxies( managedRepository, request, logicalResource );
-
-                        // At this point the incoming request can either be in default or
-                        // legacy layout format.
-                        try
-                        {
-                            // Perform an adjustment of the resource to the managed
-                            // repository expected path.
-                            String localResourcePath =
-                                repositoryRequest.toNativePath( logicalResource.getPath(), managedRepository );
-                            resourceFile = new File( managedRepository.getRepoRoot(), localResourcePath );
-                            resource =
-                                new ArchivaDavResource( resourceFile.getAbsolutePath(), logicalResource.getPath(),
-                                                        managedRepository.getRepository(), request.getRemoteAddr(),
-                                                        activePrincipal, request.getDavSession(), archivaLocator, this,
-                                                        mimeTypes, auditListeners, consumers );
-                        }
-                        catch ( LayoutException e1 )
-                        {
-                            if ( !resourceFile.exists() )
-                            {
-                                throw new DavException( HttpServletResponse.SC_NOT_FOUND, e1 );
-                            }
-                        }
-
-                        if ( fromProxy )
-                        {
-                            String repositoryId1 = archivaLocator.getRepositoryId();
-                            String event =
-                                ( previouslyExisted ? AuditEvent.MODIFY_FILE : AuditEvent.CREATE_FILE )
-                                    + PROXIED_SUFFIX;
-                            triggerAuditEvent( request.getRemoteAddr(), repositoryId1, logicalResource.getPath(),
-                                               event, activePrincipal );
-                        }
-
-                        if ( !resourceFile.exists() )
-                        {
-                            throw new DavException( HttpServletResponse.SC_NOT_FOUND, "Resource does not exist" );
-                        }
-                    }
-                }
-            }
+        /*
+         * Create parent directories that don't exist when writing a file
+         * This actually makes this implementation not compliant to the
+         * WebDAV RFC - but we have enough knowledge about how the
+         * collection is being used to do this reasonably and some versions
+         * of Maven's WebDAV don't correctly create the collections
+         * themselves.
+         */
 
-            if ( request.getMethod().equals( HTTP_PUT_METHOD ) )
-            {
-                /*
-                 * Create parent directories that don't exist when writing a file This actually makes this
-                 * implementation not compliant to the WebDAV RFC - but we have enough knowledge about how the
-                 * collection is being used to do this reasonably and some versions of Maven's WebDAV don't correctly
-                 * create the collections themselves.
-                 */
-
-                File rootDirectory = new File( managedRepository.getRepoRoot() );
-                File destDir = new File( rootDirectory, logicalResource.getPath() ).getParentFile();
-
-                if ( !destDir.exists() )
-                {
-                    destDir.mkdirs();
-                    String relPath = PathUtil.getRelative( rootDirectory.getAbsolutePath(), destDir );
-                    triggerAuditEvent( request.getRemoteAddr(), logicalResource.getPath(), relPath,
-                                       AuditEvent.CREATE_DIR, activePrincipal );
-                }
-            }
+        File rootDirectory = new File(managedRepository.getRepoRoot());
+        File destDir = new File( rootDirectory, logicalResource.getPath() ).getParentFile();
+        if ( !destDir.exists() )
+        {
+            destDir.mkdirs();
+            String relPath = PathUtil.getRelative( rootDirectory.getAbsolutePath(), destDir );
+            triggerAuditEvent(request, logicalResource.getPath(), relPath, AuditEvent.CREATE_DIR );
         }
-        return resource;
-    }
 
-    public DavResource createResource( final DavResourceLocator locator, final DavSession davSession )
-        throws DavException
-    {
-        ArchivaDavResourceLocator archivaLocator = checkLocatorIsInstanceOfRepositoryLocator( locator );
+        File resourceFile = new File( managedRepository.getRepoRoot(), logicalResource.getPath() );
 
-        ManagedRepositoryContent managedRepository;
-        try
-        {
-            managedRepository = repositoryFactory.getManagedRepositoryContent( archivaLocator.getRepositoryId() );
-        }
-        catch ( RepositoryNotFoundException e )
-        {
-            throw new DavException( HttpServletResponse.SC_NOT_FOUND, "Invalid repository: "
-                + archivaLocator.getRepositoryId() );
-        }
-        catch ( RepositoryException e )
-        {
-            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR, e );
-        }
+        boolean previouslyExisted = resourceFile.exists();
 
-        String logicalResource = RepositoryPathUtil.getLogicalResource( locator.getResourcePath() );
-        File resourceFile = new File( managedRepository.getRepoRoot(), logicalResource );
-        DavResource resource =
-            new ArchivaDavResource( resourceFile.getAbsolutePath(), logicalResource, managedRepository.getRepository(),
-                                    davSession, archivaLocator, this, mimeTypes, auditListeners, consumers );
+        processAuditEvents(request, locator.getRepositoryId(), logicalResource.getPath(), previouslyExisted, resourceFile, null );
 
-        resource.addLockManager( lockManager );
-        return resource;
+        return new ArchivaDavResource(resourceFile.getAbsolutePath(), logicalResource.getPath(), mimeTypes, locator, this);
     }
 
-    private boolean fetchContentFromProxies( ManagedRepositoryContent managedRepository, DavServletRequest request,
-                                             LogicalResource resource )
+    private boolean fetchContentFromProxies( ManagedRepositoryContent managedRepository, DavServletRequest request, LogicalResource resource )
         throws DavException
     {
         if ( repositoryRequest.isSupportFile( resource.getPath() ) )
         {
-            File proxiedFile = connectors.fetchFromProxies( managedRepository, resource.getPath() );
+            // Checksums are fetched with artifact / metadata.
 
-            return ( proxiedFile != null );
+            // Need to adjust the path for the checksum resource.
+            return false;
         }
 
         // Is it a Metadata resource?
         if ( repositoryRequest.isDefault( resource.getPath() ) && repositoryRequest.isMetadata( resource.getPath() ) )
         {
-            return connectors.fetchMetatadaFromProxies( managedRepository, resource.getPath() ) != null;
+            return fetchMetadataFromProxies(managedRepository, request, resource );
         }
 
         // Not any of the above? Then it's gotta be an artifact reference.
@@ -543,7 +303,7 @@ private boolean fetchContentFromProxies( ManagedRepositoryContent managedReposit
 
             if ( artifact != null )
             {
-                applyServerSideRelocation( managedRepository, artifact );
+                applyServerSideRelocation(managedRepository, artifact );
 
                 File proxiedFile = connectors.fetchFromProxies( managedRepository, artifact );
 
@@ -558,19 +318,59 @@ private boolean fetchContentFromProxies( ManagedRepositoryContent managedReposit
         }
         catch ( ProxyDownloadException e )
         {
-            log.error( e.getMessage(), e );
-            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Unable to fetch artifact resource." );
+            log.error(e.getMessage(), e);
+            throw new DavException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Unable to fetch artifact resource.");
         }
         return false;
     }
 
+    private boolean fetchMetadataFromProxies(ManagedRepositoryContent managedRepository, DavServletRequest request, LogicalResource resource )
+        throws DavException
+    {
+        ProjectReference project;
+        VersionedReference versioned;
+
+        try
+        {
+
+            versioned = metadataTools.toVersionedReference( resource.getPath() );
+            if ( versioned != null )
+            {
+                connectors.fetchFromProxies( managedRepository, versioned );
+                return true;
+            }
+        }
+        catch ( RepositoryMetadataException e )
+        {
+            /* eat it */
+        }
+
+        try
+        {
+            project = metadataTools.toProjectReference( resource.getPath() );
+            if ( project != null )
+            {
+                connectors.fetchFromProxies( managedRepository, project );
+                return true;
+            }
+        }
+        catch ( RepositoryMetadataException e )
+        {
+            /* eat it */
+        }
+
+        return false;
+    }
+
     /**
-     * A relocation capable client will request the POM prior to the artifact, and will then read meta-data and do
-     * client side relocation. A simplier client (like maven 1) will only request the artifact and not use the
+     * A relocation capable client will request the POM prior to the artifact,
+     * and will then read meta-data and do client side relocation. A simplier
+     * client (like maven 1) will only request the artifact and not use the
      * metadatas.
      * <p>
-     * For such clients, archiva does server-side relocation by reading itself the &lt;relocation&gt; element in
-     * metadatas and serving the expected artifact.
+     * For such clients, archiva does server-side relocation by reading itself
+     * the &lt;relocation&gt; element in metadatas and serving the expected
+     * artifact.
      */
     protected void applyServerSideRelocation( ManagedRepositoryContent managedRepository, ArtifactReference artifact )
         throws ProxyDownloadException
@@ -600,21 +400,7 @@ protected void applyServerSideRelocation( ManagedRepositoryContent managedReposi
 
         try
         {
-            // MavenXpp3Reader leaves the file open, so we need to close it ourselves.
-            FileReader reader = new FileReader( pom );
-            Model model = null;
-            try
-            {
-                model = new MavenXpp3Reader().read( reader );
-            }
-            finally
-            {
-                if ( reader != null )
-                {
-                    reader.close();
-                }
-            }
-
+            Model model = new MavenXpp3Reader().read( new FileReader( pom ) );
             DistributionManagement dist = model.getDistributionManagement();
             if ( dist != null )
             {
@@ -651,11 +437,51 @@ protected void applyServerSideRelocation( ManagedRepositoryContent managedReposi
         }
     }
 
-    // TODO: remove?
-    private void triggerAuditEvent( String remoteIP, String repositoryId, String resource, String action,
-                                    String principal )
+    private void processAuditEvents( DavServletRequest request, String repositoryId, String resource,
+                                     boolean previouslyExisted, File resourceFile, String suffix )
+    {
+        if ( suffix == null )
+        {
+            suffix = "";
+        }
+
+        // Process Create Audit Events.
+        if ( !previouslyExisted && resourceFile.exists() )
+        {
+            if ( resourceFile.isFile() )
+            {
+                triggerAuditEvent( request, repositoryId, resource, AuditEvent.CREATE_FILE + suffix );
+            }
+            else if ( resourceFile.isDirectory() )
+            {
+                triggerAuditEvent( request, repositoryId, resource, AuditEvent.CREATE_DIR + suffix );
+            }
+        }
+        // Process Remove Audit Events.
+        else if ( previouslyExisted && !resourceFile.exists() )
+        {
+            if ( resourceFile.isFile() )
+            {
+                triggerAuditEvent( request, repositoryId, resource, AuditEvent.REMOVE_FILE + suffix );
+            }
+            else if ( resourceFile.isDirectory() )
+            {
+                triggerAuditEvent( request, repositoryId, resource, AuditEvent.REMOVE_DIR + suffix );
+            }
+        }
+        // Process modify events.
+        else
+        {
+            if ( resourceFile.isFile() )
+            {
+                triggerAuditEvent( request, repositoryId, resource, AuditEvent.MODIFY_FILE + suffix );
+            }
+        }
+    }
+
+    private void triggerAuditEvent( String user, String remoteIP, String repositoryId, String resource, String action )
     {
-        AuditEvent event = new AuditEvent( repositoryId, principal, resource, action );
+        AuditEvent event = new AuditEvent( repositoryId, user, resource, action );
         event.setRemoteIP( remoteIP );
 
         for ( AuditListener listener : auditListeners )
@@ -664,6 +490,16 @@ private void triggerAuditEvent( String remoteIP, String repositoryId, String res
         }
     }
 
+    private void triggerAuditEvent( DavServletRequest request, String repositoryId, String resource, String action )
+    {
+        triggerAuditEvent( ArchivaXworkUser.getActivePrincipal( ActionContext.getContext().getSession() ), getRemoteIP( request ), repositoryId, resource, action );
+    }
+
+    private String getRemoteIP( DavServletRequest request )
+    {
+        return request.getRemoteAddr();
+    }
+
     public void addAuditListener( AuditListener listener )
     {
         this.auditListeners.add( listener );
@@ -679,7 +515,7 @@ public void removeAuditListener( AuditListener listener )
         this.auditListeners.remove( listener );
     }
 
-    private void setHeaders( DavServletResponse response, DavResourceLocator locator, DavResource resource )
+    private void setHeaders(DavResourceLocator locator, DavServletResponse response)
     {
         // [MRM-503] - Metadata file need Pragma:no-cache response
         // header.
@@ -689,320 +525,54 @@ private void setHeaders( DavServletResponse response, DavResourceLocator locator
             response.addHeader( "Cache-Control", "no-cache" );
         }
 
-        // We need to specify this so connecting wagons can work correctly
-        response.addDateHeader( "last-modified", resource.getModificationTime() );
-
         // TODO: [MRM-524] determine http caching options for other types of files (artifacts, sha1, md5, snapshots)
     }
 
-    private ArchivaDavResourceLocator checkLocatorIsInstanceOfRepositoryLocator( DavResourceLocator locator )
-        throws DavException
-    {
-        if ( !( locator instanceof ArchivaDavResourceLocator ) )
+    private ManagedRepositoryContent getManagedRepository(String respositoryId) throws DavException
+    {        
+        if (respositoryId != null)
         {
-            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                    "Locator does not implement RepositoryLocator" );
-        }
-
-        // Hidden paths
-        if ( locator.getResourcePath().startsWith( ArchivaDavResource.HIDDEN_PATH_PREFIX ) )
-        {
-            throw new DavException( HttpServletResponse.SC_NOT_FOUND );
-        }
-
-        ArchivaDavResourceLocator archivaLocator = (ArchivaDavResourceLocator) locator;
-
-        // MRM-419 - Windows Webdav support. Should not 404 if there is no content.
-        if ( StringUtils.isEmpty( archivaLocator.getRepositoryId() ) )
-        {
-            throw new DavException( HttpServletResponse.SC_NO_CONTENT );
-        }
-        return archivaLocator;
-    }
-
-    private static class LogicalResource
-    {
-        private String path;
-
-        public LogicalResource( String path )
-        {
-            this.path = path;
-        }
-
-        public String getPath()
-        {
-            return path;
-        }
-
-        public void setPath( String path )
-        {
-            this.path = path;
-        }
-    }
-
-    protected boolean isAuthorized( DavServletRequest request, String repositoryId )
-        throws DavException
-    {
-        try
-        {
-            AuthenticationResult result = httpAuth.getAuthenticationResult( request, null );
-            SecuritySession securitySession = httpAuth.getSecuritySession( request.getSession( true ) );
-
-            return servletAuth.isAuthenticated( request, result )
-                && servletAuth.isAuthorized( request, securitySession, repositoryId,
-                                             WebdavMethodUtil.getMethodPermission( request.getMethod() ) );
-        }
-        catch ( AuthenticationException e )
-        {
-            // safety check for MRM-911
-            String guest = UserManager.GUEST_USERNAME;
             try
             {
-                if ( servletAuth.isAuthorized(
-                                               guest,
-                                               ( (ArchivaDavResourceLocator) request.getRequestLocator() ).getRepositoryId(),
-                                               WebdavMethodUtil.getMethodPermission( request.getMethod() ) ) )
-                {
-                    return true;
-                }
+                return repositoryFactory.getManagedRepositoryContent(respositoryId);
             }
-            catch ( UnauthorizedException ae )
-            {
-                throw new UnauthorizedDavException( repositoryId,
-                                                    "You are not authenticated and authorized to access any repository." );
+            catch (RepositoryNotFoundException e)
+            {                
+                throw new DavException(HttpServletResponse.SC_NOT_FOUND, e);
             }
-
-            throw new UnauthorizedDavException( repositoryId, "You are not authenticated" );
-        }
-        catch ( MustChangePasswordException e )
-        {
-            throw new UnauthorizedDavException( repositoryId, "You must change your password." );
-        }
-        catch ( AccountLockedException e )
-        {
-            throw new UnauthorizedDavException( repositoryId, "User account is locked." );
-        }
-        catch ( AuthorizationException e )
-        {
-            throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                    "Fatal Authorization Subsystem Error." );
-        }
-        catch ( UnauthorizedException e )
-        {
-            throw new UnauthorizedDavException( repositoryId, e.getMessage() );
-        }
-    }
-
-    private DavResource getResource( DavServletRequest request, List<String> repositories,
-                                     ArchivaDavResourceLocator locator )
-        throws DavException
-    {
-        List<File> mergedRepositoryContents = new ArrayList<File>();
-        LogicalResource logicalResource =
-            new LogicalResource( RepositoryPathUtil.getLogicalResource( locator.getResourcePath() ) );
-
-        // flow:
-        // if the current user logged in has permission to any of the repositories, allow user to
-        // browse the repo group but displaying only the repositories which the user has permission to access.
-        // otherwise, prompt for authentication.
-
-        String activePrincipal = getActivePrincipal( request );
-
-        boolean allow = isAllowedToContinue( request, repositories, activePrincipal );
-
-        if ( allow )
-        {
-            for ( String repository : repositories )
-            {
-                ManagedRepositoryContent managedRepository = null;
-
-                try
-                {
-                    managedRepository = repositoryFactory.getManagedRepositoryContent( repository );
-                }
-                catch ( RepositoryNotFoundException e )
-                {
-                    throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                            "Invalid managed repository <" + repository + ">: " + e.getMessage() );
-                }
-                catch ( RepositoryException e )
-                {
-                    throw new DavException( HttpServletResponse.SC_INTERNAL_SERVER_ERROR,
-                                            "Invalid managed repository <" + repository + ">: " + e.getMessage() );
-                }
-
-                File resourceFile = new File( managedRepository.getRepoRoot(), logicalResource.getPath() );
-                if ( resourceFile.exists() )
-                {
-                    // for prompted authentication
-                    if ( httpAuth.getSecuritySession( request.getSession( true ) ) != null )
-                    {
-                        try
-                        {
-                            if ( isAuthorized( request, repository ) )
-                            {
-                                mergedRepositoryContents.add( resourceFile );
-                            }
-                        }
-                        catch ( DavException e )
-                        {
-                            // TODO: review exception handling
-                            log.debug( "Skipping repository '" + managedRepository + "' for user '" + activePrincipal
-                                + "': " + e.getMessage() );
-                        }
-                    }
-                    else
-                    {
-                        // for the current user logged in
-                        try
-                        {
-                            if ( servletAuth.isAuthorized( activePrincipal, repository,
-                                                           WebdavMethodUtil.getMethodPermission( request.getMethod() ) ) )
-                            {
-                                mergedRepositoryContents.add( resourceFile );
-                            }
-                        }
-                        catch ( UnauthorizedException e )
-                        {
-                            // TODO: review exception handling
-                            log.debug( "Skipping repository '" + managedRepository + "' for user '" + activePrincipal
-                                + "': " + e.getMessage() );
-                        }
-                    }
-                }
+            catch (RepositoryException e)
+            {                
+                throw new DavException(HttpServletResponse.SC_NOT_FOUND, e);
             }
         }
-        else
-        {
-            throw new UnauthorizedDavException( locator.getRepositoryId(), "User not authorized." );
-        }
-
-        ArchivaVirtualDavResource resource =
-            new ArchivaVirtualDavResource( mergedRepositoryContents, logicalResource.getPath(), mimeTypes, locator,
-                                           this );
-
-        // compatibility with MRM-440 to ensure browsing the repository group works ok
-        if ( resource.isCollection() && !request.getRequestURI().endsWith( "/" ) )
-        {
-            throw new BrowserRedirectException( resource.getHref() );
-        }
-
-        return resource;
-    }
-
-    private String getActivePrincipal( DavServletRequest request )
-    {
-        User sessionUser = httpAuth.getSessionUser( request.getSession() );
-        return sessionUser != null ? sessionUser.getUsername() : UserManager.GUEST_USERNAME;
+        return null;
     }
 
-    /**
-     * Check if the current user is authorized to access any of the repos
-     * 
-     * @param request
-     * @param repositories
-     * @param activePrincipal
-     * @return
-     */
-    private boolean isAllowedToContinue( DavServletRequest request, List<String> repositories, String activePrincipal )
+    private void checkLocatorIsInstanceOfRepositoryLocator(DavResourceLocator locator) throws DavException
     {
-        boolean allow = false;
-
-        // if securitySession != null, it means that the user was prompted for authentication
-        if ( httpAuth.getSecuritySession( request.getSession() ) != null )
-        {
-            for ( String repository : repositories )
-            {
-                try
-                {
-                    if ( isAuthorized( request, repository ) )
-                    {
-                        allow = true;
-                        break;
-                    }
-                }
-                catch ( DavException e )
-                {
-                    continue;
-                }
-            }
-        }
-        else
+        if (!(locator instanceof RepositoryLocator))
         {
-            for ( String repository : repositories )
-            {
-                try
-                {
-                    if ( servletAuth.isAuthorized( activePrincipal, repository,
-                                                   WebdavMethodUtil.getMethodPermission( request.getMethod() ) ) )
-                    {
-                        allow = true;
-                        break;
-                    }
-                }
-                catch ( UnauthorizedException e )
-                {
-                    continue;
-                }
-            }
+            throw new DavException(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, "Locator does not implement RepositoryLocator");
         }
-
-        return allow;
     }
 
-    private File writeMergedMetadataToFile( ArchivaRepositoryMetadata mergedMetadata, String outputFilename )
-        throws RepositoryMetadataException, DigesterException, IOException
+    class LogicalResource
     {
-        File outputFile = new File( outputFilename );
-        if ( outputFile.exists() )
-        {
-            FileUtils.deleteQuietly( outputFile );
-        }
-
-        outputFile.getParentFile().mkdirs();
-        RepositoryMetadataWriter.write( mergedMetadata, outputFile );
-
-        createChecksumFile( outputFilename, digestSha1 );
-        createChecksumFile( outputFilename, digestMd5 );
-
-        return outputFile;
-    }
+        private String path;
 
-    private void createChecksumFile( String path, Digester digester )
-        throws DigesterException, IOException
-    {
-        File checksumFile = new File( path + digester.getFilenameExtension() );
-        if ( !checksumFile.exists() )
-        {
-            FileUtils.deleteQuietly( checksumFile );
-            checksum.createChecksum( new File( path ), digester );
-        }
-        else if ( !checksumFile.isFile() )
+        public LogicalResource(String path)
         {
-            log.error( "Checksum file is not a file." );
+            this.path = path;
         }
-    }
 
-    private boolean isProjectReference( String requestedResource )
-    {
-        try
+        public String getPath()
         {
-            metadataTools.toVersionedReference( requestedResource );
-            return false;
+            return path;
         }
-        catch ( RepositoryMetadataException re )
+
+        public void setPath(String path)
         {
-            return true;
+            this.path = path;
         }
     }
-
-    public void setServletAuth( ServletAuthenticator servletAuth )
-    {
-        this.servletAuth = servletAuth;
-    }
-
-    public void setHttpAuth( HttpAuthenticator httpAuth )
-    {
-        this.httpAuth = httpAuth;
-    }
 }