diff --git a/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/PushFieldAccessRule.java b/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/PushFieldAccessRule.java
index 58921b468e..45560b896c 100644
--- a/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/PushFieldAccessRule.java
+++ b/asterix-algebra/src/main/java/org/apache/asterix/optimizer/rules/PushFieldAccessRule.java
@@ -1,20 +1,16 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
+ * Copyright 2009-2013 by The Regents of the University of California
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * you may obtain a copy of the License from
  *
- *   http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
- * Unless required by applicable law or agreed to in writing,
- * software distributed under the License is distributed on an
- * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
- * KIND, either express or implied.  See the License for the
- * specific language governing permissions and limitations
- * under the License.
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 package org.apache.asterix.optimizer.rules;
 
@@ -23,6 +19,9 @@ import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 
+import org.apache.commons.lang3.mutable.Mutable;
+import org.apache.commons.lang3.mutable.MutableObject;
+
 import org.apache.asterix.algebra.base.AsterixOperatorAnnotations;
 import org.apache.asterix.common.config.DatasetConfig.DatasetType;
 import org.apache.asterix.common.exceptions.AsterixRuntimeException;
@@ -41,8 +40,6 @@ import org.apache.asterix.om.types.ARecordType;
 import org.apache.asterix.om.types.ATypeTag;
 import org.apache.asterix.om.types.IAType;
 import org.apache.asterix.optimizer.base.AnalysisUtil;
-import org.apache.commons.lang3.mutable.Mutable;
-import org.apache.commons.lang3.mutable.MutableObject;
 import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;
 import org.apache.hyracks.algebricks.common.utils.Pair;
 import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;
@@ -63,7 +60,6 @@ import org.apache.hyracks.algebricks.core.algebra.operators.logical.DataSourceSc
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.GroupByOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.NestedTupleSourceOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities;
-import org.apache.hyracks.algebricks.core.algebra.util.OperatorPropertiesUtil;
 import org.apache.hyracks.algebricks.core.rewriter.base.IAlgebraicRewriteRule;
 
 public class PushFieldAccessRule implements IAlgebraicRewriteRule {
@@ -138,10 +134,13 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
         }
         ConstantExpression ce = (ConstantExpression) e1;
         IAObject obj = ((AsterixConstantValue) ce.getValue()).getObject();
-        if (obj.getType().getTypeTag() != ATypeTag.STRING) {
+        String fldName;
+        if (obj.getType().getTypeTag() == ATypeTag.STRING) {
+            fldName = ((AString) obj).getStringValue();
+        } else {
             int pos = ((AInt32) obj).getIntegerValue();
             String tName = dataset.getItemTypeName();
-            IAType t = mp.findType(dataset.getItemTypeDataverseName(), tName);
+            IAType t = mp.findType(dataset.getDataverseName(), tName);
             if (t.getTypeTag() != ATypeTag.RECORD) {
                 return false;
             }
@@ -149,6 +148,7 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
             if (pos >= rt.getFieldNames().length) {
                 return false;
             }
+            fldName = rt.getFieldNames()[pos];
         }
 
         List<Index> datasetIndexes = mp.getDatasetIndexes(dataset.getDataverseName(), dataset.getDatasetName());
@@ -167,8 +167,8 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
         if (op2.getOperatorTag() != LogicalOperatorTag.SELECT) {
             return false;
         }
-        ILogicalExpression e1 = (ILogicalExpression) access.getAnnotations()
-                .get(AsterixOperatorAnnotations.FIELD_ACCESS);
+        ILogicalExpression e1 = (ILogicalExpression) access.getAnnotations().get(
+                AsterixOperatorAnnotations.FIELD_ACCESS);
         if (e1 == null) {
             return false;
         }
@@ -191,9 +191,6 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
                 && !(op2.getOperatorTag() == LogicalOperatorTag.SELECT && isAccessToIndexedField(access, context))) {
             return false;
         }
-        if (!OperatorPropertiesUtil.isMovable(op2)) {
-            return false;
-        }
         if (tryingToPushThroughSelectionWithSameDataSource(access, op2)) {
             return false;
         }
@@ -203,7 +200,6 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
         }
         List<LogicalVariable> usedInAccess = new LinkedList<LogicalVariable>();
         VariableUtilities.getUsedVariables(access, usedInAccess);
-
         List<LogicalVariable> produced2 = new LinkedList<LogicalVariable>();
         if (op2.getOperatorTag() == LogicalOperatorTag.GROUP) {
             VariableUtilities.getLiveVariables(op2, produced2);
@@ -237,8 +233,9 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
                 for (Pair<LogicalVariable, LogicalVariable> m : varMappings) {
                     LogicalVariable v2 = context.newVar();
                     LogicalVariable oldVar = access.getVariables().get(0);
-                    g.getDecorList().add(new Pair<LogicalVariable, Mutable<ILogicalExpression>>(oldVar,
-                            new MutableObject<ILogicalExpression>(new VariableReferenceExpression(v2))));
+                    g.getDecorList().add(
+                            new Pair<LogicalVariable, Mutable<ILogicalExpression>>(oldVar,
+                                    new MutableObject<ILogicalExpression>(new VariableReferenceExpression(v2))));
                     changed = true;
                     access.getVariables().set(0, v2);
                     VariableUtilities.substituteVariables(access, m.first, m.second, context);
@@ -325,7 +322,7 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
                             } else {
                                 int pos = ((AInt32) obj).getIntegerValue();
                                 String tName = dataset.getItemTypeName();
-                                IAType t = mp.findType(dataset.getItemTypeDataverseName(), tName);
+                                IAType t = mp.findType(dataset.getDataverseName(), tName);
                                 if (t.getTypeTag() != ATypeTag.RECORD) {
                                     return false;
                                 }
@@ -374,7 +371,7 @@ public class PushFieldAccessRule implements IAlgebraicRewriteRule {
     // indirect recursivity with propagateFieldAccessRec
     private void pushAccessDown(Mutable<ILogicalOperator> fldAccessOpRef, ILogicalOperator op2,
             Mutable<ILogicalOperator> inputOfOp2, IOptimizationContext context, String finalAnnot)
-                    throws AlgebricksException {
+            throws AlgebricksException {
         ILogicalOperator fieldAccessOp = fldAccessOpRef.getValue();
         fldAccessOpRef.setValue(op2);
         List<Mutable<ILogicalOperator>> faInpList = fieldAccessOp.getInputs();