diff --git a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
index c385df35c..10babed69 100755
--- a/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
+++ b/repository/src/main/java/org/apache/atlas/repository/graph/GraphBackedSearchIndexer.java
@@ -26,11 +26,8 @@ import com.thinkaurelius.titan.core.schema.TitanGraphIndex;
 import com.thinkaurelius.titan.core.schema.TitanManagement;
 import com.tinkerpop.blueprints.Edge;
 import com.tinkerpop.blueprints.Vertex;
-import org.apache.atlas.ApplicationProperties;
 import org.apache.atlas.AtlasException;
 import org.apache.atlas.discovery.SearchIndexer;
-import org.apache.atlas.ha.HAConfiguration;
-import org.apache.atlas.listener.ActiveStateChangeHandler;
 import org.apache.atlas.repository.Constants;
 import org.apache.atlas.repository.IndexCreationException;
 import org.apache.atlas.repository.IndexException;
@@ -42,7 +39,6 @@ import org.apache.atlas.typesystem.types.IDataType;
 import org.apache.atlas.typesystem.types.Multiplicity;
 import org.apache.atlas.typesystem.types.StructType;
 import org.apache.atlas.typesystem.types.TraitType;
-import org.apache.commons.configuration.Configuration;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -57,12 +53,14 @@ import java.util.Map;
 /**
  * Adds index for properties of a given type when its added before any instances are added.
  */
-public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChangeHandler {
+public class GraphBackedSearchIndexer implements SearchIndexer {
 
     private static final Logger LOG = LoggerFactory.getLogger(GraphBackedSearchIndexer.class);
 
     private final TitanGraph titanGraph;
 
+    private TitanManagement management;
+
     List<Class> MIXED_INDEX_EXCLUSIONS = new ArrayList() {{
             add(Boolean.class);
             add(BigDecimal.class);
@@ -70,73 +68,57 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }};
 
     @Inject
-    public GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider) throws AtlasException {
-        this(graphProvider, ApplicationProperties.get());
-    }
+    public GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider) throws RepositoryException {
 
-    GraphBackedSearchIndexer(GraphProvider<TitanGraph> graphProvider, Configuration configuration)
-            throws IndexException, RepositoryException {
         this.titanGraph = graphProvider.get();
-        if (!HAConfiguration.isHAEnabled(configuration)) {
-            initialize();
-        }
+
+        /* Create the transaction for indexing.
+         */
+        management = titanGraph.getManagementSystem();
+        initialize();
     }
 
     /**
      * Initializes the indices for the graph - create indices for Global Vertex Keys
      */
-    private void initialize() throws RepositoryException, IndexException {
-        TitanManagement management = titanGraph.getManagementSystem();
-        try {
-            if (management.containsPropertyKey(Constants.VERTEX_TYPE_PROPERTY_KEY)) {
-                LOG.info("Global indexes already exist for graph");
-                return;
-            }
+    private void initialize() {
+        if (management.containsPropertyKey(Constants.VERTEX_TYPE_PROPERTY_KEY)) {
+            LOG.info("Global indexes already exist for graph");
+            return;
+        }
 
         /* This is called only once, which is the first time Atlas types are made indexable .*/
-            LOG.info("Indexes do not exist, Creating indexes for titanGraph.");
-            management.buildIndex(Constants.VERTEX_INDEX, Vertex.class).buildMixedIndex(Constants.BACKING_INDEX);
-            management.buildIndex(Constants.EDGE_INDEX, Edge.class).buildMixedIndex(Constants.BACKING_INDEX);
+        LOG.info("Indexes do not exist, Creating indexes for titanGraph.");
+        management.buildIndex(Constants.VERTEX_INDEX, Vertex.class).buildMixedIndex(Constants.BACKING_INDEX);
+        management.buildIndex(Constants.EDGE_INDEX, Edge.class).buildMixedIndex(Constants.BACKING_INDEX);
 
-            // create a composite index for guid as its unique
-            createIndexes(management, Constants.GUID_PROPERTY_KEY, String.class, true,
-                    Cardinality.SINGLE, true);
+        // create a composite index for guid as its unique
+        createCompositeAndMixedIndex(Constants.GUID_PROPERTY_KEY, String.class, true, Cardinality.SINGLE, true);
 
-            // create a composite index for entity state
-            createIndexes(management, Constants.TIMESTAMP_PROPERTY_KEY, Long.class, false, Cardinality.SINGLE, true);
+        // create a composite and mixed index for type since it can be combined with other keys
+        createCompositeAndMixedIndex(Constants.ENTITY_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE, true);
 
-            // create a composite index for entity state
-            createIndexes(management, Constants.MODIFICATION_TIMESTAMP_PROPERTY_KEY, Long.class, false,
-                    Cardinality.SINGLE, true);
+        // create a composite and mixed index for type since it can be combined with other keys
+        createCompositeAndMixedIndex(Constants.SUPER_TYPES_PROPERTY_KEY, String.class, false, Cardinality.SET, true);
 
-            // create a composite and mixed index for type since it can be combined with other keys
-            createIndexes(management, Constants.ENTITY_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE,
-                    true);
+        // create a composite and mixed index for traitNames since it can be combined with other
+        // keys. Traits must be a set and not a list.
+        createCompositeAndMixedIndex(Constants.TRAIT_NAMES_PROPERTY_KEY, String.class, false, Cardinality.SET, true);
 
-            // create a composite and mixed index for type since it can be combined with other keys
-            createIndexes(management, Constants.SUPER_TYPES_PROPERTY_KEY, String.class, false, Cardinality.SET,
-                    true);
+        // Index for full text search
+        createFullTextIndex();
 
-            // create a composite and mixed index for traitNames since it can be combined with other
-            // keys. Traits must be a set and not a list.
-            createIndexes(management, Constants.TRAIT_NAMES_PROPERTY_KEY, String.class, false, Cardinality.SET,
-                    true);
+        //Indexes for graph backed type system store
+        createTypeStoreIndexes();
 
-            // Index for full text search
-            createFullTextIndex(management);
+        management.commit();
+        //Make sure we acquire another transaction after commit for subsequent indexing
+        management = titanGraph.getManagementSystem();
 
-            //Indexes for graph backed type system store
-            createTypeStoreIndexes(management);
-
-            commit(management);
-            LOG.info("Index creation for global keys complete.");
-        } catch (Throwable t) {
-            rollback(management);
-            throw new RepositoryException(t);
-        }
+        LOG.info("Index creation for global keys complete.");
     }
 
-    private void createFullTextIndex(TitanManagement management) {
+    private void createFullTextIndex() {
         PropertyKey fullText =
                 management.makePropertyKey(Constants.ENTITY_TEXT_PROPERTY_KEY).dataType(String.class).make();
 
@@ -146,14 +128,12 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         LOG.info("Created mixed index for {}", Constants.ENTITY_TEXT_PROPERTY_KEY);
     }
 
-    private void createTypeStoreIndexes(TitanManagement management) {
+    private void createTypeStoreIndexes() {
         //Create unique index on typeName
-        createIndexes(management, Constants.TYPENAME_PROPERTY_KEY, String.class, true, Cardinality.SINGLE,
-                true);
+        createCompositeAndMixedIndex(Constants.TYPENAME_PROPERTY_KEY, String.class, true, Cardinality.SINGLE, true);
 
         //create index on vertex type
-        createIndexes(management, Constants.VERTEX_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE,
-                true);
+        createCompositeAndMixedIndex(Constants.VERTEX_TYPE_PROPERTY_KEY, String.class, false, Cardinality.SINGLE, true);
     }
 
     /**
@@ -164,30 +144,24 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
      */
     @Override
     public void onAdd(Collection<? extends IDataType> dataTypes) throws AtlasException {
-        TitanManagement management = titanGraph.getManagementSystem();
+
         for (IDataType dataType : dataTypes) {
             LOG.info("Creating indexes for type name={}, definition={}", dataType.getName(), dataType.getClass());
             try {
-                addIndexForType(management, dataType);
+                addIndexForType(dataType);
                 LOG.info("Index creation for type {} complete", dataType.getName());
             } catch (Throwable throwable) {
                 LOG.error("Error creating index for type {}", dataType, throwable);
                 //Rollback indexes if any failure
-                rollback(management);
+                rollback();
                 throw new IndexCreationException("Error while creating index for type " + dataType, throwable);
             }
         }
-
         //Commit indexes
-        commit(management);
-    }
-
-    @Override
-    public void onChange(Collection<? extends IDataType> dataTypes) throws AtlasException {
-        onAdd(dataTypes);
+        commit();
     }
 
-    private void addIndexForType(TitanManagement management, IDataType dataType) {
+    private void addIndexForType(IDataType dataType) {
         switch (dataType.getTypeCategory()) {
         case PRIMITIVE:
         case ENUM:
@@ -199,17 +173,17 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
         case STRUCT:
             StructType structType = (StructType) dataType;
-            createIndexForFields(management, structType, structType.fieldMapping().fields);
+            createIndexForFields(structType, structType.fieldMapping().fields);
             break;
 
         case TRAIT:
             TraitType traitType = (TraitType) dataType;
-            createIndexForFields(management, traitType, traitType.fieldMapping().fields);
+            createIndexForFields(traitType, traitType.fieldMapping().fields);
             break;
 
         case CLASS:
             ClassType classType = (ClassType) dataType;
-            createIndexForFields(management, classType, classType.fieldMapping().fields);
+            createIndexForFields(classType, classType.fieldMapping().fields);
             break;
 
         default:
@@ -217,26 +191,26 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    private void createIndexForFields(TitanManagement management, IDataType dataType, Map<String, AttributeInfo> fields) {
+    private void createIndexForFields(IDataType dataType, Map<String, AttributeInfo> fields) {
         for (AttributeInfo field : fields.values()) {
             if (field.isIndexable) {
-                createIndexForAttribute(management, dataType.getName(), field);
+                createIndexForAttribute(dataType.getName(), field);
             }
         }
     }
 
-    private void createIndexForAttribute(TitanManagement management, String typeName, AttributeInfo field) {
+    private void createIndexForAttribute(String typeName, AttributeInfo field) {
         final String propertyName = typeName + "." + field.name;
         switch (field.dataType().getTypeCategory()) {
         case PRIMITIVE:
             Cardinality cardinality = getCardinality(field.multiplicity);
-            createIndexes(management, propertyName, getPrimitiveClass(field.dataType()), field.isUnique,
+            createCompositeAndMixedIndex(propertyName, getPrimitiveClass(field.dataType()), field.isUnique,
                     cardinality, false);
             break;
 
         case ENUM:
             cardinality = getCardinality(field.multiplicity);
-            createIndexes(management, propertyName, String.class, field.isUnique, cardinality, false);
+            createCompositeAndMixedIndex(propertyName, String.class, field.isUnique, cardinality, false);
             break;
 
         case ARRAY:
@@ -247,7 +221,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
 
         case STRUCT:
             StructType structType = (StructType) field.dataType();
-            createIndexForFields(management, structType, structType.fieldMapping().fields);
+            createIndexForFields(structType, structType.fieldMapping().fields);
             break;
 
         case TRAIT:
@@ -309,49 +283,40 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         return Cardinality.LIST;
     }
 
-    private PropertyKey createIndexes(TitanManagement management, String propertyName,
-                                      Class propertyClass, boolean isUnique, Cardinality cardinality,
-                                      boolean isSystemProperty) {
+
+    private PropertyKey createCompositeAndMixedIndex(String propertyName, Class propertyClass,
+            boolean isUnique, Cardinality cardinality, boolean force) {
+
         PropertyKey propertyKey = management.getPropertyKey(propertyName);
         if (propertyKey == null) {
             propertyKey = management.makePropertyKey(propertyName).dataType(propertyClass).cardinality(cardinality)
                     .make();
 
-            enhanceMixedIndex(management, propertyName, propertyClass, cardinality, propertyKey);
-
-            if (isSystemProperty) {
-                createCompositeIndex(management, propertyName, propertyClass, propertyKey, isUnique);
-            } else if (isUnique) {
-                // send uniqueness as false because there can be many vertexes with the same property value
-                // but state can be active / deleted.
-                createCompositeIndex(management, propertyName, propertyClass, propertyKey, false);
+            if (checkIfMixedIndexApplicable(propertyClass, cardinality)) {
+                //Use backing index
+                LOG.debug("Creating backing index for property {} of type {} ", propertyName, propertyClass.getName());
+                TitanGraphIndex vertexIndex = management.getGraphIndex(Constants.VERTEX_INDEX);
+                management.addIndexKey(vertexIndex, propertyKey);
+                LOG.debug("Created backing index for property {} of type {} ", propertyName, propertyClass.getName());
             }
-        }
-        return propertyKey;
-    }
 
-    private void createCompositeIndex(TitanManagement management, String propertyName, Class propertyClass,
-                                      PropertyKey propertyKey, boolean enforceUniqueness) {
-        LOG.debug("Creating composite index for property {} of type {} ", propertyName,
-                propertyClass.getName());
-        TitanManagement.IndexBuilder indexBuilder =
-                management.buildIndex(propertyName, Vertex.class).addKey(propertyKey);
-        if (enforceUniqueness) {
-            indexBuilder.unique();
+            //Create mixed index only for meta properties and unique constraints:
+            //Unique can't be achieved with backing/mixed index
+            //Creating composite index for every attribute will bloat up the index
+            if (force || isUnique) {
+                LOG.debug("Creating composite index for property {} of type {} ", propertyName,
+                        propertyClass.getName());
+                TitanManagement.IndexBuilder indexBuilder =
+                        management.buildIndex(propertyName, Vertex.class).addKey(propertyKey);
+                if (isUnique) {
+                    indexBuilder.unique();
+                }
+                indexBuilder.buildCompositeIndex();
+                LOG.debug("Created composite index for property {} of type {} ", propertyName, propertyClass.getName());
+            }
         }
-        indexBuilder.buildCompositeIndex();
-        LOG.debug("Created composite index for property {} of type {} ", propertyName, propertyClass.getName());
-    }
 
-    private void enhanceMixedIndex(TitanManagement management, String propertyName, Class propertyClass,
-                                   Cardinality cardinality, PropertyKey propertyKey) {
-        if (checkIfMixedIndexApplicable(propertyClass, cardinality)) {
-            //Use backing index
-            LOG.debug("Creating backing index for property {} of type {} ", propertyName, propertyClass.getName());
-            TitanGraphIndex vertexIndex = management.getGraphIndex(Constants.VERTEX_INDEX);
-            management.addIndexKey(vertexIndex, propertyKey);
-            LOG.debug("Created backing index for property {} of type {} ", propertyName, propertyClass.getName());
-        }
+        return propertyKey;
     }
 
     private boolean checkIfMixedIndexApplicable(Class propertyClass, Cardinality cardinality) {
@@ -359,7 +324,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
                 Cardinality.SET);
     }
 
-    public void commit(TitanManagement management) throws IndexException {
+    public void commit() throws IndexException {
         try {
             management.commit();
         } catch (Exception e) {
@@ -368,7 +333,7 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    public void rollback(TitanManagement management) throws IndexException {
+    public void rollback() throws IndexException {
         try {
             management.rollback();
         } catch (Exception e) {
@@ -377,28 +342,6 @@ public class GraphBackedSearchIndexer implements SearchIndexer, ActiveStateChang
         }
     }
 
-    /**
-     * Initialize global indices for Titan graph on server activation.
-     *
-     * Since the indices are shared state, we need to do this only from an active instance.
-     */
-    @Override
-    public void instanceIsActive() throws AtlasException {
-        LOG.info("Reacting to active: initializing index");
-        try {
-            initialize();
-        } catch (RepositoryException e) {
-            throw new AtlasException("Error in reacting to active on initialization", e);
-        } catch (IndexException e) {
-            throw new AtlasException("Error in reacting to active on initialization", e);
-        }
-    }
-
-    @Override
-    public void instanceIsPassive() {
-        LOG.info("Reacting to passive state: No action right now.");
-    }
-
     /* Commenting this out since we do not need an index for edge label here
     private void createEdgeMixedIndex(String propertyName) {
         EdgeLabel edgeLabel = management.getEdgeLabel(propertyName);