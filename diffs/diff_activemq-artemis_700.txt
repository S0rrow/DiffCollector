diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/security/impl/SecurityStoreImpl.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/security/impl/SecurityStoreImpl.java
index 957a318dd9..cb55f1edc0 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/security/impl/SecurityStoreImpl.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/security/impl/SecurityStoreImpl.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -23,36 +23,38 @@ import java.util.concurrent.ConcurrentMap;
 import org.apache.activemq.artemis.api.core.SimpleString;
 import org.apache.activemq.artemis.api.core.management.CoreNotificationType;
 import org.apache.activemq.artemis.api.core.management.ManagementHelper;
-import org.apache.activemq.artemis.core.remoting.CertificateUtil;
 import org.apache.activemq.artemis.core.security.CheckType;
 import org.apache.activemq.artemis.core.security.Role;
-import org.apache.activemq.artemis.core.security.SecurityAuth;
 import org.apache.activemq.artemis.core.security.SecurityStore;
 import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
+import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
+import org.apache.activemq.artemis.core.server.ServerSession;
 import org.apache.activemq.artemis.core.server.management.Notification;
 import org.apache.activemq.artemis.core.server.management.NotificationService;
 import org.apache.activemq.artemis.core.settings.HierarchicalRepository;
 import org.apache.activemq.artemis.core.settings.HierarchicalRepositoryChangeListener;
-import org.apache.activemq.artemis.spi.core.remoting.Connection;
 import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager;
-import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager2;
-import org.apache.activemq.artemis.spi.core.security.ActiveMQSecurityManager3;
-import org.apache.activemq.artemis.utils.collections.ConcurrentHashSet;
-import org.apache.activemq.artemis.utils.collections.TypedProperties;
-import org.jboss.logging.Logger;
+import org.apache.activemq.artemis.utils.ConcurrentHashSet;
+import org.apache.activemq.artemis.utils.TypedProperties;
 
 /**
- * The ActiveMQ Artemis SecurityStore implementation
+ * The ActiveMQ SecurityStore implementation
  */
-public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryChangeListener {
+public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryChangeListener
+{
+   // Constants -----------------------------------------------------
+
+   // Static --------------------------------------------------------
+
+   // Attributes ----------------------------------------------------
 
-   private static final Logger logger = Logger.getLogger(SecurityStoreImpl.class);
+   private final boolean trace = ActiveMQServerLogger.LOGGER.isTraceEnabled();
 
    private final HierarchicalRepository<Set<Role>> securityRepository;
 
    private final ActiveMQSecurityManager securityManager;
 
-   private final ConcurrentMap<String, ConcurrentHashSet<SimpleString>> cache = new ConcurrentHashMap<>();
+   private final ConcurrentMap<String, ConcurrentHashSet<SimpleString>> cache = new ConcurrentHashMap<String, ConcurrentHashSet<SimpleString>>();
 
    private final long invalidationInterval;
 
@@ -77,7 +79,8 @@ public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryC
                             final boolean securityEnabled,
                             final String managementClusterUser,
                             final String managementClusterPassword,
-                            final NotificationService notificationService) {
+                            final NotificationService notificationService)
+   {
       this.securityRepository = securityRepository;
       this.securityManager = securityManager;
       this.invalidationInterval = invalidationInterval;
@@ -91,77 +94,72 @@ public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryC
    // SecurityManager implementation --------------------------------
 
    @Override
-   public boolean isSecurityEnabled() {
+   public boolean isSecurityEnabled()
+   {
       return securityEnabled;
    }
 
-   @Override
-   public void stop() {
+   public void stop()
+   {
       securityRepository.unRegisterListener(this);
    }
 
-   @Override
-   public String authenticate(final String user,
-                              final String password,
-                              Connection connection) throws Exception {
-      if (securityEnabled) {
-
-         if (managementClusterUser.equals(user)) {
-            if (logger.isTraceEnabled()) {
-               logger.trace("Authenticating cluster admin user");
+   public void authenticate(final String user, final String password) throws Exception
+   {
+      if (securityEnabled)
+      {
+
+         if (managementClusterUser.equals(user))
+         {
+            if (trace)
+            {
+               ActiveMQServerLogger.LOGGER.trace("Authenticating cluster admin user");
             }
 
             /*
              * The special user cluster user is used for creating sessions that replicate management
              * operation between nodes
              */
-            if (!managementClusterPassword.equals(password)) {
+            if (!managementClusterPassword.equals(password))
+            {
                throw ActiveMQMessageBundle.BUNDLE.unableToValidateClusterUser(user);
-            } else {
-               return managementClusterUser;
+            }
+            else
+            {
+               return;
             }
          }
 
-         String validatedUser = null;
-         boolean userIsValid = false;
-
-         if (securityManager instanceof ActiveMQSecurityManager3) {
-            validatedUser = ((ActiveMQSecurityManager3) securityManager).validateUser(user, password, connection);
-         } else if (securityManager instanceof ActiveMQSecurityManager2) {
-            userIsValid = ((ActiveMQSecurityManager2) securityManager).validateUser(user, password, CertificateUtil.getCertsFromConnection(connection));
-         } else {
-            userIsValid = securityManager.validateUser(user, password);
-         }
-
-         if (!userIsValid && validatedUser == null) {
-            if (notificationService != null) {
+         if (!securityManager.validateUser(user, password))
+         {
+            if (notificationService != null)
+            {
                TypedProperties props = new TypedProperties();
 
+               props.putSimpleStringProperty(ManagementHelper.HDR_USER, SimpleString.toSimpleString(user));
+
                Notification notification = new Notification(null, CoreNotificationType.SECURITY_AUTHENTICATION_VIOLATION, props);
 
                notificationService.sendNotification(notification);
             }
 
-            throw ActiveMQMessageBundle.BUNDLE.unableToValidateUser();
+            throw ActiveMQMessageBundle.BUNDLE.unableToValidateUser(user);
          }
-
-         return validatedUser;
       }
-
-      return null;
    }
 
-   @Override
-   public void check(final SimpleString address,
-                     final CheckType checkType,
-                     final SecurityAuth session) throws Exception {
-      if (securityEnabled) {
-         if (logger.isTraceEnabled()) {
-            logger.trace("checking access permissions to " + address);
+   public void check(final SimpleString address, final CheckType checkType, final ServerSession session) throws Exception
+   {
+      if (securityEnabled)
+      {
+         if (trace)
+         {
+            ActiveMQServerLogger.LOGGER.trace("checking access permissions to " + address);
          }
 
          String user = session.getUsername();
-         if (checkCached(address, user, checkType)) {
+         if (checkCached(address, user, checkType))
+         {
             // OK
             return;
          }
@@ -171,23 +169,15 @@ public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryC
          Set<Role> roles = securityRepository.getMatch(saddress);
 
          // bypass permission checks for management cluster user
-         if (managementClusterUser.equals(user) && session.getPassword().equals(managementClusterPassword)) {
+         if (managementClusterUser.equals(user) && session.getPassword().equals(managementClusterPassword))
+         {
             return;
          }
 
-         final boolean validated;
-         if (securityManager instanceof ActiveMQSecurityManager3) {
-            final ActiveMQSecurityManager3 securityManager3 = (ActiveMQSecurityManager3) securityManager;
-            validated = securityManager3.validateUserAndRole(user, session.getPassword(), roles, checkType, saddress, session.getRemotingConnection().getTransportConnection()) != null;
-         } else if (securityManager instanceof ActiveMQSecurityManager2) {
-            final ActiveMQSecurityManager2 securityManager2 = (ActiveMQSecurityManager2) securityManager;
-            validated = securityManager2.validateUserAndRole(user, session.getPassword(), roles, checkType, saddress, session.getRemotingConnection());
-         } else {
-            validated = securityManager.validateUserAndRole(user, session.getPassword(), roles, checkType);
-         }
-
-         if (!validated) {
-            if (notificationService != null) {
+         if (!securityManager.validateUserAndRole(user, session.getPassword(), roles, checkType))
+         {
+            if (notificationService != null)
+            {
                TypedProperties props = new TypedProperties();
 
                props.putSimpleStringProperty(ManagementHelper.HDR_ADDRESS, address);
@@ -202,9 +192,10 @@ public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryC
             throw ActiveMQMessageBundle.BUNDLE.userNoPermissions(session.getUsername(), checkType, saddress);
          }
          // if we get here we're granted, add to the cache
-         ConcurrentHashSet<SimpleString> set = new ConcurrentHashSet<>();
+         ConcurrentHashSet<SimpleString> set = new ConcurrentHashSet<SimpleString>();
          ConcurrentHashSet<SimpleString> act = cache.putIfAbsent(user + "." + checkType.name(), set);
-         if (act != null) {
+         if (act != null)
+         {
             set = act;
          }
          set.add(address);
@@ -212,8 +203,8 @@ public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryC
       }
    }
 
-   @Override
-   public void onChange() {
+   public void onChange()
+   {
       invalidateCache();
    }
 
@@ -224,22 +215,28 @@ public class SecurityStoreImpl implements SecurityStore, HierarchicalRepositoryC
    // Package Private -----------------------------------------------
 
    // Private -------------------------------------------------------
-   private void invalidateCache() {
+   private void invalidateCache()
+   {
       cache.clear();
    }
 
-   private boolean checkCached(final SimpleString dest, final String user, final CheckType checkType) {
+   private boolean checkCached(final SimpleString dest, final String user, final CheckType checkType)
+   {
       long now = System.currentTimeMillis();
 
       boolean granted = false;
 
-      if (now - lastCheck > invalidationInterval) {
+      if (now - lastCheck > invalidationInterval)
+      {
          invalidateCache();
 
          lastCheck = now;
-      } else {
+      }
+      else
+      {
          ConcurrentHashSet<SimpleString> act = cache.get(user + "." + checkType.name());
-         if (act != null) {
+         if (act != null)
+         {
             granted = act.contains(dest);
          }
       }