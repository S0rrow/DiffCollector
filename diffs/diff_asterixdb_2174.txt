diff --git a/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/translator/LangExpressionToPlanTranslator.java b/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/translator/LangExpressionToPlanTranslator.java
index bd87e6ebeb..0040b610ad 100644
--- a/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/translator/LangExpressionToPlanTranslator.java
+++ b/asterixdb/asterix-algebra/src/main/java/org/apache/asterix/translator/LangExpressionToPlanTranslator.java
@@ -18,8 +18,6 @@
  */
 package org.apache.asterix.translator;
 
-import static java.util.logging.Logger.global;
-
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
@@ -30,7 +28,6 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.Map.Entry;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.apache.asterix.algebra.base.ILangExpressionToPlanTranslator;
@@ -41,15 +38,13 @@ import org.apache.asterix.common.functions.FunctionConstants;
 import org.apache.asterix.common.functions.FunctionSignature;
 import org.apache.asterix.lang.aql.util.RangeMapBuilder;
 import org.apache.asterix.lang.common.base.Expression;
-import org.apache.asterix.lang.common.base.ILangExpression;
-import org.apache.asterix.lang.common.base.Statement;
 import org.apache.asterix.lang.common.base.Expression.Kind;
 import org.apache.asterix.lang.common.clause.GroupbyClause;
 import org.apache.asterix.lang.common.clause.LetClause;
 import org.apache.asterix.lang.common.clause.LimitClause;
 import org.apache.asterix.lang.common.clause.OrderbyClause;
-import org.apache.asterix.lang.common.clause.WhereClause;
 import org.apache.asterix.lang.common.clause.OrderbyClause.OrderModifier;
+import org.apache.asterix.lang.common.clause.WhereClause;
 import org.apache.asterix.lang.common.expression.CallExpr;
 import org.apache.asterix.lang.common.expression.FieldAccessor;
 import org.apache.asterix.lang.common.expression.FieldBinding;
@@ -57,14 +52,15 @@ import org.apache.asterix.lang.common.expression.GbyVariableExpressionPair;
 import org.apache.asterix.lang.common.expression.IfExpr;
 import org.apache.asterix.lang.common.expression.IndexAccessor;
 import org.apache.asterix.lang.common.expression.ListConstructor;
+import org.apache.asterix.lang.common.expression.ListConstructor.Type;
 import org.apache.asterix.lang.common.expression.LiteralExpr;
 import org.apache.asterix.lang.common.expression.OperatorExpr;
 import org.apache.asterix.lang.common.expression.QuantifiedExpression;
+import org.apache.asterix.lang.common.expression.QuantifiedExpression.Quantifier;
 import org.apache.asterix.lang.common.expression.RecordConstructor;
 import org.apache.asterix.lang.common.expression.UnaryExpr;
+import org.apache.asterix.lang.common.expression.UnaryExpr.Sign;
 import org.apache.asterix.lang.common.expression.VariableExpr;
-import org.apache.asterix.lang.common.expression.ListConstructor.Type;
-import org.apache.asterix.lang.common.expression.QuantifiedExpression.Quantifier;
 import org.apache.asterix.lang.common.literal.StringLiteral;
 import org.apache.asterix.lang.common.statement.FunctionDecl;
 import org.apache.asterix.lang.common.statement.Query;
@@ -75,20 +71,19 @@ import org.apache.asterix.lang.common.util.FunctionUtil;
 import org.apache.asterix.lang.common.visitor.base.AbstractQueryExpressionVisitor;
 import org.apache.asterix.metadata.MetadataException;
 import org.apache.asterix.metadata.MetadataManager;
+import org.apache.asterix.metadata.declared.AqlDataSource.AqlDataSourceType;
 import org.apache.asterix.metadata.declared.AqlMetadataProvider;
 import org.apache.asterix.metadata.declared.AqlSourceId;
 import org.apache.asterix.metadata.declared.DatasetDataSource;
 import org.apache.asterix.metadata.declared.LoadableDataSource;
 import org.apache.asterix.metadata.declared.ResultSetDataSink;
 import org.apache.asterix.metadata.declared.ResultSetSinkId;
-import org.apache.asterix.metadata.declared.AqlDataSource.AqlDataSourceType;
 import org.apache.asterix.metadata.entities.Dataset;
 import org.apache.asterix.metadata.entities.Function;
 import org.apache.asterix.metadata.entities.InternalDatasetDetails;
 import org.apache.asterix.metadata.feeds.FeedMetadataUtil;
 import org.apache.asterix.metadata.functions.ExternalFunctionCompilerUtil;
 import org.apache.asterix.metadata.utils.DatasetUtils;
-import org.apache.asterix.om.base.AInt64;
 import org.apache.asterix.om.base.AString;
 import org.apache.asterix.om.constants.AsterixConstantValue;
 import org.apache.asterix.om.functions.AsterixBuiltinFunctions;
@@ -107,7 +102,6 @@ import org.apache.commons.lang3.mutable.MutableObject;
 import org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;
 import org.apache.hyracks.algebricks.common.exceptions.NotImplementedException;
 import org.apache.hyracks.algebricks.common.utils.Pair;
-import org.apache.hyracks.algebricks.common.utils.Triple;
 import org.apache.hyracks.algebricks.core.algebra.base.Counter;
 import org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;
 import org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;
@@ -117,15 +111,15 @@ import org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;
 import org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;
 import org.apache.hyracks.algebricks.core.algebra.base.OperatorAnnotations;
 import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;
+import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression.FunctionKind;
 import org.apache.hyracks.algebricks.core.algebra.expressions.AggregateFunctionCallExpression;
 import org.apache.hyracks.algebricks.core.algebra.expressions.BroadcastExpressionAnnotation;
+import org.apache.hyracks.algebricks.core.algebra.expressions.BroadcastExpressionAnnotation.BroadcastSide;
 import org.apache.hyracks.algebricks.core.algebra.expressions.ConstantExpression;
 import org.apache.hyracks.algebricks.core.algebra.expressions.IExpressionAnnotation;
 import org.apache.hyracks.algebricks.core.algebra.expressions.ScalarFunctionCallExpression;
 import org.apache.hyracks.algebricks.core.algebra.expressions.UnnestingFunctionCallExpression;
 import org.apache.hyracks.algebricks.core.algebra.expressions.VariableReferenceExpression;
-import org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression.FunctionKind;
-import org.apache.hyracks.algebricks.core.algebra.expressions.BroadcastExpressionAnnotation.BroadcastSide;
 import org.apache.hyracks.algebricks.core.algebra.functions.AlgebricksBuiltinFunctions;
 import org.apache.hyracks.algebricks.core.algebra.functions.FunctionIdentifier;
 import org.apache.hyracks.algebricks.core.algebra.functions.IFunctionInfo;
@@ -141,13 +135,12 @@ import org.apache.hyracks.algebricks.core.algebra.operators.logical.InsertDelete
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.LimitOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.NestedTupleSourceOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.OrderOperator;
+import org.apache.hyracks.algebricks.core.algebra.operators.logical.OrderOperator.IOrder.OrderKind;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.ProjectOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.SelectOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.SinkOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.SubplanOperator;
-import org.apache.hyracks.algebricks.core.algebra.operators.logical.UnionAllOperator;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.UnnestOperator;
-import org.apache.hyracks.algebricks.core.algebra.operators.logical.OrderOperator.IOrder.OrderKind;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.LogicalOperatorDeepCopyWithNewVariablesVisitor;
 import org.apache.hyracks.algebricks.core.algebra.operators.logical.visitors.VariableUtilities;
 import org.apache.hyracks.algebricks.core.algebra.plan.ALogicalPlanImpl;
@@ -198,10 +191,10 @@ class LangExpressionToPlanTranslator
                     "Unable to load dataset " + clffs.getDatasetName() + " since it does not exist");
         }
         IAType itemType = metadataProvider.findType(dataset.getItemTypeDataverseName(), dataset.getItemTypeName());
-        IAType metaItemType =
-                metadataProvider.findType(dataset.getMetaItemTypeDataverseName(), dataset.getMetaItemTypeName());
-        DatasetDataSource targetDatasource =
-                validateDatasetInfo(metadataProvider, stmt.getDataverseName(), stmt.getDatasetName());
+        IAType metaItemType = metadataProvider.findType(dataset.getMetaItemTypeDataverseName(),
+                dataset.getMetaItemTypeName());
+        DatasetDataSource targetDatasource = validateDatasetInfo(metadataProvider, stmt.getDataverseName(),
+                stmt.getDatasetName());
         List<List<String>> partitionKeys = DatasetUtils.getPartitioningKeys(targetDatasource.getDataset());
         if (dataset.hasMetaPart()) {
             throw new AlgebricksException(
@@ -254,8 +247,8 @@ class LangExpressionToPlanTranslator
         }
 
         List<String> additionalFilteringField = DatasetUtils.getFilterField(targetDatasource.getDataset());
-        List<LogicalVariable> additionalFilteringVars;
-        List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions;
+        List<LogicalVariable> additionalFilteringVars = null;
+        List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions = null;
         List<Mutable<ILogicalExpression>> additionalFilteringExpressions = null;
         AssignOperator additionalFilteringAssign = null;
         if (additionalFilteringField != null) {
@@ -264,8 +257,8 @@ class LangExpressionToPlanTranslator
             additionalFilteringExpressions = new ArrayList<>();
             PlanTranslationUtil.prepareVarAndExpression(additionalFilteringField, payloadVar, additionalFilteringVars,
                     additionalFilteringAssignExpressions, additionalFilteringExpressions, context);
-            additionalFilteringAssign =
-                    new AssignOperator(additionalFilteringVars, additionalFilteringAssignExpressions);
+            additionalFilteringAssign = new AssignOperator(additionalFilteringVars,
+                    additionalFilteringAssignExpressions);
         }
 
         InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, payloadRef,
@@ -287,9 +280,9 @@ class LangExpressionToPlanTranslator
     @SuppressWarnings("unchecked")
     @Override
     public ILogicalPlan translate(Query expr, String outputDatasetName, ICompiledDmlStatement stmt)
-            throws AlgebricksException {
-        Pair<ILogicalOperator, LogicalVariable> p =
-                expr.accept(this, new MutableObject<>(new EmptyTupleSourceOperator()));
+            throws AlgebricksException, AsterixException {
+        Pair<ILogicalOperator, LogicalVariable> p = expr.accept(this,
+                new MutableObject<>(new EmptyTupleSourceOperator()));
         ArrayList<Mutable<ILogicalOperator>> globalPlanRoots = new ArrayList<>();
         ILogicalOperator topOp = p.first;
         ProjectOperator project = (ProjectOperator) topOp;
@@ -331,11 +324,10 @@ class LangExpressionToPlanTranslator
             project.getInputs().get(0).setValue(assignCollectionToSequence);
             project.getVariables().set(0, seqVar);
             resVar = seqVar;
-            DatasetDataSource targetDatasource =
-                    validateDatasetInfo(metadataProvider, stmt.getDataverseName(), stmt.getDatasetName());
-            List<Integer> keySourceIndicator =
-                    ((InternalDatasetDetails) targetDatasource.getDataset().getDatasetDetails())
-                            .getKeySourceIndicator();
+            DatasetDataSource targetDatasource = validateDatasetInfo(metadataProvider, stmt.getDataverseName(),
+                    stmt.getDatasetName());
+            List<Integer> keySourceIndicator = ((InternalDatasetDetails) targetDatasource.getDataset()
+                    .getDatasetDetails()).getKeySourceIndicator();
             ArrayList<LogicalVariable> vars = new ArrayList<>();
             ArrayList<Mutable<ILogicalExpression>> exprs = new ArrayList<>();
             List<Mutable<ILogicalExpression>> varRefsForLoading = new ArrayList<>();
@@ -355,8 +347,8 @@ class LangExpressionToPlanTranslator
 
             AssignOperator assign = new AssignOperator(vars, exprs);
             List<String> additionalFilteringField = DatasetUtils.getFilterField(targetDatasource.getDataset());
-            List<LogicalVariable> additionalFilteringVars;
-            List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions;
+            List<LogicalVariable> additionalFilteringVars = null;
+            List<Mutable<ILogicalExpression>> additionalFilteringAssignExpressions = null;
             List<Mutable<ILogicalExpression>> additionalFilteringExpressions = null;
             AssignOperator additionalFilteringAssign = null;
             if (additionalFilteringField != null) {
@@ -367,8 +359,8 @@ class LangExpressionToPlanTranslator
                 PlanTranslationUtil.prepareVarAndExpression(additionalFilteringField, resVar, additionalFilteringVars,
                         additionalFilteringAssignExpressions, additionalFilteringExpressions, context);
 
-                additionalFilteringAssign =
-                        new AssignOperator(additionalFilteringVars, additionalFilteringAssignExpressions);
+                additionalFilteringAssign = new AssignOperator(additionalFilteringVars,
+                        additionalFilteringAssignExpressions);
                 additionalFilteringAssign.getInputs().add(new MutableObject<>(project));
                 assign.getInputs().add(new MutableObject<>(additionalFilteringAssign));
             } else {
@@ -376,31 +368,148 @@ class LangExpressionToPlanTranslator
             }
 
             Mutable<ILogicalExpression> varRef = new MutableObject<>(new VariableReferenceExpression(resVar));
-            ILogicalOperator leafOperator;
+            ILogicalOperator leafOperator = null;
+
             switch (stmt.getKind()) {
-                case Statement.Kind.INSERT:
-                    leafOperator = translateInsert(targetDatasource, varRef, varRefsForLoading,
-                            additionalFilteringExpressions, assign);
+                case INSERT: {
+                    if (targetDatasource.getDataset().hasMetaPart()) {
+                        throw new AlgebricksException(targetDatasource.getDataset().getDatasetName()
+                                + ": insert into dataset is not supported on Datasets with Meta records");
+                    }
+                    InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
+                            varRefsForLoading, InsertDeleteUpsertOperator.Kind.INSERT, false);
+                    insertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
+                    insertOp.getInputs().add(new MutableObject<>(assign));
+                    leafOperator = new SinkOperator();
+                    leafOperator.getInputs().add(new MutableObject<>(insertOp));
                     break;
-                case Statement.Kind.UPSERT:
-                    leafOperator = translateUpsert(targetDatasource, varRef, varRefsForLoading,
-                            additionalFilteringExpressions, assign, additionalFilteringField);
+                }
+                case UPSERT: {
+                    if (targetDatasource.getDataset().hasMetaPart()) {
+                        throw new AlgebricksException(targetDatasource.getDataset().getDatasetName()
+                                + ": upsert into dataset is not supported on Datasets with Meta records");
+                    }
+                    InsertDeleteUpsertOperator upsertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
+                            varRefsForLoading, InsertDeleteUpsertOperator.Kind.UPSERT, false);
+                    upsertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
+                    upsertOp.getInputs().add(new MutableObject<>(assign));
+                    // Create and add a new variable used for representing the original record
+                    ARecordType recordType = (ARecordType) targetDatasource.getItemType();
+                    upsertOp.setPrevRecordVar(context.newVar());
+                    upsertOp.setPrevRecordType(recordType);
+                    if (additionalFilteringField != null) {
+                        upsertOp.setPrevFilterVar(context.newVar());
+                        upsertOp.setPrevFilterType(recordType.getFieldType(additionalFilteringField.get(0)));
+                    }
+                    leafOperator = new SinkOperator();
+                    leafOperator.getInputs().add(new MutableObject<>(upsertOp));
                     break;
-                case Statement.Kind.DELETE:
-                    leafOperator = translateDelete(targetDatasource, varRef, varRefsForLoading,
-                            additionalFilteringExpressions, assign);
+                }
+                case DELETE: {
+                    if (targetDatasource.getDataset().hasMetaPart()) {
+                        throw new AlgebricksException(targetDatasource.getDataset().getDatasetName()
+                                + ": delete from dataset is not supported on Datasets with Meta records");
+                    }
+                    InsertDeleteUpsertOperator deleteOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
+                            varRefsForLoading, InsertDeleteUpsertOperator.Kind.DELETE, false);
+                    deleteOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
+                    deleteOp.getInputs().add(new MutableObject<>(assign));
+                    leafOperator = new SinkOperator();
+                    leafOperator.getInputs().add(new MutableObject<>(deleteOp));
                     break;
-                case Statement.Kind.CONNECT_FEED:
-                    leafOperator = translateConnectFeed(targetDatasource, varRef, varRefsForLoading,
-                            additionalFilteringExpressions, assign);
+                }
+                case CONNECT_FEED: {
+                    InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
+                            varRefsForLoading, InsertDeleteUpsertOperator.Kind.INSERT, false);
+                    insertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
+                    insertOp.getInputs().add(new MutableObject<>(assign));
+                    leafOperator = new SinkOperator();
+                    leafOperator.getInputs().add(new MutableObject<>(insertOp));
                     break;
-                case Statement.Kind.SUBSCRIBE_FEED:
-                    leafOperator = translateSubscribeFeed((CompiledSubscribeFeedStatement) stmt, targetDatasource,
-                            unnestVar, project, exprs, resVar, varRefsForLoading, varRef, assign,
-                            additionalFilteringField, additionalFilteringAssign, additionalFilteringExpressions);
+                }
+                case SUBSCRIBE_FEED: {
+                    // if the feed is a change feed (i.e, performs different operations), we need to project op variable
+                    CompiledSubscribeFeedStatement sfs = (CompiledSubscribeFeedStatement) stmt;
+                    InsertDeleteUpsertOperator feedModificationOp;
+                    AssignOperator metaAndKeysAssign = null;
+                    List<LogicalVariable> metaAndKeysVars = null;
+                    List<Mutable<ILogicalExpression>> metaAndKeysExprs = null;
+                    List<Mutable<ILogicalExpression>> metaExpSingletonList = null;
+                    boolean isChangeFeed = FeedMetadataUtil.isChangeFeed(metadataProvider, sfs.getDataverseName(),
+                            sfs.getFeedName());
+                    if (targetDatasource.getDataset().hasMetaPart() || isChangeFeed) {
+                        metaAndKeysVars = new ArrayList<>();
+                        metaAndKeysExprs = new ArrayList<>();
+                    }
+                    if (targetDatasource.getDataset().hasMetaPart()) {
+                        // add the meta function
+                        IFunctionInfo finfoMeta = FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.META);
+                        ScalarFunctionCallExpression metaFunction = new ScalarFunctionCallExpression(finfoMeta,
+                                new MutableObject<>(new VariableReferenceExpression(unnestVar)));
+                        // create assign for the meta part
+                        LogicalVariable metaVar = context.newVar();
+                        metaExpSingletonList = new ArrayList<>(1);
+                        metaExpSingletonList.add(new MutableObject<>(new VariableReferenceExpression(metaVar)));
+                        metaAndKeysVars.add(metaVar);
+                        metaAndKeysExprs.add(new MutableObject<>(metaFunction));
+                        project.getVariables().add(metaVar);
+                    }
+                    if (isChangeFeed) {
+                        varRefsForLoading.clear();
+                        for (Mutable<ILogicalExpression> assignExpr : exprs) {
+                            if (assignExpr.getValue().getExpressionTag() == LogicalExpressionTag.FUNCTION_CALL) {
+                                AbstractFunctionCallExpression funcCall = (AbstractFunctionCallExpression) assignExpr
+                                        .getValue();
+                                funcCall.substituteVar(resVar, unnestVar);
+                                LogicalVariable pkVar = context.newVar();
+                                metaAndKeysVars.add(pkVar);
+                                metaAndKeysExprs.add(new MutableObject<>(assignExpr.getValue()));
+                                project.getVariables().add(pkVar);
+                                varRefsForLoading.add(new MutableObject<>(new VariableReferenceExpression(pkVar)));
+                            }
+                        }
+                        // A change feed, we don't need the assign to access PKs
+                        feedModificationOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading,
+                                metaExpSingletonList, InsertDeleteUpsertOperator.Kind.UPSERT, false);
+                        // Create and add a new variable used for representing the original record
+                        feedModificationOp.setPrevRecordVar(context.newVar());
+                        feedModificationOp.setPrevRecordType(targetDatasource.getItemType());
+                        if (targetDatasource.getDataset().hasMetaPart()) {
+                            List<LogicalVariable> metaVars = new ArrayList<>();
+                            metaVars.add(context.newVar());
+                            feedModificationOp.setPrevAdditionalNonFilteringVars(metaVars);
+                            List<Object> metaTypes = new ArrayList<>();
+                            metaTypes.add(targetDatasource.getMetaItemType());
+                            feedModificationOp.setPrevAdditionalNonFilteringTypes(metaTypes);
+                        }
+
+                        if (additionalFilteringField != null) {
+                            feedModificationOp.setPrevFilterVar(context.newVar());
+                            feedModificationOp.setPrevFilterType(((ARecordType) targetDatasource.getItemType())
+                                    .getFieldType(additionalFilteringField.get(0)));
+                            additionalFilteringAssign.getInputs().clear();
+                            additionalFilteringAssign.getInputs().add(assign.getInputs().get(0));
+                            feedModificationOp.getInputs().add(new MutableObject<>(additionalFilteringAssign));
+                        } else {
+                            feedModificationOp.getInputs().add(assign.getInputs().get(0));
+                        }
+                    } else {
+                        feedModificationOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading,
+                                metaExpSingletonList, InsertDeleteUpsertOperator.Kind.INSERT, false);
+                        feedModificationOp.getInputs().add(new MutableObject<>(assign));
+                    }
+                    if (targetDatasource.getDataset().hasMetaPart() || isChangeFeed) {
+                        metaAndKeysAssign = new AssignOperator(metaAndKeysVars, metaAndKeysExprs);
+                        metaAndKeysAssign.getInputs().add(project.getInputs().get(0));
+                        project.getInputs().set(0, new MutableObject<>(metaAndKeysAssign));
+                    }
+                    feedModificationOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
+                    leafOperator = new SinkOperator();
+                    leafOperator.getInputs().add(new MutableObject<>(feedModificationOp));
                     break;
+                }
                 default:
-                    throw new AlgebricksException("Unsupported statement kind " + stmt.getKind());
+                    break;
             }
             topOp = leafOperator;
         }
@@ -410,162 +519,6 @@ class LangExpressionToPlanTranslator
         return plan;
     }
 
-    private ILogicalOperator translateConnectFeed(DatasetDataSource targetDatasource,
-            Mutable<ILogicalExpression> varRef, List<Mutable<ILogicalExpression>> varRefsForLoading,
-            List<Mutable<ILogicalExpression>> additionalFilteringExpressions, ILogicalOperator assign) {
-        InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
-                varRefsForLoading, InsertDeleteUpsertOperator.Kind.INSERT, false);
-        insertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
-        insertOp.getInputs().add(new MutableObject<>(assign));
-        SinkOperator leafOperator = new SinkOperator();
-        leafOperator.getInputs().add(new MutableObject<>(insertOp));
-        return leafOperator;
-    }
-
-    private ILogicalOperator translateDelete(DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef,
-            List<Mutable<ILogicalExpression>> varRefsForLoading,
-            List<Mutable<ILogicalExpression>> additionalFilteringExpressions, ILogicalOperator assign)
-            throws AlgebricksException {
-        if (targetDatasource.getDataset().hasMetaPart()) {
-            throw new AlgebricksException(targetDatasource.getDataset().getDatasetName()
-                    + ": delete from dataset is not supported on Datasets with Meta records");
-        }
-        InsertDeleteUpsertOperator deleteOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
-                varRefsForLoading, InsertDeleteUpsertOperator.Kind.DELETE, false);
-        deleteOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
-        deleteOp.getInputs().add(new MutableObject<>(assign));
-        SinkOperator leafOperator = new SinkOperator();
-        leafOperator.getInputs().add(new MutableObject<>(deleteOp));
-        return leafOperator;
-    }
-
-    private ILogicalOperator translateSubscribeFeed(CompiledSubscribeFeedStatement sfs,
-            DatasetDataSource targetDatasource, LogicalVariable unnestVar, ProjectOperator project,
-            ArrayList<Mutable<ILogicalExpression>> exprs, LogicalVariable resVar,
-            List<Mutable<ILogicalExpression>> varRefsForLoading, Mutable<ILogicalExpression> varRef,
-            ILogicalOperator assign, List<String> additionalFilteringField, AssignOperator additionalFilteringAssign,
-            List<Mutable<ILogicalExpression>> additionalFilteringExpressions) throws AlgebricksException {
-        // if the feed is a change feed (i.e, performs different operations), we need to project op variable
-        InsertDeleteUpsertOperator feedModificationOp;
-        AssignOperator metaAndKeysAssign;
-        List<LogicalVariable> metaAndKeysVars = null;
-        List<Mutable<ILogicalExpression>> metaAndKeysExprs = null;
-        List<Mutable<ILogicalExpression>> metaExpSingletonList = null;
-        boolean isChangeFeed =
-                FeedMetadataUtil.isChangeFeed(metadataProvider, sfs.getDataverseName(), sfs.getFeedName());
-        if (targetDatasource.getDataset().hasMetaPart() || isChangeFeed) {
-            metaAndKeysVars = new ArrayList<>();
-            metaAndKeysExprs = new ArrayList<>();
-            if (targetDatasource.getDataset().hasMetaPart()) {
-                // add the meta function
-                IFunctionInfo finfoMeta = FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.META);
-                ScalarFunctionCallExpression metaFunction = new ScalarFunctionCallExpression(finfoMeta,
-                        new MutableObject<>(new VariableReferenceExpression(unnestVar)));
-                // create assign for the meta part
-                LogicalVariable metaVar = context.newVar();
-                metaExpSingletonList = new ArrayList<>(1);
-                metaExpSingletonList.add(new MutableObject<>(new VariableReferenceExpression(metaVar)));
-                metaAndKeysVars.add(metaVar);
-                metaAndKeysExprs.add(new MutableObject<>(metaFunction));
-                project.getVariables().add(metaVar);
-            }
-        }
-        if (isChangeFeed) {
-            varRefsForLoading.clear();
-            for (Mutable<ILogicalExpression> assignExpr : exprs) {
-                if (assignExpr.getValue().getExpressionTag() == LogicalExpressionTag.FUNCTION_CALL) {
-                    AbstractFunctionCallExpression funcCall = (AbstractFunctionCallExpression) assignExpr.getValue();
-                    funcCall.substituteVar(resVar, unnestVar);
-                    LogicalVariable pkVar = context.newVar();
-                    metaAndKeysVars.add(pkVar);
-                    metaAndKeysExprs.add(new MutableObject<>(assignExpr.getValue()));
-                    project.getVariables().add(pkVar);
-                    varRefsForLoading.add(new MutableObject<>(new VariableReferenceExpression(pkVar)));
-                }
-            }
-            // A change feed, we don't need the assign to access PKs
-            feedModificationOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading,
-                    metaExpSingletonList, InsertDeleteUpsertOperator.Kind.UPSERT, false);
-            // Create and add a new variable used for representing the original record
-            feedModificationOp.setPrevRecordVar(context.newVar());
-            feedModificationOp.setPrevRecordType(targetDatasource.getItemType());
-            if (targetDatasource.getDataset().hasMetaPart()) {
-                List<LogicalVariable> metaVars = new ArrayList<>();
-                metaVars.add(context.newVar());
-                feedModificationOp.setPrevAdditionalNonFilteringVars(metaVars);
-                List<Object> metaTypes = new ArrayList<>();
-                metaTypes.add(targetDatasource.getMetaItemType());
-                feedModificationOp.setPrevAdditionalNonFilteringTypes(metaTypes);
-            }
-
-            if (additionalFilteringField != null) {
-                feedModificationOp.setPrevFilterVar(context.newVar());
-                feedModificationOp.setPrevFilterType(
-                        ((ARecordType) targetDatasource.getItemType()).getFieldType(additionalFilteringField.get(0)));
-                additionalFilteringAssign.getInputs().clear();
-                additionalFilteringAssign.getInputs().add(assign.getInputs().get(0));
-                feedModificationOp.getInputs().add(new MutableObject<>(additionalFilteringAssign));
-            } else {
-                feedModificationOp.getInputs().add(assign.getInputs().get(0));
-            }
-        } else {
-            feedModificationOp = new InsertDeleteUpsertOperator(targetDatasource, varRef, varRefsForLoading,
-                    metaExpSingletonList, InsertDeleteUpsertOperator.Kind.INSERT, false);
-            feedModificationOp.getInputs().add(new MutableObject<>(assign));
-        }
-        if (targetDatasource.getDataset().hasMetaPart() || isChangeFeed) {
-            metaAndKeysAssign = new AssignOperator(metaAndKeysVars, metaAndKeysExprs);
-            metaAndKeysAssign.getInputs().add(project.getInputs().get(0));
-            project.getInputs().set(0, new MutableObject<>(metaAndKeysAssign));
-        }
-        feedModificationOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
-        SinkOperator leafOperator = new SinkOperator();
-        leafOperator.getInputs().add(new MutableObject<>(feedModificationOp));
-        return leafOperator;
-    }
-
-    private ILogicalOperator translateUpsert(DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef,
-            List<Mutable<ILogicalExpression>> varRefsForLoading,
-            List<Mutable<ILogicalExpression>> additionalFilteringExpressions, ILogicalOperator assign,
-            List<String> additionalFilteringField) throws AlgebricksException {
-        if (targetDatasource.getDataset().hasMetaPart()) {
-            throw new AlgebricksException(targetDatasource.getDataset().getDatasetName()
-                    + ": upsert into dataset is not supported on Datasets with Meta records");
-        }
-        InsertDeleteUpsertOperator upsertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
-                varRefsForLoading, InsertDeleteUpsertOperator.Kind.UPSERT, false);
-        upsertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
-        upsertOp.getInputs().add(new MutableObject<>(assign));
-        // Create and add a new variable used for representing the original record
-        ARecordType recordType = (ARecordType) targetDatasource.getItemType();
-        upsertOp.setPrevRecordVar(context.newVar());
-        upsertOp.setPrevRecordType(recordType);
-        if (additionalFilteringField != null) {
-            upsertOp.setPrevFilterVar(context.newVar());
-            upsertOp.setPrevFilterType(recordType.getFieldType(additionalFilteringField.get(0)));
-        }
-        SinkOperator leafOperator = new SinkOperator();
-        leafOperator.getInputs().add(new MutableObject<>(upsertOp));
-        return leafOperator;
-    }
-
-    private ILogicalOperator translateInsert(DatasetDataSource targetDatasource, Mutable<ILogicalExpression> varRef,
-            List<Mutable<ILogicalExpression>> varRefsForLoading,
-            List<Mutable<ILogicalExpression>> additionalFilteringExpressions, ILogicalOperator assign)
-            throws AlgebricksException {
-        if (targetDatasource.getDataset().hasMetaPart()) {
-            throw new AlgebricksException(targetDatasource.getDataset().getDatasetName()
-                    + ": insert into dataset is not supported on Datasets with Meta records");
-        }
-        InsertDeleteUpsertOperator insertOp = new InsertDeleteUpsertOperator(targetDatasource, varRef,
-                varRefsForLoading, InsertDeleteUpsertOperator.Kind.INSERT, false);
-        insertOp.setAdditionalFilteringExpressions(additionalFilteringExpressions);
-        insertOp.getInputs().add(new MutableObject<>(assign));
-        SinkOperator leafOperator = new SinkOperator();
-        leafOperator.getInputs().add(new MutableObject<>(insertOp));
-        return leafOperator;
-    }
-
     private DatasetDataSource validateDatasetInfo(AqlMetadataProvider metadataProvider, String dataverseName,
             String datasetName) throws AlgebricksException {
         Dataset dataset = metadataProvider.findDataset(dataverseName, datasetName);
@@ -577,17 +530,18 @@ class LangExpressionToPlanTranslator
         }
         AqlSourceId sourceId = new AqlSourceId(dataverseName, datasetName);
         IAType itemType = metadataProvider.findType(dataset.getItemTypeDataverseName(), dataset.getItemTypeName());
-        IAType metaItemType =
-                metadataProvider.findType(dataset.getMetaItemTypeDataverseName(), dataset.getMetaItemTypeName());
+        IAType metaItemType = metadataProvider.findType(dataset.getMetaItemTypeDataverseName(),
+                dataset.getMetaItemTypeName());
         INodeDomain domain = metadataProvider.findNodeDomain(dataset.getNodeGroupName());
-        return new DatasetDataSource(sourceId, dataset, itemType, metaItemType, AqlDataSourceType.INTERNAL_DATASET,
-                dataset.getDatasetDetails(), domain);
+        DatasetDataSource dataSource = new DatasetDataSource(sourceId, dataset, itemType, metaItemType,
+                AqlDataSourceType.INTERNAL_DATASET, dataset.getDatasetDetails(), domain);
+        return dataSource;
     }
 
     private FileSplit getDefaultOutputFileLocation() throws MetadataException {
         String outputDir = System.getProperty("java.io.tmpDir");
-        String filePath =
-                outputDir + System.getProperty("file.separator") + OUTPUT_FILE_PREFIX + outputFileID.incrementAndGet();
+        String filePath = outputDir + System.getProperty("file.separator") + OUTPUT_FILE_PREFIX
+                + outputFileID.incrementAndGet();
         AsterixMetadataProperties metadataProperties = AsterixAppContextInfo.getInstance().getMetadataProperties();
         return new FileSplit(metadataProperties.getMetadataNodeName(), new FileReference(new File(filePath)));
     }
@@ -597,17 +551,23 @@ class LangExpressionToPlanTranslator
             throws AsterixException {
         LogicalVariable v;
         ILogicalOperator returnedOp;
-        if (lc.getBindingExpr().getKind() == Kind.VARIABLE_EXPRESSION) {
-            v = context.newVar(lc.getVarExpr());
-            LogicalVariable prev = context.getVar(((VariableExpr) lc.getBindingExpr()).getVar().getId());
-            returnedOp = new AssignOperator(v, new MutableObject<>(new VariableReferenceExpression(prev)));
-            returnedOp.getInputs().add(tupSource);
-        } else {
-            v = context.newVar(lc.getVarExpr());
-            Pair<ILogicalExpression, Mutable<ILogicalOperator>> eo =
-                    langExprToAlgExpression(lc.getBindingExpr(), tupSource);
-            returnedOp = new AssignOperator(v, new MutableObject<>(eo.first));
-            returnedOp.getInputs().add(eo.second);
+
+        switch (lc.getBindingExpr().getKind()) {
+            case VARIABLE_EXPRESSION: {
+                v = context.newVar(lc.getVarExpr());
+                LogicalVariable prev = context.getVar(((VariableExpr) lc.getBindingExpr()).getVar().getId());
+                returnedOp = new AssignOperator(v, new MutableObject<>(new VariableReferenceExpression(prev)));
+                returnedOp.getInputs().add(tupSource);
+                break;
+            }
+            default: {
+                v = context.newVar(lc.getVarExpr());
+                Pair<ILogicalExpression, Mutable<ILogicalOperator>> eo = langExprToAlgExpression(lc.getBindingExpr(),
+                        tupSource);
+                returnedOp = new AssignOperator(v, new MutableObject<>(eo.first));
+                returnedOp.getInputs().add(eo.second);
+                break;
+            }
         }
         return new Pair<>(returnedOp, v);
     }
@@ -620,8 +580,8 @@ class LangExpressionToPlanTranslator
         AbstractFunctionCallExpression fldAccess = new ScalarFunctionCallExpression(
                 FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.FIELD_ACCESS_BY_NAME));
         fldAccess.getArguments().add(new MutableObject<>(p.first));
-        ILogicalExpression faExpr =
-                new ConstantExpression(new AsterixConstantValue(new AString(fa.getIdent().getValue())));
+        ILogicalExpression faExpr = new ConstantExpression(
+                new AsterixConstantValue(new AString(fa.getIdent().getValue())));
         fldAccess.getArguments().add(new MutableObject<>(faExpr));
         AssignOperator a = new AssignOperator(v, new MutableObject<>(fldAccess));
         a.getInputs().add(p.second);
@@ -639,8 +599,8 @@ class LangExpressionToPlanTranslator
                     FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.ANY_COLLECTION_MEMBER));
             f.getArguments().add(new MutableObject<>(p.first));
         } else {
-            Pair<ILogicalExpression, Mutable<ILogicalOperator>> indexPair =
-                    langExprToAlgExpression(ia.getIndexExpr(), tupSource);
+            Pair<ILogicalExpression, Mutable<ILogicalOperator>> indexPair = langExprToAlgExpression(ia.getIndexExpr(),
+                    tupSource);
             f = new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.GET_ITEM));
             f.getArguments().add(new MutableObject<>(p.first));
             f.getArguments().add(new MutableObject<>(indexPair.first));
@@ -660,16 +620,18 @@ class LangExpressionToPlanTranslator
 
         for (Expression expr : fcall.getExprList()) {
             switch (expr.getKind()) {
-                case VARIABLE_EXPRESSION:
+                case VARIABLE_EXPRESSION: {
                     LogicalVariable var = context.getVar(((VariableExpr) expr).getVar().getId());
                     args.add(new MutableObject<>(new VariableReferenceExpression(var)));
                     break;
-                case LITERAL_EXPRESSION:
+                }
+                case LITERAL_EXPRESSION: {
                     LiteralExpr val = (LiteralExpr) expr;
                     args.add(new MutableObject<>(new ConstantExpression(
                             new AsterixConstantValue(ConstantHelper.objectFromLiteral(val.getValue())))));
                     break;
-                default:
+                }
+                default: {
                     Pair<ILogicalExpression, Mutable<ILogicalOperator>> eo = langExprToAlgExpression(expr, topOp);
                     AbstractLogicalOperator o1 = (AbstractLogicalOperator) eo.second.getValue();
                     args.add(new MutableObject<>(eo.first));
@@ -677,6 +639,7 @@ class LangExpressionToPlanTranslator
                         topOp = eo.second;
                     }
                     break;
+                }
             }
         }
 
@@ -713,7 +676,7 @@ class LangExpressionToPlanTranslator
         if (function == null) {
             return null;
         }
-        AbstractFunctionCallExpression f;
+        AbstractFunctionCallExpression f = null;
         if (function.getLanguage().equalsIgnoreCase(Function.LANGUAGE_JAVA)) {
             IFunctionInfo finfo = ExternalFunctionCompilerUtil
                     .getExternalFunctionInfo(metadataProvider.getMetadataTxnContext(), function);
@@ -730,7 +693,7 @@ class LangExpressionToPlanTranslator
 
     private AbstractFunctionCallExpression lookupBuiltinFunction(String functionName, int arity,
             List<Mutable<ILogicalExpression>> args) {
-        AbstractFunctionCallExpression f;
+        AbstractFunctionCallExpression f = null;
         FunctionIdentifier fi = new FunctionIdentifier(AlgebricksBuiltinFunctions.ALGEBRICKS_NS, functionName, arity);
         AsterixFunctionInfo afi = AsterixBuiltinFunctions.lookupFunction(fi);
         FunctionIdentifier builtinAquafi = afi == null ? null : afi.getFunctionIdentifier();
@@ -747,8 +710,8 @@ class LangExpressionToPlanTranslator
         if (AsterixBuiltinFunctions.isBuiltinAggregateFunction(fi)) {
             f = AsterixBuiltinFunctions.makeAggregateFunctionExpression(fi, args);
         } else if (AsterixBuiltinFunctions.isBuiltinUnnestingFunction(fi)) {
-            UnnestingFunctionCallExpression ufce =
-                    new UnnestingFunctionCallExpression(FunctionUtil.getFunctionInfo(fi), args);
+            UnnestingFunctionCallExpression ufce = new UnnestingFunctionCallExpression(FunctionUtil.getFunctionInfo(fi),
+                    args);
             ufce.setReturnsUniqueValues(AsterixBuiltinFunctions.returnsUniqueValues(fi));
             f = ufce;
         } else {
@@ -771,9 +734,8 @@ class LangExpressionToPlanTranslator
             List<Pair<Expression, Identifier>> groupFieldList = gc.getGroupFieldList();
             List<Mutable<ILogicalExpression>> groupRecordConstructorArgList = new ArrayList<>();
             for (Pair<Expression, Identifier> groupField : groupFieldList) {
-                ILogicalExpression groupFieldNameExpr =
-                        langExprToAlgExpression(new LiteralExpr(new StringLiteral(groupField.second.getValue())),
-                                topOp).first;
+                ILogicalExpression groupFieldNameExpr = langExprToAlgExpression(
+                        new LiteralExpr(new StringLiteral(groupField.second.getValue())), topOp).first;
                 groupRecordConstructorArgList.add(new MutableObject<>(groupFieldNameExpr));
                 ILogicalExpression groupFieldExpr = langExprToAlgExpression(groupField.first, topOp).first;
                 groupRecordConstructorArgList.add(new MutableObject<>(groupFieldExpr));
@@ -789,38 +751,18 @@ class LangExpressionToPlanTranslator
         if (gc.isGroupAll()) {
             List<LogicalVariable> aggVars = new ArrayList<>();
             List<Mutable<ILogicalExpression>> aggFuncs = new ArrayList<>();
-            // A global aggregation can still have a decoration variable list which are used for propagate
-            // outer-scope variables. Example query:
-            // asterixdb/asterixdb/asterix-app/src/test/resources/runtimets/queries_sqlpp/global-aggregate/q09
-            for (GbyVariableExpressionPair ve : gc.getDecorPairList()) {
-                VariableExpr vexpr = ve.getVar();
-                LogicalVariable decorVar = vexpr == null ? context.newVar() : context.newVar(vexpr);
-                Pair<ILogicalExpression, Mutable<ILogicalOperator>> eo = langExprToAlgExpression(ve.getExpr(), topOp);
-                topOp = eo.second;
-                List<Mutable<ILogicalExpression>> flArgs = new ArrayList<>();
-                flArgs.add(new MutableObject<>(eo.first));
-                // Calls the first-element aggregate function on a decoration variable to make sure the value
-                // is propagated through a global aggregation.
-                AggregateFunctionCallExpression firstElementAgg = AsterixBuiltinFunctions
-                        .makeAggregateFunctionExpression(
-                        AsterixBuiltinFunctions.FIRST_ELEMENT, flArgs);
-                aggVars.add(decorVar);
-                aggFuncs.add(new MutableObject<>(firstElementAgg));
-            }
-            for (Entry<Expression, VariableExpr> entry : gc.getWithVarMap().entrySet()) {
-                Pair<ILogicalExpression, Mutable<ILogicalOperator>> listifyInput =
-                        langExprToAlgExpression(entry.getKey(), topOp);
-                topOp = listifyInput.second;
+            for (VariableExpr var : gc.getWithVarList()) {
+                LogicalVariable aggVar = context.newVar();
+                LogicalVariable oldVar = context.getVar(var);
                 List<Mutable<ILogicalExpression>> flArgs = new ArrayList<>();
-                flArgs.add(new MutableObject<>(listifyInput.first));
+                flArgs.add(new MutableObject<>(new VariableReferenceExpression(oldVar)));
                 AggregateFunctionCallExpression fListify = AsterixBuiltinFunctions
                         .makeAggregateFunctionExpression(AsterixBuiltinFunctions.LISTIFY, flArgs);
-                LogicalVariable aggVar = context.newVar();
                 aggVars.add(aggVar);
                 aggFuncs.add(new MutableObject<>(fListify));
                 // Hide the variable that was part of the "with", replacing it with
                 // the one bound by the aggregation op.
-                context.setVar(entry.getValue(), aggVar);
+                context.setVar(var, aggVar);
             }
             AggregateOperator aggOp = new AggregateOperator(aggVars, aggFuncs);
             aggOp.getInputs().add(topOp);
@@ -853,23 +795,22 @@ class LangExpressionToPlanTranslator
             }
 
             gOp.getInputs().add(topOp);
-            for (Entry<Expression, VariableExpr> entry : gc.getWithVarMap().entrySet()) {
-                Pair<ILogicalExpression, Mutable<ILogicalOperator>> listifyInput = langExprToAlgExpression(
-                        entry.getKey(), new MutableObject<>(new NestedTupleSourceOperator(new MutableObject<>(gOp))));
+            for (VariableExpr var : gc.getWithVarList()) {
+                LogicalVariable aggVar = context.newVar();
+                LogicalVariable oldVar = context.getVar(var);
                 List<Mutable<ILogicalExpression>> flArgs = new ArrayList<>(1);
-                flArgs.add(new MutableObject<>(listifyInput.first));
+                flArgs.add(new MutableObject<>(new VariableReferenceExpression(oldVar)));
                 AggregateFunctionCallExpression fListify = AsterixBuiltinFunctions
                         .makeAggregateFunctionExpression(AsterixBuiltinFunctions.LISTIFY, flArgs);
-                LogicalVariable aggVar = context.newVar();
                 AggregateOperator agg = new AggregateOperator(mkSingletonArrayList(aggVar),
-                        mkSingletonArrayList(new MutableObject<>(fListify)));
+                        (List) mkSingletonArrayList(new MutableObject<>(fListify)));
 
-                agg.getInputs().add(listifyInput.second);
+                agg.getInputs().add(new MutableObject<>(new NestedTupleSourceOperator(new MutableObject<>(gOp))));
                 ILogicalPlan plan = new ALogicalPlanImpl(new MutableObject<>(agg));
                 gOp.getNestedPlans().add(plan);
                 // Hide the variable that was part of the "with", replacing it with
                 // the one bound by the aggregation op.
-                context.setVar(entry.getValue(), aggVar);
+                context.setVar(var, aggVar);
             }
             gOp.getAnnotations().put(OperatorAnnotations.USE_HASH_GROUP_BY, gc.hasHashGroupByHint());
             return new Pair<>(gOp, null);
@@ -899,7 +840,7 @@ class LangExpressionToPlanTranslator
         // Creates a subplan for the "else" branch.
         AbstractFunctionCallExpression notVarCond = new ScalarFunctionCallExpression(
                 FunctionUtil.getFunctionInfo(AlgebricksBuiltinFunctions.NOT),
-                Collections.singletonList(generateAndNotIsUnknownWrap(new VariableReferenceExpression(varCond))));
+                Collections.singletonList(new MutableObject<>(new VariableReferenceExpression(varCond))));
         Pair<ILogicalOperator, LogicalVariable> opAndVarForElse = constructSubplanOperatorForBranch(
                 opAndVarForThen.first, new MutableObject<>(notVarCond), ifexpr.getElseExpr());
 
@@ -909,6 +850,7 @@ class LangExpressionToPlanTranslator
         arguments.add(new MutableObject<>(new VariableReferenceExpression(varCond)));
         arguments.add(new MutableObject<>(ConstantExpression.TRUE));
         arguments.add(new MutableObject<>(new VariableReferenceExpression(opAndVarForThen.second)));
+        arguments.add(new MutableObject<>(ConstantExpression.FALSE));
         arguments.add(new MutableObject<>(new VariableReferenceExpression(opAndVarForElse.second)));
         AbstractFunctionCallExpression swithCaseExpr = new ScalarFunctionCallExpression(
                 FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SWITCH_CASE), arguments);
@@ -925,8 +867,8 @@ class LangExpressionToPlanTranslator
 
         // Produces the final result.
         LogicalVariable resultVar = context.newVar();
-        AssignOperator finalAssignOp =
-                new AssignOperator(resultVar, new MutableObject<>(new VariableReferenceExpression(unnestVar)));
+        AssignOperator finalAssignOp = new AssignOperator(resultVar,
+                new MutableObject<>(new VariableReferenceExpression(unnestVar)));
         finalAssignOp.getInputs().add(new MutableObject<>(unnestOp));
         return new Pair<>(finalAssignOp, resultVar);
     }
@@ -988,6 +930,7 @@ class LangExpressionToPlanTranslator
                     }
                 } else {
                     AbstractFunctionCallExpression f = createFunctionCallExpressionForBuiltinOperator(ops.get(i));
+
                     if (i == 0) {
                         f.getArguments().add(new MutableObject<>(e));
                         currExpr = f;
@@ -1157,24 +1100,13 @@ class LangExpressionToPlanTranslator
         Pair<ILogicalExpression, Mutable<ILogicalOperator>> eo = langExprToAlgExpression(expr, tupSource);
         LogicalVariable v1 = context.newVar();
         AssignOperator a;
-        switch (u.getExprType()) {
-            case POSITIVE:
-                a = new AssignOperator(v1, new MutableObject<>(eo.first));
-                break;
-            case NEGATIVE:
-                AbstractFunctionCallExpression m = new ScalarFunctionCallExpression(
-                        FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.NUMERIC_UNARY_MINUS));
-                m.getArguments().add(new MutableObject<>(eo.first));
-                a = new AssignOperator(v1, new MutableObject<>(m));
-                break;
-            case EXISTS:
-                a = processExists(eo.first, v1, false);
-                break;
-            case NOT_EXISTS:
-                a = processExists(eo.first, v1, true);
-                break;
-            default:
-                throw new AsterixException("Unsupported operator: " + u);
+        if (u.getSign() == Sign.POSITIVE) {
+            a = new AssignOperator(v1, new MutableObject<>(eo.first));
+        } else {
+            AbstractFunctionCallExpression m = new ScalarFunctionCallExpression(
+                    FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.NUMERIC_UNARY_MINUS));
+            m.getArguments().add(new MutableObject<>(eo.first));
+            a = new AssignOperator(v1, new MutableObject<>(m));
         }
         a.getInputs().add(eo.second);
         return new Pair<>(a, v1);
@@ -1250,40 +1182,53 @@ class LangExpressionToPlanTranslator
 
     protected AbstractFunctionCallExpression createFunctionCallExpressionForBuiltinOperator(OperatorType t)
             throws AsterixException {
-        FunctionIdentifier fid;
+
+        FunctionIdentifier fid = null;
         switch (t) {
-            case PLUS:
+            case PLUS: {
                 fid = AlgebricksBuiltinFunctions.NUMERIC_ADD;
                 break;
-            case MINUS:
+            }
+            case MINUS: {
                 fid = AsterixBuiltinFunctions.NUMERIC_SUBTRACT;
                 break;
-            case MUL:
+            }
+            case MUL: {
                 fid = AsterixBuiltinFunctions.NUMERIC_MULTIPLY;
                 break;
-            case DIV:
+            }
+            case DIV: {
                 fid = AsterixBuiltinFunctions.NUMERIC_DIVIDE;
                 break;
-            case MOD:
+            }
+            case MOD: {
                 fid = AsterixBuiltinFunctions.NUMERIC_MOD;
                 break;
-            case IDIV:
+            }
+            case IDIV: {
                 fid = AsterixBuiltinFunctions.NUMERIC_IDIV;
                 break;
-            case CARET:
+            }
+            case CARET: {
                 fid = AsterixBuiltinFunctions.CARET;
                 break;
-            case AND:
+            }
+            case AND: {
                 fid = AlgebricksBuiltinFunctions.AND;
                 break;
-            case OR:
+            }
+            case OR: {
                 fid = AlgebricksBuiltinFunctions.OR;
                 break;
-            case FUZZY_EQ:
+            }
+            case FUZZY_EQ: {
                 fid = AsterixBuiltinFunctions.FUZZY_EQ;
                 break;
-            default:
+            }
+
+            default: {
                 throw new NotImplementedException("Operator " + t + " is not yet implemented");
+            }
         }
         return new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(fid));
     }
@@ -1299,15 +1244,17 @@ class LangExpressionToPlanTranslator
     protected Pair<ILogicalExpression, Mutable<ILogicalOperator>> langExprToAlgExpression(Expression expr,
             Mutable<ILogicalOperator> topOpRef) throws AsterixException {
         switch (expr.getKind()) {
-            case VARIABLE_EXPRESSION:
-                VariableReferenceExpression ve =
-                        new VariableReferenceExpression(context.getVar(((VariableExpr) expr).getVar().getId()));
+            case VARIABLE_EXPRESSION: {
+                VariableReferenceExpression ve = new VariableReferenceExpression(
+                        context.getVar(((VariableExpr) expr).getVar().getId()));
                 return new Pair<>(ve, topOpRef);
-            case LITERAL_EXPRESSION:
+            }
+            case LITERAL_EXPRESSION: {
                 LiteralExpr val = (LiteralExpr) expr;
                 return new Pair<>(new ConstantExpression(
                         new AsterixConstantValue(ConstantHelper.objectFromLiteral(val.getValue()))), topOpRef);
-            default:
+            }
+            default: {
                 if (expressionNeedsNoNesting(expr)) {
                     Pair<ILogicalOperator, LogicalVariable> p = expr.accept(this, topOpRef);
                     ILogicalExpression exp = ((AssignOperator) p.first).getExpressions().get(0).getValue();
@@ -1333,6 +1280,7 @@ class LangExpressionToPlanTranslator
                         return new Pair<>(new VariableReferenceExpression(p.second), new MutableObject<>(s));
                     }
                 }
+            }
         }
     }
 
@@ -1373,9 +1321,11 @@ class LangExpressionToPlanTranslator
             Pair<ILogicalExpression, Mutable<ILogicalOperator>> p = langExprToAlgExpression(exprs.get(i), topOp);
             topOp = p.second;
             // now look at the operator
-            if (i < nOps && ops.get(i) != opLogical) {
-                throw new TranslationException(
-                        "Unexpected operator " + ops.get(i) + " in an OperatorExpr starting with " + opLogical);
+            if (i < nOps) {
+                if (ops.get(i) != opLogical) {
+                    throw new TranslationException(
+                            "Unexpected operator " + ops.get(i) + " in an OperatorExpr starting with " + opLogical);
+                }
             }
             f.getArguments().add(new MutableObject<>(p.first));
         }
@@ -1390,18 +1340,14 @@ class LangExpressionToPlanTranslator
 
     protected boolean expressionNeedsNoNesting(Expression expr) {
         Kind k = expr.getKind();
-        boolean noNesting = k == Kind.LITERAL_EXPRESSION || k == Kind.LIST_CONSTRUCTOR_EXPRESSION
-                || k == Kind.RECORD_CONSTRUCTOR_EXPRESSION || k == Kind.VARIABLE_EXPRESSION;
-        noNesting = noNesting || k == Kind.CALL_EXPRESSION || k == Kind.OP_EXPRESSION
-                || k == Kind.FIELD_ACCESSOR_EXPRESSION;
-        noNesting = noNesting || k == Kind.INDEX_ACCESSOR_EXPRESSION || k == Kind.UNARY_EXPRESSION
-                || k == Kind.IF_EXPRESSION;
-        return noNesting || k == Kind.INDEPENDENT_SUBQUERY || k == Kind.CASE_EXPRESSION;
-
+        return (k == Kind.LITERAL_EXPRESSION) || (k == Kind.LIST_CONSTRUCTOR_EXPRESSION)
+                || (k == Kind.RECORD_CONSTRUCTOR_EXPRESSION) || (k == Kind.VARIABLE_EXPRESSION)
+                || (k == Kind.CALL_EXPRESSION) || (k == Kind.OP_EXPRESSION) || (k == Kind.FIELD_ACCESSOR_EXPRESSION)
+                || (k == Kind.INDEX_ACCESSOR_EXPRESSION) || (k == Kind.UNARY_EXPRESSION) || (k == Kind.IF_EXPRESSION);
     }
 
     protected <T> List<T> mkSingletonArrayList(T item) {
-        ArrayList<T> array = new ArrayList<>(1);
+        ArrayList<T> array = new ArrayList<T>(1);
         array.add(item);
         return array;
     }
@@ -1411,16 +1357,22 @@ class LangExpressionToPlanTranslator
         argRefs.add(new MutableObject<>(expr));
         switch (expr.getExpressionTag()) {
             case CONSTANT:
-            case VARIABLE:
+            case VARIABLE: {
                 return new UnnestingFunctionCallExpression(
                         FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCAN_COLLECTION), argRefs);
-            case FUNCTION_CALL:
+            }
+            case FUNCTION_CALL: {
                 AbstractFunctionCallExpression fce = (AbstractFunctionCallExpression) expr;
-                return (fce.getKind() == FunctionKind.UNNEST) ? expr
-                        : new UnnestingFunctionCallExpression(
-                                FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCAN_COLLECTION), argRefs);
-            default:
+                if (fce.getKind() == FunctionKind.UNNEST) {
+                    return expr;
+                } else {
+                    return new UnnestingFunctionCallExpression(
+                            FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCAN_COLLECTION), argRefs);
+                }
+            }
+            default: {
                 return expr;
+            }
         }
     }
 
@@ -1494,8 +1446,8 @@ class LangExpressionToPlanTranslator
                 if (opRefSet.contains(childRef)) {
                     // There is a shared operator reference in the query plan.
                     // Deep copies the child plan.
-                    LogicalOperatorDeepCopyWithNewVariablesVisitor visitor =
-                            new LogicalOperatorDeepCopyWithNewVariablesVisitor(context, null);
+                    LogicalOperatorDeepCopyWithNewVariablesVisitor visitor = new LogicalOperatorDeepCopyWithNewVariablesVisitor(
+                            context, null);
                     ILogicalOperator newChild = childRef.getValue().accept(visitor, null);
                     Map<LogicalVariable, LogicalVariable> cloneVarMap = visitor.getInputToOutputVariableMapping();
 
@@ -1510,8 +1462,8 @@ class LangExpressionToPlanTranslator
 
                 // Recursively eliminate shared operator reference for the operator subtree,
                 // even if it is a deep copy of some other one.
-                Map<LogicalVariable, LogicalVariable> childVarMap =
-                        eliminateSharedOperatorReference(childRef, opRefSet);
+                Map<LogicalVariable, LogicalVariable> childVarMap = eliminateSharedOperatorReference(childRef,
+                        opRefSet);
                 // Substitute variables according to the new subtree.
                 VariableUtilities.substituteVariables(currentOperator, childVarMap, null);
 
@@ -1549,13 +1501,13 @@ class LangExpressionToPlanTranslator
      * @return a pair of the constructed subplan operator and the output variable for the branch.
      * @throws AsterixException
      */
-    protected Pair<ILogicalOperator, LogicalVariable> constructSubplanOperatorForBranch(ILogicalOperator inputOp,
+    private Pair<ILogicalOperator, LogicalVariable> constructSubplanOperatorForBranch(ILogicalOperator inputOp,
             Mutable<ILogicalExpression> selectExpr, Expression branchExpression) throws AsterixException {
         context.enterSubplan();
         SubplanOperator subplanOp = new SubplanOperator();
         subplanOp.getInputs().add(new MutableObject<>(inputOp));
-        Mutable<ILogicalOperator> nestedSource =
-                new MutableObject<>(new NestedTupleSourceOperator(new MutableObject<>(subplanOp)));
+        Mutable<ILogicalOperator> nestedSource = new MutableObject<>(
+                new NestedTupleSourceOperator(new MutableObject<>(subplanOp)));
         SelectOperator select = new SelectOperator(selectExpr, false, null);
         // The select operator cannot be moved up and down, otherwise it will cause typing issues (ASTERIXDB-1203).
         OperatorPropertiesUtil.markMovable(select, false);
@@ -1572,96 +1524,4 @@ class LangExpressionToPlanTranslator
         context.exitSubplan();
         return new Pair<>(subplanOp, branchVar);
     }
-
-    // Processes EXISTS and NOT EXISTS.
-    private AssignOperator processExists(ILogicalExpression inputExpr, LogicalVariable v1, boolean not) {
-        AbstractFunctionCallExpression count =
-                new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCALAR_COUNT));
-        count.getArguments().add(new MutableObject<>(inputExpr));
-        AbstractFunctionCallExpression comparison = new ScalarFunctionCallExpression(
-                FunctionUtil.getFunctionInfo(not ? AsterixBuiltinFunctions.EQ : AsterixBuiltinFunctions.NEQ));
-        comparison.getArguments().add(new MutableObject<>(count));
-        comparison.getArguments()
-                .add(new MutableObject<>(new ConstantExpression(new AsterixConstantValue(new AInt64(0L)))));
-        return new AssignOperator(v1, new MutableObject<>(comparison));
-    }
-
-    // Generates the filter condition for whether a conditional branch should be executed.
-    protected Mutable<ILogicalExpression> generateNoMatchedPrecedingWhenBranchesFilter(
-            List<ILogicalExpression> inputBooleanExprs) {
-        List<Mutable<ILogicalExpression>> arguments = new ArrayList<>();
-        for (ILogicalExpression inputBooleanExpr : inputBooleanExprs) {
-            // A NULL/MISSING valued WHEN expression does not lead to the corresponding THEN execution.
-            // Therefore, we should check a previous WHEN boolean condition is not unknown.
-            arguments.add(generateAndNotIsUnknownWrap(inputBooleanExpr));
-        }
-        Mutable<ILogicalExpression> hasBeenExecutedExprRef = new MutableObject<>(
-                new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.OR), arguments));
-        return new MutableObject<>(
-                new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.NOT),
-                        new ArrayList<>(Collections.singletonList(hasBeenExecutedExprRef))));
-    }
-
-    // For an input expression `expr`, return `expr AND expr IS NOT UNKOWN`.
-    protected Mutable<ILogicalExpression> generateAndNotIsUnknownWrap(ILogicalExpression logicalExpr) {
-        List<Mutable<ILogicalExpression>> arguments = new ArrayList<>();
-        arguments.add(new MutableObject<>(logicalExpr));
-        Mutable<ILogicalExpression> expr = new MutableObject<>(
-                new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.IS_UNKOWN),
-                        new ArrayList<>(Collections.singletonList(new MutableObject<>(logicalExpr)))));
-        arguments.add(new MutableObject<>(
-                new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.NOT),
-                        new ArrayList<>(Collections.singletonList(expr)))));
-        return new MutableObject<>(
-                new ScalarFunctionCallExpression(FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.AND), arguments));
-    }
-
-    // Generates the plan for "UNION ALL" or union expression from its input expressions.
-    protected Pair<ILogicalOperator, LogicalVariable> translateUnionAllFromInputExprs(List<ILangExpression> inputExprs,
-            Mutable<ILogicalOperator> tupSource) throws AsterixException {
-        List<Mutable<ILogicalOperator>> inputOpRefsToUnion = new ArrayList<>();
-        List<LogicalVariable> vars = new ArrayList<>();
-        for (ILangExpression expr : inputExprs) {
-            // Visits the expression of one branch.
-            Pair<ILogicalOperator, LogicalVariable> opAndVar = expr.accept(this, tupSource);
-
-            // Creates an unnest operator.
-            LogicalVariable unnestVar = context.newVar();
-            List<Mutable<ILogicalExpression>> args = new ArrayList<>();
-            args.add(new MutableObject<ILogicalExpression>(new VariableReferenceExpression(opAndVar.second)));
-            UnnestOperator unnestOp = new UnnestOperator(unnestVar,
-                    new MutableObject<ILogicalExpression>(new UnnestingFunctionCallExpression(
-                            FunctionUtil.getFunctionInfo(AsterixBuiltinFunctions.SCAN_COLLECTION), args)));
-            unnestOp.getInputs().add(new MutableObject<ILogicalOperator>(opAndVar.first));
-            inputOpRefsToUnion.add(new MutableObject<ILogicalOperator>(unnestOp));
-            vars.add(unnestVar);
-        }
-
-        // Creates a tree of binary union-all operators.
-        UnionAllOperator topUnionAllOp = null;
-        LogicalVariable topUnionVar = null;
-        Iterator<Mutable<ILogicalOperator>> inputOpRefIterator = inputOpRefsToUnion.iterator();
-        Mutable<ILogicalOperator> leftInputBranch = inputOpRefIterator.next();
-        Iterator<LogicalVariable> inputVarIterator = vars.iterator();
-        LogicalVariable leftInputVar = inputVarIterator.next();
-
-        while (inputOpRefIterator.hasNext()) {
-            // Generates the variable triple <leftVar, rightVar, outputVar> .
-            topUnionVar = context.newVar();
-            Triple<LogicalVariable, LogicalVariable, LogicalVariable> varTriple =
-                    new Triple<>(leftInputVar, inputVarIterator.next(), topUnionVar);
-            List<Triple<LogicalVariable, LogicalVariable, LogicalVariable>> varTriples = new ArrayList<>();
-            varTriples.add(varTriple);
-
-            // Creates a binary union-all operator.
-            topUnionAllOp = new UnionAllOperator(varTriples);
-            topUnionAllOp.getInputs().add(leftInputBranch);
-            topUnionAllOp.getInputs().add(inputOpRefIterator.next());
-
-            // Re-assigns leftInputBranch and leftInputVar.
-            leftInputBranch = new MutableObject<>(topUnionAllOp);
-            leftInputVar = topUnionVar;
-        }
-        return new Pair<>(topUnionAllOp, topUnionVar);
-    }
 }