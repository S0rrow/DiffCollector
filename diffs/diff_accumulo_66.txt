diff --git a/src/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java b/src/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java
index cf96fd184f..8d387efe6b 100644
--- a/src/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java
+++ b/src/core/src/main/java/org/apache/accumulo/core/util/shell/Shell.java
@@ -27,7 +27,6 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
@@ -45,7 +44,6 @@ import org.apache.accumulo.core.client.AccumuloException;
 import org.apache.accumulo.core.client.AccumuloSecurityException;
 import org.apache.accumulo.core.client.Connector;
 import org.apache.accumulo.core.client.Instance;
-import org.apache.accumulo.core.client.IteratorSetting;
 import org.apache.accumulo.core.client.TableNotFoundException;
 import org.apache.accumulo.core.client.ZooKeeperInstance;
 import org.apache.accumulo.core.client.mock.MockInstance;
@@ -57,81 +55,13 @@ import org.apache.accumulo.core.data.thrift.TConstraintViolationSummary;
 import org.apache.accumulo.core.security.AuditLevel;
 import org.apache.accumulo.core.security.thrift.AuthInfo;
 import org.apache.accumulo.core.tabletserver.thrift.ConstraintViolationException;
-import org.apache.accumulo.core.trace.DistributedTrace;
 import org.apache.accumulo.core.util.BadArgumentException;
 import org.apache.accumulo.core.util.format.BinaryFormatter;
 import org.apache.accumulo.core.util.format.DefaultFormatter;
 import org.apache.accumulo.core.util.format.Formatter;
 import org.apache.accumulo.core.util.format.FormatterFactory;
-import org.apache.accumulo.core.util.shell.commands.AboutCommand;
-import org.apache.accumulo.core.util.shell.commands.AddSplitsCommand;
-import org.apache.accumulo.core.util.shell.commands.AuthenticateCommand;
-import org.apache.accumulo.core.util.shell.commands.ByeCommand;
-import org.apache.accumulo.core.util.shell.commands.ClasspathCommand;
-import org.apache.accumulo.core.util.shell.commands.ClearCommand;
-import org.apache.accumulo.core.util.shell.commands.CloneTableCommand;
-import org.apache.accumulo.core.util.shell.commands.ClsCommand;
-import org.apache.accumulo.core.util.shell.commands.CompactCommand;
-import org.apache.accumulo.core.util.shell.commands.ConfigCommand;
-import org.apache.accumulo.core.util.shell.commands.CreateTableCommand;
-import org.apache.accumulo.core.util.shell.commands.CreateUserCommand;
-import org.apache.accumulo.core.util.shell.commands.DUCommand;
-import org.apache.accumulo.core.util.shell.commands.DebugCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteIterCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteManyCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteRowsCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteScanIterCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteTableCommand;
-import org.apache.accumulo.core.util.shell.commands.DeleteUserCommand;
-import org.apache.accumulo.core.util.shell.commands.DropTableCommand;
-import org.apache.accumulo.core.util.shell.commands.DropUserCommand;
-import org.apache.accumulo.core.util.shell.commands.EGrepCommand;
-import org.apache.accumulo.core.util.shell.commands.ExecfileCommand;
-import org.apache.accumulo.core.util.shell.commands.ExitCommand;
-import org.apache.accumulo.core.util.shell.commands.FlushCommand;
-import org.apache.accumulo.core.util.shell.commands.FormatterCommand;
-import org.apache.accumulo.core.util.shell.commands.GetAuthsCommand;
-import org.apache.accumulo.core.util.shell.commands.GetGroupsCommand;
-import org.apache.accumulo.core.util.shell.commands.GetSplitsCommand;
-import org.apache.accumulo.core.util.shell.commands.GrantCommand;
-import org.apache.accumulo.core.util.shell.commands.GrepCommand;
-import org.apache.accumulo.core.util.shell.commands.HelpCommand;
-import org.apache.accumulo.core.util.shell.commands.HiddenCommand;
-import org.apache.accumulo.core.util.shell.commands.HistoryCommand;
-import org.apache.accumulo.core.util.shell.commands.ImportDirectoryCommand;
-import org.apache.accumulo.core.util.shell.commands.InfoCommand;
-import org.apache.accumulo.core.util.shell.commands.InsertCommand;
-import org.apache.accumulo.core.util.shell.commands.ListIterCommand;
-import org.apache.accumulo.core.util.shell.commands.ListScansCommand;
-import org.apache.accumulo.core.util.shell.commands.MasterStateCommand;
-import org.apache.accumulo.core.util.shell.commands.MaxRowCommand;
-import org.apache.accumulo.core.util.shell.commands.MergeCommand;
-import org.apache.accumulo.core.util.shell.commands.NoTableCommand;
-import org.apache.accumulo.core.util.shell.commands.OfflineCommand;
-import org.apache.accumulo.core.util.shell.commands.OnlineCommand;
-import org.apache.accumulo.core.util.shell.commands.PasswdCommand;
-import org.apache.accumulo.core.util.shell.commands.QuestionCommand;
-import org.apache.accumulo.core.util.shell.commands.QuitCommand;
-import org.apache.accumulo.core.util.shell.commands.QuotedStringTokenizer;
-import org.apache.accumulo.core.util.shell.commands.RenameTableCommand;
-import org.apache.accumulo.core.util.shell.commands.RevokeCommand;
-import org.apache.accumulo.core.util.shell.commands.ScanCommand;
-import org.apache.accumulo.core.util.shell.commands.SetAuthsCommand;
-import org.apache.accumulo.core.util.shell.commands.SetGroupsCommand;
-import org.apache.accumulo.core.util.shell.commands.SetIterCommand;
-import org.apache.accumulo.core.util.shell.commands.SetScanIterCommand;
-import org.apache.accumulo.core.util.shell.commands.SleepCommand;
-import org.apache.accumulo.core.util.shell.commands.SystemPermissionsCommand;
-import org.apache.accumulo.core.util.shell.commands.TableCommand;
-import org.apache.accumulo.core.util.shell.commands.TablePermissionsCommand;
-import org.apache.accumulo.core.util.shell.commands.TablesCommand;
-import org.apache.accumulo.core.util.shell.commands.TraceCommand;
-import org.apache.accumulo.core.util.shell.commands.UserCommand;
-import org.apache.accumulo.core.util.shell.commands.UserPermissionsCommand;
-import org.apache.accumulo.core.util.shell.commands.UsersCommand;
-import org.apache.accumulo.core.util.shell.commands.WhoAmICommand;
-import org.apache.accumulo.core.zookeeper.ZooReader;
+import org.apache.accumulo.core.util.shell.commands.*;
+import org.apache.accumulo.core.zookeeper.ZooUtil;
 import org.apache.commons.cli.BasicParser;
 import org.apache.commons.cli.CommandLine;
 import org.apache.commons.cli.HelpFormatter;
@@ -145,10 +75,13 @@ import org.apache.hadoop.fs.Path;
 import org.apache.log4j.Level;
 import org.apache.log4j.Logger;
 
+import cloudtrace.instrument.Tracer;
+import cloudtrace.instrument.receivers.ZooSpanClient;
+
 /**
  * A convenient console interface to perform basic accumulo functions Includes auto-complete, help, and quoted strings with escape sequences
  */
-public class Shell extends ShellOptions {
+public class Shell {
   public static final Logger log = Logger.getLogger(Shell.class);
   private static final Logger audit = Logger.getLogger(Shell.class.getName() + ".audit");
   
@@ -156,52 +89,102 @@ public class Shell extends ShellOptions {
   private static final String SHELL_DESCRIPTION = "Shell - Accumulo Interactive Shell";
   private static final String DEFAULT_AUTH_TIMEOUT = "60"; // in minutes
   
-  protected int exitCode = 0;
+  private int exitCode = 0;
   private String tableName;
-  protected Instance instance;
+  private Instance instance;
   private Connector connector;
-  protected ConsoleReader reader;
+  private ConsoleReader reader;
   private AuthInfo credentials;
-  private Class<? extends Formatter> defaultFormatterClass = DefaultFormatter.class;
+  private Class<? extends Formatter> formatterClass = DefaultFormatter.class;
   private Class<? extends Formatter> binaryFormatterClass = BinaryFormatter.class;
-  public Map<String,List<IteratorSetting>> scanIteratorOptions = new HashMap<String,List<IteratorSetting>>();
+  public Map<String,Map<String,Map<String,String>>> scanIteratorOptions = new HashMap<String,Map<String,Map<String,String>>>();
   
   private Token rootToken;
   public final Map<String,Command> commandFactory = new TreeMap<String,Command>();
-  protected boolean configError = false;
+  private boolean configError = false;
+  
+  // Global options flags
+  public static final String userOption = "u";
+  public static final String tableOption = "t";
+  public static final String helpOption = "?";
+  public static final String helpLongOption = "help";
   
   // exit if true
-  protected boolean exit = false;
+  private boolean exit = false;
   
   // file to execute commands from
-  protected String execFile = null;
-  // single command to execute from the command line
-  protected String execCommand = null;
-  protected boolean verbose = true;
+  private String execFile = null;
+  private boolean verbose = true;
   
   private boolean tabCompletion;
   private boolean disableAuthTimeout;
   private long authTimeout;
   private long lastUserActivity = System.currentTimeMillis();
   
-  public Shell() throws IOException {
-    super();
-    this.reader = new ConsoleReader();
-  }
-  
-  public Shell(ConsoleReader reader) {
-    super();
-    this.reader = reader;
-  }
-  
-  // Not for client use
+  @SuppressWarnings("deprecation")
   public void config(String... args) {
+    Options opts = new Options();
+    
+    Option usernameOption = new Option("u", "user", true, "username (defaults to your OS user)");
+    usernameOption.setArgName("user");
+    opts.addOption(usernameOption);
+    
+    Option passwOption = new Option("p", "password", true, "password (prompt for password if this option is missing)");
+    passwOption.setArgName("pass");
+    opts.addOption(passwOption);
+    
+    Option tabCompleteOption = new Option(null, "disable-tab-completion", false, "disables tab completion (for less overhead when scripting)");
+    opts.addOption(tabCompleteOption);
+    
+    Option debugOption = new Option(null, "debug", false, "enables client debugging");
+    opts.addOption(debugOption);
+    
+    Option fakeOption = new Option(null, "fake", false, "fake a connection to accumulo");
+    opts.addOption(fakeOption);
+    
+    Option helpOpt = new Option(helpOption, helpLongOption, false, "display this help");
+    opts.addOption(helpOpt);
+    
+    OptionGroup execFileGroup = new OptionGroup();
+    
+    Option execfileOption = new Option("f", "execute-file", true, "executes commands from a file at startup");
+    execfileOption.setArgName("file");
+    execFileGroup.addOption(execfileOption);
+    
+    Option execfileVerboseOption = new Option("fv", "execute-file-verbose", true, "executes commands from a file at startup, with commands shown");
+    execfileVerboseOption.setArgName("file");
+    execFileGroup.addOption(execfileVerboseOption);
+    
+    opts.addOptionGroup(execFileGroup);
+    
+    OptionGroup instanceOptions = new OptionGroup();
+    
+    Option hdfsZooInstance = new Option("h", "hdfsZooInstance", false, "use hdfs zoo instance");
+    instanceOptions.addOption(hdfsZooInstance);
+    
+    Option zooKeeperInstance = new Option("z", "zooKeeperInstance", true, "use a zookeeper instance with the given instance name and list of zoo hosts");
+    zooKeeperInstance.setArgName("name hosts");
+    zooKeeperInstance.setArgs(2);
+    instanceOptions.addOption(zooKeeperInstance);
+    
+    opts.addOptionGroup(instanceOptions);
+    
+    OptionGroup authTimeoutOptions = new OptionGroup();
+    
+    Option authTimeoutOpt = new Option(null, "auth-timeout", true, "minutes the shell can be idle without re-entering a password (default "
+        + DEFAULT_AUTH_TIMEOUT + " min)");
+    authTimeoutOpt.setArgName("minutes");
+    authTimeoutOptions.addOption(authTimeoutOpt);
+    
+    Option disableAuthTimeoutOpt = new Option(null, "disable-auth-timeout", false, "disables requiring the user to re-type a password after being idle");
+    authTimeoutOptions.addOption(disableAuthTimeoutOpt);
+    
+    opts.addOptionGroup(authTimeoutOptions);
     
     CommandLine cl;
     try {
       cl = new BasicParser().parse(opts, args);
-      if (cl.getArgs().length > 0)
-        throw new ParseException("Unrecognized arguments: " + cl.getArgList());
+      if (cl.getArgs().length > 0) throw new ParseException("Unrecognized arguments: " + cl.getArgList());
       
       if (cl.hasOption(helpOpt.getOpt())) {
         configError = true;
@@ -213,8 +196,8 @@ public class Shell extends ShellOptions {
       authTimeout = Integer.parseInt(cl.getOptionValue(authTimeoutOpt.getLongOpt(), DEFAULT_AUTH_TIMEOUT)) * 60 * 1000;
       disableAuthTimeout = cl.hasOption(disableAuthTimeoutOpt.getLongOpt());
       
-      if (cl.hasOption(zooKeeperInstance.getOpt()) && cl.getOptionValues(zooKeeperInstance.getOpt()).length != 2)
-        throw new MissingArgumentException(zooKeeperInstance);
+      if (cl.hasOption(zooKeeperInstance.getOpt()) && cl.getOptionValues(zooKeeperInstance.getOpt()).length != 2) throw new MissingArgumentException(
+          zooKeeperInstance);
       
     } catch (Exception e) {
       configError = true;
@@ -225,23 +208,35 @@ public class Shell extends ShellOptions {
     
     // get the options that were parsed
     String sysUser = System.getProperty("user.name");
-    if (sysUser == null)
-      sysUser = "root";
+    if (sysUser == null) sysUser = "root";
     String user = cl.getOptionValue(usernameOption.getOpt(), sysUser);
     
     String passw = cl.getOptionValue(passwOption.getOpt(), null);
     tabCompletion = !cl.hasOption(tabCompleteOption.getLongOpt());
     
-    // Use a fake (Mock), ZK, or HdfsZK Accumulo instance
-    setInstance(cl);
+    // should only be one instance option set
+    instance = null;
+    if (cl.hasOption(fakeOption.getLongOpt())) {
+      instance = new MockInstance();
+    } else if (cl.hasOption(hdfsZooInstance.getOpt())) {
+      instance = getDefaultInstance(AccumuloConfiguration.getSiteConfiguration());
+    } else if (cl.hasOption(zooKeeperInstance.getOpt())) {
+      String[] zkOpts = cl.getOptionValues(zooKeeperInstance.getOpt());
+      instance = new ZooKeeperInstance(zkOpts[0], zkOpts[1]);
+    } else {
+      instance = getDefaultInstance(AccumuloConfiguration.getSiteConfiguration());
+    }
     
     // process default parameters if unspecified
     byte[] pass;
     try {
       if (!cl.hasOption(fakeOption.getLongOpt())) {
-        DistributedTrace.enable(instance, new ZooReader(instance), "shell", InetAddress.getLocalHost().getHostName());
+        String localhost = InetAddress.getLocalHost().getHostName();
+        String path = ZooUtil.getRoot(instance) + Constants.ZTRACERS;
+        Tracer.getInstance().addReceiver(new ZooSpanClient(instance.getZooKeepers(), path, localhost, "shell", 1000));
       }
       
+      this.reader = new ConsoleReader();
       Runtime.getRuntime().addShutdownHook(new Thread() {
         @Override
         public void start() {
@@ -249,8 +244,7 @@ public class Shell extends ShellOptions {
         }
       });
       
-      if (passw == null)
-        passw = reader.readLine("Enter current password for '" + user + "'@'" + instance.getInstanceName() + "': ", '*');
+      if (passw == null) passw = reader.readLine("Enter current password for '" + user + "'@'" + instance.getInstanceName() + "': ", '*');
       if (passw == null) {
         reader.printNewline();
         configError = true;
@@ -271,13 +265,7 @@ public class Shell extends ShellOptions {
     if (cl.hasOption(execfileOption.getOpt())) {
       execFile = cl.getOptionValue(execfileOption.getOpt());
       verbose = false;
-    } else if (cl.hasOption(execfileVerboseOption.getOpt())) {
-      execFile = cl.getOptionValue(execfileVerboseOption.getOpt());
-    }
-    if (cl.hasOption(execCommandOpt.getOpt())) {
-      execCommand = cl.getOptionValue(execCommandOpt.getOpt());
-      verbose = false;
-    }
+    } else if (cl.hasOption(execfileVerboseOption.getOpt())) execFile = cl.getOptionValue(execfileVerboseOption.getOpt());
     
     rootToken = new Token();
     Command external[] = {new AboutCommand(), new AddSplitsCommand(), new AuthenticateCommand(), new ByeCommand(), new ClasspathCommand(), new ClearCommand(),
@@ -286,29 +274,26 @@ public class Shell extends ShellOptions {
         new DeleteTableCommand(), new DeleteUserCommand(), new DropTableCommand(), new DropUserCommand(), new DUCommand(), new EGrepCommand(),
         new ExecfileCommand(), new ExitCommand(), new FlushCommand(), new FormatterCommand(), new GetAuthsCommand(), new GetGroupsCommand(),
         new GetSplitsCommand(), new GrantCommand(), new GrepCommand(), new HelpCommand(), new HiddenCommand(), new HistoryCommand(),
-        new ImportDirectoryCommand(), new InfoCommand(), new InsertCommand(), new ListIterCommand(), new ListScansCommand(), new MasterStateCommand(),
-        new MaxRowCommand(), new MergeCommand(), new NoTableCommand(), new OfflineCommand(), new OnlineCommand(), new PasswdCommand(), new QuestionCommand(),
-        new QuitCommand(), new RenameTableCommand(), new RevokeCommand(), new ScanCommand(), new SetAuthsCommand(), new SetGroupsCommand(),
-        new SetIterCommand(), new SetScanIterCommand(), new SleepCommand(), new SystemPermissionsCommand(), new TableCommand(), new TablePermissionsCommand(),
-        new TablesCommand(), new TraceCommand(), new UserCommand(), new UserPermissionsCommand(), new UsersCommand(), new WhoAmICommand(),};
+        new ImportDirectoryCommand(), new InfoCommand(), new InsertCommand(), new ListScansCommand(), new MasterStateCommand(), new MaxRowCommand(),
+        new MergeCommand(), new NoTableCommand(), new OfflineCommand(), new OnlineCommand(), new PasswdCommand(), new QuestionCommand(), new QuitCommand(),
+        new RenameTableCommand(), new RevokeCommand(), new ScanCommand(), new SelectCommand(), new SelectrowCommand(), new SetAuthsCommand(),
+        new SetGroupsCommand(), new SetIterCommand(), new SetScanIterCommand(), new SleepCommand(), new SystemPermissionsCommand(), new TableCommand(),
+        new TablePermissionsCommand(), new TablesCommand(), new TraceCommand(), new UserCommand(), new UserPermissionsCommand(), new UsersCommand(),
+        new WhoAmICommand(),};
     for (Command cmd : external) {
       commandFactory.put(cmd.getName(), cmd);
     }
-  }
-  
-  @SuppressWarnings("deprecation")
-  protected void setInstance(CommandLine cl) {
-    // should only be one instance option set
-    instance = null;
-    if (cl.hasOption(fakeOption.getLongOpt())) {
-      instance = new MockInstance();
-    } else if (cl.hasOption(hdfsZooInstance.getOpt())) {
-      instance = getDefaultInstance(AccumuloConfiguration.getSiteConfiguration());
-    } else if (cl.hasOption(zooKeeperInstance.getOpt())) {
-      String[] zkOpts = cl.getOptionValues(zooKeeperInstance.getOpt());
-      instance = new ZooKeeperInstance(zkOpts[0], zkOpts[1]);
-    } else {
-      instance = getDefaultInstance(AccumuloConfiguration.getSiteConfiguration());
+    for (Class<?> subclass : Shell.class.getClasses()) {
+      Object t;
+      try {
+        t = subclass.newInstance();
+      } catch (Exception e) {
+        continue;
+      }
+      if (t instanceof Command) {
+        Command sci = (Command) t;
+        commandFactory.put(sci.getName(), sci);
+      }
     }
   }
   
@@ -333,18 +318,15 @@ public class Shell extends ShellOptions {
   }
   
   public int start() throws IOException {
-    if (configError)
-      return 1;
+    if (configError) return 1;
     
     String input;
-    if (isVerbose())
-      printInfo();
+    if (isVerbose()) printInfo();
     
     String configDir = System.getenv("HOME") + "/.accumulo";
     String historyPath = configDir + "/shell_history.txt";
     File accumuloDir = new File(configDir);
-    if (!accumuloDir.exists() && !accumuloDir.mkdirs())
-      log.warn("Unable to make directory for history at " + accumuloDir);
+    if (!accumuloDir.exists() && !accumuloDir.mkdirs()) log.warn("Unable to make directory for history at " + accumuloDir);
     try {
       History history = new History();
       history.setHistoryFile(new File(historyPath));
@@ -359,21 +341,14 @@ public class Shell extends ShellOptions {
       java.util.Scanner scanner = new java.util.Scanner(new File(execFile));
       while (scanner.hasNextLine())
         execCommand(scanner.nextLine(), true, isVerbose());
-    } else if (execCommand != null) {
-      for (String command : execCommand.split("\n")) {
-        execCommand(command, true, isVerbose());
-      }
-      return exitCode;
     }
     
     while (true) {
-      if (exit)
-        return exitCode;
+      if (exit) return exitCode;
       
       // If tab completion is true we need to reset
       if (tabCompletion) {
-        if (userCompletor != null)
-          reader.removeCompletor(userCompletor);
+        if (userCompletor != null) reader.removeCompletor(userCompletor);
         
         userCompletor = setupCompletion();
         reader.addCompletor(userCompletor);
@@ -399,21 +374,19 @@ public class Shell extends ShellOptions {
   public void printVerboseInfo() throws IOException {
     StringBuilder sb = new StringBuilder("-\n");
     sb.append("- Current user: ").append(connector.whoami()).append("\n");
-    if (execFile != null)
-      sb.append("- Executing commands from: ").append(execFile).append("\n");
-    if (disableAuthTimeout)
-      sb.append("- Authorization timeout: disabled\n");
-    else
-      sb.append("- Authorization timeout: ").append(String.format("%.2fs\n", authTimeout / 1000.0));
+    if (execFile != null) sb.append("- Executing commands from: ").append(execFile).append("\n");
+    if (disableAuthTimeout) sb.append("- Authorization timeout: disabled\n");
+    else sb.append("- Authorization timeout: ").append(String.format("%.2fs\n", authTimeout / 1000.0));
     sb.append("- Debug: ").append(isDebuggingEnabled() ? "on" : "off").append("\n");
+    if (formatterClass != null && formatterClass != DefaultFormatter.class) {
+      sb.append("- Active formatter class: ").append(formatterClass.getSimpleName()).append("\n");
+    }
     if (!scanIteratorOptions.isEmpty()) {
-      for (Entry<String,List<IteratorSetting>> entry : scanIteratorOptions.entrySet()) {
+      for (Entry<String,Map<String,Map<String,String>>> entry : scanIteratorOptions.entrySet()) {
         sb.append("- Session scan iterators for table ").append(entry.getKey()).append(":\n");
-        for (IteratorSetting setting : entry.getValue()) {
-          sb.append("-    Iterator ").append(setting.getName()).append(" options:\n");
-          sb.append("-        ").append("iteratorPriority").append(" = ").append(setting.getPriority()).append("\n");
-          sb.append("-        ").append("iteratorClassName").append(" = ").append(setting.getIteratorClass()).append("\n");
-          for (Entry<String,String> optEntry : setting.getProperties().entrySet()) {
+        for (Entry<String,Map<String,String>> namedEntry : entry.getValue().entrySet()) {
+          sb.append("-    Iterator ").append(namedEntry.getKey()).append(" options:\n");
+          for (Entry<String,String> optEntry : namedEntry.getValue().entrySet()) {
             sb.append("-        ").append(optEntry.getKey()).append(" = ").append(optEntry.getValue()).append("\n");
           }
         }
@@ -423,7 +396,7 @@ public class Shell extends ShellOptions {
     reader.printString(sb.toString());
   }
   
-  protected String getDefaultPrompt() {
+  private String getDefaultPrompt() {
     return connector.whoami() + "@" + connector.getInstance().getInstanceName() + (getTableName().isEmpty() ? "" : " ") + getTableName() + "> ";
   }
   
@@ -443,8 +416,7 @@ public class Shell extends ShellOptions {
       ++exitCode;
       return;
     }
-    if (fields.length == 0)
-      return;
+    if (fields.length == 0) return;
     
     String command = fields[0];
     fields = fields.length > 1 ? Arrays.copyOfRange(fields, 1, fields.length) : new String[] {};
@@ -476,8 +448,7 @@ public class Shell extends ShellOptions {
               printException(e);
             }
             
-            if (authFailed)
-              reader.printString("Invalid password. ");
+            if (authFailed) reader.printString("Invalid password. ");
           } while (authFailed);
           lastUserActivity = System.currentTimeMillis();
         }
@@ -512,8 +483,7 @@ public class Shell extends ShellOptions {
         printConstraintViolationException(e);
       } catch (TableNotFoundException e) {
         ++exitCode;
-        if (getTableName().equals(e.getTableName()))
-          setTableName("");
+        if (getTableName().equals(e.getTableName())) setTableName("");
         printException(e);
       } catch (ParseException e) {
         // not really an error if the exception is a missing required
@@ -522,8 +492,7 @@ public class Shell extends ShellOptions {
           ++exitCode;
           printException(e);
         }
-        if (sc != null)
-          sc.printHelp();
+        if (sc != null) sc.printHelp();
       } catch (Exception e) {
         ++exitCode;
         printException(e);
@@ -698,8 +667,7 @@ public class Shell extends ShellOptions {
         SortedSet<String> tablesToFlush = new TreeSet<String>();
         if (cl.hasOption(optTablePattern.getOpt())) {
           for (String table : shellState.getConnector().tableOperations().list())
-            if (table.matches(cl.getOptionValue(optTablePattern.getOpt())))
-              tablesToFlush.add(table);
+            if (table.matches(cl.getOptionValue(optTablePattern.getOpt()))) tablesToFlush.add(table);
         } else if (cl.hasOption(optTableName.getOpt())) {
           tablesToFlush.add(cl.getOptionValue(optTableName.getOpt()));
         }
@@ -709,13 +677,11 @@ public class Shell extends ShellOptions {
           tablesToFlush.add(shellState.getTableName());
         }
         
-        if (tablesToFlush.isEmpty())
-          log.warn("No tables found that match your criteria");
+        if (tablesToFlush.isEmpty()) log.warn("No tables found that match your criteria");
         
         // flush the tables
         for (String tableName : tablesToFlush) {
-          if (!shellState.getConnector().tableOperations().exists(tableName))
-            throw new TableNotFoundException(null, tableName, null);
+          if (!shellState.getConnector().tableOperations().exists(tableName)) throw new TableNotFoundException(null, tableName, null);
           doTableOp(shellState, tableName);
         }
       }
@@ -810,8 +776,7 @@ public class Shell extends ShellOptions {
     String peek = null;
     while (lines.hasNext()) {
       String nextLine = lines.next();
-      if (nextLine == null)
-        continue;
+      if (nextLine == null) continue;
       for (String line : nextLine.split("\\n")) {
         if (peek != null) {
           reader.printString(peek);
@@ -849,13 +814,6 @@ public class Shell extends ShellOptions {
   }
   
   public final void printRecords(Iterable<Entry<Key,Value>> scanner, boolean printTimestamps, boolean paginate) throws IOException {
-    Class<? extends Formatter> formatterClass = getFormatter();
-    
-    printRecords(scanner, printTimestamps, paginate, formatterClass);
-  }
-  
-  public final void printRecords(Iterable<Entry<Key,Value>> scanner, boolean printTimestamps, boolean paginate, Class<? extends Formatter> formatterClass)
-      throws IOException {
     printLines(FormatterFactory.getFormatter(formatterClass, scanner, printTimestamps), paginate);
   }
   
@@ -871,9 +829,8 @@ public class Shell extends ShellOptions {
   }
   
   public void checkTableState() {
-    if (getTableName().isEmpty())
-      throw new IllegalStateException(
-          "Not in a table context. Please use 'table <tableName>' to switch to a table, or use '-t' to specify a table if option is available.");
+    if (getTableName().isEmpty()) throw new IllegalStateException(
+        "Not in a table context. Please use 'table <tableName>' to switch to a table, or use '-t' to specify a table if option is available.");
   }
   
   private final void printConstraintViolationException(ConstraintViolationException cve) {
@@ -939,25 +896,13 @@ public class Shell extends ShellOptions {
   public AuthInfo getCredentials() {
     return credentials;
   }
-
-  /**
-   * Return the formatter for this table, .
-   * 
-   * @param tableName
-   * @return The formatter class for the given table
-   */
-  public Class<? extends Formatter> getFormatter() {
-    return getFormatter(this.tableName);
+  
+  public void setFormatterClass(Class<? extends Formatter> formatterClass) {
+    this.formatterClass = formatterClass;
   }
   
-  public Class<? extends Formatter> getFormatter(String tableName) {
-    Class<? extends Formatter> formatter = FormatterCommand.getCurrentFormatter(tableName, this);
-    
-    if (null == formatter) {
-      log.error("Could not load the specified formatter. Using the DefaultFormatter");
-      return this.defaultFormatterClass;
-    } else {
-      return formatter;
-    }
+  public Class<? extends Formatter> getFormatterClass() {
+    return formatterClass;
   }
+  
 }