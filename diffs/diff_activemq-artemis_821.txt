diff --git a/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/Page.java b/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/Page.java
index 03d0e672b9..992d585e49 100644
--- a/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/Page.java
+++ b/artemis-server/src/main/java/org/apache/activemq/artemis/core/paging/impl/Page.java
@@ -1,4 +1,4 @@
-/*
+/**
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements. See the NOTICE file distributed with
  * this work for additional information regarding copyright ownership.
@@ -22,14 +22,11 @@ import java.util.List;
 import java.util.Set;
 import java.util.concurrent.atomic.AtomicInteger;
 
-import io.netty.buffer.Unpooled;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffer;
 import org.apache.activemq.artemis.api.core.ActiveMQBuffers;
-import org.apache.activemq.artemis.api.core.ICoreMessage;
 import org.apache.activemq.artemis.api.core.SimpleString;
-import org.apache.activemq.artemis.core.buffers.impl.ChannelBufferWrapper;
-import org.apache.activemq.artemis.core.io.SequentialFile;
-import org.apache.activemq.artemis.core.io.SequentialFileFactory;
+import org.apache.activemq.artemis.core.journal.SequentialFile;
+import org.apache.activemq.artemis.core.journal.SequentialFileFactory;
 import org.apache.activemq.artemis.core.paging.PagedMessage;
 import org.apache.activemq.artemis.core.paging.cursor.LivePageCache;
 import org.apache.activemq.artemis.core.paging.cursor.PageSubscriptionCounter;
@@ -37,15 +34,14 @@ import org.apache.activemq.artemis.core.persistence.StorageManager;
 import org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;
 import org.apache.activemq.artemis.core.server.ActiveMQServerLogger;
 import org.apache.activemq.artemis.core.server.LargeServerMessage;
+import org.apache.activemq.artemis.utils.ConcurrentHashSet;
 import org.apache.activemq.artemis.utils.DataConstants;
-import org.apache.activemq.artemis.utils.Env;
-import org.apache.activemq.artemis.utils.collections.ConcurrentHashSet;
-import org.jboss.logging.Logger;
-
-public final class Page implements Comparable<Page> {
 
+public final class Page implements Comparable<Page>
+{
    // Constants -----------------------------------------------------
-   private static final Logger logger = Logger.getLogger(Page.class);
+   private static final boolean isTrace = ActiveMQServerLogger.LOGGER.isTraceEnabled();
+   private static final boolean isDebug = ActiveMQServerLogger.LOGGER.isDebugEnabled();
 
    public static final int SIZE_RECORD = DataConstants.SIZE_BYTE + DataConstants.SIZE_INT + DataConstants.SIZE_BYTE;
 
@@ -85,7 +81,8 @@ public final class Page implements Comparable<Page> {
                final StorageManager storageManager,
                final SequentialFileFactory factory,
                final SequentialFile file,
-               final int pageId) throws Exception {
+               final int pageId) throws Exception
+   {
       this.pageId = pageId;
       this.file = file;
       fileFactory = factory;
@@ -93,203 +90,164 @@ public final class Page implements Comparable<Page> {
       this.storeName = storeName;
    }
 
-   public int getPageId() {
+   public int getPageId()
+   {
       return pageId;
    }
 
-   public void setLiveCache(LivePageCache pageCache) {
+   public void setLiveCache(LivePageCache pageCache)
+   {
       this.pageCache = pageCache;
    }
 
-   public synchronized List<PagedMessage> read(StorageManager storage) throws Exception {
-      if (logger.isDebugEnabled()) {
-         logger.debug("reading page " + this.pageId + " on address = " + storeName);
+   public synchronized List<PagedMessage> read(StorageManager storage) throws Exception
+   {
+      if (isDebug)
+      {
+         ActiveMQServerLogger.LOGGER.debug("reading page " + this.pageId + " on address = " + storeName);
       }
 
-      if (!file.isOpen()) {
+      if (!file.isOpen())
+      {
          throw ActiveMQMessageBundle.BUNDLE.invalidPageIO();
       }
 
-      size.lazySet((int) file.size());
-
-      final List<PagedMessage> messages = readFromSequentialFile(storage);
-
-      numberOfMessages.lazySet(messages.size());
-
-      return messages;
-   }
-
-   private static void decodeInto(ByteBuffer fileBuffer, int encodedSize, PagedMessageImpl msg) {
-      final ActiveMQBuffer wrappedBuffer = ActiveMQBuffers.wrappedBuffer(fileBuffer);
-      wrappedBuffer.writerIndex(encodedSize);
-      msg.decode(wrappedBuffer);
-   }
-
-   private ByteBuffer allocateAndReadIntoFileBuffer(ByteBuffer fileBuffer, int requiredBytes) throws Exception {
-      final ByteBuffer newFileBuffer = fileFactory.newBuffer(Math.max(requiredBytes, MIN_CHUNK_SIZE));
-      newFileBuffer.put(fileBuffer);
-      fileFactory.releaseBuffer(fileBuffer);
-      fileBuffer = newFileBuffer;
-      //move the limit to allow reading as much as possible from the file
-      fileBuffer.limit(fileBuffer.capacity());
-      file.read(fileBuffer);
-      fileBuffer.position(0);
-      return fileBuffer;
-   }
-
-   /**
-    * It returns a {@link ByteBuffer} that has {@link ByteBuffer#remaining()} bytes >= {@code requiredBytes}
-    * of valid data from {@link #file}.
-    */
-   private ByteBuffer readIntoFileBufferIfNecessary(ByteBuffer fileBuffer, int requiredBytes) throws Exception {
-      final int remaining = fileBuffer.remaining();
-      //fileBuffer::remaining is the current size of valid data
-      final int bytesToBeRead = requiredBytes - remaining;
-      if (bytesToBeRead > 0) {
-         final int capacity = fileBuffer.capacity();
-         //fileBuffer has enough overall capacity to hold all the required bytes?
-         if (capacity >= requiredBytes) {
-            //we do not care to use the free space between
-            //fileBuffer::limit and fileBuffer::capacity
-            //to save compactions, because fileBuffer
-            //is very unlikely to not be completely full
-            //after each file::read
-            if (fileBuffer.limit() > 0) {
-               //the previous check avoid compact
-               //to attempt a copy of 0 bytes
-               fileBuffer.compact();
-            } else {
-               //compact already set the limit == capacity
-               fileBuffer.limit(capacity);
-            }
-            file.read(fileBuffer);
-            fileBuffer.position(0);
-         } else {
-            fileBuffer = allocateAndReadIntoFileBuffer(fileBuffer, requiredBytes);
-         }
-      }
-      return fileBuffer;
-   }
-
-   //sizeOf(START_BYTE) + sizeOf(MESSAGE LENGTH) + sizeOf(END_BYTE)
-   private static final int HEADER_AND_TRAILER_SIZE = DataConstants.SIZE_INT + 2;
-   private static final int MINIMUM_MSG_PERSISTENT_SIZE = HEADER_AND_TRAILER_SIZE;
-   private static final int MIN_CHUNK_SIZE = Env.osPageSize();
+      ArrayList<PagedMessage> messages = new ArrayList<PagedMessage>();
 
-   private List<PagedMessage> readFromSequentialFile(StorageManager storage) throws Exception {
-      final List<PagedMessage> messages = new ArrayList<>();
-      final int fileSize = (int) file.size();
-      file.position(0);
-      int processedBytes = 0;
-      ByteBuffer fileBuffer = null;
-      try {
-         int remainingBytes = fileSize - processedBytes;
-         if (remainingBytes >= MINIMUM_MSG_PERSISTENT_SIZE) {
-            fileBuffer = fileFactory.newBuffer(Math.min(remainingBytes, MIN_CHUNK_SIZE));
-            fileBuffer.limit(0);
-            do {
-               fileBuffer = readIntoFileBufferIfNecessary(fileBuffer, MINIMUM_MSG_PERSISTENT_SIZE);
-               final byte startByte = fileBuffer.get();
-               if (startByte == Page.START_BYTE) {
-                  final int encodedSize = fileBuffer.getInt();
-                  final int nextPosition = processedBytes + HEADER_AND_TRAILER_SIZE + encodedSize;
-                  if (nextPosition <= fileSize) {
-                     fileBuffer = readIntoFileBufferIfNecessary(fileBuffer, encodedSize + 1);
-                     final int endPosition = fileBuffer.position() + encodedSize;
-                     //this check must be performed upfront decoding
-                     if (fileBuffer.remaining() >= (encodedSize + 1) && fileBuffer.get(endPosition) == Page.END_BYTE) {
-                        final PagedMessageImpl msg = new PagedMessageImpl(storageManager);
-                        decodeInto(fileBuffer, encodedSize, msg);
-                        fileBuffer.position(endPosition + 1);
-                        assert fileBuffer.get(endPosition) == Page.END_BYTE : "decoding cannot change end byte";
-                        msg.initMessage(storage);
-                        if (logger.isTraceEnabled()) {
-                           logger.tracef("Reading message %s on pageId=%d for address=%s", msg, pageId, storeName);
-                        }
-                        messages.add(msg);
-                        processedBytes = nextPosition;
-                     } else {
-                        markFileAsSuspect(file.getFileName(), processedBytes, messages.size());
-                        return messages;
+      size.set((int) file.size());
+      // Using direct buffer, as described on https://jira.jboss.org/browse/HORNETQ-467
+      ByteBuffer directBuffer = storage.allocateDirectBuffer((int) file.size());
+      ActiveMQBuffer fileBuffer = null;
+      try
+      {
+
+         file.position(0);
+         file.read(directBuffer);
+
+         directBuffer.rewind();
+
+         fileBuffer = ActiveMQBuffers.wrappedBuffer(directBuffer);
+         fileBuffer.writerIndex(fileBuffer.capacity());
+
+         while (fileBuffer.readable())
+         {
+            final int position = fileBuffer.readerIndex();
+
+            byte byteRead = fileBuffer.readByte();
+
+            if (byteRead == Page.START_BYTE)
+            {
+               if (fileBuffer.readerIndex() + DataConstants.SIZE_INT < fileBuffer.capacity())
+               {
+                  int messageSize = fileBuffer.readInt();
+                  int oldPos = fileBuffer.readerIndex();
+                  if (fileBuffer.readerIndex() + messageSize < fileBuffer.capacity() &&
+                     fileBuffer.getByte(oldPos + messageSize) == Page.END_BYTE)
+                  {
+                     PagedMessage msg = new PagedMessageImpl();
+                     msg.decode(fileBuffer);
+                     byte b = fileBuffer.readByte();
+                     if (b != Page.END_BYTE)
+                     {
+                        // Sanity Check: This would only happen if there is a bug on decode or any internal code, as
+                        // this
+                        // constraint was already checked
+                        throw new IllegalStateException("Internal error, it wasn't possible to locate END_BYTE " + b);
+                     }
+                     msg.initMessage(storage);
+                     if (isTrace)
+                     {
+                        ActiveMQServerLogger.LOGGER.trace("Reading message " + msg + " on pageId=" + this.pageId + " for address=" + storeName);
                      }
-                  } else {
-                     markFileAsSuspect(file.getFileName(), processedBytes, messages.size());
-                     return messages;
+                     messages.add(msg);
+                  }
+                  else
+                  {
+                     markFileAsSuspect(file.getFileName(), position, messages.size());
+                     break;
                   }
-               } else {
-                  markFileAsSuspect(file.getFileName(), processedBytes, messages.size());
-                  return messages;
                }
-               remainingBytes = fileSize - processedBytes;
             }
-            while (remainingBytes >= MINIMUM_MSG_PERSISTENT_SIZE);
-         }
-         //ignore incomplete messages at the end of the file
-         if (logger.isTraceEnabled()) {
-            logger.tracef("%s has %d bytes of unknown data at position = %d", file.getFileName(), remainingBytes, processedBytes);
-         }
-         return messages;
-      } finally {
-         if (fileBuffer != null) {
-            fileFactory.releaseBuffer(fileBuffer);
+            else
+            {
+               markFileAsSuspect(file.getFileName(), position, messages.size());
+               break;
+            }
          }
-         if (file.position() != fileSize) {
-            file.position(fileSize);
+      }
+      finally
+      {
+         if (fileBuffer != null)
+         {
+            fileBuffer.byteBuf().unwrap().release();
          }
+         storage.freeDirectBuffer(directBuffer);
       }
+
+      numberOfMessages.set(messages.size());
+
+      return messages;
    }
 
-   public synchronized void write(final PagedMessage message) throws Exception {
-      if (!file.isOpen()) {
-         throw ActiveMQMessageBundle.BUNDLE.cannotWriteToClosedFile(file);
+   public synchronized void write(final PagedMessage message) throws Exception
+   {
+      if (!file.isOpen())
+      {
+
+         return;
       }
-      final int messageEncodedSize = message.getEncodeSize();
-      final int bufferSize = messageEncodedSize + Page.SIZE_RECORD;
-      final ByteBuffer buffer = fileFactory.newBuffer(bufferSize);
-      ChannelBufferWrapper activeMQBuffer = new ChannelBufferWrapper(Unpooled.wrappedBuffer(buffer));
-      activeMQBuffer.clear();
-      activeMQBuffer.writeByte(Page.START_BYTE);
-      activeMQBuffer.writeInt(messageEncodedSize);
-      message.encode(activeMQBuffer);
-      activeMQBuffer.writeByte(Page.END_BYTE);
-      assert (activeMQBuffer.readableBytes() == bufferSize) : "messageEncodedSize is different from expected";
-      //buffer limit and position are the same
-      assert (buffer.remaining() == bufferSize) : "buffer position or limit are changed";
+
+      ByteBuffer buffer = fileFactory.newBuffer(message.getEncodeSize() + Page.SIZE_RECORD);
+
+      ActiveMQBuffer wrap = ActiveMQBuffers.wrappedBuffer(buffer);
+      wrap.clear();
+
+      wrap.writeByte(Page.START_BYTE);
+      wrap.writeInt(0);
+      int startIndex = wrap.writerIndex();
+      message.encode(wrap);
+      int endIndex = wrap.writerIndex();
+      wrap.setInt(1, endIndex - startIndex); // The encoded length
+      wrap.writeByte(Page.END_BYTE);
+
+      buffer.rewind();
+
       file.writeDirect(buffer, false);
-      if (pageCache != null) {
+
+      if (pageCache != null)
+      {
          pageCache.addLiveMessage(message);
       }
-      //lighter than addAndGet when single writer
-      numberOfMessages.lazySet(numberOfMessages.get() + 1);
-      size.lazySet(size.get() + bufferSize);
+
+      numberOfMessages.incrementAndGet();
+      size.addAndGet(buffer.limit());
+
       storageManager.pageWrite(message, pageId);
    }
 
-   public void sync() throws Exception {
+   public void sync() throws Exception
+   {
       file.sync();
    }
 
-   public void open() throws Exception {
-      if (!file.isOpen()) {
+   public void open() throws Exception
+   {
+      if (!file.isOpen())
+      {
          file.open();
       }
       size.set((int) file.size());
       file.position(0);
    }
 
-   public void close() throws Exception {
-      close(false);
-   }
-
-   /**
-    * sendEvent means it's a close happening from a major event such moveNext.
-    * While reading the cache we don't need (and shouldn't inform the backup
-    */
-   public synchronized void close(boolean sendEvent) throws Exception {
-      if (sendEvent && storageManager != null) {
+   public synchronized void close() throws Exception
+   {
+      if (storageManager != null)
+      {
          storageManager.pageClosed(storeName, pageId);
       }
-      if (pageCache != null) {
+      if (pageCache != null)
+      {
          pageCache.close();
          // leave it to the soft cache to decide when to release it now
          pageCache = null;
@@ -297,29 +255,38 @@ public final class Page implements Comparable<Page> {
       file.close();
 
       Set<PageSubscriptionCounter> counters = getPendingCounters();
-      if (counters != null) {
-         for (PageSubscriptionCounter counter : counters) {
+      if (counters != null)
+      {
+         for (PageSubscriptionCounter counter : counters)
+         {
             counter.cleanupNonTXCounters(this.getPageId());
          }
       }
    }
 
-   public boolean isLive() {
+   public boolean isLive()
+   {
       return pageCache != null;
    }
 
-   public boolean delete(final PagedMessage[] messages) throws Exception {
-      if (storageManager != null) {
+   public boolean delete(final PagedMessage[] messages) throws Exception
+   {
+      if (storageManager != null)
+      {
          storageManager.pageDeleted(storeName, pageId);
       }
 
-      if (logger.isDebugEnabled()) {
-         logger.debug("Deleting pageNr=" + pageId + " on store " + storeName);
+      if (isDebug)
+      {
+         ActiveMQServerLogger.LOGGER.debug("Deleting pageId=" + pageId + " on store " + storeName);
       }
 
-      if (messages != null) {
-         for (PagedMessage msg : messages) {
-            if (msg.getMessage() instanceof ICoreMessage && (msg.getMessage()).isLargeMessage()) {
+      if (messages != null)
+      {
+         for (PagedMessage msg : messages)
+         {
+            if (msg.getMessage().isLargeMessage())
+            {
                LargeServerMessage lmsg = (LargeServerMessage) msg.getMessage();
 
                // Remember, cannot call delete directly here
@@ -330,52 +297,68 @@ public final class Page implements Comparable<Page> {
          }
       }
 
-      try {
-         if (suspiciousRecords) {
+      try
+      {
+         if (suspiciousRecords)
+         {
             ActiveMQServerLogger.LOGGER.pageInvalid(file.getFileName(), file.getFileName());
             file.renameTo(file.getFileName() + ".invalidPage");
-         } else {
+         }
+         else
+         {
             file.delete();
          }
 
          return true;
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          ActiveMQServerLogger.LOGGER.pageDeleteError(e);
          return false;
       }
    }
 
-   public int getNumberOfMessages() {
+   public int getNumberOfMessages()
+   {
       return numberOfMessages.intValue();
    }
 
-   public int getSize() {
+   public int getSize()
+   {
       return size.intValue();
    }
 
    @Override
-   public String toString() {
-      return "Page::pageNr=" + this.pageId + ", file=" + this.file;
+   public String toString()
+   {
+      return "Page::pageID=" + this.pageId + ", file=" + this.file;
    }
 
-   @Override
-   public int compareTo(Page otherPage) {
+
+   public int compareTo(Page otherPage)
+   {
       return otherPage.getPageId() - this.pageId;
    }
 
    @Override
-   protected void finalize() {
-      try {
-         if (file != null && file.isOpen()) {
-            file.close(false);
+   protected void finalize()
+   {
+      try
+      {
+         if (file != null && file.isOpen())
+         {
+            file.close();
          }
-      } catch (Exception e) {
+      }
+      catch (Exception e)
+      {
          ActiveMQServerLogger.LOGGER.pageFinaliseError(e);
       }
    }
 
    @Override
-   public int hashCode() {
+   public int hashCode()
+   {
       final int prime = 31;
       int result = 1;
       result = prime * result + pageId;
@@ -383,7 +366,8 @@ public final class Page implements Comparable<Page> {
    }
 
    @Override
-   public boolean equals(Object obj) {
+   public boolean equals(Object obj)
+   {
       if (this == obj)
          return true;
       if (obj == null)
@@ -400,12 +384,14 @@ public final class Page implements Comparable<Page> {
     * @param position
     * @param msgNumber
     */
-   private void markFileAsSuspect(final String fileName, final int position, final int msgNumber) {
+   private void markFileAsSuspect(final String fileName, final int position, final int msgNumber)
+   {
       ActiveMQServerLogger.LOGGER.pageSuspectFile(fileName, position, msgNumber);
       suspiciousRecords = true;
    }
 
-   public SequentialFile getFile() {
+   public SequentialFile getFile()
+   {
       return file;
    }
 
@@ -414,18 +400,22 @@ public final class Page implements Comparable<Page> {
     *
     * @param pageSubscriptionCounter
     */
-   public void addPendingCounter(PageSubscriptionCounter pageSubscriptionCounter) {
+   public void addPendingCounter(PageSubscriptionCounter pageSubscriptionCounter)
+   {
       Set<PageSubscriptionCounter> counter = getOrCreatePendingCounters();
       pendingCounters.add(pageSubscriptionCounter);
    }
 
-   private synchronized Set<PageSubscriptionCounter> getPendingCounters() {
+   private synchronized Set<PageSubscriptionCounter> getPendingCounters()
+   {
       return pendingCounters;
    }
 
-   private synchronized Set<PageSubscriptionCounter> getOrCreatePendingCounters() {
-      if (pendingCounters == null) {
-         pendingCounters = new ConcurrentHashSet<>();
+   private synchronized Set<PageSubscriptionCounter> getOrCreatePendingCounters()
+   {
+      if (pendingCounters == null)
+      {
+         pendingCounters = new ConcurrentHashSet<PageSubscriptionCounter>();
       }
 
       return pendingCounters;